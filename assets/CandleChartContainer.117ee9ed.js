import{q as K1,s as iO,F as nO,G as Yu,u as ch,h as _t,d as uh,i as Zt,v as Pm,H as Yi,_ as $d,r as Ct,o as qe,c as at,j as pi,g as os,I as Og,a as ot,t as mn,m as tm,b as Ne,w as We,J as or,K as rO,f as ls,p as X1,e as Y1,L as aO,M as Ig,z as xg,N as oO,P as qi,Q as Li,R as en,S as _g,U as Cg,V as Qh,W as dO,X as Hu,Y as sm,k as Mg,Z as Pg,$ as Z1,E as cO,a0 as ko}from"./index.a985966a.js";import{_ as Ye,a2 as Q1,B as Am,c as hh,ab as aa,ac as Bm,h as Zu,W as J1,a4 as Nm,ad as im,ae as uO,af as eS,x as tS,u as Ie,z as sS,Q as iS,S as Ag,O as hO,ag as fO,G as ms,N as lO,ah as nm,ai as rm,aj as pO,ak as nS,al as rS,am as aS,X as gn,an as wn,ao as bn,I as ps,ap as oS,aq as mO,b as dS,ar as gO,Y as Ss,as as am,d as ao,at as yO,au as cS,av as wO,K as kn,aw as Bg,ax as bO,L as kO,M as SO,ay as Vm,az as Dd,aA as uS,aB as Jh,aC as vO,p as Xa,r as Jr,aD as TO,aE as fh,aF as OO,aG as IO,aH as fr,aI as xO,g as Fd,Z as Ya,aJ as Za,aK as Ng,aL as lh,aM as _O,F as hS,aN as CO,aO as MO,aP as fS,aQ as PO,aR as AO,aS as BO,aT as NO,aU as lS,y as ta,aV as Em,aW as VO,aX as EO,aY as Vg,m as pS,C as Wd,aZ as mS,a_ as gS,a$ as qO,b0 as LO,b1 as RO,b2 as DO,b3 as Gu,b4 as FO,b5 as yS,b6 as om,b7 as Eg,b8 as HO,b9 as ef,J as GO,ba as UO,bb as $O,bc as WO,bd as zO,be as jO,bf as KO,a1 as XO,bg as qg,bh as YO,bi as ZO,bj as QO,bk as JO,bl as eI,bm as tI,bn as sI,H as iI,a5 as nI,bo as rI,a7 as aI,a8 as oI,a9 as dI,aa as cI,a6 as uI}from"./install.1a6288f8.js";import{c as hI,p as wS,S as fI,i as lI,t as pI,r as mI,a as gI,D as yI,b as wI,d as bI,s as kI,A as SI,e as vI,f as TI,g as OI,h as II,j as xI,k as _I,l as CI}from"./install.659276a7.js";import{c as MI}from"./createSeriesDataSimply.d3428088.js";var Uu=(p=>(p.line="line",p.bar="bar",p.scatter="scatter",p))(Uu||{});const Qu={main_plot:{},subplots:{}};var PI=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t.hasSymbolVisual=!0,t}return e.prototype.getInitialData=function(t,s){return hI(null,this,{useEncodeDefaulter:!0})},e.prototype.getProgressive=function(){var t=this.option.progressive;return t==null?this.option.large?5e3:this.get("progressive"):t},e.prototype.getProgressiveThreshold=function(){var t=this.option.progressiveThreshold;return t==null?this.option.large?1e4:this.get("progressiveThreshold"):t},e.prototype.brushSelector=function(t,s,i){return i.point(s.getItemLayout(t))},e.prototype.getZLevelKey=function(){return this.getData().count()>this.getProgressiveThreshold()?this.id:""},e.type="series.scatter",e.dependencies=["grid","polar","geo","singleAxis","calendar"],e.defaultOption={coordinateSystem:"cartesian2d",z:2,legendHoverLink:!0,symbolSize:10,large:!1,largeThreshold:2e3,itemStyle:{opacity:.8},emphasis:{scale:!0},clip:!0,select:{itemStyle:{borderColor:"#212121"}},universalTransition:{divideShape:"clone"}},e}(Q1),AI=PI,bS=4,BI=function(){function p(){}return p}(),NI=function(p){Ye(e,p);function e(t){var s=p.call(this,t)||this;return s._off=0,s.hoverDataIdx=-1,s}return e.prototype.getDefaultShape=function(){return new BI},e.prototype.reset=function(){this.notClear=!1,this._off=0},e.prototype.buildPath=function(t,s){var i=s.points,n=s.size,r=this.symbolProxy,a=r.shape,o=t.getContext?t.getContext():t,d=o&&n[0]<bS,c=this.softClipShape,u;if(d){this._ctx=o;return}for(this._ctx=null,u=this._off;u<i.length;){var h=i[u++],f=i[u++];isNaN(h)||isNaN(f)||c&&!c.contain(h,f)||(a.x=h-n[0]/2,a.y=f-n[1]/2,a.width=n[0],a.height=n[1],r.buildPath(t,a,!0))}this.incremental&&(this._off=u,this.notClear=!0)},e.prototype.afterBrush=function(){var t=this.shape,s=t.points,i=t.size,n=this._ctx,r=this.softClipShape,a;if(!!n){for(a=this._off;a<s.length;){var o=s[a++],d=s[a++];isNaN(o)||isNaN(d)||r&&!r.contain(o,d)||n.fillRect(o-i[0]/2,d-i[1]/2,i[0],i[1])}this.incremental&&(this._off=a,this.notClear=!0)}},e.prototype.findDataIndex=function(t,s){for(var i=this.shape,n=i.points,r=i.size,a=Math.max(r[0],4),o=Math.max(r[1],4),d=n.length/2-1;d>=0;d--){var c=d*2,u=n[c]-a/2,h=n[c+1]-o/2;if(t>=u&&s>=h&&t<=u+a&&s<=h+o)return d}return-1},e.prototype.contain=function(t,s){var i=this.transformCoordToLocal(t,s),n=this.getBoundingRect();if(t=i[0],s=i[1],n.contain(t,s)){var r=this.hoverDataIdx=this.findDataIndex(t,s);return r>=0}return this.hoverDataIdx=-1,!1},e.prototype.getBoundingRect=function(){var t=this._rect;if(!t){for(var s=this.shape,i=s.points,n=s.size,r=n[0],a=n[1],o=1/0,d=1/0,c=-1/0,u=-1/0,h=0;h<i.length;){var f=i[h++],l=i[h++];o=Math.min(f,o),c=Math.max(f,c),d=Math.min(l,d),u=Math.max(l,u)}t=this._rect=new Am(o-r/2,d-a/2,c-o+r,u-d+a)}return t},e}(hh),VI=function(){function p(){this.group=new aa}return p.prototype.updateData=function(e,t){this._clear();var s=this._create();s.setShape({points:e.getLayout("points")}),this._setCommon(s,e,t)},p.prototype.updateLayout=function(e){var t=e.getLayout("points");this.group.eachChild(function(s){if(s.startIndex!=null){var i=(s.endIndex-s.startIndex)*2,n=s.startIndex*4*2;t=new Float32Array(t.buffer,n,i)}s.setShape("points",t),s.reset()})},p.prototype.incrementalPrepareUpdate=function(e){this._clear()},p.prototype.incrementalUpdate=function(e,t,s){var i=this._newAdded[0],n=t.getLayout("points"),r=i&&i.shape.points;if(r&&r.length<2e4){var a=r.length,o=new Float32Array(a+n.length);o.set(r),o.set(n,a),i.endIndex=e.end,i.setShape({points:o})}else{this._newAdded=[];var d=this._create();d.startIndex=e.start,d.endIndex=e.end,d.incremental=!0,d.setShape({points:n}),this._setCommon(d,t,s)}},p.prototype.eachRendered=function(e){this._newAdded[0]&&e(this._newAdded[0])},p.prototype._create=function(){var e=new NI({cursor:"default"});return e.ignoreCoarsePointer=!0,this.group.add(e),this._newAdded.push(e),e},p.prototype._setCommon=function(e,t,s){var i=t.hostModel;s=s||{};var n=t.getVisual("symbolSize");e.setShape("size",n instanceof Array?n:[n,n]),e.softClipShape=s.clipShape||null,e.symbolProxy=Bm(t.getVisual("symbol"),0,0,0,0),e.setColor=e.symbolProxy.setColor;var r=e.shape.size[0]<bS;e.useStyle(i.getModel("itemStyle").getItemStyle(r?["color","shadowBlur","shadowColor"]:["color"]));var a=t.getVisual("style"),o=a&&a.fill;o&&e.setColor(o);var d=Zu(e);d.seriesIndex=i.seriesIndex,e.on("mousemove",function(c){d.dataIndex=null;var u=e.hoverDataIdx;u>=0&&(d.dataIndex=u+(e.startIndex||0))})},p.prototype.remove=function(){this._clear()},p.prototype._clear=function(){this._newAdded=[],this.group.removeAll()},p}(),EI=VI,qI=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.render=function(t,s,i){var n=t.getData(),r=this._updateSymbolDraw(n,t);r.updateData(n,{clipShape:this._getClipShape(t)}),this._finished=!0},e.prototype.incrementalPrepareRender=function(t,s,i){var n=t.getData(),r=this._updateSymbolDraw(n,t);r.incrementalPrepareUpdate(n),this._finished=!1},e.prototype.incrementalRender=function(t,s,i){this._symbolDraw.incrementalUpdate(t,s.getData(),{clipShape:this._getClipShape(s)}),this._finished=t.end===s.getData().count()},e.prototype.updateTransform=function(t,s,i){var n=t.getData();if(this.group.dirty(),!this._finished||n.count()>1e4)return{update:!0};var r=wS("").reset(t,s,i);r.progress&&r.progress({start:0,end:n.count(),count:n.count()},n),this._symbolDraw.updateLayout(n)},e.prototype.eachRendered=function(t){this._symbolDraw&&this._symbolDraw.eachRendered(t)},e.prototype._getClipShape=function(t){var s=t.coordinateSystem,i=s&&s.getArea&&s.getArea();return t.get("clip",!0)?i:null},e.prototype._updateSymbolDraw=function(t,s){var i=this._symbolDraw,n=s.pipelineContext,r=n.large;return(!i||r!==this._isLargeDraw)&&(i&&i.remove(),i=this._symbolDraw=r?new EI:new fI,this._isLargeDraw=r,this.group.removeAll()),this.group.add(i.group),i},e.prototype.remove=function(t,s){this._symbolDraw&&this._symbolDraw.remove(!0),this._symbolDraw=null},e.prototype.dispose=function(){},e.type="scatter",e}(J1),LI=qI;function RI(p){Nm(lI),p.registerSeriesModel(AI),p.registerChartView(LI),p.registerLayout(wS("scatter"))}var DI={axisPointer:1,tooltip:1,brush:1};function FI(p,e,t){var s=e.getComponentByElement(p.topTarget),i=s&&s.coordinateSystem;return s&&s!==t&&!DI.hasOwnProperty(s.mainType)&&i&&i.model!==t}var Lg=im.prototype,tf=uO.prototype,kS=function(){function p(){this.x1=0,this.y1=0,this.x2=0,this.y2=0,this.percent=1}return p}();(function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e})(kS);function sf(p){return isNaN(+p.cpx1)||isNaN(+p.cpy1)}var HI=function(p){Ye(e,p);function e(t){var s=p.call(this,t)||this;return s.type="ec-line",s}return e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new kS},e.prototype.buildPath=function(t,s){sf(s)?Lg.buildPath.call(this,t,s):tf.buildPath.call(this,t,s)},e.prototype.pointAt=function(t){return sf(this.shape)?Lg.pointAt.call(this,t):tf.pointAt.call(this,t)},e.prototype.tangentAt=function(t){var s=this.shape,i=sf(s)?[s.x2-s.x1,s.y2-s.y1]:tf.tangentAt.call(this,t);return eS(i,i)},e}(hh),GI=HI,nf=["fromSymbol","toSymbol"];function Rg(p){return"_"+p+"Type"}function Dg(p,e,t){var s=e.getItemVisual(t,p);if(!(!s||s==="none")){var i=e.getItemVisual(t,p+"Size"),n=e.getItemVisual(t,p+"Rotate"),r=e.getItemVisual(t,p+"Offset"),a=e.getItemVisual(t,p+"KeepAspect"),o=nS(i),d=rS(r||0,o),c=Bm(s,-o[0]/2+d[0],-o[1]/2+d[1],o[0],o[1],null,a);return c.__specifiedRotation=n==null||isNaN(n)?void 0:+n*Math.PI/180||0,c.name=p,c}}function UI(p){var e=new GI({name:"line",subPixelOptimize:!0});return dm(e.shape,p),e}function dm(p,e){p.x1=e[0][0],p.y1=e[0][1],p.x2=e[1][0],p.y2=e[1][1],p.percent=1;var t=e[2];t?(p.cpx1=t[0],p.cpy1=t[1]):(p.cpx1=NaN,p.cpy1=NaN)}var $I=function(p){Ye(e,p);function e(t,s,i){var n=p.call(this)||this;return n._createLine(t,s,i),n}return e.prototype._createLine=function(t,s,i){var n=t.hostModel,r=t.getItemLayout(s),a=UI(r);a.shape.percent=0,tS(a,{shape:{percent:1}},n,s),this.add(a),Ie(nf,function(o){var d=Dg(o,t,s);this.add(d),this[Rg(o)]=t.getItemVisual(s,o)},this),this._updateCommonStl(t,s,i)},e.prototype.updateData=function(t,s,i){var n=t.hostModel,r=this.childOfName("line"),a=t.getItemLayout(s),o={shape:{}};dm(o.shape,a),sS(r,o,n,s),Ie(nf,function(d){var c=t.getItemVisual(s,d),u=Rg(d);if(this[u]!==c){this.remove(this.childOfName(d));var h=Dg(d,t,s);this.add(h)}this[u]=c},this),this._updateCommonStl(t,s,i)},e.prototype.getLinePath=function(){return this.childAt(0)},e.prototype._updateCommonStl=function(t,s,i){var n=t.hostModel,r=this.childOfName("line"),a=i&&i.emphasisLineStyle,o=i&&i.blurLineStyle,d=i&&i.selectLineStyle,c=i&&i.labelStatesModels,u=i&&i.emphasisDisabled,h=i&&i.focus,f=i&&i.blurScope;if(!i||t.hasItemOption){var l=t.getItemModel(s),m=l.getModel("emphasis");a=m.getModel("lineStyle").getLineStyle(),o=l.getModel(["blur","lineStyle"]).getLineStyle(),d=l.getModel(["select","lineStyle"]).getLineStyle(),u=m.get("disabled"),h=m.get("focus"),f=m.get("blurScope"),c=iS(l)}var g=t.getItemVisual(s,"style"),y=g.stroke;r.useStyle(g),r.style.fill=null,r.style.strokeNoScale=!0,r.ensureState("emphasis").style=a,r.ensureState("blur").style=o,r.ensureState("select").style=d,Ie(nf,function(T){var I=this.childOfName(T);if(I){I.setColor(y),I.style.opacity=g.opacity;for(var A=0;A<Ag.length;A++){var N=Ag[A],B=r.getState(N);if(B){var x=B.style||{},k=I.ensureState(N),O=k.style||(k.style={});x.stroke!=null&&(O[I.__isEmptyBrush?"stroke":"fill"]=x.stroke),x.opacity!=null&&(O.opacity=x.opacity)}}I.markRedraw()}},this);var w=n.getRawValue(s);hO(this,c,{labelDataIndex:s,labelFetcher:{getFormattedLabel:function(T,I){return n.getFormattedLabel(T,I,t.dataType)}},inheritColor:y||"#000",defaultOpacity:g.opacity,defaultText:(w==null?t.getName(s):isFinite(w)?fO(w):w)+""});var b=this.getTextContent();if(b){var S=c.normal;b.__align=b.style.align,b.__verticalAlign=b.style.verticalAlign,b.__position=S.get("position")||"middle";var v=S.get("distance");ms(v)||(v=[v,v]),b.__labelDistance=v}this.setTextConfig({position:null,local:!0,inside:!1}),lO(this,h,f,u)},e.prototype.highlight=function(){nm(this)},e.prototype.downplay=function(){rm(this)},e.prototype.updateLayout=function(t,s){this.setLinePoints(t.getItemLayout(s))},e.prototype.setLinePoints=function(t){var s=this.childOfName("line");dm(s.shape,t),s.dirty()},e.prototype.beforeUpdate=function(){var t=this,s=t.childOfName("fromSymbol"),i=t.childOfName("toSymbol"),n=t.getTextContent();if(!s&&!i&&(!n||n.ignore))return;for(var r=1,a=this.parent;a;)a.scaleX&&(r/=a.scaleX),a=a.parent;var o=t.childOfName("line");if(!this.__dirty&&!o.__dirty)return;var d=o.shape.percent,c=o.pointAt(0),u=o.pointAt(d),h=pO([],u,c);eS(h,h);function f(B,x){var k=B.__specifiedRotation;if(k==null){var O=o.tangentAt(x);B.attr("rotation",(x===1?-1:1)*Math.PI/2-Math.atan2(O[1],O[0]))}else B.attr("rotation",k)}if(s&&(s.setPosition(c),f(s,0),s.scaleX=s.scaleY=r*d,s.markRedraw()),i&&(i.setPosition(u),f(i,1),i.scaleX=i.scaleY=r*d,i.markRedraw()),n&&!n.ignore){n.x=n.y=0,n.originX=n.originY=0;var l=void 0,m=void 0,g=n.__labelDistance,y=g[0]*r,w=g[1]*r,b=d/2,S=o.tangentAt(b),v=[S[1],-S[0]],T=o.pointAt(b);v[1]>0&&(v[0]=-v[0],v[1]=-v[1]);var I=S[0]<0?-1:1;if(n.__position!=="start"&&n.__position!=="end"){var A=-Math.atan2(S[1],S[0]);u[0]<c[0]&&(A=Math.PI+A),n.rotation=A}var N=void 0;switch(n.__position){case"insideStartTop":case"insideMiddleTop":case"insideEndTop":case"middle":N=-w,m="bottom";break;case"insideStartBottom":case"insideMiddleBottom":case"insideEndBottom":N=w,m="top";break;default:N=0,m="middle"}switch(n.__position){case"end":n.x=h[0]*y+u[0],n.y=h[1]*w+u[1],l=h[0]>.8?"left":h[0]<-.8?"right":"center",m=h[1]>.8?"top":h[1]<-.8?"bottom":"middle";break;case"start":n.x=-h[0]*y+c[0],n.y=-h[1]*w+c[1],l=h[0]>.8?"right":h[0]<-.8?"left":"center",m=h[1]>.8?"bottom":h[1]<-.8?"top":"middle";break;case"insideStartTop":case"insideStart":case"insideStartBottom":n.x=y*I+c[0],n.y=c[1]+N,l=S[0]<0?"right":"left",n.originX=-y*I,n.originY=-N;break;case"insideMiddleTop":case"insideMiddle":case"insideMiddleBottom":case"middle":n.x=T[0],n.y=T[1]+N,l="center",n.originY=-N;break;case"insideEndTop":case"insideEnd":case"insideEndBottom":n.x=-y*I+u[0],n.y=u[1]+N,l=S[0]>=0?"right":"left",n.originX=y*I,n.originY=-N;break}n.scaleX=n.scaleY=r,n.setStyle({verticalAlign:n.__verticalAlign||m,align:n.__align||l})}},e}(aa),WI=$I,zI=function(){function p(e){this.group=new aa,this._LineCtor=e||WI}return p.prototype.updateData=function(e){var t=this;this._progressiveEls=null;var s=this,i=s.group,n=s._lineData;s._lineData=e,n||i.removeAll();var r=Fg(e);e.diff(n).add(function(a){t._doAdd(e,a,r)}).update(function(a,o){t._doUpdate(n,e,o,a,r)}).remove(function(a){i.remove(n.getItemGraphicEl(a))}).execute()},p.prototype.updateLayout=function(){var e=this._lineData;!e||e.eachItemGraphicEl(function(t,s){t.updateLayout(e,s)},this)},p.prototype.incrementalPrepareUpdate=function(e){this._seriesScope=Fg(e),this._lineData=null,this.group.removeAll()},p.prototype.incrementalUpdate=function(e,t){this._progressiveEls=[];function s(a){!a.isGroup&&!jI(a)&&(a.incremental=!0,a.ensureState("emphasis").hoverLayer=!0)}for(var i=e.start;i<e.end;i++){var n=t.getItemLayout(i);if(rf(n)){var r=new this._LineCtor(t,i,this._seriesScope);r.traverse(s),this.group.add(r),t.setItemGraphicEl(i,r),this._progressiveEls.push(r)}}},p.prototype.remove=function(){this.group.removeAll()},p.prototype.eachRendered=function(e){aS(this._progressiveEls||this.group,e)},p.prototype._doAdd=function(e,t,s){var i=e.getItemLayout(t);if(!!rf(i)){var n=new this._LineCtor(e,t,s);e.setItemGraphicEl(t,n),this.group.add(n)}},p.prototype._doUpdate=function(e,t,s,i,n){var r=e.getItemGraphicEl(s);if(!rf(t.getItemLayout(i))){this.group.remove(r);return}r?r.updateData(t,i,n):r=new this._LineCtor(t,i,n),t.setItemGraphicEl(i,r),this.group.add(r)},p}();function jI(p){return p.animators&&p.animators.length>0}function Fg(p){var e=p.hostModel,t=e.getModel("emphasis");return{lineStyle:e.getModel("lineStyle").getLineStyle(),emphasisLineStyle:t.getModel(["lineStyle"]).getLineStyle(),blurLineStyle:e.getModel(["blur","lineStyle"]).getLineStyle(),selectLineStyle:e.getModel(["select","lineStyle"]).getLineStyle(),emphasisDisabled:t.get("disabled"),blurScope:t.get("blurScope"),focus:t.get("focus"),labelStatesModels:iS(e)}}function Hg(p){return isNaN(p[0])||isNaN(p[1])}function rf(p){return p&&!Hg(p[0])&&!Hg(p[1])}var KI=zI,sa=!0,Hd=Math.min,Ja=Math.max,XI=Math.pow,YI=1e4,ZI=6,QI=6,Gg="globalPan",JI={w:[0,0],e:[0,1],n:[1,0],s:[1,1]},ex={w:"ew",e:"ew",n:"ns",s:"ns",ne:"nesw",sw:"nesw",nw:"nwse",se:"nwse"},Ug={brushStyle:{lineWidth:2,stroke:"rgba(210,219,238,0.3)",fill:"#D2DBEE"},transformable:!0,brushMode:"single",removeOnClick:!1},tx=0,sx=function(p){Ye(e,p);function e(t){var s=p.call(this)||this;return s._track=[],s._covers=[],s._handlers={},s._zr=t,s.group=new aa,s._uid="brushController_"+tx++,Ie(cx,function(i,n){this._handlers[n]=gn(i,this)},s),s}return e.prototype.enableBrush=function(t){return this._brushType&&this._doDisableBrush(),t.brushType&&this._doEnableBrush(t),this},e.prototype._doEnableBrush=function(t){var s=this._zr;this._enableGlobalPan||pI(s,Gg,this._uid),Ie(this._handlers,function(i,n){s.on(n,i)}),this._brushType=t.brushType,this._brushOption=wn(bn(Ug),t,!0)},e.prototype._doDisableBrush=function(){var t=this._zr;mI(t,Gg,this._uid),Ie(this._handlers,function(s,i){t.off(i,s)}),this._brushType=this._brushOption=null},e.prototype.setPanels=function(t){if(t&&t.length){var s=this._panels={};Ie(t,function(i){s[i.panelId]=bn(i)})}else this._panels=null;return this},e.prototype.mount=function(t){t=t||{},this._enableGlobalPan=t.enableGlobalPan;var s=this.group;return this._zr.add(s),s.attr({x:t.x||0,y:t.y||0,rotation:t.rotation||0,scaleX:t.scaleX||1,scaleY:t.scaleY||1}),this._transform=s.getLocalTransform(),this},e.prototype.updateCovers=function(t){t=ps(t,function(h){return wn(bn(Ug),h,!0)});var s="\0-brush-index-",i=this._covers,n=this._covers=[],r=this,a=this._creatingCover;return new oS(i,t,d,o).add(c).update(c).remove(u).execute(),this;function o(h,f){return(h.id!=null?h.id:s+f)+"-"+h.brushType}function d(h,f){return o(h.__brushOption,f)}function c(h,f){var l=t[h];if(f!=null&&i[f]===a)n[h]=i[f];else{var m=n[h]=f!=null?(i[f].__brushOption=l,i[f]):vS(r,SS(r,l));qm(r,m)}}function u(h){i[h]!==a&&r.group.remove(i[h])}},e.prototype.unmount=function(){return this.enableBrush(!1),cm(this),this._zr.remove(this.group),this},e.prototype.dispose=function(){this.unmount(),this.off()},e}(mO);function SS(p,e){var t=ph[e.brushType].createCover(p,e);return t.__brushOption=e,OS(t,e),p.group.add(t),t}function vS(p,e){var t=Lm(e);return t.endCreating&&(t.endCreating(p,e),OS(e,e.__brushOption)),e}function TS(p,e){var t=e.__brushOption;Lm(e).updateCoverShape(p,e,t.range,t)}function OS(p,e){var t=e.z;t==null&&(t=YI),p.traverse(function(s){s.z=t,s.z2=t})}function qm(p,e){Lm(e).updateCommon(p,e),TS(p,e)}function Lm(p){return ph[p.__brushOption.brushType]}function Rm(p,e,t){var s=p._panels;if(!s)return sa;var i,n=p._transform;return Ie(s,function(r){r.isTargetByCursor(e,t,n)&&(i=r)}),i}function IS(p,e){var t=p._panels;if(!t)return sa;var s=e.__brushOption.panelId;return s!=null?t[s]:sa}function cm(p){var e=p._covers,t=e.length;return Ie(e,function(s){p.group.remove(s)},p),e.length=0,!!t}function ia(p,e){var t=ps(p._covers,function(s){var i=s.__brushOption,n=bn(i.range);return{brushType:i.brushType,panelId:i.panelId,range:n}});p.trigger("brush",{areas:t,isEnd:!!e.isEnd,removeOnClick:!!e.removeOnClick})}function ix(p){var e=p._track;if(!e.length)return!1;var t=e[e.length-1],s=e[0],i=t[0]-s[0],n=t[1]-s[1],r=XI(i*i+n*n,.5);return r>ZI}function xS(p){var e=p.length-1;return e<0&&(e=0),[p[0],p[e]]}function _S(p,e,t,s){var i=new aa;return i.add(new am({name:"main",style:Dm(t),silent:!0,draggable:!0,cursor:"move",drift:Ss($g,p,e,i,["n","s","w","e"]),ondragend:Ss(ia,e,{isEnd:!0})})),Ie(s,function(n){i.add(new am({name:n.join(""),style:{opacity:0},draggable:!0,silent:!0,invisible:!0,drift:Ss($g,p,e,i,n),ondragend:Ss(ia,e,{isEnd:!0})}))}),i}function CS(p,e,t,s){var i=s.brushStyle.lineWidth||0,n=Ja(i,QI),r=t[0][0],a=t[1][0],o=r-i/2,d=a-i/2,c=t[0][1],u=t[1][1],h=c-n+i/2,f=u-n+i/2,l=c-r,m=u-a,g=l+i,y=m+i;vn(p,e,"main",r,a,l,m),s.transformable&&(vn(p,e,"w",o,d,n,y),vn(p,e,"e",h,d,n,y),vn(p,e,"n",o,d,g,n),vn(p,e,"s",o,f,g,n),vn(p,e,"nw",o,d,n,n),vn(p,e,"ne",h,d,n,n),vn(p,e,"sw",o,f,n,n),vn(p,e,"se",h,f,n,n))}function um(p,e){var t=e.__brushOption,s=t.transformable,i=e.childAt(0);i.useStyle(Dm(t)),i.attr({silent:!s,cursor:s?"move":"default"}),Ie([["w"],["e"],["n"],["s"],["s","e"],["s","w"],["n","e"],["n","w"]],function(n){var r=e.childOfName(n.join("")),a=n.length===1?hm(p,n[0]):rx(p,n);r&&r.attr({silent:!s,invisible:!s,cursor:s?ex[a]+"-resize":null})})}function vn(p,e,t,s,i,n,r){var a=e.childOfName(t);a&&a.setShape(ox(Fm(p,e,[[s,i],[s+n,i+r]])))}function Dm(p){return ao({strokeNoScale:!0},p.brushStyle)}function MS(p,e,t,s){var i=[Hd(p,t),Hd(e,s)],n=[Ja(p,t),Ja(e,s)];return[[i[0],n[0]],[i[1],n[1]]]}function nx(p){return cS(p.group)}function hm(p,e){var t={w:"left",e:"right",n:"top",s:"bottom"},s={left:"w",right:"e",top:"n",bottom:"s"},i=yO(t[e],nx(p));return s[i]}function rx(p,e){var t=[hm(p,e[0]),hm(p,e[1])];return(t[0]==="e"||t[0]==="w")&&t.reverse(),t.join("")}function $g(p,e,t,s,i,n){var r=t.__brushOption,a=p.toRectRange(r.range),o=PS(e,i,n);Ie(s,function(d){var c=JI[d];a[c[0]][c[1]]+=o[c[0]]}),r.range=p.fromRectRange(MS(a[0][0],a[1][0],a[0][1],a[1][1])),qm(e,t),ia(e,{isEnd:!1})}function ax(p,e,t,s){var i=e.__brushOption.range,n=PS(p,t,s);Ie(i,function(r){r[0]+=n[0],r[1]+=n[1]}),qm(p,e),ia(p,{isEnd:!1})}function PS(p,e,t){var s=p.group,i=s.transformCoordToLocal(e,t),n=s.transformCoordToLocal(0,0);return[i[0]-n[0],i[1]-n[1]]}function Fm(p,e,t){var s=IS(p,e);return s&&s!==sa?s.clipPath(t,p._transform):bn(t)}function ox(p){var e=Hd(p[0][0],p[1][0]),t=Hd(p[0][1],p[1][1]),s=Ja(p[0][0],p[1][0]),i=Ja(p[0][1],p[1][1]);return{x:e,y:t,width:s-e,height:i-t}}function dx(p,e,t){if(!(!p._brushType||ux(p,e.offsetX,e.offsetY))){var s=p._zr,i=p._covers,n=Rm(p,e,t);if(!p._dragging)for(var r=0;r<i.length;r++){var a=i[r].__brushOption;if(n&&(n===sa||a.panelId===n.panelId)&&ph[a.brushType].contain(i[r],t[0],t[1]))return}n&&s.setCursorStyle("crosshair")}}function fm(p){var e=p.event;e.preventDefault&&e.preventDefault()}function lm(p,e,t){return p.childOfName("main").contain(e,t)}function AS(p,e,t,s){var i=p._creatingCover,n=p._creatingPanel,r=p._brushOption,a;if(p._track.push(t.slice()),ix(p)||i){if(n&&!i){r.brushMode==="single"&&cm(p);var o=bn(r);o.brushType=Wg(o.brushType,n),o.panelId=n===sa?null:n.panelId,i=p._creatingCover=SS(p,o),p._covers.push(i)}if(i){var d=ph[Wg(p._brushType,n)],c=i.__brushOption;c.range=d.getCreatingRange(Fm(p,i,p._track)),s&&(vS(p,i),d.updateCommon(p,i)),TS(p,i),a={isEnd:s}}}else s&&r.brushMode==="single"&&r.removeOnClick&&Rm(p,e,t)&&cm(p)&&(a={isEnd:s,removeOnClick:!0});return a}function Wg(p,e){return p==="auto"?e.defaultBrushType:p}var cx={mousedown:function(p){if(this._dragging)zg(this,p);else if(!p.target||!p.target.draggable){fm(p);var e=this.group.transformCoordToLocal(p.offsetX,p.offsetY);this._creatingCover=null;var t=this._creatingPanel=Rm(this,p,e);t&&(this._dragging=!0,this._track=[e.slice()])}},mousemove:function(p){var e=p.offsetX,t=p.offsetY,s=this.group.transformCoordToLocal(e,t);if(dx(this,p,s),this._dragging){fm(p);var i=AS(this,p,s,!1);i&&ia(this,i)}},mouseup:function(p){zg(this,p)}};function zg(p,e){if(p._dragging){fm(e);var t=e.offsetX,s=e.offsetY,i=p.group.transformCoordToLocal(t,s),n=AS(p,e,i,!0);p._dragging=!1,p._track=[],p._creatingCover=null,n&&ia(p,n)}}function ux(p,e,t){var s=p._zr;return e<0||e>s.getWidth()||t<0||t>s.getHeight()}var ph={lineX:jg(0),lineY:jg(1),rect:{createCover:function(p,e){function t(s){return s}return _S({toRectRange:t,fromRectRange:t},p,e,[["w"],["e"],["n"],["s"],["s","e"],["s","w"],["n","e"],["n","w"]])},getCreatingRange:function(p){var e=xS(p);return MS(e[1][0],e[1][1],e[0][0],e[0][1])},updateCoverShape:function(p,e,t,s){CS(p,e,t,s)},updateCommon:um,contain:lm},polygon:{createCover:function(p,e){var t=new aa;return t.add(new dS({name:"main",style:Dm(e),silent:!0})),t},getCreatingRange:function(p){return p},endCreating:function(p,e){e.remove(e.childAt(0)),e.add(new gO({name:"main",draggable:!0,drift:Ss(ax,p,e),ondragend:Ss(ia,p,{isEnd:!0})}))},updateCoverShape:function(p,e,t,s){e.childAt(0).setShape({points:Fm(p,e,t)})},updateCommon:um,contain:lm}};function jg(p){return{createCover:function(e,t){return _S({toRectRange:function(s){var i=[s,[0,100]];return p&&i.reverse(),i},fromRectRange:function(s){return s[p]}},e,t,[[["w"],["e"]],[["n"],["s"]]][p])},getCreatingRange:function(e){var t=xS(e),s=Hd(t[0][p],t[1][p]),i=Ja(t[0][p],t[1][p]);return[s,i]},updateCoverShape:function(e,t,s,i){var n,r=IS(e,t);if(r!==sa&&r.getLinearBrushOtherExtent)n=r.getLinearBrushOtherExtent(p);else{var a=e._zr;n=[0,[a.getWidth(),a.getHeight()][1-p]]}var o=[s,n];p&&o.reverse(),CS(e,t,o,i)},updateCommon:um,contain:lm}}var hx=sx;function fx(p){return p=Hm(p),function(e){return wO(e,p)}}function lx(p,e){return p=Hm(p),function(t){var s=e!=null?e:t,i=s?p.width:p.height,n=s?p.x:p.y;return[n,n+(i||0)]}}function px(p,e,t){var s=Hm(p);return function(i,n){return s.contain(n[0],n[1])&&!FI(i,e,t)}}function Hm(p){return Am.create(p)}var mx=function(){function p(){}return p.prototype.getInitialData=function(e,t){var s,i=t.getComponent("xAxis",this.get("xAxisIndex")),n=t.getComponent("yAxis",this.get("yAxisIndex")),r=i.get("type"),a=n.get("type"),o;r==="category"?(e.layout="horizontal",s=i.getOrdinalMeta(),o=!0):a==="category"?(e.layout="vertical",s=n.getOrdinalMeta(),o=!0):e.layout=e.layout||"horizontal";var d=["x","y"],c=e.layout==="horizontal"?0:1,u=this._baseAxisDim=d[c],h=d[1-c],f=[i,n],l=f[c].get("type"),m=f[1-c].get("type"),g=e.data;if(g&&o){var y=[];Ie(g,function(S,v){var T;ms(S)?(T=S.slice(),S.unshift(v)):ms(S.value)?(T=kn({},S),T.value=T.value.slice(),S.value.unshift(v)):T=S,y.push(T)}),e.data=y}var w=this.defaultValueDimensions,b=[{name:u,type:Bg(l),ordinalMeta:s,otherDims:{tooltip:!1,itemName:0},dimsDef:["base"]},{name:h,type:Bg(m),dimsDef:w.slice()}];return MI(this,{coordDimensions:b,dimensionsCount:w.length+1,encodeDefaulter:Ss(bO,b,this)})},p.prototype.getBaseAxis=function(){var e=this._baseAxisDim;return this.ecModel.getComponent(e+"Axis",this.get(e+"AxisIndex")).axis},p}(),gx=["color","borderColor"],yx=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.render=function(t,s,i){this.group.removeClipPath(),this._progressiveEls=null,this._updateDrawMode(t),this._isLargeDraw?this._renderLarge(t):this._renderNormal(t)},e.prototype.incrementalPrepareRender=function(t,s,i){this._clear(),this._updateDrawMode(t)},e.prototype.incrementalRender=function(t,s,i,n){this._progressiveEls=[],this._isLargeDraw?this._incrementalRenderLarge(t,s):this._incrementalRenderNormal(t,s)},e.prototype.eachRendered=function(t){aS(this._progressiveEls||this.group,t)},e.prototype._updateDrawMode=function(t){var s=t.pipelineContext.large;(this._isLargeDraw==null||s!==this._isLargeDraw)&&(this._isLargeDraw=s,this._clear())},e.prototype._renderNormal=function(t){var s=t.getData(),i=this._data,n=this.group,r=s.getLayout("isSimpleBox"),a=t.get("clip",!0),o=t.coordinateSystem,d=o.getArea&&o.getArea();this._data||n.removeAll(),s.diff(i).add(function(c){if(s.hasValue(c)){var u=s.getItemLayout(c);if(a&&Kg(d,u))return;var h=af(u,c,!0);tS(h,{shape:{points:u.ends}},t,c),of(h,s,c,r),n.add(h),s.setItemGraphicEl(c,h)}}).update(function(c,u){var h=i.getItemGraphicEl(u);if(!s.hasValue(c)){n.remove(h);return}var f=s.getItemLayout(c);if(a&&Kg(d,f)){n.remove(h);return}h?(sS(h,{shape:{points:f.ends}},t,c),kO(h)):h=af(f),of(h,s,c,r),n.add(h),s.setItemGraphicEl(c,h)}).remove(function(c){var u=i.getItemGraphicEl(c);u&&n.remove(u)}).execute(),this._data=s},e.prototype._renderLarge=function(t){this._clear(),Xg(t,this.group);var s=t.get("clip",!0)?gI(t.coordinateSystem,!1,t):null;s?this.group.setClipPath(s):this.group.removeClipPath()},e.prototype._incrementalRenderNormal=function(t,s){for(var i=s.getData(),n=i.getLayout("isSimpleBox"),r;(r=t.next())!=null;){var a=i.getItemLayout(r),o=af(a);of(o,i,r,n),o.incremental=!0,this.group.add(o),this._progressiveEls.push(o)}},e.prototype._incrementalRenderLarge=function(t,s){Xg(s,this.group,this._progressiveEls,!0)},e.prototype.remove=function(t){this._clear()},e.prototype._clear=function(){this.group.removeAll(),this._data=null},e.type="candlestick",e}(J1),wx=function(){function p(){}return p}(),bx=function(p){Ye(e,p);function e(t){var s=p.call(this,t)||this;return s.type="normalCandlestickBox",s}return e.prototype.getDefaultShape=function(){return new wx},e.prototype.buildPath=function(t,s){var i=s.points;this.__simpleBox?(t.moveTo(i[4][0],i[4][1]),t.lineTo(i[6][0],i[6][1])):(t.moveTo(i[0][0],i[0][1]),t.lineTo(i[1][0],i[1][1]),t.lineTo(i[2][0],i[2][1]),t.lineTo(i[3][0],i[3][1]),t.closePath(),t.moveTo(i[4][0],i[4][1]),t.lineTo(i[5][0],i[5][1]),t.moveTo(i[6][0],i[6][1]),t.lineTo(i[7][0],i[7][1]))},e}(hh);function af(p,e,t){var s=p.ends;return new bx({shape:{points:t?kx(s,p):s},z2:100})}function Kg(p,e){for(var t=!0,s=0;s<e.ends.length;s++)if(p.contain(e.ends[s][0],e.ends[s][1])){t=!1;break}return t}function of(p,e,t,s){var i=e.getItemModel(t);p.useStyle(e.getItemVisual(t,"style")),p.style.strokeNoScale=!0,p.__simpleBox=s,SO(p,i)}function kx(p,e){return ps(p,function(t){return t=t.slice(),t[1]=e.initBaseline,t})}var Sx=function(){function p(){}return p}(),df=function(p){Ye(e,p);function e(t){var s=p.call(this,t)||this;return s.type="largeCandlestickBox",s}return e.prototype.getDefaultShape=function(){return new Sx},e.prototype.buildPath=function(t,s){for(var i=s.points,n=0;n<i.length;)if(this.__sign===i[n++]){var r=i[n++];t.moveTo(r,i[n++]),t.lineTo(r,i[n++])}else n+=3},e}(hh);function Xg(p,e,t,s){var i=p.getData(),n=i.getLayout("largePoints"),r=new df({shape:{points:n},__sign:1,ignoreCoarsePointer:!0});e.add(r);var a=new df({shape:{points:n},__sign:-1,ignoreCoarsePointer:!0});e.add(a);var o=new df({shape:{points:n},__sign:0,ignoreCoarsePointer:!0});e.add(o),cf(1,r,p),cf(-1,a,p),cf(0,o,p),s&&(r.incremental=!0,a.incremental=!0),t&&t.push(r,a)}function cf(p,e,t,s){var i=t.get(["itemStyle",p>0?"borderColor":"borderColor0"])||t.get(["itemStyle",p>0?"color":"color0"]);p===0&&(i=t.get(["itemStyle","borderColorDoji"]));var n=t.getModel("itemStyle").getItemStyle(gx);e.useStyle(n),e.style.fill=null,e.style.stroke=i}var vx=yx,BS=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t.defaultValueDimensions=[{name:"open",defaultTooltip:!0},{name:"close",defaultTooltip:!0},{name:"lowest",defaultTooltip:!0},{name:"highest",defaultTooltip:!0}],t}return e.prototype.getShadowDim=function(){return"open"},e.prototype.brushSelector=function(t,s,i){var n=s.getItemLayout(t);return n&&i.rect(n.brushRect)},e.type="series.candlestick",e.dependencies=["xAxis","yAxis","grid"],e.defaultOption={z:2,coordinateSystem:"cartesian2d",legendHoverLink:!0,layout:null,clip:!0,itemStyle:{color:"#eb5454",color0:"#47b262",borderColor:"#eb5454",borderColor0:"#47b262",borderColorDoji:null,borderWidth:1},emphasis:{scale:!0,itemStyle:{borderWidth:2}},barMaxWidth:null,barMinWidth:null,barWidth:null,large:!0,largeThreshold:600,progressive:3e3,progressiveThreshold:1e4,progressiveChunkMode:"mod",animationEasing:"linear",animationDuration:300},e}(Q1);Vm(BS,mx,!0);var Tx=BS;function Ox(p){!p||!ms(p.series)||Ie(p.series,function(e){Dd(e)&&e.type==="k"&&(e.type="candlestick")})}var Ix=["itemStyle","borderColor"],xx=["itemStyle","borderColor0"],_x=["itemStyle","borderColorDoji"],Cx=["itemStyle","color"],Mx=["itemStyle","color0"],Px={seriesType:"candlestick",plan:uS(),performRawSeries:!0,reset:function(p,e){function t(n,r){return r.get(n>0?Cx:Mx)}function s(n,r){return r.get(n===0?_x:n>0?Ix:xx)}if(!e.isSeriesFiltered(p)){var i=p.pipelineContext.large;return!i&&{progress:function(n,r){for(var a;(a=n.next())!=null;){var o=r.getItemModel(a),d=r.getItemLayout(a).sign,c=o.getItemStyle();c.fill=t(d,o),c.stroke=s(d,o)||c.fill;var u=r.ensureUniqueItemVisual(a,"style");kn(u,c)}}}}}},Ax=Px,Bx={seriesType:"candlestick",plan:uS(),reset:function(p){var e=p.coordinateSystem,t=p.getData(),s=Nx(p,t),i=0,n=1,r=["x","y"],a=t.getDimensionIndex(t.mapDimension(r[i])),o=ps(t.mapDimensionsAll(r[n]),t.getDimensionIndex,t),d=o[0],c=o[1],u=o[2],h=o[3];if(t.setLayout({candleWidth:s,isSimpleBox:s<=1.3}),a<0||o.length<4)return;return{progress:p.pipelineContext.large?l:f};function f(m,g){for(var y,w=g.getStore();(y=m.next())!=null;){var b=w.get(a,y),S=w.get(d,y),v=w.get(c,y),T=w.get(u,y),I=w.get(h,y),A=Math.min(S,v),N=Math.max(S,v),B=D(A,b),x=D(N,b),k=D(T,b),O=D(I,b),P=[];H(P,x,0),H(P,B,1),P.push(_(O),_(x),_(k),_(B));var q=g.getItemModel(y),L=!!q.get(["itemStyle","borderColorDoji"]);g.setItemLayout(y,{sign:Yg(w,y,S,v,c,L),initBaseline:S>v?x[n]:B[n],ends:P,brushRect:R(T,I,b)})}function D(E,U){var G=[];return G[i]=U,G[n]=E,isNaN(U)||isNaN(E)?[NaN,NaN]:e.dataToPoint(G)}function H(E,U,G){var $=U.slice(),Z=U.slice();$[i]=Jh($[i]+s/2,1,!1),Z[i]=Jh(Z[i]-s/2,1,!0),G?E.push($,Z):E.push(Z,$)}function R(E,U,G){var $=D(E,G),Z=D(U,G);return $[i]-=s/2,Z[i]-=s/2,{x:$[0],y:$[1],width:s,height:Z[1]-$[1]}}function _(E){return E[i]=Jh(E[i],1),E}}function l(m,g){for(var y=vO(m.count*4),w=0,b,S=[],v=[],T,I=g.getStore(),A=!!p.get(["itemStyle","borderColorDoji"]);(T=m.next())!=null;){var N=I.get(a,T),B=I.get(d,T),x=I.get(c,T),k=I.get(u,T),O=I.get(h,T);if(isNaN(N)||isNaN(k)||isNaN(O)){y[w++]=NaN,w+=3;continue}y[w++]=Yg(I,T,B,x,c,A),S[i]=N,S[n]=k,b=e.dataToPoint(S,null,v),y[w++]=b?b[0]:NaN,y[w++]=b?b[1]:NaN,S[n]=O,b=e.dataToPoint(S,null,v),y[w++]=b?b[1]:NaN}g.setLayout("largePoints",y)}}};function Yg(p,e,t,s,i,n){var r;return t>s?r=-1:t<s?r=1:r=n?0:e>0?p.get(i,e-1)<=s?1:-1:1,r}function Nx(p,e){var t=p.getBaseAxis(),s,i=t.type==="category"?t.getBandWidth():(s=t.getExtent(),Math.abs(s[1]-s[0])/e.count()),n=Xa(Jr(p.get("barMaxWidth"),i),i),r=Xa(Jr(p.get("barMinWidth"),1),i),a=p.get("barWidth");return a!=null?Xa(a,i):Math.max(Math.min(i/2,n),r)}var Vx=Bx;function Ex(p){p.registerChartView(vx),p.registerSeriesModel(Tx),p.registerPreprocessor(Ox),p.registerVisual(Ax),p.registerLayout(Vx)}var qx=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.init=function(t,s,i){var n=TO(t);p.prototype.init.apply(this,arguments),Zg(t,n)},e.prototype.mergeOption=function(t){p.prototype.mergeOption.apply(this,arguments),Zg(this.option,t)},e.prototype.getCellSize=function(){return this.option.cellSize},e.type="calendar",e.defaultOption={z:2,left:80,top:60,cellSize:20,orient:"horizontal",splitLine:{show:!0,lineStyle:{color:"#000",width:1,type:"solid"}},itemStyle:{color:"#fff",borderWidth:1,borderColor:"#ccc"},dayLabel:{show:!0,firstDay:0,position:"start",margin:"50%",color:"#000"},monthLabel:{show:!0,position:"start",margin:5,align:"center",formatter:null,color:"#000"},yearLabel:{show:!0,position:null,margin:30,formatter:null,color:"#ccc",fontFamily:"sans-serif",fontWeight:"bolder",fontSize:20}},e}(fh);function Zg(p,e){var t=p.cellSize,s;ms(t)?s=t:s=p.cellSize=[t,t],s.length===1&&(s[1]=s[0]);var i=ps([0,1],function(n){return OO(e,n)&&(s[n]="auto"),s[n]!=null&&s[n]!=="auto"});IO(p,e,{type:"box",ignoreSize:i})}var Lx=qx,Rx=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.render=function(t,s,i){var n=this.group;n.removeAll();var r=t.coordinateSystem,a=r.getRangeInfo(),o=r.getOrient(),d=s.getLocaleModel();this._renderDayRect(t,a,n),this._renderLines(t,a,o,n),this._renderYearText(t,a,o,n),this._renderMonthText(t,d,o,n),this._renderWeekText(t,d,a,o,n)},e.prototype._renderDayRect=function(t,s,i){for(var n=t.coordinateSystem,r=t.getModel("itemStyle").getItemStyle(),a=n.getCellWidth(),o=n.getCellHeight(),d=s.start.time;d<=s.end.time;d=n.getNextNDay(d,1).time){var c=n.dataToRect([d],!1).tl,u=new am({shape:{x:c[0],y:c[1],width:a,height:o},cursor:"default",style:r});i.add(u)}},e.prototype._renderLines=function(t,s,i,n){var r=this,a=t.coordinateSystem,o=t.getModel(["splitLine","lineStyle"]).getLineStyle(),d=t.get(["splitLine","show"]),c=o.lineWidth;this._tlpoints=[],this._blpoints=[],this._firstDayOfMonth=[],this._firstDayPoints=[];for(var u=s.start,h=0;u.time<=s.end.time;h++){l(u.formatedDate),h===0&&(u=a.getDateInfo(s.start.y+"-"+s.start.m));var f=u.date;f.setMonth(f.getMonth()+1),u=a.getDateInfo(f)}l(a.getNextNDay(s.end.time,1).formatedDate);function l(m){r._firstDayOfMonth.push(a.getDateInfo(m)),r._firstDayPoints.push(a.dataToRect([m],!1).tl);var g=r._getLinePointsOfOneWeek(t,m,i);r._tlpoints.push(g[0]),r._blpoints.push(g[g.length-1]),d&&r._drawSplitline(g,o,n)}d&&this._drawSplitline(r._getEdgesPoints(r._tlpoints,c,i),o,n),d&&this._drawSplitline(r._getEdgesPoints(r._blpoints,c,i),o,n)},e.prototype._getEdgesPoints=function(t,s,i){var n=[t[0].slice(),t[t.length-1].slice()],r=i==="horizontal"?0:1;return n[0][r]=n[0][r]-s/2,n[1][r]=n[1][r]+s/2,n},e.prototype._drawSplitline=function(t,s,i){var n=new dS({z2:20,shape:{points:t},style:s});i.add(n)},e.prototype._getLinePointsOfOneWeek=function(t,s,i){for(var n=t.coordinateSystem,r=n.getDateInfo(s),a=[],o=0;o<7;o++){var d=n.getNextNDay(r.time,o),c=n.dataToRect([d.time],!1);a[2*d.day]=c.tl,a[2*d.day+1]=c[i==="horizontal"?"bl":"tr"]}return a},e.prototype._formatterLabel=function(t,s){return fr(t)&&t?xO(t,s):Fd(t)?t(s):s.nameMap},e.prototype._yearTextPositionControl=function(t,s,i,n,r){var a=s[0],o=s[1],d=["center","bottom"];n==="bottom"?(o+=r,d=["center","top"]):n==="left"?a-=r:n==="right"?(a+=r,d=["center","top"]):o-=r;var c=0;return(n==="left"||n==="right")&&(c=Math.PI/2),{rotation:c,x:a,y:o,style:{align:d[0],verticalAlign:d[1]}}},e.prototype._renderYearText=function(t,s,i,n){var r=t.getModel("yearLabel");if(!!r.get("show")){var a=r.get("margin"),o=r.get("position");o||(o=i!=="horizontal"?"top":"left");var d=[this._tlpoints[this._tlpoints.length-1],this._blpoints[0]],c=(d[0][0]+d[1][0])/2,u=(d[0][1]+d[1][1])/2,h=i==="horizontal"?0:1,f={top:[c,d[h][1]],bottom:[c,d[1-h][1]],left:[d[1-h][0],u],right:[d[h][0],u]},l=s.start.y;+s.end.y>+s.start.y&&(l=l+"-"+s.end.y);var m=r.get("formatter"),g={start:s.start.y,end:s.end.y,nameMap:l},y=this._formatterLabel(m,g),w=new Ya({z2:30,style:Za(r,{text:y})});w.attr(this._yearTextPositionControl(w,f[o],i,o,a)),n.add(w)}},e.prototype._monthTextPositionControl=function(t,s,i,n,r){var a="left",o="top",d=t[0],c=t[1];return i==="horizontal"?(c=c+r,s&&(a="center"),n==="start"&&(o="bottom")):(d=d+r,s&&(o="middle"),n==="start"&&(a="right")),{x:d,y:c,align:a,verticalAlign:o}},e.prototype._renderMonthText=function(t,s,i,n){var r=t.getModel("monthLabel");if(!!r.get("show")){var a=r.get("nameMap"),o=r.get("margin"),d=r.get("position"),c=r.get("align"),u=[this._tlpoints,this._blpoints];(!a||fr(a))&&(a&&(s=Ng(a)||s),a=s.get(["time","monthAbbr"])||[]);var h=d==="start"?0:1,f=i==="horizontal"?0:1;o=d==="start"?-o:o;for(var l=c==="center",m=0;m<u[h].length-1;m++){var g=u[h][m].slice(),y=this._firstDayOfMonth[m];if(l){var w=this._firstDayPoints[m];g[f]=(w[f]+u[0][m+1][f])/2}var b=r.get("formatter"),S=a[+y.m-1],v={yyyy:y.y,yy:(y.y+"").slice(2),MM:y.m,M:+y.m,nameMap:S},T=this._formatterLabel(b,v),I=new Ya({z2:30,style:kn(Za(r,{text:T}),this._monthTextPositionControl(g,l,i,d,o))});n.add(I)}}},e.prototype._weekTextPositionControl=function(t,s,i,n,r){var a="center",o="middle",d=t[0],c=t[1],u=i==="start";return s==="horizontal"?(d=d+n+(u?1:-1)*r[0]/2,a=u?"right":"left"):(c=c+n+(u?1:-1)*r[1]/2,o=u?"bottom":"top"),{x:d,y:c,align:a,verticalAlign:o}},e.prototype._renderWeekText=function(t,s,i,n,r){var a=t.getModel("dayLabel");if(!!a.get("show")){var o=t.coordinateSystem,d=a.get("position"),c=a.get("nameMap"),u=a.get("margin"),h=o.getFirstDayOfWeek();if(!c||fr(c)){c&&(s=Ng(c)||s);var f=s.get(["time","dayOfWeekShort"]);c=f||ps(s.get(["time","dayOfWeekAbbr"]),function(v){return v[0]})}var l=o.getNextNDay(i.end.time,7-i.lweek).time,m=[o.getCellWidth(),o.getCellHeight()];u=Xa(u,Math.min(m[1],m[0])),d==="start"&&(l=o.getNextNDay(i.start.time,-(7+i.fweek)).time,u=-u);for(var g=0;g<7;g++){var y=o.getNextNDay(l,g),w=o.dataToRect([y.time],!1).center,b=g;b=Math.abs((g+h)%7);var S=new Ya({z2:30,style:kn(Za(a,{text:c[b]}),this._weekTextPositionControl(w,n,d,u,m))});r.add(S)}}},e.type="calendar",e}(lh),Dx=Rx,uf=864e5,Fx=function(){function p(e,t,s){this.type="calendar",this.dimensions=p.dimensions,this.getDimensionsInfo=p.getDimensionsInfo,this._model=e}return p.getDimensionsInfo=function(){return[{name:"time",type:"time"},"value"]},p.prototype.getRangeInfo=function(){return this._rangeInfo},p.prototype.getModel=function(){return this._model},p.prototype.getRect=function(){return this._rect},p.prototype.getCellWidth=function(){return this._sw},p.prototype.getCellHeight=function(){return this._sh},p.prototype.getOrient=function(){return this._orient},p.prototype.getFirstDayOfWeek=function(){return this._firstDayOfWeek},p.prototype.getDateInfo=function(e){e=_O(e);var t=e.getFullYear(),s=e.getMonth()+1,i=s<10?"0"+s:""+s,n=e.getDate(),r=n<10?"0"+n:""+n,a=e.getDay();return a=Math.abs((a+7-this.getFirstDayOfWeek())%7),{y:t+"",m:i,d:r,day:a,time:e.getTime(),formatedDate:t+"-"+i+"-"+r,date:e}},p.prototype.getNextNDay=function(e,t){return t=t||0,t===0?this.getDateInfo(e):(e=new Date(this.getDateInfo(e).time),e.setDate(e.getDate()+t),this.getDateInfo(e))},p.prototype.update=function(e,t){this._firstDayOfWeek=+this._model.getModel("dayLabel").get("firstDay"),this._orient=this._model.get("orient"),this._lineWidth=this._model.getModel("itemStyle").getItemStyle().lineWidth||0,this._rangeInfo=this._getRangeInfo(this._initRangeOption());var s=this._rangeInfo.weeks||1,i=["width","height"],n=this._model.getCellSize().slice(),r=this._model.getBoxLayoutParams(),a=this._orient==="horizontal"?[s,7]:[7,s];Ie([0,1],function(u){c(n,u)&&(r[i[u]]=n[u]*a[u])});var o={width:t.getWidth(),height:t.getHeight()},d=this._rect=hS(r,o);Ie([0,1],function(u){c(n,u)||(n[u]=d[i[u]]/a[u])});function c(u,h){return u[h]!=null&&u[h]!=="auto"}this._sw=n[0],this._sh=n[1]},p.prototype.dataToPoint=function(e,t){ms(e)&&(e=e[0]),t==null&&(t=!0);var s=this.getDateInfo(e),i=this._rangeInfo,n=s.formatedDate;if(t&&!(s.time>=i.start.time&&s.time<i.end.time+uf))return[NaN,NaN];var r=s.day,a=this._getRangeInfo([i.start.time,n]).nthWeek;return this._orient==="vertical"?[this._rect.x+r*this._sw+this._sw/2,this._rect.y+a*this._sh+this._sh/2]:[this._rect.x+a*this._sw+this._sw/2,this._rect.y+r*this._sh+this._sh/2]},p.prototype.pointToData=function(e){var t=this.pointToDate(e);return t&&t.time},p.prototype.dataToRect=function(e,t){var s=this.dataToPoint(e,t);return{contentShape:{x:s[0]-(this._sw-this._lineWidth)/2,y:s[1]-(this._sh-this._lineWidth)/2,width:this._sw-this._lineWidth,height:this._sh-this._lineWidth},center:s,tl:[s[0]-this._sw/2,s[1]-this._sh/2],tr:[s[0]+this._sw/2,s[1]-this._sh/2],br:[s[0]+this._sw/2,s[1]+this._sh/2],bl:[s[0]-this._sw/2,s[1]+this._sh/2]}},p.prototype.pointToDate=function(e){var t=Math.floor((e[0]-this._rect.x)/this._sw)+1,s=Math.floor((e[1]-this._rect.y)/this._sh)+1,i=this._rangeInfo.range;return this._orient==="vertical"?this._getDateByWeeksAndDay(s,t-1,i):this._getDateByWeeksAndDay(t,s-1,i)},p.prototype.convertToPixel=function(e,t,s){var i=Qg(t);return i===this?i.dataToPoint(s):null},p.prototype.convertFromPixel=function(e,t,s){var i=Qg(t);return i===this?i.pointToData(s):null},p.prototype.containPoint=function(e){return console.warn("Not implemented."),!1},p.prototype._initRangeOption=function(){var e=this._model.get("range"),t;if(ms(e)&&e.length===1&&(e=e[0]),ms(e))t=e;else{var s=e.toString();if(/^\d{4}$/.test(s)&&(t=[s+"-01-01",s+"-12-31"]),/^\d{4}[\/|-]\d{1,2}$/.test(s)){var i=this.getDateInfo(s),n=i.date;n.setMonth(n.getMonth()+1);var r=this.getNextNDay(n,-1);t=[i.formatedDate,r.formatedDate]}/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(s)&&(t=[s,s])}if(!t)return e;var a=this._getRangeInfo(t);return a.start.time>a.end.time&&t.reverse(),t},p.prototype._getRangeInfo=function(e){var t=[this.getDateInfo(e[0]),this.getDateInfo(e[1])],s;t[0].time>t[1].time&&(s=!0,t.reverse());var i=Math.floor(t[1].time/uf)-Math.floor(t[0].time/uf)+1,n=new Date(t[0].time),r=n.getDate(),a=t[1].date.getDate();n.setDate(r+i-1);var o=n.getDate();if(o!==a)for(var d=n.getTime()-t[1].time>0?1:-1;(o=n.getDate())!==a&&(n.getTime()-t[1].time)*d>0;)i-=d,n.setDate(o-d);var c=Math.floor((i+t[0].day+6)/7),u=s?-c+1:c-1;return s&&t.reverse(),{range:[t[0].formatedDate,t[1].formatedDate],start:t[0],end:t[1],allDay:i,weeks:c,nthWeek:u,fweek:t[0].day,lweek:t[1].day}},p.prototype._getDateByWeeksAndDay=function(e,t,s){var i=this._getRangeInfo(s);if(e>i.weeks||e===0&&t<i.fweek||e===i.weeks&&t>i.lweek)return null;var n=(e-1)*7-i.fweek+t,r=new Date(i.start.time);return r.setDate(+i.start.d+n),this.getDateInfo(r)},p.create=function(e,t){var s=[];return e.eachComponent("calendar",function(i){var n=new p(i);s.push(n),i.coordinateSystem=n}),e.eachSeries(function(i){i.get("coordinateSystem")==="calendar"&&(i.coordinateSystem=s[i.get("calendarIndex")||0])}),s},p.dimensions=["time","value"],p}();function Qg(p){var e=p.calendarModel,t=p.seriesModel,s=e?e.coordinateSystem:t?t.coordinateSystem:null;return s}var Hx=Fx;function Gx(p){p.registerComponentModel(Lx),p.registerComponentView(Dx),p.registerCoordinateSystem("calendar",Hx)}var Ux=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.type="dataZoom.select",e}(yI),$x=Ux,Wx=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.type="dataZoom.select",e}(wI),zx=Wx;function jx(p){p.registerComponentModel($x),p.registerComponentView(zx),bI(p)}var Zi=function(){function p(){}return p}(),NS={};function So(p,e){NS[p]=e}function VS(p){return NS[p]}var Kx=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.optionUpdated=function(){p.prototype.optionUpdated.apply(this,arguments);var t=this.ecModel;Ie(this.option.feature,function(s,i){var n=VS(i);n&&(n.getDefaultOption&&(n.defaultOption=n.getDefaultOption(t)),wn(s,n.defaultOption))})},e.type="toolbox",e.layoutMode={type:"box",ignoreSize:!0},e.defaultOption={show:!0,z:6,orient:"horizontal",left:"right",top:"top",backgroundColor:"transparent",borderColor:"#ccc",borderRadius:0,borderWidth:0,padding:5,itemSize:15,itemGap:8,showTitle:!0,iconStyle:{borderColor:"#666",color:"none"},emphasis:{iconStyle:{borderColor:"#3E98C5"}},tooltip:{show:!1,position:"bottom"}},e}(fh),Xx=Kx,Yx=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.render=function(t,s,i,n){var r=this.group;if(r.removeAll(),!t.get("show"))return;var a=+t.get("itemSize"),o=t.get("orient")==="vertical",d=t.get("feature")||{},c=this._features||(this._features={}),u=[];Ie(d,function(l,m){u.push(m)}),new oS(this._featureNames||[],u).add(h).update(h).remove(Ss(h,null)).execute(),this._featureNames=u;function h(l,m){var g=u[l],y=u[m],w=d[g],b=new CO(w,t,t.ecModel),S;if(n&&n.newTitle!=null&&n.featureName===g&&(w.title=n.newTitle),g&&!y){if(Zx(g))S={onclick:b.option.onclick,featureName:g};else{var v=VS(g);if(!v)return;S=new v}c[g]=S}else if(S=c[y],!S)return;S.uid=MO("toolbox-feature"),S.model=b,S.ecModel=s,S.api=i;var T=S instanceof Zi;if(!g&&y){T&&S.dispose&&S.dispose(s,i);return}if(!b.get("show")||T&&S.unusable){T&&S.remove&&S.remove(s,i);return}f(b,S,g),b.setIconStatus=function(I,A){var N=this.option,B=this.iconPaths;N.iconStatus=N.iconStatus||{},N.iconStatus[I]=A,B[I]&&(A==="emphasis"?nm:rm)(B[I])},S instanceof Zi&&S.render&&S.render(b,s,i,n)}function f(l,m,g){var y=l.getModel("iconStyle"),w=l.getModel(["emphasis","iconStyle"]),b=m instanceof Zi&&m.getIcons?m.getIcons():l.get("icon"),S=l.get("title")||{},v,T;fr(b)?(v={},v[g]=b):v=b,fr(S)?(T={},T[g]=S):T=S;var I=l.iconPaths={};Ie(v,function(A,N){var B=fS(A,{},{x:-a/2,y:-a/2,width:a,height:a});B.setStyle(y.getItemStyle());var x=B.ensureState("emphasis");x.style=w.getItemStyle();var k=new Ya({style:{text:T[N],align:w.get("textAlign"),borderRadius:w.get("textBorderRadius"),padding:w.get("textPadding"),fill:null},ignore:!0});B.setTextContent(k),PO({el:B,componentModel:t,itemName:N,formatterParamsExtra:{title:T[N]}}),B.__title=T[N],B.on("mouseover",function(){var O=w.getItemStyle(),P=o?t.get("right")==null&&t.get("left")!=="right"?"right":"left":t.get("bottom")==null&&t.get("top")!=="bottom"?"bottom":"top";k.setStyle({fill:w.get("textFill")||O.fill||O.stroke||"#000",backgroundColor:w.get("textBackgroundColor")}),B.setTextConfig({position:w.get("textPosition")||P}),k.ignore=!t.get("showTitle"),i.enterEmphasis(this)}).on("mouseout",function(){l.get(["iconStatus",N])!=="emphasis"&&i.leaveEmphasis(this),k.hide()}),(l.get(["iconStatus",N])==="emphasis"?nm:rm)(B),r.add(B),B.on("click",gn(m.onclick,m,s,i,N)),I[N]=B})}AO(r,t,i),r.add(BO(r.getBoundingRect(),t)),o||r.eachChild(function(l){var m=l.__title,g=l.ensureState("emphasis"),y=g.textConfig||(g.textConfig={}),w=l.getTextContent(),b=w&&w.ensureState("emphasis");if(b&&!Fd(b)&&m){var S=b.style||(b.style={}),v=NO(m,Ya.makeFont(S)),T=l.x+r.x,I=l.y+r.y+a,A=!1;I+v.height>i.getHeight()&&(y.position="top",A=!0);var N=A?-5-v.height:a+10;T+v.width/2>i.getWidth()?(y.position=["100%",N],S.align="right"):T-v.width/2<0&&(y.position=[0,N],S.align="left")}})},e.prototype.updateView=function(t,s,i,n){Ie(this._features,function(r){r instanceof Zi&&r.updateView&&r.updateView(r.model,s,i,n)})},e.prototype.remove=function(t,s){Ie(this._features,function(i){i instanceof Zi&&i.remove&&i.remove(t,s)}),this.group.removeAll()},e.prototype.dispose=function(t,s){Ie(this._features,function(i){i instanceof Zi&&i.dispose&&i.dispose(t,s)})},e.type="toolbox",e}(lh);function Zx(p){return p.indexOf("my")===0}var Qx=Yx,Jx=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.onclick=function(t,s){var i=this.model,n=i.get("name")||t.get("title.0.text")||"echarts",r=s.getZr().painter.getType()==="svg",a=r?"svg":i.get("type",!0)||"png",o=s.getConnectedDataURL({type:a,backgroundColor:i.get("backgroundColor",!0)||t.get("backgroundColor")||"#fff",connectedBackgroundColor:i.get("connectedBackgroundColor"),excludeComponents:i.get("excludeComponents"),pixelRatio:i.get("pixelRatio")}),d=lS.browser;if(Fd(MouseEvent)&&(d.newEdge||!d.ie&&!d.edge)){var c=document.createElement("a");c.download=n+"."+a,c.target="_blank",c.href=o;var u=new MouseEvent("click",{view:document.defaultView,bubbles:!0,cancelable:!1});c.dispatchEvent(u)}else if(window.navigator.msSaveOrOpenBlob||r){var h=o.split(","),f=h[0].indexOf("base64")>-1,l=r?decodeURIComponent(h[1]):h[1];f&&(l=window.atob(l));var m=n+"."+a;if(window.navigator.msSaveOrOpenBlob){for(var g=l.length,y=new Uint8Array(g);g--;)y[g]=l.charCodeAt(g);var w=new Blob([y]);window.navigator.msSaveOrOpenBlob(w,m)}else{var b=document.createElement("iframe");document.body.appendChild(b);var S=b.contentWindow,v=S.document;v.open("image/svg+xml","replace"),v.write(l),v.close(),S.focus(),v.execCommand("SaveAs",!0,m),document.body.removeChild(b)}}else{var T=i.get("lang"),I='<body style="margin:0;"><img src="'+o+'" style="max-width:100%;" title="'+(T&&T[0]||"")+'" /></body>',A=window.open();A.document.write(I),A.document.title=n}},e.getDefaultOption=function(t){var s={show:!0,icon:"M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",title:t.getLocaleModel().get(["toolbox","saveAsImage","title"]),type:"png",connectedBackgroundColor:"#fff",name:"",excludeComponents:["toolbox"],lang:t.getLocaleModel().get(["toolbox","saveAsImage","lang"])};return s},e}(Zi),e_=Jx,Jg="__ec_magicType_stack__",t_=[["line","bar"],["stack"]],s_=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.getIcons=function(){var t=this.model,s=t.get("icon"),i={};return Ie(t.get("type"),function(n){s[n]&&(i[n]=s[n])}),i},e.getDefaultOption=function(t){var s={show:!0,type:[],icon:{line:"M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",bar:"M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",stack:"M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"},title:t.getLocaleModel().get(["toolbox","magicType","title"]),option:{},seriesIndex:{}};return s},e.prototype.onclick=function(t,s,i){var n=this.model,r=n.get(["seriesIndex",i]);if(!!e0[i]){var a={series:[]},o=function(u){var h=u.subType,f=u.id,l=e0[i](h,f,u,n);l&&(ao(l,u.option),a.series.push(l));var m=u.coordinateSystem;if(m&&m.type==="cartesian2d"&&(i==="line"||i==="bar")){var g=m.getAxesByScale("ordinal")[0];if(g){var y=g.dim,w=y+"Axis",b=u.getReferringComponents(w,VO).models[0],S=b.componentIndex;a[w]=a[w]||[];for(var v=0;v<=S;v++)a[w][S]=a[w][S]||{};a[w][S].boundaryGap=i==="bar"}}};Ie(t_,function(u){ta(u,i)>=0&&Ie(u,function(h){n.setIconStatus(h,"normal")})}),n.setIconStatus(i,"emphasis"),t.eachComponent({mainType:"series",query:r==null?null:{seriesIndex:r}},o);var d,c=i;i==="stack"&&(d=wn({stack:n.option.title.tiled,tiled:n.option.title.stack},n.option.title),n.get(["iconStatus",i])!=="emphasis"&&(c="tiled")),s.dispatchAction({type:"changeMagicType",currentType:c,newOption:a,newTitle:d,featureName:"magicType"})}},e}(Zi),e0={line:function(p,e,t,s){if(p==="bar")return wn({id:e,type:"line",data:t.get("data"),stack:t.get("stack"),markPoint:t.get("markPoint"),markLine:t.get("markLine")},s.get(["option","line"])||{},!0)},bar:function(p,e,t,s){if(p==="line")return wn({id:e,type:"bar",data:t.get("data"),stack:t.get("stack"),markPoint:t.get("markPoint"),markLine:t.get("markLine")},s.get(["option","bar"])||{},!0)},stack:function(p,e,t,s){var i=t.get("stack")===Jg;if(p==="line"||p==="bar")return s.setIconStatus("stack",i?"normal":"emphasis"),wn({id:e,stack:i?"":Jg},s.get(["option","stack"])||{},!0)}};Em({type:"changeMagicType",event:"magicTypeChanged",update:"prepareAndUpdate"},function(p,e){e.mergeOption(p.newOption)});var i_=s_,mh=new Array(60).join("-"),eo="	";function n_(p){var e={},t=[],s=[];return p.eachRawSeries(function(i){var n=i.coordinateSystem;if(n&&(n.type==="cartesian2d"||n.type==="polar")){var r=n.getBaseAxis();if(r.type==="category"){var a=r.dim+"_"+r.index;e[a]||(e[a]={categoryAxis:r,valueAxis:n.getOtherAxis(r),series:[]},s.push({axisDim:r.dim,axisIndex:r.index})),e[a].series.push(i)}else t.push(i)}else t.push(i)}),{seriesGroupByCategoryAxis:e,other:t,meta:s}}function r_(p){var e=[];return Ie(p,function(t,s){var i=t.categoryAxis,n=t.valueAxis,r=n.dim,a=[" "].concat(ps(t.series,function(f){return f.name})),o=[i.model.getCategories()];Ie(t.series,function(f){var l=f.getRawData();o.push(f.getRawData().mapArray(l.mapDimension(r),function(m){return m}))});for(var d=[a.join(eo)],c=0;c<o[0].length;c++){for(var u=[],h=0;h<o.length;h++)u.push(o[h][c]);d.push(u.join(eo))}e.push(d.join(`
`))}),e.join(`

`+mh+`

`)}function a_(p){return ps(p,function(e){var t=e.getRawData(),s=[e.name],i=[];return t.each(t.dimensions,function(){for(var n=arguments.length,r=arguments[n-1],a=t.getName(r),o=0;o<n-1;o++)i[o]=arguments[o];s.push((a?a+eo:"")+i.join(eo))}),s.join(`
`)}).join(`

`+mh+`

`)}function o_(p){var e=n_(p);return{value:pS([r_(e.seriesGroupByCategoryAxis),a_(e.other)],function(t){return!!t.replace(/[\n\t\s]/g,"")}).join(`

`+mh+`

`),meta:e.meta}}function Ju(p){return p.replace(/^\s\s*/,"").replace(/\s\s*$/,"")}function d_(p){var e=p.slice(0,p.indexOf(`
`));if(e.indexOf(eo)>=0)return!0}var pm=new RegExp("["+eo+"]+","g");function c_(p){for(var e=p.split(/\n+/g),t=Ju(e.shift()).split(pm),s=[],i=ps(t,function(o){return{name:o,data:[]}}),n=0;n<e.length;n++){var r=Ju(e[n]).split(pm);s.push(r.shift());for(var a=0;a<r.length;a++)i[a]&&(i[a].data[n]=r[a])}return{series:i,categories:s}}function u_(p){for(var e=p.split(/\n+/g),t=Ju(e.shift()),s=[],i=0;i<e.length;i++){var n=Ju(e[i]);if(!!n){var r=n.split(pm),a="",o=void 0,d=!1;isNaN(r[0])?(d=!0,a=r[0],r=r.slice(1),s[i]={name:a,value:[]},o=s[i].value):o=s[i]=[];for(var c=0;c<r.length;c++)o.push(+r[c]);o.length===1&&(d?s[i].value=o[0]:s[i]=o[0])}}return{name:t,data:s}}function h_(p,e){var t=p.split(new RegExp(`
*`+mh+`
*`,"g")),s={series:[]};return Ie(t,function(i,n){if(d_(i)){var r=c_(i),a=e[n],o=a.axisDim+"Axis";a&&(s[o]=s[o]||[],s[o][a.axisIndex]={data:r.categories},s.series=s.series.concat(r.series))}else{var r=u_(i);s.series.push(r)}}),s}var f_=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.onclick=function(t,s){setTimeout(function(){s.dispatchAction({type:"hideTip"})});var i=s.getDom(),n=this.model;this._dom&&i.removeChild(this._dom);var r=document.createElement("div");r.style.cssText="position:absolute;top:0;bottom:0;left:0;right:0;padding:5px",r.style.backgroundColor=n.get("backgroundColor")||"#fff";var a=document.createElement("h4"),o=n.get("lang")||[];a.innerHTML=o[0]||n.get("title"),a.style.cssText="margin:10px 20px",a.style.color=n.get("textColor");var d=document.createElement("div"),c=document.createElement("textarea");d.style.cssText="overflow:auto";var u=n.get("optionToContent"),h=n.get("contentToOption"),f=o_(t);if(Fd(u)){var l=u(s.getOption());fr(l)?d.innerHTML=l:EO(l)&&d.appendChild(l)}else{c.readOnly=n.get("readOnly");var m=c.style;m.cssText="display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none",m.color=n.get("textColor"),m.borderColor=n.get("textareaBorderColor"),m.backgroundColor=n.get("textareaColor"),c.value=f.value,d.appendChild(c)}var g=f.meta,y=document.createElement("div");y.style.cssText="position:absolute;bottom:5px;left:0;right:0";var w="float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",b=document.createElement("div"),S=document.createElement("div");w+=";background-color:"+n.get("buttonColor"),w+=";color:"+n.get("buttonTextColor");var v=this;function T(){i.removeChild(r),v._dom=null}Vg(b,"click",T),Vg(S,"click",function(){if(h==null&&u!=null||h!=null&&u==null){T();return}var I;try{Fd(h)?I=h(d,s.getOption()):I=h_(c.value,g)}catch(A){throw T(),new Error("Data view format error "+A)}I&&s.dispatchAction({type:"changeDataView",newOption:I}),T()}),b.innerHTML=o[1],S.innerHTML=o[2],S.style.cssText=b.style.cssText=w,!n.get("readOnly")&&y.appendChild(S),y.appendChild(b),r.appendChild(a),r.appendChild(d),r.appendChild(y),d.style.height=i.clientHeight-80+"px",i.appendChild(r),this._dom=r},e.prototype.remove=function(t,s){this._dom&&s.getDom().removeChild(this._dom)},e.prototype.dispose=function(t,s){this.remove(t,s)},e.getDefaultOption=function(t){var s={show:!0,readOnly:!1,optionToContent:null,contentToOption:null,icon:"M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",title:t.getLocaleModel().get(["toolbox","dataView","title"]),lang:t.getLocaleModel().get(["toolbox","dataView","lang"]),backgroundColor:"#fff",textColor:"#000",textareaColor:"#fff",textareaBorderColor:"#333",buttonColor:"#c23531",buttonTextColor:"#fff"};return s},e}(Zi);function l_(p,e){return ps(p,function(t,s){var i=e&&e[s];if(Dd(i)&&!ms(i)){var n=Dd(t)&&!ms(t);n||(t={value:t});var r=i.name!=null&&t.name==null;return t=ao(t,i),r&&delete t.name,t}else return t})}Em({type:"changeDataView",event:"dataViewChanged",update:"prepareAndUpdate"},function(p,e){var t=[];Ie(p.newOption.series,function(s){var i=e.getSeriesByName(s.name)[0];if(!i)t.push(kn({type:"scatter"},s));else{var n=i.get("data");t.push({name:s.name,data:l_(s.data,n)})}}),e.mergeOption(ao({series:t},p.newOption))});var p_=f_,ES=Ie,qS=Wd();function m_(p,e){var t=Gm(p);ES(e,function(s,i){for(var n=t.length-1;n>=0;n--){var r=t[n];if(r[i])break}if(n<0){var a=p.queryComponents({mainType:"dataZoom",subType:"select",id:i})[0];if(a){var o=a.getPercentRange();t[0][i]={dataZoomId:i,start:o[0],end:o[1]}}}}),t.push(e)}function g_(p){var e=Gm(p),t=e[e.length-1];e.length>1&&e.pop();var s={};return ES(t,function(i,n){for(var r=e.length-1;r>=0;r--)if(i=e[r][n],i){s[n]=i;break}}),s}function y_(p){qS(p).snapshots=null}function w_(p){return Gm(p).length}function Gm(p){var e=qS(p);return e.snapshots||(e.snapshots=[{}]),e.snapshots}var b_=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.onclick=function(t,s){y_(t),s.dispatchAction({type:"restore",from:this.uid})},e.getDefaultOption=function(t){var s={show:!0,icon:"M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",title:t.getLocaleModel().get(["toolbox","restore","title"])};return s},e}(Zi);Em({type:"restore",event:"restore",update:"prepareAndUpdate"},function(p,e){e.resetOption("recreate")});var k_=b_,S_=["grid","xAxis","yAxis","geo","graph","polar","radiusAxis","angleAxis","bmap"],v_=function(){function p(e,t,s){var i=this;this._targetInfoList=[];var n=t0(t,e);Ie(T_,function(r,a){(!s||!s.include||ta(s.include,a)>=0)&&r(n,i._targetInfoList)})}return p.prototype.setOutputRanges=function(e,t){return this.matchOutputRanges(e,t,function(s,i,n){if((s.coordRanges||(s.coordRanges=[])).push(i),!s.coordRange){s.coordRange=i;var r=hf[s.brushType](0,n,i);s.__rangeOffset={offset:r0[s.brushType](r.values,s.range,[1,1]),xyMinMax:r.xyMinMax}}}),e},p.prototype.matchOutputRanges=function(e,t,s){Ie(e,function(i){var n=this.findTargetInfo(i,t);n&&n!==!0&&Ie(n.coordSyses,function(r){var a=hf[i.brushType](1,r,i.range,!0);s(i,a.values,r,t)})},this)},p.prototype.setInputRanges=function(e,t){Ie(e,function(s){var i=this.findTargetInfo(s,t);if(s.range=s.range||[],i&&i!==!0){s.panelId=i.panelId;var n=hf[s.brushType](0,i.coordSys,s.coordRange),r=s.__rangeOffset;s.range=r?r0[s.brushType](n.values,r.offset,O_(n.xyMinMax,r.xyMinMax)):n.values}},this)},p.prototype.makePanelOpts=function(e,t){return ps(this._targetInfoList,function(s){var i=s.getPanelRect();return{panelId:s.panelId,defaultBrushType:t?t(s):null,clipPath:fx(i),isTargetByCursor:px(i,e,s.coordSysModel),getLinearBrushOtherExtent:lx(i)}})},p.prototype.controlSeries=function(e,t,s){var i=this.findTargetInfo(e,s);return i===!0||i&&ta(i.coordSyses,t.coordinateSystem)>=0},p.prototype.findTargetInfo=function(e,t){for(var s=this._targetInfoList,i=t0(t,e),n=0;n<s.length;n++){var r=s[n],a=e.panelId;if(a){if(r.panelId===a)return r}else for(var o=0;o<s0.length;o++)if(s0[o](i,r))return r}return!0},p}();function mm(p){return p[0]>p[1]&&p.reverse(),p}function t0(p,e){return mS(p,e,{includeMainTypes:S_})}var T_={grid:function(p,e){var t=p.xAxisModels,s=p.yAxisModels,i=p.gridModels,n=gS(),r={},a={};!t&&!s&&!i||(Ie(t,function(o){var d=o.axis.grid.model;n.set(d.id,d),r[d.id]=!0}),Ie(s,function(o){var d=o.axis.grid.model;n.set(d.id,d),a[d.id]=!0}),Ie(i,function(o){n.set(o.id,o),r[o.id]=!0,a[o.id]=!0}),n.each(function(o){var d=o.coordinateSystem,c=[];Ie(d.getCartesians(),function(u,h){(ta(t,u.getAxis("x").model)>=0||ta(s,u.getAxis("y").model)>=0)&&c.push(u)}),e.push({panelId:"grid--"+o.id,gridModel:o,coordSysModel:o,coordSys:c[0],coordSyses:c,getPanelRect:i0.grid,xAxisDeclared:r[o.id],yAxisDeclared:a[o.id]})}))},geo:function(p,e){Ie(p.geoModels,function(t){var s=t.coordinateSystem;e.push({panelId:"geo--"+t.id,geoModel:t,coordSysModel:t,coordSys:s,coordSyses:[s],getPanelRect:i0.geo})})}},s0=[function(p,e){var t=p.xAxisModel,s=p.yAxisModel,i=p.gridModel;return!i&&t&&(i=t.axis.grid.model),!i&&s&&(i=s.axis.grid.model),i&&i===e.gridModel},function(p,e){var t=p.geoModel;return t&&t===e.geoModel}],i0={grid:function(){return this.coordSys.master.getRect().clone()},geo:function(){var p=this.coordSys,e=p.getBoundingRect().clone();return e.applyTransform(cS(p)),e}},hf={lineX:Ss(n0,0),lineY:Ss(n0,1),rect:function(p,e,t,s){var i=p?e.pointToData([t[0][0],t[1][0]],s):e.dataToPoint([t[0][0],t[1][0]],s),n=p?e.pointToData([t[0][1],t[1][1]],s):e.dataToPoint([t[0][1],t[1][1]],s),r=[mm([i[0],n[0]]),mm([i[1],n[1]])];return{values:r,xyMinMax:r}},polygon:function(p,e,t,s){var i=[[1/0,-1/0],[1/0,-1/0]],n=ps(t,function(r){var a=p?e.pointToData(r,s):e.dataToPoint(r,s);return i[0][0]=Math.min(i[0][0],a[0]),i[1][0]=Math.min(i[1][0],a[1]),i[0][1]=Math.max(i[0][1],a[0]),i[1][1]=Math.max(i[1][1],a[1]),a});return{values:n,xyMinMax:i}}};function n0(p,e,t,s){var i=t.getAxis(["x","y"][p]),n=mm(ps([0,1],function(a){return e?i.coordToData(i.toLocalCoord(s[a]),!0):i.toGlobalCoord(i.dataToCoord(s[a]))})),r=[];return r[p]=n,r[1-p]=[NaN,NaN],{values:n,xyMinMax:r}}var r0={lineX:Ss(a0,0),lineY:Ss(a0,1),rect:function(p,e,t){return[[p[0][0]-t[0]*e[0][0],p[0][1]-t[0]*e[0][1]],[p[1][0]-t[1]*e[1][0],p[1][1]-t[1]*e[1][1]]]},polygon:function(p,e,t){return ps(p,function(s,i){return[s[0]-t[0]*e[i][0],s[1]-t[1]*e[i][1]]})}};function a0(p,e,t,s){return[e[0]-s[p]*t[0],e[1]-s[p]*t[1]]}function O_(p,e){var t=o0(p),s=o0(e),i=[t[0]/s[0],t[1]/s[1]];return isNaN(i[0])&&(i[0]=1),isNaN(i[1])&&(i[1]=1),i}function o0(p){return p?[p[0][1]-p[0][0],p[1][1]-p[1][0]]:[NaN,NaN]}var LS=v_,gm=Ie,I_=LO("toolbox-dataZoom_"),x_=function(p){Ye(e,p);function e(){return p!==null&&p.apply(this,arguments)||this}return e.prototype.render=function(t,s,i,n){this._brushController||(this._brushController=new hx(i.getZr()),this._brushController.on("brush",gn(this._onBrush,this)).mount()),M_(t,s,this,n,i),C_(t,s)},e.prototype.onclick=function(t,s,i){__[i].call(this)},e.prototype.remove=function(t,s){this._brushController&&this._brushController.unmount()},e.prototype.dispose=function(t,s){this._brushController&&this._brushController.dispose()},e.prototype._onBrush=function(t){var s=t.areas;if(!t.isEnd||!s.length)return;var i={},n=this.ecModel;this._brushController.updateCovers([]);var r=new LS(Um(this.model),n,{include:["grid"]});r.matchOutputRanges(s,n,function(d,c,u){if(u.type==="cartesian2d"){var h=d.brushType;h==="rect"?(a("x",u,c[0]),a("y",u,c[1])):a({lineX:"x",lineY:"y"}[h],u,c)}}),m_(n,i),this._dispatchZoomAction(i);function a(d,c,u){var h=c.getAxis(d),f=h.model,l=o(d,f,n),m=l.findRepresentativeAxisProxy(f).getMinMaxSpan();(m.minValueSpan!=null||m.maxValueSpan!=null)&&(u=kI(0,u.slice(),h.scale.getExtent(),0,m.minValueSpan,m.maxValueSpan)),l&&(i[l.id]={dataZoomId:l.id,startValue:u[0],endValue:u[1]})}function o(d,c,u){var h;return u.eachComponent({mainType:"dataZoom",subType:"select"},function(f){var l=f.getAxisModel(d,c.componentIndex);l&&(h=f)}),h}},e.prototype._dispatchZoomAction=function(t){var s=[];gm(t,function(i,n){s.push(bn(i))}),s.length&&this.api.dispatchAction({type:"dataZoom",from:this.uid,batch:s})},e.getDefaultOption=function(t){var s={show:!0,filterMode:"filter",icon:{zoom:"M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",back:"M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"},title:t.getLocaleModel().get(["toolbox","dataZoom","title"]),brushStyle:{borderWidth:0,color:"rgba(210,219,238,0.2)"}};return s},e}(Zi),__={zoom:function(){var p=!this._isZoomActive;this.api.dispatchAction({type:"takeGlobalCursor",key:"dataZoomSelect",dataZoomSelectActive:p})},back:function(){this._dispatchZoomAction(g_(this.ecModel))}};function Um(p){var e={xAxisIndex:p.get("xAxisIndex",!0),yAxisIndex:p.get("yAxisIndex",!0),xAxisId:p.get("xAxisId",!0),yAxisId:p.get("yAxisId",!0)};return e.xAxisIndex==null&&e.xAxisId==null&&(e.xAxisIndex="all"),e.yAxisIndex==null&&e.yAxisId==null&&(e.yAxisIndex="all"),e}function C_(p,e){p.setIconStatus("back",w_(e)>1?"emphasis":"normal")}function M_(p,e,t,s,i){var n=t._isZoomActive;s&&s.type==="takeGlobalCursor"&&(n=s.key==="dataZoomSelect"?s.dataZoomSelectActive:!1),t._isZoomActive=n,p.setIconStatus("zoom",n?"emphasis":"normal");var r=new LS(Um(p),e,{include:["grid"]}),a=r.makePanelOpts(i,function(o){return o.xAxisDeclared&&!o.yAxisDeclared?"lineX":!o.xAxisDeclared&&o.yAxisDeclared?"lineY":"rect"});t._brushController.setPanels(a).enableBrush(n&&a.length?{brushType:"auto",brushStyle:p.getModel("brushStyle").getItemStyle()}:!1)}qO("dataZoom",function(p){var e=p.getComponent("toolbox",0),t=["feature","dataZoom"];if(!e||e.get(t)==null)return;var s=e.getModel(t),i=[],n=Um(s),r=mS(p,n);gm(r.xAxisModels,function(o){return a(o,"xAxis","xAxisIndex")}),gm(r.yAxisModels,function(o){return a(o,"yAxis","yAxisIndex")});function a(o,d,c){var u=o.componentIndex,h={type:"select",$fromToolbox:!0,filterMode:s.get("filterMode",!0)||"filter",id:I_+d+u};h[c]=u,i.push(h)}return i});var P_=x_;function A_(p){p.registerComponentModel(Xx),p.registerComponentView(Qx),So("saveAsImage",e_),So("magicType",i_),So("dataView",p_),So("dataZoom",P_),So("restore",k_),Nm(jx)}var B_=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t.layoutMode="box",t}return e.prototype.init=function(t,s,i){this.mergeDefaultAndTheme(t,i),this._initData()},e.prototype.mergeOption=function(t){p.prototype.mergeOption.apply(this,arguments),this._initData()},e.prototype.setCurrentIndex=function(t){t==null&&(t=this.option.currentIndex);var s=this._data.count();this.option.loop?t=(t%s+s)%s:(t>=s&&(t=s-1),t<0&&(t=0)),this.option.currentIndex=t},e.prototype.getCurrentIndex=function(){return this.option.currentIndex},e.prototype.isIndexMax=function(){return this.getCurrentIndex()>=this._data.count()-1},e.prototype.setPlayState=function(t){this.option.autoPlay=!!t},e.prototype.getPlayState=function(){return!!this.option.autoPlay},e.prototype._initData=function(){var t=this.option,s=t.data||[],i=t.axisType,n=this._names=[],r;i==="category"?(r=[],Ie(s,function(d,c){var u=RO(DO(d),""),h;Dd(d)?(h=bn(d),h.value=c):h=c,r.push(h),n.push(u)})):r=s;var a={category:"ordinal",time:"time",value:"number"}[i]||"number",o=this._data=new Gu([{name:"value",type:a}],this);o.initData(r,n)},e.prototype.getData=function(){return this._data},e.prototype.getCategories=function(){if(this.get("axisType")==="category")return this._names.slice()},e.type="timeline",e.defaultOption={z:4,show:!0,axisType:"time",realtime:!0,left:"20%",top:null,right:"20%",bottom:0,width:null,height:40,padding:5,controlPosition:"left",autoPlay:!1,rewind:!1,loop:!0,playInterval:2e3,currentIndex:0,itemStyle:{},label:{color:"#000"},data:[]},e}(fh),d0=B_,RS=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.type="timeline.slider",e.defaultOption=FO(d0.defaultOption,{backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderWidth:0,orient:"horizontal",inverse:!1,tooltip:{trigger:"item"},symbol:"circle",symbolSize:12,lineStyle:{show:!0,width:2,color:"#DAE1F5"},label:{position:"auto",show:!0,interval:"auto",rotate:0,color:"#A4B1D7"},itemStyle:{color:"#A4B1D7",borderWidth:1},checkpointStyle:{symbol:"circle",symbolSize:15,color:"#316bf3",borderColor:"#fff",borderWidth:2,shadowBlur:2,shadowOffsetX:1,shadowOffsetY:1,shadowColor:"rgba(0, 0, 0, 0.3)",animation:!0,animationDuration:300,animationEasing:"quinticInOut"},controlStyle:{show:!0,showPlayBtn:!0,showPrevBtn:!0,showNextBtn:!0,itemSize:24,itemGap:12,position:"left",playIcon:"path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",stopIcon:"path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",nextIcon:"M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",prevIcon:"M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",prevBtnSize:18,nextBtnSize:18,color:"#A4B1D7",borderColor:"#A4B1D7",borderWidth:1},emphasis:{label:{show:!0,color:"#6f778d"},itemStyle:{color:"#316BF3"},controlStyle:{color:"#316BF3",borderColor:"#316BF3",borderWidth:2}},progress:{lineStyle:{color:"#316BF3"},itemStyle:{color:"#316BF3"},label:{color:"#6f778d"}},data:[]}),e}(d0);Vm(RS,yS.prototype);var N_=RS,V_=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.type="timeline",e}(lh),E_=V_,q_=function(p){Ye(e,p);function e(t,s,i,n){var r=p.call(this,t,s,i)||this;return r.type=n||"value",r}return e.prototype.getLabelModel=function(){return this.model.getModel("label")},e.prototype.isHorizontal=function(){return this.model.get("orient")==="horizontal"},e}(SI),L_=q_,ff=Math.PI,c0=Wd(),R_=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.init=function(t,s){this.api=s},e.prototype.render=function(t,s,i){if(this.model=t,this.api=i,this.ecModel=s,this.group.removeAll(),t.get("show",!0)){var n=this._layout(t,i),r=this._createGroup("_mainGroup"),a=this._createGroup("_labelGroup"),o=this._axis=this._createAxis(n,t);t.formatTooltip=function(d){var c=o.scale.getLabel({value:d});return om("nameValue",{noName:!0,value:c})},Ie(["AxisLine","AxisTick","Control","CurrentPointer"],function(d){this["_render"+d](n,r,o,t)},this),this._renderAxisLabel(n,a,o,t),this._position(n,t)}this._doPlayStop(),this._updateTicksStatus()},e.prototype.remove=function(){this._clearTimer(),this.group.removeAll()},e.prototype.dispose=function(){this._clearTimer()},e.prototype._layout=function(t,s){var i=t.get(["label","position"]),n=t.get("orient"),r=F_(t,s),a;i==null||i==="auto"?a=n==="horizontal"?r.y+r.height/2<s.getHeight()/2?"-":"+":r.x+r.width/2<s.getWidth()/2?"+":"-":fr(i)?a={horizontal:{top:"-",bottom:"+"},vertical:{left:"-",right:"+"}}[n][i]:a=i;var o={horizontal:"center",vertical:a>=0||a==="+"?"left":"right"},d={horizontal:a>=0||a==="+"?"top":"bottom",vertical:"middle"},c={horizontal:0,vertical:ff/2},u=n==="vertical"?r.height:r.width,h=t.getModel("controlStyle"),f=h.get("show",!0),l=f?h.get("itemSize"):0,m=f?h.get("itemGap"):0,g=l+m,y=t.get(["label","rotate"])||0;y=y*ff/180;var w,b,S,v=h.get("position",!0),T=f&&h.get("showPlayBtn",!0),I=f&&h.get("showPrevBtn",!0),A=f&&h.get("showNextBtn",!0),N=0,B=u;v==="left"||v==="bottom"?(T&&(w=[0,0],N+=g),I&&(b=[N,0],N+=g),A&&(S=[B-l,0],B-=g)):(T&&(w=[B-l,0],B-=g),I&&(b=[0,0],N+=g),A&&(S=[B-l,0],B-=g));var x=[N,B];return t.get("inverse")&&x.reverse(),{viewRect:r,mainLength:u,orient:n,rotation:c[n],labelRotation:y,labelPosOpt:a,labelAlign:t.get(["label","align"])||o[n],labelBaseline:t.get(["label","verticalAlign"])||t.get(["label","baseline"])||d[n],playPosition:w,prevBtnPosition:b,nextBtnPosition:S,axisExtent:x,controlSize:l,controlGap:m}},e.prototype._position=function(t,s){var i=this._mainGroup,n=this._labelGroup,r=t.viewRect;if(t.orient==="vertical"){var a=KO(),o=r.x,d=r.y+r.height;Eg(a,a,[-o,-d]),HO(a,a,-ff/2),Eg(a,a,[o,d]),r=r.clone(),r.applyTransform(a)}var c=w(r),u=w(i.getBoundingRect()),h=w(n.getBoundingRect()),f=[i.x,i.y],l=[n.x,n.y];l[0]=f[0]=c[0][0];var m=t.labelPosOpt;if(m==null||fr(m)){var g=m==="+"?0:1;b(f,u,c,1,g),b(l,h,c,1,1-g)}else{var g=m>=0?0:1;b(f,u,c,1,g),l[1]=f[1]+m}i.setPosition(f),n.setPosition(l),i.rotation=n.rotation=t.rotation,y(i),y(n);function y(S){S.originX=c[0][0]-S.x,S.originY=c[1][0]-S.y}function w(S){return[[S.x,S.x+S.width],[S.y,S.y+S.height]]}function b(S,v,T,I,A){S[I]+=T[I][A]-v[I][A]}},e.prototype._createAxis=function(t,s){var i=s.getData(),n=s.get("axisType"),r=D_(s,n);r.getTicks=function(){return i.mapArray(["value"],function(d){return{value:d}})};var a=i.getDataExtent("value");r.setExtent(a[0],a[1]),r.calcNiceTicks();var o=new L_("value",r,t.axisExtent,n);return o.model=s,o},e.prototype._createGroup=function(t){var s=this[t]=new aa;return this.group.add(s),s},e.prototype._renderAxisLine=function(t,s,i,n){var r=i.getExtent();if(!!n.get(["lineStyle","show"])){var a=new im({shape:{x1:r[0],y1:0,x2:r[1],y2:0},style:kn({lineCap:"round"},n.getModel("lineStyle").getLineStyle()),silent:!0,z2:1});s.add(a);var o=this._progressLine=new im({shape:{x1:r[0],x2:this._currentPointer?this._currentPointer.x:r[0],y1:0,y2:0},style:ao({lineCap:"round",lineWidth:a.style.lineWidth},n.getModel(["progress","lineStyle"]).getLineStyle()),silent:!0,z2:1});s.add(o)}},e.prototype._renderAxisTick=function(t,s,i,n){var r=this,a=n.getData(),o=i.scale.getTicks();this._tickSymbols=[],Ie(o,function(d){var c=i.dataToCoord(d.value),u=a.getItemModel(d.value),h=u.getModel("itemStyle"),f=u.getModel(["emphasis","itemStyle"]),l=u.getModel(["progress","itemStyle"]),m={x:c,y:0,onclick:gn(r._changeTimeline,r,d.value)},g=u0(u,h,s,m);g.ensureState("emphasis").style=f.getItemStyle(),g.ensureState("progress").style=l.getItemStyle(),ef(g);var y=Zu(g);u.get("tooltip")?(y.dataIndex=d.value,y.dataModel=n):y.dataIndex=y.dataModel=null,r._tickSymbols.push(g)})},e.prototype._renderAxisLabel=function(t,s,i,n){var r=this,a=i.getLabelModel();if(!!a.get("show")){var o=n.getData(),d=i.getViewLabels();this._tickLabels=[],Ie(d,function(c){var u=c.tickValue,h=o.getItemModel(u),f=h.getModel("label"),l=h.getModel(["emphasis","label"]),m=h.getModel(["progress","label"]),g=i.dataToCoord(c.tickValue),y=new Ya({x:g,y:0,rotation:t.labelRotation-t.rotation,onclick:gn(r._changeTimeline,r,u),silent:!1,style:Za(f,{text:c.formattedLabel,align:t.labelAlign,verticalAlign:t.labelBaseline})});y.ensureState("emphasis").style=Za(l),y.ensureState("progress").style=Za(m),s.add(y),ef(y),c0(y).dataIndex=u,r._tickLabels.push(y)})}},e.prototype._renderControl=function(t,s,i,n){var r=t.controlSize,a=t.rotation,o=n.getModel("controlStyle").getItemStyle(),d=n.getModel(["emphasis","controlStyle"]).getItemStyle(),c=n.getPlayState(),u=n.get("inverse",!0);h(t.nextBtnPosition,"next",gn(this._changeTimeline,this,u?"-":"+")),h(t.prevBtnPosition,"prev",gn(this._changeTimeline,this,u?"+":"-")),h(t.playPosition,c?"stop":"play",gn(this._handlePlayClick,this,!c),!0);function h(f,l,m,g){if(!!f){var y=GO(Jr(n.get(["controlStyle",l+"BtnSize"]),r),r),w=[0,-y/2,y,y],b=H_(n,l+"Icon",w,{x:f[0],y:f[1],originX:r/2,originY:0,rotation:g?-a:0,rectHover:!0,style:o,onclick:m});b.ensureState("emphasis").style=d,s.add(b),ef(b)}}},e.prototype._renderCurrentPointer=function(t,s,i,n){var r=n.getData(),a=n.getCurrentIndex(),o=r.getItemModel(a).getModel("checkpointStyle"),d=this,c={onCreate:function(u){u.draggable=!0,u.drift=gn(d._handlePointerDrag,d),u.ondragend=gn(d._handlePointerDragend,d),h0(u,d._progressLine,a,i,n,!0)},onUpdate:function(u){h0(u,d._progressLine,a,i,n)}};this._currentPointer=u0(o,o,this._mainGroup,{},this._currentPointer,c)},e.prototype._handlePlayClick=function(t){this._clearTimer(),this.api.dispatchAction({type:"timelinePlayChange",playState:t,from:this.uid})},e.prototype._handlePointerDrag=function(t,s,i){this._clearTimer(),this._pointerChangeTimeline([i.offsetX,i.offsetY])},e.prototype._handlePointerDragend=function(t){this._pointerChangeTimeline([t.offsetX,t.offsetY],!0)},e.prototype._pointerChangeTimeline=function(t,s){var i=this._toAxisCoord(t)[0],n=this._axis,r=UO(n.getExtent().slice());i>r[1]&&(i=r[1]),i<r[0]&&(i=r[0]),this._currentPointer.x=i,this._currentPointer.markRedraw();var a=this._progressLine;a&&(a.shape.x2=i,a.dirty());var o=this._findNearestTick(i),d=this.model;(s||o!==d.getCurrentIndex()&&d.get("realtime"))&&this._changeTimeline(o)},e.prototype._doPlayStop=function(){var t=this;this._clearTimer(),this.model.getPlayState()&&(this._timer=setTimeout(function(){var s=t.model;t._changeTimeline(s.getCurrentIndex()+(s.get("rewind",!0)?-1:1))},this.model.get("playInterval")))},e.prototype._toAxisCoord=function(t){var s=this._mainGroup.getLocalTransform();return $O(t,s,!0)},e.prototype._findNearestTick=function(t){var s=this.model.getData(),i=1/0,n,r=this._axis;return s.each(["value"],function(a,o){var d=r.dataToCoord(a),c=Math.abs(d-t);c<i&&(i=c,n=o)}),n},e.prototype._clearTimer=function(){this._timer&&(clearTimeout(this._timer),this._timer=null)},e.prototype._changeTimeline=function(t){var s=this.model.getCurrentIndex();t==="+"?t=s+1:t==="-"&&(t=s-1),this.api.dispatchAction({type:"timelineChange",currentIndex:t,from:this.uid})},e.prototype._updateTicksStatus=function(){var t=this.model.getCurrentIndex(),s=this._tickSymbols,i=this._tickLabels;if(s)for(var n=0;n<s.length;n++)s&&s[n]&&s[n].toggleState("progress",n<t);if(i)for(var n=0;n<i.length;n++)i&&i[n]&&i[n].toggleState("progress",c0(i[n]).dataIndex<=t)},e.type="timeline.slider",e}(E_);function D_(p,e){if(e=e||p.get("type"),e)switch(e){case"category":return new jO({ordinalMeta:p.getCategories(),extent:[1/0,-1/0]});case"time":return new zO({locale:p.ecModel.getLocaleModel(),useUTC:p.ecModel.get("useUTC")});default:return new WO}}function F_(p,e){return hS(p.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()},p.get("padding"))}function H_(p,e,t,s){var i=s.style,n=fS(p.get(["controlStyle",e]),s||{},new Am(t[0],t[1],t[2],t[3]));return i&&n.setStyle(i),n}function u0(p,e,t,s,i,n){var r=e.get("color");if(i)i.setColor(r),t.add(i),n&&n.onUpdate(i);else{var a=p.get("symbol");i=Bm(a,-1,-1,2,2,r),i.setStyle("strokeNoScale",!0),t.add(i),n&&n.onCreate(i)}var o=e.getItemStyle(["color"]);i.setStyle(o),s=wn({rectHover:!0,z2:100},s,!0);var d=nS(p.get("symbolSize"));s.scaleX=d[0]/2,s.scaleY=d[1]/2;var c=rS(p.get("symbolOffset"),d);c&&(s.x=(s.x||0)+c[0],s.y=(s.y||0)+c[1]);var u=p.get("symbolRotate");return s.rotation=(u||0)*Math.PI/180||0,i.attr(s),i.updateTransform(),i}function h0(p,e,t,s,i,n){if(!p.dragging){var r=i.getModel("checkpointStyle"),a=s.dataToCoord(i.getData().get("value",t));if(n||!r.get("animation",!0))p.attr({x:a,y:0}),e&&e.attr({shape:{x2:a}});else{var o={duration:r.get("animationDuration",!0),easing:r.get("animationEasing",!0)};p.stopAnimation(null,!0),p.animateTo({x:a,y:0},o),e&&e.animateTo({shape:{x2:a}},o)}}}var G_=R_;function U_(p){p.registerAction({type:"timelineChange",event:"timelineChanged",update:"prepareAndUpdate"},function(e,t,s){var i=t.getComponent("timeline");return i&&e.currentIndex!=null&&(i.setCurrentIndex(e.currentIndex),!i.get("loop",!0)&&i.isIndexMax()&&i.getPlayState()&&(i.setPlayState(!1),s.dispatchAction({type:"timelinePlayChange",playState:!1,from:e.from}))),t.resetOption("timeline",{replaceMerge:i.get("replaceMerge",!0)}),ao({currentIndex:i.option.currentIndex},e)}),p.registerAction({type:"timelinePlayChange",event:"timelinePlayChanged",update:"update"},function(e,t){var s=t.getComponent("timeline");s&&e.playState!=null&&s.setPlayState(e.playState)})}function $_(p){var e=p&&p.timeline;ms(e)||(e=e?[e]:[]),Ie(e,function(t){!t||W_(t)})}function W_(p){var e=p.type,t={number:"value",time:"time"};if(t[e]&&(p.axisType=t[e],delete p.type),f0(p),Zr(p,"controlPosition")){var s=p.controlStyle||(p.controlStyle={});Zr(s,"position")||(s.position=p.controlPosition),s.position==="none"&&!Zr(s,"show")&&(s.show=!1,delete s.position),delete p.controlPosition}Ie(p.data||[],function(i){Dd(i)&&!ms(i)&&(!Zr(i,"value")&&Zr(i,"name")&&(i.value=i.name),f0(i))})}function f0(p){var e=p.itemStyle||(p.itemStyle={}),t=e.emphasis||(e.emphasis={}),s=p.label||p.label||{},i=s.normal||(s.normal={}),n={normal:1,emphasis:1};Ie(s,function(r,a){!n[a]&&!Zr(i,a)&&(i[a]=r)}),t.label&&!Zr(s,"emphasis")&&(s.emphasis=t.label,delete t.label)}function Zr(p,e){return p.hasOwnProperty(e)}function z_(p){p.registerComponentModel(N_),p.registerComponentView(G_),p.registerSubTypeDefaulter("timeline",function(){return"slider"}),U_(p),p.registerPreprocessor($_)}function j_(p,e){if(!p)return!1;for(var t=ms(p)?p:[p],s=0;s<t.length;s++)if(t[s]&&t[s][e])return!0;return!1}function ac(p){XO(p,"label",["show"])}var oc=Wd(),DS=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t.createdBySelf=!1,t}return e.prototype.init=function(t,s,i){this.mergeDefaultAndTheme(t,i),this._mergeOption(t,i,!1,!0)},e.prototype.isAnimationEnabled=function(){if(lS.node)return!1;var t=this.__hostSeries;return this.getShallow("animation")&&t&&t.isAnimationEnabled()},e.prototype.mergeOption=function(t,s){this._mergeOption(t,s,!1,!1)},e.prototype._mergeOption=function(t,s,i,n){var r=this.mainType;i||s.eachSeries(function(a){var o=a.get(this.mainType,!0),d=oc(a)[r];if(!o||!o.data){oc(a)[r]=null;return}d?d._mergeOption(o,s,!0):(n&&ac(o),Ie(o.data,function(c){c instanceof Array?(ac(c[0]),ac(c[1])):ac(c)}),d=this.createMarkerModelFromSeries(o,this,s),kn(d,{mainType:this.mainType,seriesIndex:a.seriesIndex,name:a.name,createdBySelf:!0}),d.__hostSeries=a),oc(a)[r]=d},this)},e.prototype.formatTooltip=function(t,s,i){var n=this.getData(),r=this.getRawValue(t),a=n.getName(t);return om("section",{header:this.name,blocks:[om("nameValue",{name:a,value:r,noName:!a,noValue:r==null})]})},e.prototype.getData=function(){return this._data},e.prototype.setData=function(t){this._data=t},e.getMarkerModelFromSeries=function(t,s){return oc(t)[s]},e.type="marker",e.dependencies=["series","grid","polar","geo"],e}(fh);Vm(DS,yS.prototype);var eh=DS;function K_(p){return!(isNaN(parseFloat(p.x))&&isNaN(parseFloat(p.y)))}function X_(p){return!isNaN(parseFloat(p.x))&&!isNaN(parseFloat(p.y))}function dc(p,e,t,s,i,n){var r=[],a=YO(e,s),o=a?e.getCalculationInfo("stackResultDimension"):s,d=$m(e,o,p),c=e.indicesOfNearest(o,d)[0];r[i]=e.get(t,c),r[n]=e.get(o,c);var u=e.get(s,c),h=ZO(e.get(s,c));return h=Math.min(h,20),h>=0&&(r[n]=+r[n].toFixed(h)),[r,u]}var lf={min:Ss(dc,"min"),max:Ss(dc,"max"),average:Ss(dc,"average"),median:Ss(dc,"median")};function l0(p,e){if(!!e){var t=p.getData(),s=p.coordinateSystem,i=s.dimensions;if(!X_(e)&&!ms(e.coord)&&s){var n=FS(e,t,s,p);if(e=bn(e),e.type&&lf[e.type]&&n.baseAxis&&n.valueAxis){var r=ta(i,n.baseAxis.dim),a=ta(i,n.valueAxis.dim),o=lf[e.type](t,n.baseDataDim,n.valueDataDim,r,a);e.coord=o[0],e.value=o[1]}else e.coord=[e.xAxis!=null?e.xAxis:e.radiusAxis,e.yAxis!=null?e.yAxis:e.angleAxis]}if(e.coord==null)e.coord=[];else for(var d=e.coord,c=0;c<2;c++)lf[d[c]]&&(d[c]=$m(t,t.mapDimension(i[c]),d[c]));return e}}function FS(p,e,t,s){var i={};return p.valueIndex!=null||p.valueDim!=null?(i.valueDataDim=p.valueIndex!=null?e.getDimension(p.valueIndex):p.valueDim,i.valueAxis=t.getAxis(Y_(s,i.valueDataDim)),i.baseAxis=t.getOtherAxis(i.valueAxis),i.baseDataDim=e.mapDimension(i.baseAxis.dim)):(i.baseAxis=s.getBaseAxis(),i.valueAxis=t.getOtherAxis(i.baseAxis),i.baseDataDim=e.mapDimension(i.baseAxis.dim),i.valueDataDim=e.mapDimension(i.valueAxis.dim)),i}function Y_(p,e){var t=p.getData().getDimensionInfo(e);return t&&t.coordDim}function p0(p,e){return p&&p.containData&&e.coord&&!K_(e)?p.containData(e.coord):!0}function Z_(p,e){return p?function(t,s,i,n){var r=n<2?t.coord&&t.coord[n]:t.value;return qg(r,e[n])}:function(t,s,i,n){return qg(t.value,e[n])}}function $m(p,e,t){if(t==="average"){var s=0,i=0;return p.each(e,function(n,r){isNaN(n)||(s+=n,i++)}),s/i}else return t==="median"?p.getMedian(e):p.getDataExtent(e)[t==="max"?1:0]}var pf=Wd(),Q_=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.init=function(){this.markerGroupMap=gS()},e.prototype.render=function(t,s,i){var n=this,r=this.markerGroupMap;r.each(function(a){pf(a).keep=!1}),s.eachSeries(function(a){var o=eh.getMarkerModelFromSeries(a,n.type);o&&n.renderSeries(a,o,s,i)}),r.each(function(a){!pf(a).keep&&n.group.remove(a.group)})},e.prototype.markKeep=function(t){pf(t).keep=!0},e.prototype.toggleBlurSeries=function(t,s){var i=this;Ie(t,function(n){var r=eh.getMarkerModelFromSeries(n,i.type);if(r){var a=r.getData();a.eachItemGraphicEl(function(o){o&&(s?QO(o):JO(o))})}})},e.type="marker",e}(lh),J_=Q_,eC=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.createMarkerModelFromSeries=function(t,s,i){return new e(t,s,i)},e.type="markLine",e.defaultOption={z:5,symbol:["circle","arrow"],symbolSize:[8,16],symbolOffset:0,precision:2,tooltip:{trigger:"item"},label:{show:!0,position:"end",distance:5},lineStyle:{type:"dashed"},emphasis:{label:{show:!0},lineStyle:{width:3}},animationEasing:"linear"},e}(eh),tC=eC,cc=Wd(),sC=function(p,e,t,s){var i=p.getData(),n;if(ms(s))n=s;else{var r=s.type;if(r==="min"||r==="max"||r==="average"||r==="median"||s.xAxis!=null||s.yAxis!=null){var a=void 0,o=void 0;if(s.yAxis!=null||s.xAxis!=null)a=e.getAxis(s.yAxis!=null?"y":"x"),o=tI(s.yAxis,s.xAxis);else{var d=FS(s,i,e,p);a=d.valueAxis;var c=sI(i,d.valueDataDim);o=$m(i,c,r)}var u=a.dim==="x"?0:1,h=1-u,f=bn(s),l={coord:[]};f.type=null,f.coord=[],f.coord[h]=-1/0,l.coord[h]=1/0;var m=t.get("precision");m>=0&&iI(o)&&(o=+o.toFixed(Math.min(m,20))),f.coord[u]=l.coord[u]=o,n=[f,l,{type:r,valueIndex:s.valueIndex,value:o}]}else n=[]}var g=[l0(p,n[0]),l0(p,n[1]),kn({},n[2])];return g[2].type=g[2].type||null,wn(g[2],g[0]),wn(g[2],g[1]),g};function th(p){return!isNaN(p)&&!isFinite(p)}function m0(p,e,t,s){var i=1-p,n=s.dimensions[p];return th(e[i])&&th(t[i])&&e[p]===t[p]&&s.getAxis(n).containData(e[p])}function iC(p,e){if(p.type==="cartesian2d"){var t=e[0].coord,s=e[1].coord;if(t&&s&&(m0(1,t,s,p)||m0(0,t,s,p)))return!0}return p0(p,e[0])&&p0(p,e[1])}function mf(p,e,t,s,i){var n=s.coordinateSystem,r=p.getItemModel(e),a,o=Xa(r.get("x"),i.getWidth()),d=Xa(r.get("y"),i.getHeight());if(!isNaN(o)&&!isNaN(d))a=[o,d];else{if(s.getMarkerPosition)a=s.getMarkerPosition(p.getValues(p.dimensions,e));else{var c=n.dimensions,u=p.get(c[0],e),h=p.get(c[1],e);a=n.dataToPoint([u,h])}if(vI(n,"cartesian2d")){var f=n.getAxis("x"),l=n.getAxis("y"),c=n.dimensions;th(p.get(c[0],e))?a[0]=f.toGlobalCoord(f.getExtent()[t?0:1]):th(p.get(c[1],e))&&(a[1]=l.toGlobalCoord(l.getExtent()[t?0:1]))}isNaN(o)||(a[0]=o),isNaN(d)||(a[1]=d)}p.setItemLayout(e,a)}var nC=function(p){Ye(e,p);function e(){var t=p!==null&&p.apply(this,arguments)||this;return t.type=e.type,t}return e.prototype.updateTransform=function(t,s,i){s.eachSeries(function(n){var r=eh.getMarkerModelFromSeries(n,"markLine");if(r){var a=r.getData(),o=cc(r).from,d=cc(r).to;o.each(function(c){mf(o,c,!0,n,i),mf(d,c,!1,n,i)}),a.each(function(c){a.setItemLayout(c,[o.getItemLayout(c),d.getItemLayout(c)])}),this.markerGroupMap.get(n.id).updateLayout()}},this)},e.prototype.renderSeries=function(t,s,i,n){var r=t.coordinateSystem,a=t.id,o=t.getData(),d=this.markerGroupMap,c=d.get(a)||d.set(a,new KI);this.group.add(c.group);var u=rC(r,t,s),h=u.from,f=u.to,l=u.line;cc(s).from=h,cc(s).to=f,s.setData(l);var m=s.get("symbol"),g=s.get("symbolSize"),y=s.get("symbolRotate"),w=s.get("symbolOffset");ms(m)||(m=[m,m]),ms(g)||(g=[g,g]),ms(y)||(y=[y,y]),ms(w)||(w=[w,w]),u.from.each(function(S){b(h,S,!0),b(f,S,!1)}),l.each(function(S){var v=l.getItemModel(S).getModel("lineStyle").getLineStyle();l.setItemLayout(S,[h.getItemLayout(S),f.getItemLayout(S)]),v.stroke==null&&(v.stroke=h.getItemVisual(S,"style").fill),l.setItemVisual(S,{fromSymbolKeepAspect:h.getItemVisual(S,"symbolKeepAspect"),fromSymbolOffset:h.getItemVisual(S,"symbolOffset"),fromSymbolRotate:h.getItemVisual(S,"symbolRotate"),fromSymbolSize:h.getItemVisual(S,"symbolSize"),fromSymbol:h.getItemVisual(S,"symbol"),toSymbolKeepAspect:f.getItemVisual(S,"symbolKeepAspect"),toSymbolOffset:f.getItemVisual(S,"symbolOffset"),toSymbolRotate:f.getItemVisual(S,"symbolRotate"),toSymbolSize:f.getItemVisual(S,"symbolSize"),toSymbol:f.getItemVisual(S,"symbol"),style:v})}),c.updateData(l),u.line.eachItemGraphicEl(function(S){Zu(S).dataModel=s,S.traverse(function(v){Zu(v).dataModel=s})});function b(S,v,T){var I=S.getItemModel(v);mf(S,v,T,t,n);var A=I.getModel("itemStyle").getItemStyle();A.fill==null&&(A.fill=eI(o,"color")),S.setItemVisual(v,{symbolKeepAspect:I.get("symbolKeepAspect"),symbolOffset:Jr(I.get("symbolOffset",!0),w[T?0:1]),symbolRotate:Jr(I.get("symbolRotate",!0),y[T?0:1]),symbolSize:Jr(I.get("symbolSize"),g[T?0:1]),symbol:Jr(I.get("symbol",!0),m[T?0:1]),style:A})}this.markKeep(c),c.group.silent=s.get("silent")||t.get("silent")},e.type="markLine",e}(J_);function rC(p,e,t){var s;p?s=ps(p&&p.dimensions,function(d){var c=e.getData().getDimensionInfo(e.getData().mapDimension(d))||{};return kn(kn({},c),{name:d,ordinalMeta:null})}):s=[{name:"value",type:"float"}];var i=new Gu(s,t),n=new Gu(s,t),r=new Gu([],t),a=ps(t.get("data"),Ss(sC,e,p,t));p&&(a=pS(a,Ss(iC,p)));var o=Z_(!!p,s);return i.initData(ps(a,function(d){return d[0]}),null,o),n.initData(ps(a,function(d){return d[1]}),null,o),r.initData(ps(a,function(d){return d[2]})),r.hasItemOption=!0,{from:i,to:n,line:r}}var aC=nC;function oC(p){p.registerComponentModel(tC),p.registerComponentView(aC),p.registerPreprocessor(function(e){j_(e.series,"markLine")&&(e.markLine=e.markLine||{})})}function $u(){return`#${(Math.random()*16777215<<0).toString(16)}`}function dC(p,e){const t=p.indexOf("open"),s=p.indexOf("close"),i=p.indexOf("high"),n=p.indexOf("low");let r;return e.map((a,o)=>{const d=a.slice(),c=o===0?(d[t]+d[s])/2:(r[t]+r[s])/2,u=(d[t]+d[i]+d[n]+d[s])/4,h=Math.max(d[i],d[t],d[s]),f=Math.min(d[n],d[t],d[s]);return d[t]=c,d[s]=u,d[i]=h,d[n]=f,r=d.slice(),d})}const cC=2,uC=3;function ha(p,e,t=uC){const s=e%p;return e-s+(t===cC?p:0)}function HS(p,e){var t;return`${e.ft_order_side==="buy"?"+":"-"}${iO("cost"in e?e.cost:e.amount*e.safe_price,(t=p.quote_currency)!=null?t:"<stake_currency>")}`}function g0(p,e,t){var s,i;return`${p.is_short?"Short":"Long"} ${t}  ${K1(p.profit_ratio)}
  ${HS(p,e)}
  Enter-tag: ${(s=p.enter_tag)!=null?s:""}
  Exit-Tag: ${(i=p.exit_reason)!=null?i:""}`}function hC(p,e){var t;return`${p.is_short?"Short":"Long"} adjustment
  ${HS(p,e)}
  Enter-tag: ${(t=p.enter_tag)!=null?t:""}`}const fC="path://m 52.444161,104.1909 8.386653,25.34314 8.386651,25.34313 -16.731501,0.0422 -16.731501,0.0422 8.344848,-25.38539 z m 0.08656,-48.368126 8.386652,25.343139 8.386652,25.343137 -16.731501,0.0422 -16.731502,0.0422 8.344848,-25.385389 z",y0="path://m 102.20764,19.885384 h 24.1454 v 41.928829 h -24.1454 z m 12.17344,36.423813 8.38665,25.343139 8.38666,25.343134 -16.7315,0.0422 -16.731507,0.0422 8.344847,-25.385386 z",gf="#AD00FF",yf="#0066FF";function lC(p,e){var s,i,n,r,a,o;const t=[];for(let d=0,c=e.length;d<c;d+=1){const u=e[d];if((ha((s=p.timeframe_ms)!=null?s:0,u.open_timestamp)<=p.data_stop_ts||!u.close_timestamp||u.close_timestamp&&u.close_timestamp>=p.data_start_ts)&&u.orders)for(let h=0;h<u.orders.length;h++){const f=u.orders[h];f.order_filled_timestamp&&ha((i=p.timeframe_ms)!=null?i:0,f.order_filled_timestamp)<=p.data_stop_ts&&f.order_filled_timestamp>p.data_start_ts&&(h===0?t.push([ha((n=p.timeframe_ms)!=null?n:0,f.order_filled_timestamp),f.safe_price,y0,f.ft_order_side=="sell"?180:0,u.is_short?gf:yf,u.is_short?"Short":"Long",g0(u,f,"entry")]):h===u.orders.length-1&&u.close_timestamp?ha((r=p.timeframe_ms)!=null?r:0,u.close_timestamp)<=p.data_stop_ts&&u.close_timestamp>p.data_start_ts&&u.is_open===!1&&t.push([ha((a=p.timeframe_ms)!=null?a:0,u.close_timestamp),f.safe_price,y0,u.is_short?0:180,u.is_short?gf:yf,K1(u.profit_ratio,2),g0(u,f,"exit")]):t.push([ha((o=p.timeframe_ms)!=null?o:0,f.order_filled_timestamp),f.safe_price,fC,f.ft_order_side=="sell"?180:0,u.is_short?gf:yf,"",hC(u,f)]))}}return{tradeData:t}}const GS=p=>p?(p^Math.random()*16>>p/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,GS),US=p=>p?(p^Math.random()*16>>p/4).toString(16):([1e5]+100+400+8e3).replace(/[018]/g,US),$S=p=>p?(p^Math.random()*16>>p/4).toString(16):([1e7]+1e3+4e3+8e5).replace(/[018]/g,$S);var Wm={uuid:GS,uuid16:US,uuid22:$S,unCamelCase:p=>p.match(/[A-Z]/)?p.replace(/[a-z0-9][A-Z]/g,e=>e[0]+"_"+e[1]).replace(/[A-Z0-9][A-Z0-9][a-z][^$]/g,e=>e[0]+"_"+e[1]+e[2]+e[3]).replace(/[a-z][0-9]$/g,e=>e[0]+"_"+e[1]).toLowerCase():p,capitalize:p=>p.length?p.charAt(0).toUpperCase()+p.slice(1):p,strip:p=>p.replace(/^\s+|\s+$/g,"")},ym={exports:{}},pC={},mC=Object.freeze(Object.defineProperty({__proto__:null,default:pC},Symbol.toStringTag,{value:"Module"})),ht=nO(mC);(function(p,e){Object.defineProperty(e,"__esModule",{value:!0});const t=Symbol("buffer"),s=Symbol("type");class i{constructor(){this[s]="";const z=arguments[0],V=arguments[1],C=[];if(z){const F=z,j=Number(F.length);for(let X=0;X<j;X++){const J=F[X];let be;J instanceof Buffer?be=J:ArrayBuffer.isView(J)?be=Buffer.from(J.buffer,J.byteOffset,J.byteLength):J instanceof ArrayBuffer?be=Buffer.from(J):J instanceof i?be=J[t]:be=Buffer.from(typeof J=="string"?J:String(J)),C.push(be)}}this[t]=Buffer.concat(C);let M=V&&V.type!==void 0&&String(V.type).toLowerCase();M&&!/[^\u0020-\u007E]/.test(M)&&(this[s]=M)}get size(){return this[t].length}get type(){return this[s]}slice(){const z=this.size,V=arguments[0],C=arguments[1];let M,F;V===void 0?M=0:V<0?M=Math.max(z+V,0):M=Math.min(V,z),C===void 0?F=z:C<0?F=Math.max(z+C,0):F=Math.min(C,z);const j=Math.max(F-M,0),J=this[t].slice(M,M+j),be=new i([],{type:arguments[2]});return be[t]=J,be}}Object.defineProperties(i.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(i.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0});function n(K,z,V){Error.call(this,K),this.message=K,this.type=z,V&&(this.code=this.errno=V.code),Error.captureStackTrace(this,this.constructor)}n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n.prototype.name="FetchError";const r=ht;var a=ht;const o=a.PassThrough,d=Symbol("Body internals");function c(K){var z=this,V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},C=V.size;let M=C===void 0?0:C;var F=V.timeout;let j=F===void 0?0:F;K==null?K=null:typeof K=="string"||f(K)||K instanceof i||Buffer.isBuffer(K)||Object.prototype.toString.call(K)==="[object ArrayBuffer]"||K instanceof r||(K=String(K)),this[d]={body:K,disturbed:!1,error:null},this.size=M,this.timeout=j,K instanceof r&&K.on("error",function(X){z[d].error=new n(`Invalid response body while trying to fetch ${z.url}: ${X.message}`,"system",X)})}c.prototype={get body(){return this[d].body},get bodyUsed(){return this[d].disturbed},arrayBuffer(){return u.call(this).then(function(K){return K.buffer.slice(K.byteOffset,K.byteOffset+K.byteLength)})},blob(){let K=this.headers&&this.headers.get("content-type")||"";return u.call(this).then(function(z){return Object.assign(new i([],{type:K.toLowerCase()}),{[t]:z})})},json(){var K=this;return u.call(this).then(function(z){try{return JSON.parse(z.toString())}catch(V){return c.Promise.reject(new n(`invalid json response body at ${K.url} reason: ${V.message}`,"invalid-json"))}})},text(){return u.call(this).then(function(K){return K.toString()})},buffer(){return u.call(this)},textConverted(){var K=this;return u.call(this).then(function(z){return h(z,K.headers)})}},Object.defineProperties(c.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),c.mixIn=function(K){for(const z of Object.getOwnPropertyNames(c.prototype))if(!(z in K)){const V=Object.getOwnPropertyDescriptor(c.prototype,z);Object.defineProperty(K,z,V)}};function u(){var K=this;if(this[d].disturbed)return c.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[d].disturbed=!0,this[d].error)return c.Promise.reject(this[d].error);if(this.body===null)return c.Promise.resolve(Buffer.alloc(0));if(typeof this.body=="string")return c.Promise.resolve(Buffer.from(this.body));if(this.body instanceof i)return c.Promise.resolve(this.body[t]);if(Buffer.isBuffer(this.body))return c.Promise.resolve(this.body);if(Object.prototype.toString.call(this.body)==="[object ArrayBuffer]")return c.Promise.resolve(Buffer.from(this.body));if(!(this.body instanceof r))return c.Promise.resolve(Buffer.alloc(0));let z=[],V=0,C=!1;return new c.Promise(function(M,F){let j;K.timeout&&(j=setTimeout(function(){C=!0,F(new n(`Response timeout while trying to fetch ${K.url} (over ${K.timeout}ms)`,"body-timeout"))},K.timeout)),K.body.on("error",function(X){F(new n(`Invalid response body while trying to fetch ${K.url}: ${X.message}`,"system",X))}),K.body.on("data",function(X){if(!(C||X===null)){if(K.size&&V+X.length>K.size){C=!0,F(new n(`content size at ${K.url} over limit: ${K.size}`,"max-size"));return}V+=X.length,z.push(X)}}),K.body.on("end",function(){if(!C){clearTimeout(j);try{M(Buffer.concat(z))}catch(X){F(new n(`Could not create Buffer from response body for ${K.url}: ${X.message}`,"system",X))}}})})}function h(K,z){if(typeof convert!="function")throw new Error("The package `encoding` must be installed to use the textConverted() function");const V=z.get("content-type");let C="utf-8",M,F;return V&&(M=/charset=([^;]*)/i.exec(V)),F=K.slice(0,1024).toString(),!M&&F&&(M=/<meta.+?charset=(['"])(.+?)\1/i.exec(F)),!M&&F&&(M=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(F),M&&(M=/charset=(.*)/i.exec(M.pop()))),!M&&F&&(M=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(F)),M&&(C=M.pop(),(C==="gb2312"||C==="gbk")&&(C="gb18030")),convert(K,"UTF-8",C).toString()}function f(K){return typeof K!="object"||typeof K.append!="function"||typeof K.delete!="function"||typeof K.get!="function"||typeof K.getAll!="function"||typeof K.has!="function"||typeof K.set!="function"?!1:K.constructor.name==="URLSearchParams"||Object.prototype.toString.call(K)==="[object URLSearchParams]"||typeof K.sort=="function"}function l(K){let z,V,C=K.body;if(K.bodyUsed)throw new Error("cannot clone body after it is used");return C instanceof r&&typeof C.getBoundary!="function"&&(z=new o,V=new o,C.pipe(z),C.pipe(V),K[d].body=z,C=V),C}function m(K){const z=K.body;return z===null?null:typeof z=="string"?"text/plain;charset=UTF-8":f(z)?"application/x-www-form-urlencoded;charset=UTF-8":z instanceof i?z.type||null:Buffer.isBuffer(z)||Object.prototype.toString.call(z)==="[object ArrayBuffer]"?null:typeof z.getBoundary=="function"?`multipart/form-data;boundary=${z.getBoundary()}`:null}function g(K){const z=K.body;return z===null?0:typeof z=="string"?Buffer.byteLength(z):f(z)?Buffer.byteLength(String(z)):z instanceof i?z.size:Buffer.isBuffer(z)?z.length:Object.prototype.toString.call(z)==="[object ArrayBuffer]"?z.byteLength:z&&typeof z.getLengthSync=="function"&&(z._lengthRetrievers&&z._lengthRetrievers.length==0||z.hasKnownLength&&z.hasKnownLength())?z.getLengthSync():null}function y(K,z){const V=z.body;V===null?K.end():typeof V=="string"?(K.write(V),K.end()):f(V)?(K.write(Buffer.from(String(V))),K.end()):V instanceof i?(K.write(V[t]),K.end()):Buffer.isBuffer(V)?(K.write(V),K.end()):Object.prototype.toString.call(V)==="[object ArrayBuffer]"?(K.write(Buffer.from(V)),K.end()):V.pipe(K)}c.Promise=Yu.Promise;const w=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,b=/[^\t\x20-\x7e\x80-\xff]/;function S(K){if(K=`${K}`,w.test(K))throw new TypeError(`${K} is not a legal HTTP header name`)}function v(K){if(K=`${K}`,b.test(K))throw new TypeError(`${K} is not a legal HTTP header value`)}function T(K,z){z=z.toLowerCase();for(const V in K)if(V.toLowerCase()===z)return V}const I=Symbol("map");class A{constructor(){let z=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;if(this[I]=Object.create(null),z instanceof A){const V=z.raw(),C=Object.keys(V);for(const M of C)for(const F of V[M])this.append(M,F);return}if(z!=null)if(typeof z=="object"){const V=z[Symbol.iterator];if(V!=null){if(typeof V!="function")throw new TypeError("Header pairs must be iterable");const C=[];for(const M of z){if(typeof M!="object"||typeof M[Symbol.iterator]!="function")throw new TypeError("Each header pair must be iterable");C.push(Array.from(M))}for(const M of C){if(M.length!==2)throw new TypeError("Each header pair must be a name/value tuple");this.append(M[0],M[1])}}else for(const C of Object.keys(z)){const M=z[C];this.append(C,M)}}else throw new TypeError("Provided initializer must be an object")}get(z){z=`${z}`,S(z);const V=T(this[I],z);return V===void 0?null:this[I][V].join(", ")}forEach(z){let V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,C=N(this),M=0;for(;M<C.length;){var F=C[M];const j=F[0],X=F[1];z.call(V,X,j,this),C=N(this),M++}}set(z,V){z=`${z}`,V=`${V}`,S(z),v(V);const C=T(this[I],z);this[I][C!==void 0?C:z]=[V]}append(z,V){z=`${z}`,V=`${V}`,S(z),v(V);const C=T(this[I],z);C!==void 0?this[I][C].push(V):this[I][z]=[V]}has(z){return z=`${z}`,S(z),T(this[I],z)!==void 0}delete(z){z=`${z}`,S(z);const V=T(this[I],z);V!==void 0&&delete this[I][V]}raw(){return this[I]}keys(){return x(this,"key")}values(){return x(this,"value")}[Symbol.iterator](){return x(this,"key+value")}}A.prototype.entries=A.prototype[Symbol.iterator],Object.defineProperty(A.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(A.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});function N(K){let z=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"key+value";return Object.keys(K[I]).sort().map(z==="key"?function(C){return C.toLowerCase()}:z==="value"?function(C){return K[I][C].join(", ")}:function(C){return[C.toLowerCase(),K[I][C].join(", ")]})}const B=Symbol("internal");function x(K,z){const V=Object.create(k);return V[B]={target:K,kind:z,index:0},V}const k=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==k)throw new TypeError("Value of `this` is not a HeadersIterator");var K=this[B];const z=K.target,V=K.kind,C=K.index,M=N(z,V),F=M.length;return C>=F?{value:void 0,done:!0}:(this[B].index=C+1,{value:M[C],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(k,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});function O(K){const z=Object.assign({__proto__:null},K[I]),V=T(K[I],"Host");return V!==void 0&&(z[V]=z[V][0]),z}function P(K){const z=new A;for(const V of Object.keys(K))if(!w.test(V))if(Array.isArray(K[V]))for(const C of K[V])b.test(C)||(z[I][V]===void 0?z[I][V]=[C]:z[I][V].push(C));else b.test(K[V])||(z[I][V]=[K[V]]);return z}var q=ht;const L=q.STATUS_CODES,D=Symbol("Response internals");class H{constructor(){let z=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};c.call(this,z,V);const C=V.status||200;this[D]={url:V.url,status:C,statusText:V.statusText||L[C],headers:new A(V.headers)}}get url(){return this[D].url}get status(){return this[D].status}get ok(){return this[D].status>=200&&this[D].status<300}get statusText(){return this[D].statusText}get headers(){return this[D].headers}clone(){return new H(l(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok})}}c.mixIn(H.prototype),Object.defineProperties(H.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(H.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});var R=ht;const _=R.format,E=R.parse,U=Symbol("Request internals");function G(K){return typeof K=="object"&&typeof K[U]=="object"}class ${constructor(z){let V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},C;G(z)?C=E(z.url):(z&&z.href?C=E(z.href):C=E(`${z}`),z={});let M=V.method||z.method||"GET";if(M=M.toUpperCase(),(V.body!=null||G(z)&&z.body!==null)&&(M==="GET"||M==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");let F=V.body!=null?V.body:G(z)&&z.body!==null?l(z):null;c.call(this,F,{timeout:V.timeout||z.timeout||0,size:V.size||z.size||0});const j=new A(V.headers||z.headers||{});if(V.body!=null){const X=m(this);X!==null&&!j.has("Content-Type")&&j.append("Content-Type",X)}this[U]={method:M,redirect:V.redirect||z.redirect||"follow",headers:j,parsedURL:C},this.follow=V.follow!==void 0?V.follow:z.follow!==void 0?z.follow:20,this.compress=V.compress!==void 0?V.compress:z.compress!==void 0?z.compress:!0,this.counter=V.counter||z.counter||0,this.agent=V.agent||z.agent}get method(){return this[U].method}get url(){return _(this[U].parsedURL)}get headers(){return this[U].headers}get redirect(){return this[U].redirect}clone(){return new $(this)}}c.mixIn($.prototype),Object.defineProperty($.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties($.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0}});function Z(K){const z=K[U].parsedURL,V=new A(K[U].headers);if(V.has("Accept")||V.set("Accept","*/*"),!z.protocol||!z.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(z.protocol))throw new TypeError("Only HTTP(S) protocols are supported");let C=null;if(K.body==null&&/^(POST|PUT)$/i.test(K.method)&&(C="0"),K.body!=null){const M=g(K);typeof M=="number"&&(C=String(M))}return C&&V.set("Content-Length",C),V.has("User-Agent")||V.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),K.compress&&V.set("Accept-Encoding","gzip,deflate"),!V.has("Connection")&&!K.agent&&V.set("Connection","close"),Object.assign({},z,{method:K.method,headers:O(V),agent:K.agent})}const he=ht,me=ht;var ye=ht;const xe=ye.PassThrough;var Ae=ht;const Mt=Ae.resolve,Me=ht;function ge(K,z){if(!ge.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return c.Promise=ge.Promise,new ge.Promise(function(V,C){const M=new $(K,z),F=Z(M),j=(F.protocol==="https:"?me:he).request,X=j(F);let J;function be(){X.abort(),clearTimeout(J)}M.timeout&&X.once("socket",function(le){J=setTimeout(function(){C(new n(`network timeout at: ${M.url}`,"request-timeout")),be()},M.timeout)}),X.on("error",function(le){C(new n(`request to ${M.url} failed, reason: ${le.message}`,"system",le)),be()}),X.on("response",function(le){clearTimeout(J);const Te=P(le.headers);if(ge.isRedirect(le.statusCode)){const Ze=Te.get("Location"),De=Ze===null?null:Mt(M.url,Ze);switch(M.redirect){case"error":C(new n(`redirect mode is set to error: ${M.url}`,"no-redirect")),be();return;case"manual":De!==null&&Te.set("Location",De);break;case"follow":if(De===null)break;if(M.counter>=M.follow){C(new n(`maximum redirect reached at: ${M.url}`,"max-redirect")),be();return}const ai={headers:new A(M.headers),follow:M.follow,counter:M.counter+1,agent:M.agent,compress:M.compress,method:M.method,body:M.body};if(le.statusCode!==303&&M.body&&g(M)===null){C(new n("Cannot follow redirect with body being a readable stream","unsupported-redirect")),be();return}(le.statusCode===303||(le.statusCode===301||le.statusCode===302)&&M.method==="POST")&&(ai.method="GET",ai.body=void 0,ai.headers.delete("content-length")),V(ge(new $(De,ai))),be();return}}let Re=le.pipe(new xe);const ve={url:M.url,status:le.statusCode,statusText:le.statusMessage,headers:Te,size:M.size,timeout:M.timeout},Ue=Te.get("Content-Encoding");if(!M.compress||M.method==="HEAD"||Ue===null||le.statusCode===204||le.statusCode===304){V(new H(Re,ve));return}const Ji={flush:Me.Z_SYNC_FLUSH,finishFlush:Me.Z_SYNC_FLUSH};if(Ue=="gzip"||Ue=="x-gzip"){Re=Re.pipe(Me.createGunzip(Ji)),V(new H(Re,ve));return}if(Ue=="deflate"||Ue=="x-deflate"){le.pipe(new xe).once("data",function(De){(De[0]&15)===8?Re=Re.pipe(Me.createInflate()):Re=Re.pipe(Me.createInflateRaw()),V(new H(Re,ve))});return}V(new H(Re,ve))}),y(X,M)})}ge.isRedirect=function(K){return K===301||K===302||K===303||K===307||K===308},ge.default=ge,ge.Promise=Yu.Promise,ge.http=he,ge.https=me,p.exports=e=ge,e.Headers=A,e.Request=$,e.Response=H,e.FetchError=n})(ym,ym.exports);var vo=ym.exports;function gC(p){const e=function(t,s){return typeof t=="string"&&t.slice(0,2)==="//"?p("https:"+t,s):p(t,s)};return e.http=p.http,e.https=p.https,e}var yC=function(p){return p&&p.Promise&&(vo.Promise=p.Promise),{fetch:gC(vo),Headers:vo.Headers,Request:vo.Request,Response:vo.Response}};const WS=typeof window!="undefined",wC=typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.electron!="undefined",zS=typeof WorkerGlobalScope!="undefined"&&self instanceof WorkerGlobalScope,bC=typeof process!="undefined"&&process.platform==="win32",jS=!(WS||zS),kC=jS?yC().fetch:fetch;var SC={isBrowser:WS,isElectron:wC,isWebWorker:zS,isNode:jS,isWindows:bC,defaultFetch:kC};const Ls=Number.isFinite,vC=Number.isInteger,KS=Array.isArray,Ed=p=>p!=null,zm=p=>typeof p=="string",gh=p=>p!==null&&typeof p=="object",TC=p=>p instanceof RegExp,OC=p=>gh(p)&&Object.getPrototypeOf(p)===Object.prototype&&!KS(p)&&!TC(p),tn=p=>Ed(p)&&p.toString||Ls(p),pn=(p,e)=>gh(p)&&p[e]!==""&&p[e]!==null?p[e]:void 0,Ln=(p,e,t)=>gh(p)?p[e]!==void 0&&p[e]!==""&&p[e]!==null?p[e]:p[t]!==""&&p[t]!==null?p[t]:void 0:void 0,Rn=(p,e)=>p[e.find(t=>pn(p,t)!==void 0)],mr=p=>Ls(p)||zm(p)&&p.length!==0?parseFloat(p):NaN,gr=p=>Ls(p)||zm(p)&&p.length!==0?Math.trunc(Number(p)):NaN;var XS={isNumber:Ls,isInteger:vC,isArray:KS,isObject:gh,isString:zm,isStringCoercible:tn,isDictionary:OC,hasProps:Ed,prop:pn,asFloat:mr,asInteger:gr,safeFloat:(p,e,t,s=mr(pn(p,e)))=>Ls(s)?s:t,safeInteger:(p,e,t,s=gr(pn(p,e)))=>Ls(s)?s:t,safeIntegerProduct:(p,e,t,s,i=gr(pn(p,e)))=>Ls(i)?parseInt(i*t):s,safeTimestamp:(p,e,t,s=mr(pn(p,e)))=>Ls(s)?parseInt(s*1e3):t,safeValue:(p,e,t,s=pn(p,e))=>Ed(s)?s:t,safeString:(p,e,t,s=pn(p,e))=>tn(s)?String(s):t,safeStringLower:(p,e,t,s=pn(p,e))=>tn(s)?String(s).toLowerCase():t&&t.toLowerCase(),safeStringUpper:(p,e,t,s=pn(p,e))=>tn(s)?String(s).toUpperCase():t&&t.toUpperCase(),safeFloat2:(p,e,t,s,i=mr(Ln(p,e,t)))=>Ls(i)?i:s,safeInteger2:(p,e,t,s,i=gr(Ln(p,e,t)))=>Ls(i)?i:s,safeIntegerProduct2:(p,e,t,s,i,n=gr(Ln(p,e,t)))=>Ls(n)?parseInt(n*s):i,safeTimestamp2:(p,e,t,s,i=mr(Ln(p,e,t)))=>Ls(i)?parseInt(i*1e3):s,safeValue2:(p,e,t,s,i=Ln(p,e,t))=>Ed(i)?i:s,safeString2:(p,e,t,s,i=Ln(p,e,t))=>tn(i)?String(i):s,safeStringLower2:(p,e,t,s,i=Ln(p,e,t))=>tn(i)?String(i).toLowerCase():s&&s.toLowerCase(),safeStringUpper2:(p,e,t,s,i=Ln(p,e,t))=>tn(i)?String(i).toUpperCase():s&&s.toUpperCase(),safeFloatN:(p,e,t,s=mr(Rn(p,e)))=>Ls(s)?s:t,safeIntegerN:(p,e,t,s=gr(Rn(p,e)))=>Ls(s)?s:t,safeIntegerProductN:(p,e,t,s,i=gr(Rn(p,e)))=>Ls(i)?parseInt(i*t):s,safeTimestampN:(p,e,t,s=mr(Rn(p,e)))=>Ls(s)?parseInt(s*1e3):t,safeValueN:(p,e,t,s=Rn(p,e))=>Ed(s)?s:t,safeStringN:(p,e,t,s=Rn(p,e))=>tn(s)?String(s):t,safeStringLowerN:(p,e,t,s=Rn(p,e))=>tn(s)?String(s).toLowerCase():t&&t.toLowerCase(),safeStringUpperN:(p,e,t,s=Rn(p,e))=>tn(s)?String(s).toUpperCase():t&&t.toUpperCase()};const{isNumber:IC,isDictionary:w0,isArray:sh}=XS,b0=Object.keys,Ua=p=>sh(p)?p:Object.values(p),k0=p=>new Set(Ua(p)),YS=(...p)=>Object.assign({},...p),S0=p=>sh(p)?Array.from(p):YS(p);var ZS={keys:b0,values:Ua,extend:YS,clone:S0,index:k0,ordered:p=>p,unique:p=>Array.from(k0(p)),arrayConcat:(p,e)=>p.concat(e),inArray(p,e){return e.includes(p)},toArray(p){return Object.values(p)},isEmpty(p){return p?(Array.isArray(p)?p:Object.keys(p)).length<1:!0},keysort(p,e={}){for(const t of b0(p).sort())e[t]=p[t];return e},indexBy(p,e,t={}){for(const s of Ua(p))e in s&&(t[s[e]]=s);return t},groupBy(p,e,t={}){for(const s of Ua(p))if(e in s){const i=s[e];t[i]=t[i]||[],t[i].push(s)}return t},filterBy(p,e,t=void 0,s=[]){for(const i of Ua(p))i[e]===t&&s.push(i);return s},sortBy:(p,e,t=!1,s=t?-1:1)=>p.sort((i,n)=>i[e]<n[e]?-s:i[e]>n[e]?s:0),sortBy2:(p,e,t,s=!1,i=s?-1:1)=>p.sort((n,r)=>n[e]<r[e]?-i:n[e]>r[e]?i:n[t]<r[t]?-i:n[t]>r[t]?i:0),flatten:function p(e,t=[]){for(const s of e)sh(s)?p(s,t):t.push(s);return t},pluck:(p,e)=>Ua(p).filter(t=>e in t).map(t=>t[e]),omit(p,...e){if(!Array.isArray(p)){const t=S0(p);for(const s of e)if(sh(s))for(const i of s)delete t[i];else delete t[s];return t}return p},sum(...p){const e=p.filter(IC);return e.length>0?e.reduce((t,s)=>t+s,0):void 0},deepExtend:function p(...e){let t;for(const s of e)if(w0(s)){w0(t)||(t={});for(const i in s)t[i]=p(t[i],s[i])}else t=s;return t}};const Bn=0,ih=1,QS=2,JS=3,dr=0,jm=1,nh=2,Qr=0,ev=1,xC={ROUND:Bn,TRUNCATE:ih,ROUND_UP:QS,ROUND_DOWN:JS,DECIMAL_PLACES:dr,SIGNIFICANT_DIGITS:jm,TICK_SIZE:nh,NO_PADDING:Qr,PAD_WITH_ZERO:ev};function Km(p){if(p===void 0)return;if(typeof p!="number")return p.toString();const e=p.toString();if(Math.abs(p)<1){const t=e.split("e-"),s=t[0].replace(".",""),i=parseInt(t[1]),n=e[0]==="-";if(i)return p=(n?"-":"")+"0."+new Array(i).join("0")+s.substring(n),p}else{const t=e.split("e");if(t[1]){let s=parseInt(t[1]);const i=t[0].split(".");let n="";return i[1]&&(s-=i[1].length,n=i[1]),i[0]+n+new Array(s+1).join("0")}}return e}const v0=[],tv=(p,e=0)=>{if(p=Km(p),e>0){const t=v0[e]||(v0[e]=new RegExp("([-]*\\d+\\.\\d{"+e+"})(\\d)")),[,s]=p.toString().match(t)||[null,p];return s.toString()}return parseInt(p).toString()},_C=(p,e=0)=>parseFloat(tv(p,e));function wm(p){if(p.indexOf("e")>-1){const t=p.replace(/\de/,"");return parseInt(t)*-1}const e=p.replace(/0+$/g,"").split(".");return e.length>1?e[1].length:0}const $a=(p,e,t,s=dr,i=Qr)=>{if(s===nh&&t<=0)throw new Error("TICK_SIZE cant be used with negative or zero numPrecisionDigits");if(t<0){const G=Math.pow(10,-t);if(e===Bn)return(G*$a(p/G,e,0,s,i)).toString();if(e===ih)return(p-p%G).toString()}if(s===nh){const G=$a(t,Bn,22,dr,Qr),$=wm(G);let Z=p%t;Z=Number($a(Z,Bn,8,dr,Qr));const he=$a(Z/t,Bn,Math.max($,8),dr,Qr);return wm(he)!==0&&(e===Bn?p>0?Z>=t/2?p=p-Z+t:p=p-Z:Z>=t/2?p=Number(p)-Z:p=Number(p)-Z-t:e===ih&&(p=p-Z)),$a(p,Bn,$,dr,i)}const n=Km(p),r=n[0]==="-",a=r?1:0,o=n.length;for(var d=0;d<o&&n[d]!==".";d++);const c=d<n.length,u=45,h=46,f=48,l=f+1,m=f+5,g=f+9,y=new Uint8Array(o-a+(c?0:1));y[0]=f;let w=y.length,b=-1,S=-1;for(var v=1,T=a;T<o;T++,v++){const G=n.charCodeAt(T);if(G===h)w=v--;else{if(G<f||G>g)throw new Error(`${n}: invalid number (contains an illegal character '${n[v-1]}')`);y[v]=G,G!==f&&b<0&&(b=v)}}b<0&&(b=1);let I=s===dr?w:b,A=I+t;S=-1;let N=!0,B=r;for(let G=y.length-1,$=0;G>=0;G--){let Z=y[G];G!==0?(Z+=$,G>=I+t&&(Z=e===Bn&&Z>=m&&!(Z===m&&$)?g+1:f),Z>g?(Z=f,$=1):$=0):$&&(Z=l),y[G]=Z,Z!==f&&(N=!1,b=G,S=S<0?G+1:S)}s===jm&&(I=b,A=I+t),N&&(B=!1);const x=b>=w||N?w-1:b,k=S<w?w:S,O=B?1:0,P=O+(w-x),q=Math.max(k-w,0),L=k-x,D=i===Qr?L:A-x,H=Math.max(D-L,0),R=P+1+q,_=R+H,E=q+H===0,U=new Uint8Array(P+(E?0:1)+q+H);for(B&&(U[0]=u),v=O,T=x;v<P;v++,T++)U[v]=y[T];for(E||(U[P]=h),v=P+1,T=w;v<R;v++,T++)U[v]=y[T];for(v=R;v<_;v++)U[v]=f;return String.fromCharCode(...U)};function CC(p){if(!(p===void 0||p==="")&&parseFloat(p)!==0)return p}var ne={numberToString:Km,precisionFromString:wm,decimalToPrecision:$a,truncate_to_string:tv,truncate:_C,omitZero:CC,precisionConstants:xC,ROUND:Bn,TRUNCATE:ih,ROUND_UP:QS,ROUND_DOWN:JS,DECIMAL_PLACES:dr,SIGNIFICANT_DIGITS:jm,TICK_SIZE:nh,NO_PADDING:Qr,PAD_WITH_ZERO:ev},oo={exports:{}},co={exports:{}};(function(p,e){(function(t,s){p.exports=s()})(Yu,function(){var t=t||function(s,i){var n=Object.create||function(){function g(){}return function(y){var w;return g.prototype=y,w=new g,g.prototype=null,w}}(),r={},a=r.lib={},o=a.Base=function(){return{extend:function(g){var y=n(this);return g&&y.mixIn(g),(!y.hasOwnProperty("init")||this.init===y.init)&&(y.init=function(){y.$super.init.apply(this,arguments)}),y.init.prototype=y,y.$super=this,y},create:function(){var g=this.extend();return g.init.apply(g,arguments),g},init:function(){},mixIn:function(g){for(var y in g)g.hasOwnProperty(y)&&(this[y]=g[y]);g.hasOwnProperty("toString")&&(this.toString=g.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),d=a.WordArray=o.extend({init:function(g,y){g=this.words=g||[],y!=i?this.sigBytes=y:this.sigBytes=g.length*4},toString:function(g){return(g||u).stringify(this)},concat:function(g){var y=this.words,w=g.words,b=this.sigBytes,S=g.sigBytes;if(this.clamp(),b%4)for(var v=0;v<S;v++){var T=w[v>>>2]>>>24-v%4*8&255;y[b+v>>>2]|=T<<24-(b+v)%4*8}else for(var v=0;v<S;v+=4)y[b+v>>>2]=w[v>>>2];return this.sigBytes+=S,this},clamp:function(){var g=this.words,y=this.sigBytes;g[y>>>2]&=4294967295<<32-y%4*8,g.length=s.ceil(y/4)},clone:function(){var g=o.clone.call(this);return g.words=this.words.slice(0),g},random:function(g){for(var y=[],w=function(I){var I=I,A=987654321,N=4294967295;return function(){A=36969*(A&65535)+(A>>16)&N,I=18e3*(I&65535)+(I>>16)&N;var B=(A<<16)+I&N;return B/=4294967296,B+=.5,B*(s.random()>.5?1:-1)}},b=0,S;b<g;b+=4){var v=w((S||s.random())*4294967296);S=v()*987654071,y.push(v()*4294967296|0)}return new d.init(y,g)}}),c=r.enc={},u=c.Hex={stringify:function(g){for(var y=g.words,w=g.sigBytes,b=[],S=0;S<w;S++){var v=y[S>>>2]>>>24-S%4*8&255;b.push((v>>>4).toString(16)),b.push((v&15).toString(16))}return b.join("")},parse:function(g){for(var y=g.length,w=[],b=0;b<y;b+=2)w[b>>>3]|=parseInt(g.substr(b,2),16)<<24-b%8*4;return new d.init(w,y/2)}},h=c.Latin1={stringify:function(g){for(var y=g.words,w=g.sigBytes,b=[],S=0;S<w;S++){var v=y[S>>>2]>>>24-S%4*8&255;b.push(String.fromCharCode(v))}return b.join("")},parse:function(g){for(var y=g.length,w=[],b=0;b<y;b++)w[b>>>2]|=(g.charCodeAt(b)&255)<<24-b%4*8;return new d.init(w,y)}},f=c.Utf8={stringify:function(g){try{return decodeURIComponent(escape(h.stringify(g)))}catch{throw new Error("Malformed UTF-8 data")}},parse:function(g){return h.parse(unescape(encodeURIComponent(g)))}},l=a.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new d.init,this._nDataBytes=0},_append:function(g){typeof g=="string"&&(g=f.parse(g)),this._data.concat(g),this._nDataBytes+=g.sigBytes},_process:function(g){var y=this._data,w=y.words,b=y.sigBytes,S=this.blockSize,v=S*4,T=b/v;g?T=s.ceil(T):T=s.max((T|0)-this._minBufferSize,0);var I=T*S,A=s.min(I*4,b);if(I){for(var N=0;N<I;N+=S)this._doProcessBlock(w,N);var B=w.splice(0,I);y.sigBytes-=A}return new d.init(B,A)},clone:function(){var g=o.clone.call(this);return g._data=this._data.clone(),g},_minBufferSize:0});a.Hasher=l.extend({cfg:o.extend(),init:function(g){this.cfg=this.cfg.extend(g),this.reset()},reset:function(){l.reset.call(this),this._doReset()},update:function(g){return this._append(g),this._process(),this},finalize:function(g){g&&this._append(g);var y=this._doFinalize();return y},blockSize:16,_createHelper:function(g){return function(y,w){return new g.init(w).finalize(y)}},_createHmacHelper:function(g){return function(y,w){return new m.HMAC.init(g,w).finalize(y)}}});var m=r.algo={};return r}(Math);(function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Base64={stringify:function(o){var d=o.words,c=o.sigBytes,u=this._map;o.clamp();for(var h=[],f=0;f<c;f+=3)for(var l=d[f>>>2]>>>24-f%4*8&255,m=d[f+1>>>2]>>>24-(f+1)%4*8&255,g=d[f+2>>>2]>>>24-(f+2)%4*8&255,y=l<<16|m<<8|g,w=0;w<4&&f+w*.75<c;w++)h.push(u.charAt(y>>>6*(3-w)&63));var b=u.charAt(64);if(b)for(;h.length%4;)h.push(b);return h.join("")},parse:function(o){var d=o.length,c=this._map,u=this._reverseMap;if(!u){u=this._reverseMap=[];for(var h=0;h<c.length;h++)u[c.charCodeAt(h)]=h}var f=c.charAt(64);if(f){var l=o.indexOf(f);l!==-1&&(d=l)}return a(o,d,u)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};function a(o,d,c){for(var u=[],h=0,f=0;f<d;f++)if(f%4){var l=c[o.charCodeAt(f-1)]<<f%4*2,m=c[o.charCodeAt(f)]>>>6-f%4*2;u[h>>>2]|=(l|m)<<24-h%4*8,h++}return n.create(u,h)}})(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[];(function(){for(var m=0;m<64;m++)d[m]=s.abs(s.sin(m+1))*4294967296|0})();var c=o.MD5=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(m,g){for(var y=0;y<16;y++){var w=g+y,b=m[w];m[w]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360}var S=this._hash.words,v=m[g+0],T=m[g+1],I=m[g+2],A=m[g+3],N=m[g+4],B=m[g+5],x=m[g+6],k=m[g+7],O=m[g+8],P=m[g+9],q=m[g+10],L=m[g+11],D=m[g+12],H=m[g+13],R=m[g+14],_=m[g+15],E=S[0],U=S[1],G=S[2],$=S[3];E=u(E,U,G,$,v,7,d[0]),$=u($,E,U,G,T,12,d[1]),G=u(G,$,E,U,I,17,d[2]),U=u(U,G,$,E,A,22,d[3]),E=u(E,U,G,$,N,7,d[4]),$=u($,E,U,G,B,12,d[5]),G=u(G,$,E,U,x,17,d[6]),U=u(U,G,$,E,k,22,d[7]),E=u(E,U,G,$,O,7,d[8]),$=u($,E,U,G,P,12,d[9]),G=u(G,$,E,U,q,17,d[10]),U=u(U,G,$,E,L,22,d[11]),E=u(E,U,G,$,D,7,d[12]),$=u($,E,U,G,H,12,d[13]),G=u(G,$,E,U,R,17,d[14]),U=u(U,G,$,E,_,22,d[15]),E=h(E,U,G,$,T,5,d[16]),$=h($,E,U,G,x,9,d[17]),G=h(G,$,E,U,L,14,d[18]),U=h(U,G,$,E,v,20,d[19]),E=h(E,U,G,$,B,5,d[20]),$=h($,E,U,G,q,9,d[21]),G=h(G,$,E,U,_,14,d[22]),U=h(U,G,$,E,N,20,d[23]),E=h(E,U,G,$,P,5,d[24]),$=h($,E,U,G,R,9,d[25]),G=h(G,$,E,U,A,14,d[26]),U=h(U,G,$,E,O,20,d[27]),E=h(E,U,G,$,H,5,d[28]),$=h($,E,U,G,I,9,d[29]),G=h(G,$,E,U,k,14,d[30]),U=h(U,G,$,E,D,20,d[31]),E=f(E,U,G,$,B,4,d[32]),$=f($,E,U,G,O,11,d[33]),G=f(G,$,E,U,L,16,d[34]),U=f(U,G,$,E,R,23,d[35]),E=f(E,U,G,$,T,4,d[36]),$=f($,E,U,G,N,11,d[37]),G=f(G,$,E,U,k,16,d[38]),U=f(U,G,$,E,q,23,d[39]),E=f(E,U,G,$,H,4,d[40]),$=f($,E,U,G,v,11,d[41]),G=f(G,$,E,U,A,16,d[42]),U=f(U,G,$,E,x,23,d[43]),E=f(E,U,G,$,P,4,d[44]),$=f($,E,U,G,D,11,d[45]),G=f(G,$,E,U,_,16,d[46]),U=f(U,G,$,E,I,23,d[47]),E=l(E,U,G,$,v,6,d[48]),$=l($,E,U,G,k,10,d[49]),G=l(G,$,E,U,R,15,d[50]),U=l(U,G,$,E,B,21,d[51]),E=l(E,U,G,$,D,6,d[52]),$=l($,E,U,G,A,10,d[53]),G=l(G,$,E,U,q,15,d[54]),U=l(U,G,$,E,T,21,d[55]),E=l(E,U,G,$,O,6,d[56]),$=l($,E,U,G,_,10,d[57]),G=l(G,$,E,U,x,15,d[58]),U=l(U,G,$,E,H,21,d[59]),E=l(E,U,G,$,N,6,d[60]),$=l($,E,U,G,L,10,d[61]),G=l(G,$,E,U,I,15,d[62]),U=l(U,G,$,E,P,21,d[63]),S[0]=S[0]+E|0,S[1]=S[1]+U|0,S[2]=S[2]+G|0,S[3]=S[3]+$|0},_doFinalize:function(){var m=this._data,g=m.words,y=this._nDataBytes*8,w=m.sigBytes*8;g[w>>>5]|=128<<24-w%32;var b=s.floor(y/4294967296),S=y;g[(w+64>>>9<<4)+15]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,g[(w+64>>>9<<4)+14]=(S<<8|S>>>24)&16711935|(S<<24|S>>>8)&4278255360,m.sigBytes=(g.length+1)*4,this._process();for(var v=this._hash,T=v.words,I=0;I<4;I++){var A=T[I];T[I]=(A<<8|A>>>24)&16711935|(A<<24|A>>>8)&4278255360}return v},clone:function(){var m=a.clone.call(this);return m._hash=this._hash.clone(),m}});function u(m,g,y,w,b,S,v){var T=m+(g&y|~g&w)+b+v;return(T<<S|T>>>32-S)+g}function h(m,g,y,w,b,S,v){var T=m+(g&w|y&~w)+b+v;return(T<<S|T>>>32-S)+g}function f(m,g,y,w,b,S,v){var T=m+(g^y^w)+b+v;return(T<<S|T>>>32-S)+g}function l(m,g,y,w,b,S,v){var T=m+(y^(g|~w))+b+v;return(T<<S|T>>>32-S)+g}i.MD5=a._createHelper(c),i.HmacMD5=a._createHmacHelper(c)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=i.Hasher,a=s.algo,o=[],d=a.SHA1=r.extend({_doReset:function(){this._hash=new n.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(c,u){for(var h=this._hash.words,f=h[0],l=h[1],m=h[2],g=h[3],y=h[4],w=0;w<80;w++){if(w<16)o[w]=c[u+w]|0;else{var b=o[w-3]^o[w-8]^o[w-14]^o[w-16];o[w]=b<<1|b>>>31}var S=(f<<5|f>>>27)+y+o[w];w<20?S+=(l&m|~l&g)+1518500249:w<40?S+=(l^m^g)+1859775393:w<60?S+=(l&m|l&g|m&g)-1894007588:S+=(l^m^g)-899497514,y=g,g=m,m=l<<30|l>>>2,l=f,f=S}h[0]=h[0]+f|0,h[1]=h[1]+l|0,h[2]=h[2]+m|0,h[3]=h[3]+g|0,h[4]=h[4]+y|0},_doFinalize:function(){var c=this._data,u=c.words,h=this._nDataBytes*8,f=c.sigBytes*8;return u[f>>>5]|=128<<24-f%32,u[(f+64>>>9<<4)+14]=Math.floor(h/4294967296),u[(f+64>>>9<<4)+15]=h,c.sigBytes=u.length*4,this._process(),this._hash},clone:function(){var c=r.clone.call(this);return c._hash=this._hash.clone(),c}});s.SHA1=r._createHelper(d),s.HmacSHA1=r._createHmacHelper(d)}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[],c=[];(function(){function f(y){for(var w=s.sqrt(y),b=2;b<=w;b++)if(!(y%b))return!1;return!0}function l(y){return(y-(y|0))*4294967296|0}for(var m=2,g=0;g<64;)f(m)&&(g<8&&(d[g]=l(s.pow(m,1/2))),c[g]=l(s.pow(m,1/3)),g++),m++})();var u=[],h=o.SHA256=a.extend({_doReset:function(){this._hash=new r.init(d.slice(0))},_doProcessBlock:function(f,l){for(var m=this._hash.words,g=m[0],y=m[1],w=m[2],b=m[3],S=m[4],v=m[5],T=m[6],I=m[7],A=0;A<64;A++){if(A<16)u[A]=f[l+A]|0;else{var N=u[A-15],B=(N<<25|N>>>7)^(N<<14|N>>>18)^N>>>3,x=u[A-2],k=(x<<15|x>>>17)^(x<<13|x>>>19)^x>>>10;u[A]=B+u[A-7]+k+u[A-16]}var O=S&v^~S&T,P=g&y^g&w^y&w,q=(g<<30|g>>>2)^(g<<19|g>>>13)^(g<<10|g>>>22),L=(S<<26|S>>>6)^(S<<21|S>>>11)^(S<<7|S>>>25),D=I+L+O+c[A]+u[A],H=q+P;I=T,T=v,v=S,S=b+D|0,b=w,w=y,y=g,g=D+H|0}m[0]=m[0]+g|0,m[1]=m[1]+y|0,m[2]=m[2]+w|0,m[3]=m[3]+b|0,m[4]=m[4]+S|0,m[5]=m[5]+v|0,m[6]=m[6]+T|0,m[7]=m[7]+I|0},_doFinalize:function(){var f=this._data,l=f.words,m=this._nDataBytes*8,g=f.sigBytes*8;return l[g>>>5]|=128<<24-g%32,l[(g+64>>>9<<4)+14]=s.floor(m/4294967296),l[(g+64>>>9<<4)+15]=m,f.sigBytes=l.length*4,this._process(),this._hash},clone:function(){var f=a.clone.call(this);return f._hash=this._hash.clone(),f}});i.SHA256=a._createHelper(h),i.HmacSHA256=a._createHmacHelper(h)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Utf16=r.Utf16BE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var f=d[h>>>2]>>>16-h%4*8&65535;u.push(String.fromCharCode(f))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=o.charCodeAt(u)<<16-u%2*16;return n.create(c,d*2)}},r.Utf16LE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var f=a(d[h>>>2]>>>16-h%4*8&65535);u.push(String.fromCharCode(f))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=a(o.charCodeAt(u)<<16-u%2*16);return n.create(c,d*2)}};function a(o){return o<<8&4278255360|o>>>8&16711935}}(),function(){if(typeof ArrayBuffer=="function"){var s=t,i=s.lib,n=i.WordArray,r=n.init,a=n.init=function(o){if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),(o instanceof Int8Array||typeof Uint8ClampedArray!="undefined"&&o instanceof Uint8ClampedArray||o instanceof Int16Array||o instanceof Uint16Array||o instanceof Int32Array||o instanceof Uint32Array||o instanceof Float32Array||o instanceof Float64Array)&&(o=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),o instanceof Uint8Array){for(var d=o.byteLength,c=[],u=0;u<d;u++)c[u>>>2]|=o[u]<<24-u%4*8;r.call(this,c,d)}else r.apply(this,arguments)};a.prototype=n}}();/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/(function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),c=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),u=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),h=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),f=r.create([0,1518500249,1859775393,2400959708,2840853838]),l=r.create([1352829926,1548603684,1836072691,2053994217,0]),m=o.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(T,I){for(var A=0;A<16;A++){var N=I+A,B=T[N];T[N]=(B<<8|B>>>24)&16711935|(B<<24|B>>>8)&4278255360}var x=this._hash.words,k=f.words,O=l.words,P=d.words,q=c.words,L=u.words,D=h.words,H,R,_,E,U,G,$,Z,he,me;G=H=x[0],$=R=x[1],Z=_=x[2],he=E=x[3],me=U=x[4];for(var ye,A=0;A<80;A+=1)ye=H+T[I+P[A]]|0,A<16?ye+=g(R,_,E)+k[0]:A<32?ye+=y(R,_,E)+k[1]:A<48?ye+=w(R,_,E)+k[2]:A<64?ye+=b(R,_,E)+k[3]:ye+=S(R,_,E)+k[4],ye=ye|0,ye=v(ye,L[A]),ye=ye+U|0,H=U,U=E,E=v(_,10),_=R,R=ye,ye=G+T[I+q[A]]|0,A<16?ye+=S($,Z,he)+O[0]:A<32?ye+=b($,Z,he)+O[1]:A<48?ye+=w($,Z,he)+O[2]:A<64?ye+=y($,Z,he)+O[3]:ye+=g($,Z,he)+O[4],ye=ye|0,ye=v(ye,D[A]),ye=ye+me|0,G=me,me=he,he=v(Z,10),Z=$,$=ye;ye=x[1]+_+he|0,x[1]=x[2]+E+me|0,x[2]=x[3]+U+G|0,x[3]=x[4]+H+$|0,x[4]=x[0]+R+Z|0,x[0]=ye},_doFinalize:function(){var T=this._data,I=T.words,A=this._nDataBytes*8,N=T.sigBytes*8;I[N>>>5]|=128<<24-N%32,I[(N+64>>>9<<4)+14]=(A<<8|A>>>24)&16711935|(A<<24|A>>>8)&4278255360,T.sigBytes=(I.length+1)*4,this._process();for(var B=this._hash,x=B.words,k=0;k<5;k++){var O=x[k];x[k]=(O<<8|O>>>24)&16711935|(O<<24|O>>>8)&4278255360}return B},clone:function(){var T=a.clone.call(this);return T._hash=this._hash.clone(),T}});function g(T,I,A){return T^I^A}function y(T,I,A){return T&I|~T&A}function w(T,I,A){return(T|~I)^A}function b(T,I,A){return T&A|I&~A}function S(T,I,A){return T^(I|~A)}function v(T,I){return T<<I|T>>>32-I}i.RIPEMD160=a._createHelper(m),i.HmacRIPEMD160=a._createHmacHelper(m)})(),function(){var s=t,i=s.lib,n=i.Base,r=s.enc,a=r.Utf8,o=s.algo;o.HMAC=n.extend({init:function(d,c){d=this._hasher=new d.init,typeof c=="string"&&(c=a.parse(c));var u=d.blockSize,h=u*4;c.sigBytes>h&&(c=d.finalize(c)),c.clamp();for(var f=this._oKey=c.clone(),l=this._iKey=c.clone(),m=f.words,g=l.words,y=0;y<u;y++)m[y]^=1549556828,g[y]^=909522486;f.sigBytes=l.sigBytes=h,this.reset()},reset:function(){var d=this._hasher;d.reset(),d.update(this._iKey)},update:function(d){return this._hasher.update(d),this},finalize:function(d){var c=this._hasher,u=c.finalize(d);c.reset();var h=c.finalize(this._oKey.clone().concat(u));return h}})}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.SHA1,d=a.HMAC,c=a.PBKDF2=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(u){this.cfg=this.cfg.extend(u)},compute:function(u,h){for(var f=this.cfg,l=d.create(f.hasher,u),m=r.create(),g=r.create([1]),y=m.words,w=g.words,b=f.keySize,S=f.iterations;y.length<b;){var v=l.update(h).finalize(g);l.reset();for(var T=v.words,I=T.length,A=v,N=1;N<S;N++){A=l.finalize(A),l.reset();for(var B=A.words,x=0;x<I;x++)T[x]^=B[x]}m.concat(v),w[0]++}return m.sigBytes=b*4,m}});s.PBKDF2=function(u,h,f){return c.create(f).compute(u,h)}}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.MD5,d=a.EvpKDF=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(c){this.cfg=this.cfg.extend(c)},compute:function(c,u){for(var h=this.cfg,f=h.hasher.create(),l=r.create(),m=l.words,g=h.keySize,y=h.iterations;m.length<g;){w&&f.update(w);var w=f.update(c).finalize(u);f.reset();for(var b=1;b<y;b++)w=f.finalize(w),f.reset();l.concat(w)}return l.sigBytes=g*4,l}});s.EvpKDF=function(c,u,h){return d.create(h).compute(c,u)}}(),function(){var s=t,i=s.lib,n=i.WordArray,r=s.algo,a=r.SHA256,o=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var d=a._doFinalize.call(this);return d.sigBytes-=4,d}});s.SHA224=a._createHelper(o),s.HmacSHA224=a._createHmacHelper(o)}(),function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=i.x64={};o.Word=r.extend({init:function(d,c){this.high=d,this.low=c}}),o.WordArray=r.extend({init:function(d,c){d=this.words=d||[],c!=s?this.sigBytes=c:this.sigBytes=d.length*8},toX32:function(){for(var d=this.words,c=d.length,u=[],h=0;h<c;h++){var f=d[h];u.push(f.high),u.push(f.low)}return a.create(u,this.sigBytes)},clone:function(){for(var d=r.clone.call(this),c=d.words=this.words.slice(0),u=c.length,h=0;h<u;h++)c[h]=c[h].clone();return d}})}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.x64,d=o.Word,c=i.algo,u=[],h=[],f=[];(function(){for(var g=1,y=0,w=0;w<24;w++){u[g+5*y]=(w+1)*(w+2)/2%64;var b=y%5,S=(2*g+3*y)%5;g=b,y=S}for(var g=0;g<5;g++)for(var y=0;y<5;y++)h[g+5*y]=y+(2*g+3*y)%5*5;for(var v=1,T=0;T<24;T++){for(var I=0,A=0,N=0;N<7;N++){if(v&1){var B=(1<<N)-1;B<32?A^=1<<B:I^=1<<B-32}v&128?v=v<<1^113:v<<=1}f[T]=d.create(I,A)}})();var l=[];(function(){for(var g=0;g<25;g++)l[g]=d.create()})();var m=c.SHA3=a.extend({cfg:a.cfg.extend({outputLength:512}),_doReset:function(){for(var g=this._state=[],y=0;y<25;y++)g[y]=new d.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(g,y){for(var w=this._state,b=this.blockSize/2,S=0;S<b;S++){var v=g[y+2*S],T=g[y+2*S+1];v=(v<<8|v>>>24)&16711935|(v<<24|v>>>8)&4278255360,T=(T<<8|T>>>24)&16711935|(T<<24|T>>>8)&4278255360;var I=w[S];I.high^=T,I.low^=v}for(var A=0;A<24;A++){for(var N=0;N<5;N++){for(var B=0,x=0,k=0;k<5;k++){var I=w[N+5*k];B^=I.high,x^=I.low}var O=l[N];O.high=B,O.low=x}for(var N=0;N<5;N++)for(var P=l[(N+4)%5],q=l[(N+1)%5],L=q.high,D=q.low,B=P.high^(L<<1|D>>>31),x=P.low^(D<<1|L>>>31),k=0;k<5;k++){var I=w[N+5*k];I.high^=B,I.low^=x}for(var H=1;H<25;H++){var I=w[H],R=I.high,_=I.low,E=u[H];if(E<32)var B=R<<E|_>>>32-E,x=_<<E|R>>>32-E;else var B=_<<E-32|R>>>64-E,x=R<<E-32|_>>>64-E;var U=l[h[H]];U.high=B,U.low=x}var G=l[0],$=w[0];G.high=$.high,G.low=$.low;for(var N=0;N<5;N++)for(var k=0;k<5;k++){var H=N+5*k,I=w[H],Z=l[H],he=l[(N+1)%5+5*k],me=l[(N+2)%5+5*k];I.high=Z.high^~he.high&me.high,I.low=Z.low^~he.low&me.low}var I=w[0],ye=f[A];I.high^=ye.high,I.low^=ye.low}},_doFinalize:function(){var g=this._data,y=g.words;this._nDataBytes*8;var w=g.sigBytes*8,b=this.blockSize*32;y[w>>>5]|=1<<24-w%32,y[(s.ceil((w+1)/b)*b>>>5)-1]|=128,g.sigBytes=y.length*4,this._process();for(var S=this._state,v=this.cfg.outputLength/8,T=v/8,I=[],A=0;A<T;A++){var N=S[A],B=N.high,x=N.low;B=(B<<8|B>>>24)&16711935|(B<<24|B>>>8)&4278255360,x=(x<<8|x>>>24)&16711935|(x<<24|x>>>8)&4278255360,I.push(x),I.push(B)}return new r.init(I,v)},clone:function(){for(var g=a.clone.call(this),y=g._state=this._state.slice(0),w=0;w<25;w++)y[w]=y[w].clone();return g}});i.SHA3=a._createHelper(m),i.HmacSHA3=a._createHmacHelper(m)}(Math),function(){var s=t,i=s.lib,n=i.Hasher,r=s.x64,a=r.Word,o=r.WordArray,d=s.algo;function c(){return a.create.apply(a,arguments)}var u=[c(1116352408,3609767458),c(1899447441,602891725),c(3049323471,3964484399),c(3921009573,2173295548),c(961987163,4081628472),c(1508970993,3053834265),c(2453635748,2937671579),c(2870763221,3664609560),c(3624381080,2734883394),c(310598401,1164996542),c(607225278,1323610764),c(1426881987,3590304994),c(1925078388,4068182383),c(2162078206,991336113),c(2614888103,633803317),c(3248222580,3479774868),c(3835390401,2666613458),c(4022224774,944711139),c(264347078,2341262773),c(604807628,2007800933),c(770255983,1495990901),c(1249150122,1856431235),c(1555081692,3175218132),c(1996064986,2198950837),c(2554220882,3999719339),c(2821834349,766784016),c(2952996808,2566594879),c(3210313671,3203337956),c(3336571891,1034457026),c(3584528711,2466948901),c(113926993,3758326383),c(338241895,168717936),c(666307205,1188179964),c(773529912,1546045734),c(1294757372,1522805485),c(1396182291,2643833823),c(1695183700,2343527390),c(1986661051,1014477480),c(2177026350,1206759142),c(2456956037,344077627),c(2730485921,1290863460),c(2820302411,3158454273),c(3259730800,3505952657),c(3345764771,106217008),c(3516065817,3606008344),c(3600352804,1432725776),c(4094571909,1467031594),c(275423344,851169720),c(430227734,3100823752),c(506948616,1363258195),c(659060556,3750685593),c(883997877,3785050280),c(958139571,3318307427),c(1322822218,3812723403),c(1537002063,2003034995),c(1747873779,3602036899),c(1955562222,1575990012),c(2024104815,1125592928),c(2227730452,2716904306),c(2361852424,442776044),c(2428436474,593698344),c(2756734187,3733110249),c(3204031479,2999351573),c(3329325298,3815920427),c(3391569614,3928383900),c(3515267271,566280711),c(3940187606,3454069534),c(4118630271,4000239992),c(116418474,1914138554),c(174292421,2731055270),c(289380356,3203993006),c(460393269,320620315),c(685471733,587496836),c(852142971,1086792851),c(1017036298,365543100),c(1126000580,2618297676),c(1288033470,3409855158),c(1501505948,4234509866),c(1607167915,987167468),c(1816402316,1246189591)],h=[];(function(){for(var l=0;l<80;l++)h[l]=c()})();var f=d.SHA512=n.extend({_doReset:function(){this._hash=new o.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(l,m){for(var g=this._hash.words,y=g[0],w=g[1],b=g[2],S=g[3],v=g[4],T=g[5],I=g[6],A=g[7],N=y.high,B=y.low,x=w.high,k=w.low,O=b.high,P=b.low,q=S.high,L=S.low,D=v.high,H=v.low,R=T.high,_=T.low,E=I.high,U=I.low,G=A.high,$=A.low,Z=N,he=B,me=x,ye=k,xe=O,Ae=P,Mt=q,Me=L,ge=D,K=H,z=R,V=_,C=E,M=U,F=G,j=$,X=0;X<80;X++){var J=h[X];if(X<16)var be=J.high=l[m+X*2]|0,le=J.low=l[m+X*2+1]|0;else{var Te=h[X-15],Re=Te.high,ve=Te.low,Ue=(Re>>>1|ve<<31)^(Re>>>8|ve<<24)^Re>>>7,Ji=(ve>>>1|Re<<31)^(ve>>>8|Re<<24)^(ve>>>7|Re<<25),Ze=h[X-2],De=Ze.high,ai=Ze.low,Pt=(De>>>19|ai<<13)^(De<<3|ai>>>29)^De>>>6,pt=(ai>>>19|De<<13)^(ai<<3|De>>>29)^(ai>>>6|De<<26),wo=h[X-7],At=wo.high,Bt=wo.low,bo=h[X-16],Nt=bo.high,mt=bo.low,le=Ji+Bt,be=Ue+At+(le>>>0<Ji>>>0?1:0),le=le+pt,be=be+Pt+(le>>>0<pt>>>0?1:0),le=le+mt,be=be+Nt+(le>>>0<mt>>>0?1:0);J.high=be,J.low=le}var sc=ge&z^~ge&C,gt=K&V^~K&M,Vt=Z&me^Z&xe^me&xe,ic=he&ye^he&Ae^ye&Ae,Et=(Z>>>28|he<<4)^(Z<<30|he>>>2)^(Z<<25|he>>>7),yt=(he>>>28|Z<<4)^(he<<30|Z>>>2)^(he<<25|Z>>>7),nc=(ge>>>14|K<<18)^(ge>>>18|K<<14)^(ge<<23|K>>>9),qt=(K>>>14|ge<<18)^(K>>>18|ge<<14)^(K<<23|ge>>>9),wt=u[X],rc=wt.high,bt=wt.low,Fe=j+qt,Ei=F+nc+(Fe>>>0<j>>>0?1:0),Fe=Fe+gt,Ei=Ei+sc+(Fe>>>0<gt>>>0?1:0),Fe=Fe+bt,Ei=Ei+rc+(Fe>>>0<bt>>>0?1:0),Fe=Fe+le,Ei=Ei+be+(Fe>>>0<le>>>0?1:0),kt=yt+ic,Lt=Et+Vt+(kt>>>0<yt>>>0?1:0);F=C,j=M,C=z,M=V,z=ge,V=K,K=Me+Fe|0,ge=Mt+Ei+(K>>>0<Me>>>0?1:0)|0,Mt=xe,Me=Ae,xe=me,Ae=ye,me=Z,ye=he,he=Fe+kt|0,Z=Ei+Lt+(he>>>0<Fe>>>0?1:0)|0}B=y.low=B+he,y.high=N+Z+(B>>>0<he>>>0?1:0),k=w.low=k+ye,w.high=x+me+(k>>>0<ye>>>0?1:0),P=b.low=P+Ae,b.high=O+xe+(P>>>0<Ae>>>0?1:0),L=S.low=L+Me,S.high=q+Mt+(L>>>0<Me>>>0?1:0),H=v.low=H+K,v.high=D+ge+(H>>>0<K>>>0?1:0),_=T.low=_+V,T.high=R+z+(_>>>0<V>>>0?1:0),U=I.low=U+M,I.high=E+C+(U>>>0<M>>>0?1:0),$=A.low=$+j,A.high=G+F+($>>>0<j>>>0?1:0)},_doFinalize:function(){var l=this._data,m=l.words,g=this._nDataBytes*8,y=l.sigBytes*8;m[y>>>5]|=128<<24-y%32,m[(y+128>>>10<<5)+30]=Math.floor(g/4294967296),m[(y+128>>>10<<5)+31]=g,l.sigBytes=m.length*4,this._process();var w=this._hash.toX32();return w},clone:function(){var l=n.clone.call(this);return l._hash=this._hash.clone(),l},blockSize:1024/32});s.SHA512=n._createHelper(f),s.HmacSHA512=n._createHmacHelper(f)}(),function(){var s=t,i=s.x64,n=i.Word,r=i.WordArray,a=s.algo,o=a.SHA512,d=a.SHA384=o.extend({_doReset:function(){this._hash=new r.init([new n.init(3418070365,3238371032),new n.init(1654270250,914150663),new n.init(2438529370,812702999),new n.init(355462360,4144912697),new n.init(1731405415,4290775857),new n.init(2394180231,1750603025),new n.init(3675008525,1694076839),new n.init(1203062813,3204075428)])},_doFinalize:function(){var c=o._doFinalize.call(this);return c.sigBytes-=16,c}});s.SHA384=o._createHelper(d),s.HmacSHA384=o._createHmacHelper(d)}(),t.lib.Cipher||function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=n.BufferedBlockAlgorithm,d=i.enc;d.Utf8;var c=d.Base64,u=i.algo,h=u.EvpKDF,f=n.Cipher=o.extend({cfg:r.extend(),createEncryptor:function(B,x){return this.create(this._ENC_XFORM_MODE,B,x)},createDecryptor:function(B,x){return this.create(this._DEC_XFORM_MODE,B,x)},init:function(B,x,k){this.cfg=this.cfg.extend(k),this._xformMode=B,this._key=x,this.reset()},reset:function(){o.reset.call(this),this._doReset()},process:function(B){return this._append(B),this._process()},finalize:function(B){B&&this._append(B);var x=this._doFinalize();return x},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function B(x){return typeof x=="string"?N:T}return function(x){return{encrypt:function(k,O,P){return B(O).encrypt(x,k,O,P)},decrypt:function(k,O,P){return B(O).decrypt(x,k,O,P)}}}}()});n.StreamCipher=f.extend({_doFinalize:function(){var B=this._process(!0);return B},blockSize:1});var l=i.mode={},m=n.BlockCipherMode=r.extend({createEncryptor:function(B,x){return this.Encryptor.create(B,x)},createDecryptor:function(B,x){return this.Decryptor.create(B,x)},init:function(B,x){this._cipher=B,this._iv=x}}),g=l.CBC=function(){var B=m.extend();B.Encryptor=B.extend({processBlock:function(k,O){var P=this._cipher,q=P.blockSize;x.call(this,k,O,q),P.encryptBlock(k,O),this._prevBlock=k.slice(O,O+q)}}),B.Decryptor=B.extend({processBlock:function(k,O){var P=this._cipher,q=P.blockSize,L=k.slice(O,O+q);P.decryptBlock(k,O),x.call(this,k,O,q),this._prevBlock=L}});function x(k,O,P){var q=this._iv;if(q){var L=q;this._iv=s}else var L=this._prevBlock;for(var D=0;D<P;D++)k[O+D]^=L[D]}return B}(),y=i.pad={},w=y.Pkcs7={pad:function(B,x){for(var k=x*4,O=k-B.sigBytes%k,P=O<<24|O<<16|O<<8|O,q=[],L=0;L<O;L+=4)q.push(P);var D=a.create(q,O);B.concat(D)},unpad:function(B){var x=B.words[B.sigBytes-1>>>2]&255;B.sigBytes-=x}};n.BlockCipher=f.extend({cfg:f.cfg.extend({mode:g,padding:w}),reset:function(){f.reset.call(this);var B=this.cfg,x=B.iv,k=B.mode;if(this._xformMode==this._ENC_XFORM_MODE)var O=k.createEncryptor;else{var O=k.createDecryptor;this._minBufferSize=1}this._mode&&this._mode.__creator==O?this._mode.init(this,x&&x.words):(this._mode=O.call(k,this,x&&x.words),this._mode.__creator=O)},_doProcessBlock:function(B,x){this._mode.processBlock(B,x)},_doFinalize:function(){var B=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){B.pad(this._data,this.blockSize);var x=this._process(!0)}else{var x=this._process(!0);B.unpad(x)}return x},blockSize:128/32});var b=n.CipherParams=r.extend({init:function(B){this.mixIn(B)},toString:function(B){return(B||this.formatter).stringify(this)}}),S=i.format={},v=S.OpenSSL={stringify:function(B){var x=B.ciphertext,k=B.salt;if(k)var O=a.create([1398893684,1701076831]).concat(k).concat(x);else var O=x;return O.toString(c)},parse:function(B){var x=c.parse(B),k=x.words;if(k[0]==1398893684&&k[1]==1701076831){var O=a.create(k.slice(2,4));k.splice(0,4),x.sigBytes-=16}return b.create({ciphertext:x,salt:O})}},T=n.SerializableCipher=r.extend({cfg:r.extend({format:v}),encrypt:function(B,x,k,O){O=this.cfg.extend(O);var P=B.createEncryptor(k,O),q=P.finalize(x),L=P.cfg;return b.create({ciphertext:q,key:k,iv:L.iv,algorithm:B,mode:L.mode,padding:L.padding,blockSize:B.blockSize,formatter:O.format})},decrypt:function(B,x,k,O){O=this.cfg.extend(O),x=this._parse(x,O.format);var P=B.createDecryptor(k,O).finalize(x.ciphertext);return P},_parse:function(B,x){return typeof B=="string"?x.parse(B,this):B}}),I=i.kdf={},A=I.OpenSSL={execute:function(B,x,k,O){O||(O=a.random(64/8));var P=h.create({keySize:x+k}).compute(B,O),q=a.create(P.words.slice(x),k*4);return P.sigBytes=x*4,b.create({key:P,iv:q,salt:O})}},N=n.PasswordBasedCipher=T.extend({cfg:T.cfg.extend({kdf:A}),encrypt:function(B,x,k,O){O=this.cfg.extend(O);var P=O.kdf.execute(k,B.keySize,B.ivSize);O.iv=P.iv;var q=T.encrypt.call(this,B,x,P.key,O);return q.mixIn(P),q},decrypt:function(B,x,k,O){O=this.cfg.extend(O),x=this._parse(x,O.format);var P=O.kdf.execute(k,B.keySize,B.ivSize,x.salt);O.iv=P.iv;var q=T.decrypt.call(this,B,x,P.key,O);return q}})}(),t.mode.CFB=function(){var s=t.lib.BlockCipherMode.extend();s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize;i.call(this,n,r,o,a),this._prevBlock=n.slice(r,r+o)}}),s.Decryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=n.slice(r,r+o);i.call(this,n,r,o,a),this._prevBlock=d}});function i(n,r,a,o){var d=this._iv;if(d){var c=d.slice(0);this._iv=void 0}else var c=this._prevBlock;o.encryptBlock(c,0);for(var u=0;u<a;u++)n[r+u]^=c[u]}return s}(),t.mode.ECB=function(){var s=t.lib.BlockCipherMode.extend();return s.Encryptor=s.extend({processBlock:function(i,n){this._cipher.encryptBlock(i,n)}}),s.Decryptor=s.extend({processBlock:function(i,n){this._cipher.decryptBlock(i,n)}}),s}(),t.pad.AnsiX923={pad:function(s,i){var n=s.sigBytes,r=i*4,a=r-n%r,o=n+a-1;s.clamp(),s.words[o>>>2]|=a<<24-o%4*8,s.sigBytes+=a},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso10126={pad:function(s,i){var n=i*4,r=n-s.sigBytes%n;s.concat(t.lib.WordArray.random(r-1)).concat(t.lib.WordArray.create([r<<24],1))},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso97971={pad:function(s,i){s.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(s,i)},unpad:function(s){t.pad.ZeroPadding.unpad(s),s.sigBytes--}},t.mode.OFB=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._keystream;d&&(c=this._keystream=d.slice(0),this._iv=void 0),a.encryptBlock(c,0);for(var u=0;u<o;u++)n[r+u]^=c[u]}});return s.Decryptor=i,s}(),t.pad.NoPadding={pad:function(){},unpad:function(){}},function(s){var i=t,n=i.lib,r=n.CipherParams,a=i.enc,o=a.Hex,d=i.format;d.Hex={stringify:function(c){return c.ciphertext.toString(o)},parse:function(c){var u=o.parse(c);return r.create({ciphertext:u})}}}(),function(){var s=t,i=s.lib,n=i.BlockCipher,r=s.algo,a=[],o=[],d=[],c=[],u=[],h=[],f=[],l=[],m=[],g=[];(function(){for(var b=[],S=0;S<256;S++)S<128?b[S]=S<<1:b[S]=S<<1^283;for(var v=0,T=0,S=0;S<256;S++){var I=T^T<<1^T<<2^T<<3^T<<4;I=I>>>8^I&255^99,a[v]=I,o[I]=v;var A=b[v],N=b[A],B=b[N],x=b[I]*257^I*16843008;d[v]=x<<24|x>>>8,c[v]=x<<16|x>>>16,u[v]=x<<8|x>>>24,h[v]=x;var x=B*16843009^N*65537^A*257^v*16843008;f[I]=x<<24|x>>>8,l[I]=x<<16|x>>>16,m[I]=x<<8|x>>>24,g[I]=x,v?(v=A^b[b[b[B^A]]],T^=b[b[T]]):v=T=1}})();var y=[0,1,2,4,8,16,32,64,128,27,54],w=r.AES=n.extend({_doReset:function(){if(!(this._nRounds&&this._keyPriorReset===this._key)){for(var b=this._keyPriorReset=this._key,S=b.words,v=b.sigBytes/4,T=this._nRounds=v+6,I=(T+1)*4,A=this._keySchedule=[],N=0;N<I;N++)if(N<v)A[N]=S[N];else{var B=A[N-1];N%v?v>6&&N%v==4&&(B=a[B>>>24]<<24|a[B>>>16&255]<<16|a[B>>>8&255]<<8|a[B&255]):(B=B<<8|B>>>24,B=a[B>>>24]<<24|a[B>>>16&255]<<16|a[B>>>8&255]<<8|a[B&255],B^=y[N/v|0]<<24),A[N]=A[N-v]^B}for(var x=this._invKeySchedule=[],k=0;k<I;k++){var N=I-k;if(k%4)var B=A[N];else var B=A[N-4];k<4||N<=4?x[k]=B:x[k]=f[a[B>>>24]]^l[a[B>>>16&255]]^m[a[B>>>8&255]]^g[a[B&255]]}}},encryptBlock:function(b,S){this._doCryptBlock(b,S,this._keySchedule,d,c,u,h,a)},decryptBlock:function(b,S){var v=b[S+1];b[S+1]=b[S+3],b[S+3]=v,this._doCryptBlock(b,S,this._invKeySchedule,f,l,m,g,o);var v=b[S+1];b[S+1]=b[S+3],b[S+3]=v},_doCryptBlock:function(b,S,v,T,I,A,N,B){for(var x=this._nRounds,k=b[S]^v[0],O=b[S+1]^v[1],P=b[S+2]^v[2],q=b[S+3]^v[3],L=4,D=1;D<x;D++){var H=T[k>>>24]^I[O>>>16&255]^A[P>>>8&255]^N[q&255]^v[L++],R=T[O>>>24]^I[P>>>16&255]^A[q>>>8&255]^N[k&255]^v[L++],_=T[P>>>24]^I[q>>>16&255]^A[k>>>8&255]^N[O&255]^v[L++],E=T[q>>>24]^I[k>>>16&255]^A[O>>>8&255]^N[P&255]^v[L++];k=H,O=R,P=_,q=E}var H=(B[k>>>24]<<24|B[O>>>16&255]<<16|B[P>>>8&255]<<8|B[q&255])^v[L++],R=(B[O>>>24]<<24|B[P>>>16&255]<<16|B[q>>>8&255]<<8|B[k&255])^v[L++],_=(B[P>>>24]<<24|B[q>>>16&255]<<16|B[k>>>8&255]<<8|B[O&255])^v[L++],E=(B[q>>>24]<<24|B[k>>>16&255]<<16|B[O>>>8&255]<<8|B[P&255])^v[L++];b[S]=H,b[S+1]=R,b[S+2]=_,b[S+3]=E},keySize:256/32});s.AES=n._createHelper(w)}(),function(){var s=t,i=s.lib,n=i.WordArray,r=i.BlockCipher,a=s.algo,o=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],d=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],c=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],h=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],f=a.DES=r.extend({_doReset:function(){for(var y=this._key,w=y.words,b=[],S=0;S<56;S++){var v=o[S]-1;b[S]=w[v>>>5]>>>31-v%32&1}for(var T=this._subKeys=[],I=0;I<16;I++){for(var A=T[I]=[],N=c[I],S=0;S<24;S++)A[S/6|0]|=b[(d[S]-1+N)%28]<<31-S%6,A[4+(S/6|0)]|=b[28+(d[S+24]-1+N)%28]<<31-S%6;A[0]=A[0]<<1|A[0]>>>31;for(var S=1;S<7;S++)A[S]=A[S]>>>(S-1)*4+3;A[7]=A[7]<<5|A[7]>>>27}for(var B=this._invSubKeys=[],S=0;S<16;S++)B[S]=T[15-S]},encryptBlock:function(y,w){this._doCryptBlock(y,w,this._subKeys)},decryptBlock:function(y,w){this._doCryptBlock(y,w,this._invSubKeys)},_doCryptBlock:function(y,w,b){this._lBlock=y[w],this._rBlock=y[w+1],l.call(this,4,252645135),l.call(this,16,65535),m.call(this,2,858993459),m.call(this,8,16711935),l.call(this,1,1431655765);for(var S=0;S<16;S++){for(var v=b[S],T=this._lBlock,I=this._rBlock,A=0,N=0;N<8;N++)A|=u[N][((I^v[N])&h[N])>>>0];this._lBlock=I,this._rBlock=T^A}var B=this._lBlock;this._lBlock=this._rBlock,this._rBlock=B,l.call(this,1,1431655765),m.call(this,8,16711935),m.call(this,2,858993459),l.call(this,16,65535),l.call(this,4,252645135),y[w]=this._lBlock,y[w+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function l(y,w){var b=(this._lBlock>>>y^this._rBlock)&w;this._rBlock^=b,this._lBlock^=b<<y}function m(y,w){var b=(this._rBlock>>>y^this._lBlock)&w;this._lBlock^=b,this._rBlock^=b<<y}s.DES=r._createHelper(f);var g=a.TripleDES=r.extend({_doReset:function(){var y=this._key,w=y.words;this._des1=f.createEncryptor(n.create(w.slice(0,2))),this._des2=f.createEncryptor(n.create(w.slice(2,4))),this._des3=f.createEncryptor(n.create(w.slice(4,6)))},encryptBlock:function(y,w){this._des1.encryptBlock(y,w),this._des2.decryptBlock(y,w),this._des3.encryptBlock(y,w)},decryptBlock:function(y,w){this._des3.decryptBlock(y,w),this._des2.encryptBlock(y,w),this._des1.decryptBlock(y,w)},keySize:192/32,ivSize:64/32,blockSize:64/32});s.TripleDES=r._createHelper(g)}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=r.RC4=n.extend({_doReset:function(){for(var c=this._key,u=c.words,h=c.sigBytes,f=this._S=[],l=0;l<256;l++)f[l]=l;for(var l=0,m=0;l<256;l++){var g=l%h,y=u[g>>>2]>>>24-g%4*8&255;m=(m+f[l]+y)%256;var w=f[l];f[l]=f[m],f[m]=w}this._i=this._j=0},_doProcessBlock:function(c,u){c[u]^=o.call(this)},keySize:256/32,ivSize:0});function o(){for(var c=this._S,u=this._i,h=this._j,f=0,l=0;l<4;l++){u=(u+1)%256,h=(h+c[u])%256;var m=c[u];c[u]=c[h],c[h]=m,f|=c[(c[u]+c[h])%256]<<24-l*8}return this._i=u,this._j=h,f}s.RC4=n._createHelper(a);var d=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var c=this.cfg.drop;c>0;c--)o.call(this)}});s.RC4Drop=n._createHelper(d)}();/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */return t.mode.CTRGladman=function(){var s=t.lib.BlockCipherMode.extend();function i(a){if((a>>24&255)===255){var o=a>>16&255,d=a>>8&255,c=a&255;o===255?(o=0,d===255?(d=0,c===255?c=0:++c):++d):++o,a=0,a+=o<<16,a+=d<<8,a+=c}else a+=1<<24;return a}function n(a){return(a[0]=i(a[0]))===0&&(a[1]=i(a[1])),a}var r=s.Encryptor=s.extend({processBlock:function(a,o){var d=this._cipher,c=d.blockSize,u=this._iv,h=this._counter;u&&(h=this._counter=u.slice(0),this._iv=void 0),n(h);var f=h.slice(0);d.encryptBlock(f,0);for(var l=0;l<c;l++)a[o+l]^=f[l]}});return s.Decryptor=r,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.Rabbit=n.extend({_doReset:function(){for(var h=this._key.words,f=this.cfg.iv,l=0;l<4;l++)h[l]=(h[l]<<8|h[l]>>>24)&16711935|(h[l]<<24|h[l]>>>8)&4278255360;var m=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],g=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var l=0;l<4;l++)u.call(this);for(var l=0;l<8;l++)g[l]^=m[l+4&7];if(f){var y=f.words,w=y[0],b=y[1],S=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,v=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,T=S>>>16|v&4294901760,I=v<<16|S&65535;g[0]^=S,g[1]^=T,g[2]^=v,g[3]^=I,g[4]^=S,g[5]^=T,g[6]^=v,g[7]^=I;for(var l=0;l<4;l++)u.call(this)}},_doProcessBlock:function(h,f){var l=this._X;u.call(this),a[0]=l[0]^l[5]>>>16^l[3]<<16,a[1]=l[2]^l[7]>>>16^l[5]<<16,a[2]=l[4]^l[1]>>>16^l[7]<<16,a[3]=l[6]^l[3]>>>16^l[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[f+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,f=this._C,l=0;l<8;l++)o[l]=f[l];f[0]=f[0]+1295307597+this._b|0,f[1]=f[1]+3545052371+(f[0]>>>0<o[0]>>>0?1:0)|0,f[2]=f[2]+886263092+(f[1]>>>0<o[1]>>>0?1:0)|0,f[3]=f[3]+1295307597+(f[2]>>>0<o[2]>>>0?1:0)|0,f[4]=f[4]+3545052371+(f[3]>>>0<o[3]>>>0?1:0)|0,f[5]=f[5]+886263092+(f[4]>>>0<o[4]>>>0?1:0)|0,f[6]=f[6]+1295307597+(f[5]>>>0<o[5]>>>0?1:0)|0,f[7]=f[7]+3545052371+(f[6]>>>0<o[6]>>>0?1:0)|0,this._b=f[7]>>>0<o[7]>>>0?1:0;for(var l=0;l<8;l++){var m=h[l]+f[l],g=m&65535,y=m>>>16,w=((g*g>>>17)+g*y>>>15)+y*y,b=((m&4294901760)*m|0)+((m&65535)*m|0);d[l]=w^b}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.Rabbit=n._createHelper(c)}(),t.mode.CTR=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._counter;d&&(c=this._counter=d.slice(0),this._iv=void 0);var u=c.slice(0);a.encryptBlock(u,0),c[o-1]=c[o-1]+1|0;for(var h=0;h<o;h++)n[r+h]^=u[h]}});return s.Decryptor=i,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.RabbitLegacy=n.extend({_doReset:function(){var h=this._key.words,f=this.cfg.iv,l=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],m=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var g=0;g<4;g++)u.call(this);for(var g=0;g<8;g++)m[g]^=l[g+4&7];if(f){var y=f.words,w=y[0],b=y[1],S=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,v=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,T=S>>>16|v&4294901760,I=v<<16|S&65535;m[0]^=S,m[1]^=T,m[2]^=v,m[3]^=I,m[4]^=S,m[5]^=T,m[6]^=v,m[7]^=I;for(var g=0;g<4;g++)u.call(this)}},_doProcessBlock:function(h,f){var l=this._X;u.call(this),a[0]=l[0]^l[5]>>>16^l[3]<<16,a[1]=l[2]^l[7]>>>16^l[5]<<16,a[2]=l[4]^l[1]>>>16^l[7]<<16,a[3]=l[6]^l[3]>>>16^l[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[f+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,f=this._C,l=0;l<8;l++)o[l]=f[l];f[0]=f[0]+1295307597+this._b|0,f[1]=f[1]+3545052371+(f[0]>>>0<o[0]>>>0?1:0)|0,f[2]=f[2]+886263092+(f[1]>>>0<o[1]>>>0?1:0)|0,f[3]=f[3]+1295307597+(f[2]>>>0<o[2]>>>0?1:0)|0,f[4]=f[4]+3545052371+(f[3]>>>0<o[3]>>>0?1:0)|0,f[5]=f[5]+886263092+(f[4]>>>0<o[4]>>>0?1:0)|0,f[6]=f[6]+1295307597+(f[5]>>>0<o[5]>>>0?1:0)|0,f[7]=f[7]+3545052371+(f[6]>>>0<o[6]>>>0?1:0)|0,this._b=f[7]>>>0<o[7]>>>0?1:0;for(var l=0;l<8;l++){var m=h[l]+f[l],g=m&65535,y=m>>>16,w=((g*g>>>17)+g*y>>>15)+y*y,b=((m&4294901760)*m|0)+((m&65535)*m|0);d[l]=w^b}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.RabbitLegacy=n._createHelper(c)}(),t.pad.ZeroPadding={pad:function(s,i){var n=i*4;s.clamp(),s.sigBytes+=n-(s.sigBytes%n||n)},unpad:function(s){for(var i=s.words,n=s.sigBytes-1;!(i[n>>>2]>>>24-n%4*8&255);)n--;s.sigBytes=n+1}},t})})(co);var wf=Object.prototype.hasOwnProperty,Wa=Array.isArray,sn=function(){for(var p=[],e=0;e<256;++e)p.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return p}(),MC=function(e){for(;e.length>1;){var t=e.pop(),s=t.obj[t.prop];if(Wa(s)){for(var i=[],n=0;n<s.length;++n)typeof s[n]!="undefined"&&i.push(s[n]);t.obj[t.prop]=i}}},sv=function(e,t){for(var s=t&&t.plainObjects?Object.create(null):{},i=0;i<e.length;++i)typeof e[i]!="undefined"&&(s[i]=e[i]);return s},PC=function p(e,t,s){if(!t)return e;if(typeof t!="object"){if(Wa(e))e.push(t);else if(e&&typeof e=="object")(s&&(s.plainObjects||s.allowPrototypes)||!wf.call(Object.prototype,t))&&(e[t]=!0);else return[e,t];return e}if(!e||typeof e!="object")return[e].concat(t);var i=e;return Wa(e)&&!Wa(t)&&(i=sv(e,s)),Wa(e)&&Wa(t)?(t.forEach(function(n,r){if(wf.call(e,r)){var a=e[r];a&&typeof a=="object"&&n&&typeof n=="object"?e[r]=p(a,n,s):e.push(n)}else e[r]=n}),e):Object.keys(t).reduce(function(n,r){var a=t[r];return wf.call(n,r)?n[r]=p(n[r],a,s):n[r]=a,n},i)},AC=function(e,t){return Object.keys(t).reduce(function(s,i){return s[i]=t[i],s},e)},BC=function(p,e,t){var s=p.replace(/\+/g," ");if(t==="iso-8859-1")return s.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(s)}catch{return s}},NC=function(e,t,s){if(e.length===0)return e;var i=typeof e=="string"?e:String(e);if(s==="iso-8859-1")return escape(i).replace(/%u[0-9a-f]{4}/gi,function(o){return"%26%23"+parseInt(o.slice(2),16)+"%3B"});for(var n="",r=0;r<i.length;++r){var a=i.charCodeAt(r);if(a===45||a===46||a===95||a===126||a>=48&&a<=57||a>=65&&a<=90||a>=97&&a<=122){n+=i.charAt(r);continue}if(a<128){n=n+sn[a];continue}if(a<2048){n=n+(sn[192|a>>6]+sn[128|a&63]);continue}if(a<55296||a>=57344){n=n+(sn[224|a>>12]+sn[128|a>>6&63]+sn[128|a&63]);continue}r+=1,a=65536+((a&1023)<<10|i.charCodeAt(r)&1023),n+=sn[240|a>>18]+sn[128|a>>12&63]+sn[128|a>>6&63]+sn[128|a&63]}return n},VC=function(e){for(var t=[{obj:{o:e},prop:"o"}],s=[],i=0;i<t.length;++i)for(var n=t[i],r=n.obj[n.prop],a=Object.keys(r),o=0;o<a.length;++o){var d=a[o],c=r[d];typeof c=="object"&&c!==null&&s.indexOf(c)===-1&&(t.push({obj:r,prop:d}),s.push(c))}return MC(t),e},EC=function(e){return Object.prototype.toString.call(e)==="[object RegExp]"},qC=function(e){return!e||typeof e!="object"?!1:!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},LC=function(e,t){return[].concat(e,t)},iv={arrayToObject:sv,assign:AC,combine:LC,compact:VC,decode:BC,encode:NC,isBuffer:qC,isRegExp:EC,merge:PC},RC=String.prototype.replace,DC=/%20/g,nv={default:"RFC3986",formatters:{RFC1738:function(p){return RC.call(p,DC,"+")},RFC3986:function(p){return p}},RFC1738:"RFC1738",RFC3986:"RFC3986"},rv=iv,Rd=nv,FC=Object.prototype.hasOwnProperty,T0={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},Qa=Array.isArray,HC=Array.prototype.push,bm=function(p,e){HC.apply(p,Qa(e)?e:[e])},GC=Date.prototype.toISOString,Rs={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:rv.encode,encodeValuesOnly:!1,formatter:Rd.formatters[Rd.default],indices:!1,serializeDate:function(e){return GC.call(e)},skipNulls:!1,strictNullHandling:!1},UC=function p(e,t,s,i,n,r,a,o,d,c,u,h,f){var l=e;if(typeof a=="function"?l=a(t,l):l instanceof Date?l=c(l):s==="comma"&&Qa(l)&&(l=l.join(",")),l===null){if(i)return r&&!h?r(t,Rs.encoder,f):t;l=""}if(typeof l=="string"||typeof l=="number"||typeof l=="boolean"||rv.isBuffer(l)){if(r){var m=h?t:r(t,Rs.encoder,f);return[u(m)+"="+u(r(l,Rs.encoder,f))]}return[u(t)+"="+u(String(l))]}var g=[];if(typeof l=="undefined")return g;var y;if(Qa(a))y=a;else{var w=Object.keys(l);y=o?w.sort(o):w}for(var b=0;b<y.length;++b){var S=y[b];n&&l[S]===null||(Qa(l)?bm(g,p(l[S],typeof s=="function"?s(t,S):t,s,i,n,r,a,o,d,c,u,h,f)):bm(g,p(l[S],t+(d?"."+S:"["+S+"]"),s,i,n,r,a,o,d,c,u,h,f)))}return g},$C=function(e){if(!e)return Rs;if(e.encoder!==null&&e.encoder!==void 0&&typeof e.encoder!="function")throw new TypeError("Encoder has to be a function.");var t=e.charset||Rs.charset;if(typeof e.charset!="undefined"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var s=Rd.default;if(typeof e.format!="undefined"){if(!FC.call(Rd.formatters,e.format))throw new TypeError("Unknown format option provided.");s=e.format}var i=Rd.formatters[s],n=Rs.filter;return(typeof e.filter=="function"||Qa(e.filter))&&(n=e.filter),{addQueryPrefix:typeof e.addQueryPrefix=="boolean"?e.addQueryPrefix:Rs.addQueryPrefix,allowDots:typeof e.allowDots=="undefined"?Rs.allowDots:!!e.allowDots,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:Rs.charsetSentinel,delimiter:typeof e.delimiter=="undefined"?Rs.delimiter:e.delimiter,encode:typeof e.encode=="boolean"?e.encode:Rs.encode,encoder:typeof e.encoder=="function"?e.encoder:Rs.encoder,encodeValuesOnly:typeof e.encodeValuesOnly=="boolean"?e.encodeValuesOnly:Rs.encodeValuesOnly,filter:n,formatter:i,serializeDate:typeof e.serializeDate=="function"?e.serializeDate:Rs.serializeDate,skipNulls:typeof e.skipNulls=="boolean"?e.skipNulls:Rs.skipNulls,sort:typeof e.sort=="function"?e.sort:null,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:Rs.strictNullHandling}},WC=function(p,e){var t=p,s=$C(e),i,n;typeof s.filter=="function"?(n=s.filter,t=n("",t)):Qa(s.filter)&&(n=s.filter,i=n);var r=[];if(typeof t!="object"||t===null)return"";var a;e&&e.arrayFormat in T0?a=e.arrayFormat:e&&"indices"in e?a=e.indices?"indices":"repeat":a="indices";var o=T0[a];i||(i=Object.keys(t)),s.sort&&i.sort(s.sort);for(var d=0;d<i.length;++d){var c=i[d];s.skipNulls&&t[c]===null||bm(r,UC(t[c],c,o,s.strictNullHandling,s.skipNulls,s.encode?s.encoder:null,s.filter,s.sort,s.allowDots,s.serializeDate,s.formatter,s.encodeValuesOnly,s.charset))}var u=r.join(s.delimiter),h=s.addQueryPrefix===!0?"?":"";return s.charsetSentinel&&(s.charset==="iso-8859-1"?h+="utf8=%26%2310003%3B&":h+="utf8=%E2%9C%93&"),u.length>0?h+u:""},Gd=iv,km=Object.prototype.hasOwnProperty,_s={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:Gd.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},zC=function(p){return p.replace(/&#(\d+);/g,function(e,t){return String.fromCharCode(parseInt(t,10))})},jC="utf8=%26%2310003%3B",KC="utf8=%E2%9C%93",XC=function(e,t){var s={},i=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,n=t.parameterLimit===1/0?void 0:t.parameterLimit,r=i.split(t.delimiter,n),a=-1,o,d=t.charset;if(t.charsetSentinel)for(o=0;o<r.length;++o)r[o].indexOf("utf8=")===0&&(r[o]===KC?d="utf-8":r[o]===jC&&(d="iso-8859-1"),a=o,o=r.length);for(o=0;o<r.length;++o)if(o!==a){var c=r[o],u=c.indexOf("]="),h=u===-1?c.indexOf("="):u+1,f,l;h===-1?(f=t.decoder(c,_s.decoder,d),l=t.strictNullHandling?null:""):(f=t.decoder(c.slice(0,h),_s.decoder,d),l=t.decoder(c.slice(h+1),_s.decoder,d)),l&&t.interpretNumericEntities&&d==="iso-8859-1"&&(l=zC(l)),l&&t.comma&&l.indexOf(",")>-1&&(l=l.split(",")),km.call(s,f)?s[f]=Gd.combine(s[f],l):s[f]=l}return s},YC=function(p,e,t){for(var s=e,i=p.length-1;i>=0;--i){var n,r=p[i];if(r==="[]"&&t.parseArrays)n=[].concat(s);else{n=t.plainObjects?Object.create(null):{};var a=r.charAt(0)==="["&&r.charAt(r.length-1)==="]"?r.slice(1,-1):r,o=parseInt(a,10);!t.parseArrays&&a===""?n={0:s}:!isNaN(o)&&r!==a&&String(o)===a&&o>=0&&t.parseArrays&&o<=t.arrayLimit?(n=[],n[o]=s):n[a]=s}s=n}return s},ZC=function(e,t,s){if(!!e){var i=s.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,n=/(\[[^[\]]*])/,r=/(\[[^[\]]*])/g,a=n.exec(i),o=a?i.slice(0,a.index):i,d=[];if(o){if(!s.plainObjects&&km.call(Object.prototype,o)&&!s.allowPrototypes)return;d.push(o)}for(var c=0;(a=r.exec(i))!==null&&c<s.depth;){if(c+=1,!s.plainObjects&&km.call(Object.prototype,a[1].slice(1,-1))&&!s.allowPrototypes)return;d.push(a[1])}return a&&d.push("["+i.slice(a.index)+"]"),YC(d,t,s)}},QC=function(e){if(!e)return _s;if(e.decoder!==null&&e.decoder!==void 0&&typeof e.decoder!="function")throw new TypeError("Decoder has to be a function.");if(typeof e.charset!="undefined"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=typeof e.charset=="undefined"?_s.charset:e.charset;return{allowDots:typeof e.allowDots=="undefined"?_s.allowDots:!!e.allowDots,allowPrototypes:typeof e.allowPrototypes=="boolean"?e.allowPrototypes:_s.allowPrototypes,arrayLimit:typeof e.arrayLimit=="number"?e.arrayLimit:_s.arrayLimit,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:_s.charsetSentinel,comma:typeof e.comma=="boolean"?e.comma:_s.comma,decoder:typeof e.decoder=="function"?e.decoder:_s.decoder,delimiter:typeof e.delimiter=="string"||Gd.isRegExp(e.delimiter)?e.delimiter:_s.delimiter,depth:typeof e.depth=="number"?e.depth:_s.depth,ignoreQueryPrefix:e.ignoreQueryPrefix===!0,interpretNumericEntities:typeof e.interpretNumericEntities=="boolean"?e.interpretNumericEntities:_s.interpretNumericEntities,parameterLimit:typeof e.parameterLimit=="number"?e.parameterLimit:_s.parameterLimit,parseArrays:e.parseArrays!==!1,plainObjects:typeof e.plainObjects=="boolean"?e.plainObjects:_s.plainObjects,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:_s.strictNullHandling}},JC=function(p,e){var t=QC(e);if(p===""||p===null||typeof p=="undefined")return t.plainObjects?Object.create(null):{};for(var s=typeof p=="string"?XC(p,t):p,i=t.plainObjects?Object.create(null):{},n=Object.keys(s),r=0;r<n.length;++r){var a=n[r],o=ZC(a,s[a],t);i=Gd.merge(i,o,t)}return Gd.compact(i)},eM=WC,tM=JC,sM=nv,iM={formats:sM,parse:tM,stringify:eM},mi={exports:{}};(function(p){(function(e,t){function s(x,k){if(!x)throw new Error(k||"Assertion failed")}function i(x,k){x.super_=k;var O=function(){};O.prototype=k.prototype,x.prototype=new O,x.prototype.constructor=x}function n(x,k,O){if(n.isBN(x))return x;this.negative=0,this.words=null,this.length=0,this.red=null,x!==null&&((k==="le"||k==="be")&&(O=k,k=10),this._init(x||0,k||10,O||"be"))}typeof e=="object"?e.exports=n:t.BN=n,n.BN=n,n.wordSize=26;var r;try{r=require("buffer").Buffer}catch{}n.isBN=function(k){return k instanceof n?!0:k!==null&&typeof k=="object"&&k.constructor.wordSize===n.wordSize&&Array.isArray(k.words)},n.max=function(k,O){return k.cmp(O)>0?k:O},n.min=function(k,O){return k.cmp(O)<0?k:O},n.prototype._init=function(k,O,P){if(typeof k=="number")return this._initNumber(k,O,P);if(typeof k=="object")return this._initArray(k,O,P);O==="hex"&&(O=16),s(O===(O|0)&&O>=2&&O<=36),k=k.toString().replace(/\s+/g,"");var q=0;k[0]==="-"&&q++,O===16?this._parseHex(k,q):this._parseBase(k,O,q),k[0]==="-"&&(this.negative=1),this._strip(),P==="le"&&this._initArray(this.toArray(),O,P)},n.prototype._initNumber=function(k,O,P){k<0&&(this.negative=1,k=-k),k<67108864?(this.words=[k&67108863],this.length=1):k<4503599627370496?(this.words=[k&67108863,k/67108864&67108863],this.length=2):(s(k<9007199254740992),this.words=[k&67108863,k/67108864&67108863,1],this.length=3),P==="le"&&this._initArray(this.toArray(),O,P)},n.prototype._initArray=function(k,O,P){if(s(typeof k.length=="number"),k.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(k.length/3),this.words=new Array(this.length);for(var q=0;q<this.length;q++)this.words[q]=0;var L,D,H=0;if(P==="be")for(q=k.length-1,L=0;q>=0;q-=3)D=k[q]|k[q-1]<<8|k[q-2]<<16,this.words[L]|=D<<H&67108863,this.words[L+1]=D>>>26-H&67108863,H+=24,H>=26&&(H-=26,L++);else if(P==="le")for(q=0,L=0;q<k.length;q+=3)D=k[q]|k[q+1]<<8|k[q+2]<<16,this.words[L]|=D<<H&67108863,this.words[L+1]=D>>>26-H&67108863,H+=24,H>=26&&(H-=26,L++);return this._strip()};function a(x,k,O){for(var P=0,q=Math.min(x.length,O),L=0,D=k;D<q;D++){var H=x.charCodeAt(D)-48;P<<=4;var R;H>=49&&H<=54?R=H-49+10:H>=17&&H<=22?R=H-17+10:R=H,P|=R,L|=R}return s(!(L&240),"Invalid character in "+x),P}n.prototype._parseHex=function(k,O){this.length=Math.ceil((k.length-O)/6),this.words=new Array(this.length);for(var P=0;P<this.length;P++)this.words[P]=0;var q,L,D=0;for(P=k.length-6,q=0;P>=O;P-=6)L=a(k,P,P+6),this.words[q]|=L<<D&67108863,this.words[q+1]|=L>>>26-D&4194303,D+=24,D>=26&&(D-=26,q++);P+6!==O&&(L=a(k,O,P+6),this.words[q]|=L<<D&67108863,this.words[q+1]|=L>>>26-D&4194303),this._strip()};function o(x,k,O,P){for(var q=0,L=0,D=Math.min(x.length,O),H=k;H<D;H++){var R=x.charCodeAt(H)-48;q*=P,R>=49?L=R-49+10:R>=17?L=R-17+10:L=R,s(R>=0&&L<P,"Invalid character"),q+=L}return q}n.prototype._parseBase=function(k,O,P){this.words=[0],this.length=1;for(var q=0,L=1;L<=67108863;L*=O)q++;q--,L=L/O|0;for(var D=k.length-P,H=D%q,R=Math.min(D,D-H)+P,_=0,E=P;E<R;E+=q)_=o(k,E,E+q,O),this.imuln(L),this.words[0]+_<67108864?this.words[0]+=_:this._iaddn(_);if(H!==0){var U=1;for(_=o(k,E,k.length,O),E=0;E<H;E++)U*=O;this.imuln(U),this.words[0]+_<67108864?this.words[0]+=_:this._iaddn(_)}},n.prototype.copy=function(k){k.words=new Array(this.length);for(var O=0;O<this.length;O++)k.words[O]=this.words[O];k.length=this.length,k.negative=this.negative,k.red=this.red},n.prototype._move=function(k){k.words=this.words,k.length=this.length,k.negative=this.negative,k.red=this.red},n.prototype.clone=function(){var k=new n(null);return this.copy(k),k},n.prototype._expand=function(k){for(;this.length<k;)this.words[this.length++]=0;return this},n.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},n.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol!="undefined"&&typeof Symbol.for=="function"?n.prototype[Symbol.for("nodejs.util.inspect.custom")]=d:n.prototype.inspect=d;function d(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],u=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],h=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];n.prototype.toString=function(k,O){k=k||10,O=O|0||1;var P;if(k===16||k==="hex"){P="";for(var q=0,L=0,D=0;D<this.length;D++){var H=this.words[D],R=((H<<q|L)&16777215).toString(16);L=H>>>24-q&16777215,L!==0||D!==this.length-1?P=c[6-R.length]+R+P:P=R+P,q+=2,q>=26&&(q-=26,D--)}for(L!==0&&(P=L.toString(16)+P);P.length%O!==0;)P="0"+P;return this.negative!==0&&(P="-"+P),P}if(k===(k|0)&&k>=2&&k<=36){var _=u[k],E=h[k];P="";var U=this.clone();for(U.negative=0;!U.isZero();){var G=U.modrn(E).toString(k);U=U.idivn(E),U.isZero()?P=G+P:P=c[_-G.length]+G+P}for(this.isZero()&&(P="0"+P);P.length%O!==0;)P="0"+P;return this.negative!==0&&(P="-"+P),P}s(!1,"Base should be between 2 and 36")},n.prototype.toNumber=function(){var k=this.words[0];return this.length===2?k+=this.words[1]*67108864:this.length===3&&this.words[2]===1?k+=4503599627370496+this.words[1]*67108864:this.length>2&&s(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-k:k},n.prototype.toJSON=function(){return this.toString(16,2)},r&&(n.prototype.toBuffer=function(k,O){return this.toArrayLike(r,k,O)}),n.prototype.toArray=function(k,O){return this.toArrayLike(Array,k,O)};var f=function(k,O){return k.allocUnsafe?k.allocUnsafe(O):new k(O)};n.prototype.toArrayLike=function(k,O,P){this._strip();var q=this.byteLength(),L=P||Math.max(1,q);s(q<=L,"byte array longer than desired length"),s(L>0,"Requested array length <= 0");var D=f(k,L),H=O==="le"?"LE":"BE";return this["_toArrayLike"+H](D,q),D},n.prototype._toArrayLikeLE=function(k,O){for(var P=0,q=0,L=0,D=0;L<this.length;L++){var H=this.words[L]<<D|q;k[P++]=H&255,P<k.length&&(k[P++]=H>>8&255),P<k.length&&(k[P++]=H>>16&255),D===6?(P<k.length&&(k[P++]=H>>24&255),q=0,D=0):(q=H>>>24,D+=2)}if(P<k.length)for(k[P++]=q;P<k.length;)k[P++]=0},n.prototype._toArrayLikeBE=function(k,O){for(var P=k.length-1,q=0,L=0,D=0;L<this.length;L++){var H=this.words[L]<<D|q;k[P--]=H&255,P>=0&&(k[P--]=H>>8&255),P>=0&&(k[P--]=H>>16&255),D===6?(P>=0&&(k[P--]=H>>24&255),q=0,D=0):(q=H>>>24,D+=2)}if(P>=0)for(k[P--]=q;P>=0;)k[P--]=0},Math.clz32?n.prototype._countBits=function(k){return 32-Math.clz32(k)}:n.prototype._countBits=function(k){var O=k,P=0;return O>=4096&&(P+=13,O>>>=13),O>=64&&(P+=7,O>>>=7),O>=8&&(P+=4,O>>>=4),O>=2&&(P+=2,O>>>=2),P+O},n.prototype._zeroBits=function(k){if(k===0)return 26;var O=k,P=0;return(O&8191)===0&&(P+=13,O>>>=13),(O&127)===0&&(P+=7,O>>>=7),(O&15)===0&&(P+=4,O>>>=4),(O&3)===0&&(P+=2,O>>>=2),(O&1)===0&&P++,P},n.prototype.bitLength=function(){var k=this.words[this.length-1],O=this._countBits(k);return(this.length-1)*26+O};function l(x){for(var k=new Array(x.bitLength()),O=0;O<k.length;O++){var P=O/26|0,q=O%26;k[O]=x.words[P]>>>q&1}return k}n.prototype.zeroBits=function(){if(this.isZero())return 0;for(var k=0,O=0;O<this.length;O++){var P=this._zeroBits(this.words[O]);if(k+=P,P!==26)break}return k},n.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},n.prototype.toTwos=function(k){return this.negative!==0?this.abs().inotn(k).iaddn(1):this.clone()},n.prototype.fromTwos=function(k){return this.testn(k-1)?this.notn(k).iaddn(1).ineg():this.clone()},n.prototype.isNeg=function(){return this.negative!==0},n.prototype.neg=function(){return this.clone().ineg()},n.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},n.prototype.iuor=function(k){for(;this.length<k.length;)this.words[this.length++]=0;for(var O=0;O<k.length;O++)this.words[O]=this.words[O]|k.words[O];return this._strip()},n.prototype.ior=function(k){return s((this.negative|k.negative)===0),this.iuor(k)},n.prototype.or=function(k){return this.length>k.length?this.clone().ior(k):k.clone().ior(this)},n.prototype.uor=function(k){return this.length>k.length?this.clone().iuor(k):k.clone().iuor(this)},n.prototype.iuand=function(k){var O;this.length>k.length?O=k:O=this;for(var P=0;P<O.length;P++)this.words[P]=this.words[P]&k.words[P];return this.length=O.length,this._strip()},n.prototype.iand=function(k){return s((this.negative|k.negative)===0),this.iuand(k)},n.prototype.and=function(k){return this.length>k.length?this.clone().iand(k):k.clone().iand(this)},n.prototype.uand=function(k){return this.length>k.length?this.clone().iuand(k):k.clone().iuand(this)},n.prototype.iuxor=function(k){var O,P;this.length>k.length?(O=this,P=k):(O=k,P=this);for(var q=0;q<P.length;q++)this.words[q]=O.words[q]^P.words[q];if(this!==O)for(;q<O.length;q++)this.words[q]=O.words[q];return this.length=O.length,this._strip()},n.prototype.ixor=function(k){return s((this.negative|k.negative)===0),this.iuxor(k)},n.prototype.xor=function(k){return this.length>k.length?this.clone().ixor(k):k.clone().ixor(this)},n.prototype.uxor=function(k){return this.length>k.length?this.clone().iuxor(k):k.clone().iuxor(this)},n.prototype.inotn=function(k){s(typeof k=="number"&&k>=0);var O=Math.ceil(k/26)|0,P=k%26;this._expand(O),P>0&&O--;for(var q=0;q<O;q++)this.words[q]=~this.words[q]&67108863;return P>0&&(this.words[q]=~this.words[q]&67108863>>26-P),this._strip()},n.prototype.notn=function(k){return this.clone().inotn(k)},n.prototype.setn=function(k,O){s(typeof k=="number"&&k>=0);var P=k/26|0,q=k%26;return this._expand(P+1),O?this.words[P]=this.words[P]|1<<q:this.words[P]=this.words[P]&~(1<<q),this._strip()},n.prototype.iadd=function(k){var O;if(this.negative!==0&&k.negative===0)return this.negative=0,O=this.isub(k),this.negative^=1,this._normSign();if(this.negative===0&&k.negative!==0)return k.negative=0,O=this.isub(k),k.negative=1,O._normSign();var P,q;this.length>k.length?(P=this,q=k):(P=k,q=this);for(var L=0,D=0;D<q.length;D++)O=(P.words[D]|0)+(q.words[D]|0)+L,this.words[D]=O&67108863,L=O>>>26;for(;L!==0&&D<P.length;D++)O=(P.words[D]|0)+L,this.words[D]=O&67108863,L=O>>>26;if(this.length=P.length,L!==0)this.words[this.length]=L,this.length++;else if(P!==this)for(;D<P.length;D++)this.words[D]=P.words[D];return this},n.prototype.add=function(k){var O;return k.negative!==0&&this.negative===0?(k.negative=0,O=this.sub(k),k.negative^=1,O):k.negative===0&&this.negative!==0?(this.negative=0,O=k.sub(this),this.negative=1,O):this.length>k.length?this.clone().iadd(k):k.clone().iadd(this)},n.prototype.isub=function(k){if(k.negative!==0){k.negative=0;var O=this.iadd(k);return k.negative=1,O._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(k),this.negative=1,this._normSign();var P=this.cmp(k);if(P===0)return this.negative=0,this.length=1,this.words[0]=0,this;var q,L;P>0?(q=this,L=k):(q=k,L=this);for(var D=0,H=0;H<L.length;H++)O=(q.words[H]|0)-(L.words[H]|0)+D,D=O>>26,this.words[H]=O&67108863;for(;D!==0&&H<q.length;H++)O=(q.words[H]|0)+D,D=O>>26,this.words[H]=O&67108863;if(D===0&&H<q.length&&q!==this)for(;H<q.length;H++)this.words[H]=q.words[H];return this.length=Math.max(this.length,H),q!==this&&(this.negative=1),this._strip()},n.prototype.sub=function(k){return this.clone().isub(k)};function m(x,k,O){O.negative=k.negative^x.negative;var P=x.length+k.length|0;O.length=P,P=P-1|0;var q=x.words[0]|0,L=k.words[0]|0,D=q*L,H=D&67108863,R=D/67108864|0;O.words[0]=H;for(var _=1;_<P;_++){for(var E=R>>>26,U=R&67108863,G=Math.min(_,k.length-1),$=Math.max(0,_-x.length+1);$<=G;$++){var Z=_-$|0;q=x.words[Z]|0,L=k.words[$]|0,D=q*L+U,E+=D/67108864|0,U=D&67108863}O.words[_]=U|0,R=E|0}return R!==0?O.words[_]=R|0:O.length--,O._strip()}var g=function(k,O,P){var q=k.words,L=O.words,D=P.words,H=0,R,_,E,U=q[0]|0,G=U&8191,$=U>>>13,Z=q[1]|0,he=Z&8191,me=Z>>>13,ye=q[2]|0,xe=ye&8191,Ae=ye>>>13,Mt=q[3]|0,Me=Mt&8191,ge=Mt>>>13,K=q[4]|0,z=K&8191,V=K>>>13,C=q[5]|0,M=C&8191,F=C>>>13,j=q[6]|0,X=j&8191,J=j>>>13,be=q[7]|0,le=be&8191,Te=be>>>13,Re=q[8]|0,ve=Re&8191,Ue=Re>>>13,Ji=q[9]|0,Ze=Ji&8191,De=Ji>>>13,ai=L[0]|0,Pt=ai&8191,pt=ai>>>13,wo=L[1]|0,At=wo&8191,Bt=wo>>>13,bo=L[2]|0,Nt=bo&8191,mt=bo>>>13,sc=L[3]|0,gt=sc&8191,Vt=sc>>>13,ic=L[4]|0,Et=ic&8191,yt=ic>>>13,nc=L[5]|0,qt=nc&8191,wt=nc>>>13,rc=L[6]|0,bt=rc&8191,Fe=rc>>>13,Ei=L[7]|0,kt=Ei&8191,Lt=Ei>>>13,vg=L[8]|0,Qt=vg&8191,Jt=vg>>>13,Tg=L[9]|0,es=Tg&8191,ts=Tg>>>13;P.negative=k.negative^O.negative,P.length=19,R=Math.imul(G,Pt),_=Math.imul(G,pt),_=_+Math.imul($,Pt)|0,E=Math.imul($,pt);var Nh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Nh>>>26)|0,Nh&=67108863,R=Math.imul(he,Pt),_=Math.imul(he,pt),_=_+Math.imul(me,Pt)|0,E=Math.imul(me,pt),R=R+Math.imul(G,At)|0,_=_+Math.imul(G,Bt)|0,_=_+Math.imul($,At)|0,E=E+Math.imul($,Bt)|0;var Vh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Vh>>>26)|0,Vh&=67108863,R=Math.imul(xe,Pt),_=Math.imul(xe,pt),_=_+Math.imul(Ae,Pt)|0,E=Math.imul(Ae,pt),R=R+Math.imul(he,At)|0,_=_+Math.imul(he,Bt)|0,_=_+Math.imul(me,At)|0,E=E+Math.imul(me,Bt)|0,R=R+Math.imul(G,Nt)|0,_=_+Math.imul(G,mt)|0,_=_+Math.imul($,Nt)|0,E=E+Math.imul($,mt)|0;var Eh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Eh>>>26)|0,Eh&=67108863,R=Math.imul(Me,Pt),_=Math.imul(Me,pt),_=_+Math.imul(ge,Pt)|0,E=Math.imul(ge,pt),R=R+Math.imul(xe,At)|0,_=_+Math.imul(xe,Bt)|0,_=_+Math.imul(Ae,At)|0,E=E+Math.imul(Ae,Bt)|0,R=R+Math.imul(he,Nt)|0,_=_+Math.imul(he,mt)|0,_=_+Math.imul(me,Nt)|0,E=E+Math.imul(me,mt)|0,R=R+Math.imul(G,gt)|0,_=_+Math.imul(G,Vt)|0,_=_+Math.imul($,gt)|0,E=E+Math.imul($,Vt)|0;var qh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(qh>>>26)|0,qh&=67108863,R=Math.imul(z,Pt),_=Math.imul(z,pt),_=_+Math.imul(V,Pt)|0,E=Math.imul(V,pt),R=R+Math.imul(Me,At)|0,_=_+Math.imul(Me,Bt)|0,_=_+Math.imul(ge,At)|0,E=E+Math.imul(ge,Bt)|0,R=R+Math.imul(xe,Nt)|0,_=_+Math.imul(xe,mt)|0,_=_+Math.imul(Ae,Nt)|0,E=E+Math.imul(Ae,mt)|0,R=R+Math.imul(he,gt)|0,_=_+Math.imul(he,Vt)|0,_=_+Math.imul(me,gt)|0,E=E+Math.imul(me,Vt)|0,R=R+Math.imul(G,Et)|0,_=_+Math.imul(G,yt)|0,_=_+Math.imul($,Et)|0,E=E+Math.imul($,yt)|0;var Lh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Lh>>>26)|0,Lh&=67108863,R=Math.imul(M,Pt),_=Math.imul(M,pt),_=_+Math.imul(F,Pt)|0,E=Math.imul(F,pt),R=R+Math.imul(z,At)|0,_=_+Math.imul(z,Bt)|0,_=_+Math.imul(V,At)|0,E=E+Math.imul(V,Bt)|0,R=R+Math.imul(Me,Nt)|0,_=_+Math.imul(Me,mt)|0,_=_+Math.imul(ge,Nt)|0,E=E+Math.imul(ge,mt)|0,R=R+Math.imul(xe,gt)|0,_=_+Math.imul(xe,Vt)|0,_=_+Math.imul(Ae,gt)|0,E=E+Math.imul(Ae,Vt)|0,R=R+Math.imul(he,Et)|0,_=_+Math.imul(he,yt)|0,_=_+Math.imul(me,Et)|0,E=E+Math.imul(me,yt)|0,R=R+Math.imul(G,qt)|0,_=_+Math.imul(G,wt)|0,_=_+Math.imul($,qt)|0,E=E+Math.imul($,wt)|0;var Rh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Rh>>>26)|0,Rh&=67108863,R=Math.imul(X,Pt),_=Math.imul(X,pt),_=_+Math.imul(J,Pt)|0,E=Math.imul(J,pt),R=R+Math.imul(M,At)|0,_=_+Math.imul(M,Bt)|0,_=_+Math.imul(F,At)|0,E=E+Math.imul(F,Bt)|0,R=R+Math.imul(z,Nt)|0,_=_+Math.imul(z,mt)|0,_=_+Math.imul(V,Nt)|0,E=E+Math.imul(V,mt)|0,R=R+Math.imul(Me,gt)|0,_=_+Math.imul(Me,Vt)|0,_=_+Math.imul(ge,gt)|0,E=E+Math.imul(ge,Vt)|0,R=R+Math.imul(xe,Et)|0,_=_+Math.imul(xe,yt)|0,_=_+Math.imul(Ae,Et)|0,E=E+Math.imul(Ae,yt)|0,R=R+Math.imul(he,qt)|0,_=_+Math.imul(he,wt)|0,_=_+Math.imul(me,qt)|0,E=E+Math.imul(me,wt)|0,R=R+Math.imul(G,bt)|0,_=_+Math.imul(G,Fe)|0,_=_+Math.imul($,bt)|0,E=E+Math.imul($,Fe)|0;var Dh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Dh>>>26)|0,Dh&=67108863,R=Math.imul(le,Pt),_=Math.imul(le,pt),_=_+Math.imul(Te,Pt)|0,E=Math.imul(Te,pt),R=R+Math.imul(X,At)|0,_=_+Math.imul(X,Bt)|0,_=_+Math.imul(J,At)|0,E=E+Math.imul(J,Bt)|0,R=R+Math.imul(M,Nt)|0,_=_+Math.imul(M,mt)|0,_=_+Math.imul(F,Nt)|0,E=E+Math.imul(F,mt)|0,R=R+Math.imul(z,gt)|0,_=_+Math.imul(z,Vt)|0,_=_+Math.imul(V,gt)|0,E=E+Math.imul(V,Vt)|0,R=R+Math.imul(Me,Et)|0,_=_+Math.imul(Me,yt)|0,_=_+Math.imul(ge,Et)|0,E=E+Math.imul(ge,yt)|0,R=R+Math.imul(xe,qt)|0,_=_+Math.imul(xe,wt)|0,_=_+Math.imul(Ae,qt)|0,E=E+Math.imul(Ae,wt)|0,R=R+Math.imul(he,bt)|0,_=_+Math.imul(he,Fe)|0,_=_+Math.imul(me,bt)|0,E=E+Math.imul(me,Fe)|0,R=R+Math.imul(G,kt)|0,_=_+Math.imul(G,Lt)|0,_=_+Math.imul($,kt)|0,E=E+Math.imul($,Lt)|0;var Fh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Fh>>>26)|0,Fh&=67108863,R=Math.imul(ve,Pt),_=Math.imul(ve,pt),_=_+Math.imul(Ue,Pt)|0,E=Math.imul(Ue,pt),R=R+Math.imul(le,At)|0,_=_+Math.imul(le,Bt)|0,_=_+Math.imul(Te,At)|0,E=E+Math.imul(Te,Bt)|0,R=R+Math.imul(X,Nt)|0,_=_+Math.imul(X,mt)|0,_=_+Math.imul(J,Nt)|0,E=E+Math.imul(J,mt)|0,R=R+Math.imul(M,gt)|0,_=_+Math.imul(M,Vt)|0,_=_+Math.imul(F,gt)|0,E=E+Math.imul(F,Vt)|0,R=R+Math.imul(z,Et)|0,_=_+Math.imul(z,yt)|0,_=_+Math.imul(V,Et)|0,E=E+Math.imul(V,yt)|0,R=R+Math.imul(Me,qt)|0,_=_+Math.imul(Me,wt)|0,_=_+Math.imul(ge,qt)|0,E=E+Math.imul(ge,wt)|0,R=R+Math.imul(xe,bt)|0,_=_+Math.imul(xe,Fe)|0,_=_+Math.imul(Ae,bt)|0,E=E+Math.imul(Ae,Fe)|0,R=R+Math.imul(he,kt)|0,_=_+Math.imul(he,Lt)|0,_=_+Math.imul(me,kt)|0,E=E+Math.imul(me,Lt)|0,R=R+Math.imul(G,Qt)|0,_=_+Math.imul(G,Jt)|0,_=_+Math.imul($,Qt)|0,E=E+Math.imul($,Jt)|0;var Hh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Hh>>>26)|0,Hh&=67108863,R=Math.imul(Ze,Pt),_=Math.imul(Ze,pt),_=_+Math.imul(De,Pt)|0,E=Math.imul(De,pt),R=R+Math.imul(ve,At)|0,_=_+Math.imul(ve,Bt)|0,_=_+Math.imul(Ue,At)|0,E=E+Math.imul(Ue,Bt)|0,R=R+Math.imul(le,Nt)|0,_=_+Math.imul(le,mt)|0,_=_+Math.imul(Te,Nt)|0,E=E+Math.imul(Te,mt)|0,R=R+Math.imul(X,gt)|0,_=_+Math.imul(X,Vt)|0,_=_+Math.imul(J,gt)|0,E=E+Math.imul(J,Vt)|0,R=R+Math.imul(M,Et)|0,_=_+Math.imul(M,yt)|0,_=_+Math.imul(F,Et)|0,E=E+Math.imul(F,yt)|0,R=R+Math.imul(z,qt)|0,_=_+Math.imul(z,wt)|0,_=_+Math.imul(V,qt)|0,E=E+Math.imul(V,wt)|0,R=R+Math.imul(Me,bt)|0,_=_+Math.imul(Me,Fe)|0,_=_+Math.imul(ge,bt)|0,E=E+Math.imul(ge,Fe)|0,R=R+Math.imul(xe,kt)|0,_=_+Math.imul(xe,Lt)|0,_=_+Math.imul(Ae,kt)|0,E=E+Math.imul(Ae,Lt)|0,R=R+Math.imul(he,Qt)|0,_=_+Math.imul(he,Jt)|0,_=_+Math.imul(me,Qt)|0,E=E+Math.imul(me,Jt)|0,R=R+Math.imul(G,es)|0,_=_+Math.imul(G,ts)|0,_=_+Math.imul($,es)|0,E=E+Math.imul($,ts)|0;var Gh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Gh>>>26)|0,Gh&=67108863,R=Math.imul(Ze,At),_=Math.imul(Ze,Bt),_=_+Math.imul(De,At)|0,E=Math.imul(De,Bt),R=R+Math.imul(ve,Nt)|0,_=_+Math.imul(ve,mt)|0,_=_+Math.imul(Ue,Nt)|0,E=E+Math.imul(Ue,mt)|0,R=R+Math.imul(le,gt)|0,_=_+Math.imul(le,Vt)|0,_=_+Math.imul(Te,gt)|0,E=E+Math.imul(Te,Vt)|0,R=R+Math.imul(X,Et)|0,_=_+Math.imul(X,yt)|0,_=_+Math.imul(J,Et)|0,E=E+Math.imul(J,yt)|0,R=R+Math.imul(M,qt)|0,_=_+Math.imul(M,wt)|0,_=_+Math.imul(F,qt)|0,E=E+Math.imul(F,wt)|0,R=R+Math.imul(z,bt)|0,_=_+Math.imul(z,Fe)|0,_=_+Math.imul(V,bt)|0,E=E+Math.imul(V,Fe)|0,R=R+Math.imul(Me,kt)|0,_=_+Math.imul(Me,Lt)|0,_=_+Math.imul(ge,kt)|0,E=E+Math.imul(ge,Lt)|0,R=R+Math.imul(xe,Qt)|0,_=_+Math.imul(xe,Jt)|0,_=_+Math.imul(Ae,Qt)|0,E=E+Math.imul(Ae,Jt)|0,R=R+Math.imul(he,es)|0,_=_+Math.imul(he,ts)|0,_=_+Math.imul(me,es)|0,E=E+Math.imul(me,ts)|0;var Uh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Uh>>>26)|0,Uh&=67108863,R=Math.imul(Ze,Nt),_=Math.imul(Ze,mt),_=_+Math.imul(De,Nt)|0,E=Math.imul(De,mt),R=R+Math.imul(ve,gt)|0,_=_+Math.imul(ve,Vt)|0,_=_+Math.imul(Ue,gt)|0,E=E+Math.imul(Ue,Vt)|0,R=R+Math.imul(le,Et)|0,_=_+Math.imul(le,yt)|0,_=_+Math.imul(Te,Et)|0,E=E+Math.imul(Te,yt)|0,R=R+Math.imul(X,qt)|0,_=_+Math.imul(X,wt)|0,_=_+Math.imul(J,qt)|0,E=E+Math.imul(J,wt)|0,R=R+Math.imul(M,bt)|0,_=_+Math.imul(M,Fe)|0,_=_+Math.imul(F,bt)|0,E=E+Math.imul(F,Fe)|0,R=R+Math.imul(z,kt)|0,_=_+Math.imul(z,Lt)|0,_=_+Math.imul(V,kt)|0,E=E+Math.imul(V,Lt)|0,R=R+Math.imul(Me,Qt)|0,_=_+Math.imul(Me,Jt)|0,_=_+Math.imul(ge,Qt)|0,E=E+Math.imul(ge,Jt)|0,R=R+Math.imul(xe,es)|0,_=_+Math.imul(xe,ts)|0,_=_+Math.imul(Ae,es)|0,E=E+Math.imul(Ae,ts)|0;var $h=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+($h>>>26)|0,$h&=67108863,R=Math.imul(Ze,gt),_=Math.imul(Ze,Vt),_=_+Math.imul(De,gt)|0,E=Math.imul(De,Vt),R=R+Math.imul(ve,Et)|0,_=_+Math.imul(ve,yt)|0,_=_+Math.imul(Ue,Et)|0,E=E+Math.imul(Ue,yt)|0,R=R+Math.imul(le,qt)|0,_=_+Math.imul(le,wt)|0,_=_+Math.imul(Te,qt)|0,E=E+Math.imul(Te,wt)|0,R=R+Math.imul(X,bt)|0,_=_+Math.imul(X,Fe)|0,_=_+Math.imul(J,bt)|0,E=E+Math.imul(J,Fe)|0,R=R+Math.imul(M,kt)|0,_=_+Math.imul(M,Lt)|0,_=_+Math.imul(F,kt)|0,E=E+Math.imul(F,Lt)|0,R=R+Math.imul(z,Qt)|0,_=_+Math.imul(z,Jt)|0,_=_+Math.imul(V,Qt)|0,E=E+Math.imul(V,Jt)|0,R=R+Math.imul(Me,es)|0,_=_+Math.imul(Me,ts)|0,_=_+Math.imul(ge,es)|0,E=E+Math.imul(ge,ts)|0;var Wh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Wh>>>26)|0,Wh&=67108863,R=Math.imul(Ze,Et),_=Math.imul(Ze,yt),_=_+Math.imul(De,Et)|0,E=Math.imul(De,yt),R=R+Math.imul(ve,qt)|0,_=_+Math.imul(ve,wt)|0,_=_+Math.imul(Ue,qt)|0,E=E+Math.imul(Ue,wt)|0,R=R+Math.imul(le,bt)|0,_=_+Math.imul(le,Fe)|0,_=_+Math.imul(Te,bt)|0,E=E+Math.imul(Te,Fe)|0,R=R+Math.imul(X,kt)|0,_=_+Math.imul(X,Lt)|0,_=_+Math.imul(J,kt)|0,E=E+Math.imul(J,Lt)|0,R=R+Math.imul(M,Qt)|0,_=_+Math.imul(M,Jt)|0,_=_+Math.imul(F,Qt)|0,E=E+Math.imul(F,Jt)|0,R=R+Math.imul(z,es)|0,_=_+Math.imul(z,ts)|0,_=_+Math.imul(V,es)|0,E=E+Math.imul(V,ts)|0;var zh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(zh>>>26)|0,zh&=67108863,R=Math.imul(Ze,qt),_=Math.imul(Ze,wt),_=_+Math.imul(De,qt)|0,E=Math.imul(De,wt),R=R+Math.imul(ve,bt)|0,_=_+Math.imul(ve,Fe)|0,_=_+Math.imul(Ue,bt)|0,E=E+Math.imul(Ue,Fe)|0,R=R+Math.imul(le,kt)|0,_=_+Math.imul(le,Lt)|0,_=_+Math.imul(Te,kt)|0,E=E+Math.imul(Te,Lt)|0,R=R+Math.imul(X,Qt)|0,_=_+Math.imul(X,Jt)|0,_=_+Math.imul(J,Qt)|0,E=E+Math.imul(J,Jt)|0,R=R+Math.imul(M,es)|0,_=_+Math.imul(M,ts)|0,_=_+Math.imul(F,es)|0,E=E+Math.imul(F,ts)|0;var jh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(jh>>>26)|0,jh&=67108863,R=Math.imul(Ze,bt),_=Math.imul(Ze,Fe),_=_+Math.imul(De,bt)|0,E=Math.imul(De,Fe),R=R+Math.imul(ve,kt)|0,_=_+Math.imul(ve,Lt)|0,_=_+Math.imul(Ue,kt)|0,E=E+Math.imul(Ue,Lt)|0,R=R+Math.imul(le,Qt)|0,_=_+Math.imul(le,Jt)|0,_=_+Math.imul(Te,Qt)|0,E=E+Math.imul(Te,Jt)|0,R=R+Math.imul(X,es)|0,_=_+Math.imul(X,ts)|0,_=_+Math.imul(J,es)|0,E=E+Math.imul(J,ts)|0;var Kh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Kh>>>26)|0,Kh&=67108863,R=Math.imul(Ze,kt),_=Math.imul(Ze,Lt),_=_+Math.imul(De,kt)|0,E=Math.imul(De,Lt),R=R+Math.imul(ve,Qt)|0,_=_+Math.imul(ve,Jt)|0,_=_+Math.imul(Ue,Qt)|0,E=E+Math.imul(Ue,Jt)|0,R=R+Math.imul(le,es)|0,_=_+Math.imul(le,ts)|0,_=_+Math.imul(Te,es)|0,E=E+Math.imul(Te,ts)|0;var Xh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Xh>>>26)|0,Xh&=67108863,R=Math.imul(Ze,Qt),_=Math.imul(Ze,Jt),_=_+Math.imul(De,Qt)|0,E=Math.imul(De,Jt),R=R+Math.imul(ve,es)|0,_=_+Math.imul(ve,ts)|0,_=_+Math.imul(Ue,es)|0,E=E+Math.imul(Ue,ts)|0;var Yh=(H+R|0)+((_&8191)<<13)|0;H=(E+(_>>>13)|0)+(Yh>>>26)|0,Yh&=67108863,R=Math.imul(Ze,es),_=Math.imul(Ze,ts),_=_+Math.imul(De,es)|0,E=Math.imul(De,ts);var Zh=(H+R|0)+((_&8191)<<13)|0;return H=(E+(_>>>13)|0)+(Zh>>>26)|0,Zh&=67108863,D[0]=Nh,D[1]=Vh,D[2]=Eh,D[3]=qh,D[4]=Lh,D[5]=Rh,D[6]=Dh,D[7]=Fh,D[8]=Hh,D[9]=Gh,D[10]=Uh,D[11]=$h,D[12]=Wh,D[13]=zh,D[14]=jh,D[15]=Kh,D[16]=Xh,D[17]=Yh,D[18]=Zh,H!==0&&(D[19]=H,P.length++),P};Math.imul||(g=m);function y(x,k,O){O.negative=k.negative^x.negative,O.length=x.length+k.length;for(var P=0,q=0,L=0;L<O.length-1;L++){var D=q;q=0;for(var H=P&67108863,R=Math.min(L,k.length-1),_=Math.max(0,L-x.length+1);_<=R;_++){var E=L-_,U=x.words[E]|0,G=k.words[_]|0,$=U*G,Z=$&67108863;D=D+($/67108864|0)|0,Z=Z+H|0,H=Z&67108863,D=D+(Z>>>26)|0,q+=D>>>26,D&=67108863}O.words[L]=H,P=D,D=q}return P!==0?O.words[L]=P:O.length--,O._strip()}function w(x,k,O){return y(x,k,O)}n.prototype.mulTo=function(k,O){var P,q=this.length+k.length;return this.length===10&&k.length===10?P=g(this,k,O):q<63?P=m(this,k,O):q<1024?P=y(this,k,O):P=w(this,k,O),P},n.prototype.mul=function(k){var O=new n(null);return O.words=new Array(this.length+k.length),this.mulTo(k,O)},n.prototype.mulf=function(k){var O=new n(null);return O.words=new Array(this.length+k.length),w(this,k,O)},n.prototype.imul=function(k){return this.clone().mulTo(k,this)},n.prototype.imuln=function(k){var O=k<0;O&&(k=-k),s(typeof k=="number"),s(k<67108864);for(var P=0,q=0;q<this.length;q++){var L=(this.words[q]|0)*k,D=(L&67108863)+(P&67108863);P>>=26,P+=L/67108864|0,P+=D>>>26,this.words[q]=D&67108863}return P!==0&&(this.words[q]=P,this.length++),O?this.ineg():this},n.prototype.muln=function(k){return this.clone().imuln(k)},n.prototype.sqr=function(){return this.mul(this)},n.prototype.isqr=function(){return this.imul(this.clone())},n.prototype.pow=function(k){var O=l(k);if(O.length===0)return new n(1);for(var P=this,q=0;q<O.length&&O[q]===0;q++,P=P.sqr());if(++q<O.length)for(var L=P.sqr();q<O.length;q++,L=L.sqr())O[q]!==0&&(P=P.mul(L));return P},n.prototype.iushln=function(k){s(typeof k=="number"&&k>=0);var O=k%26,P=(k-O)/26,q=67108863>>>26-O<<26-O,L;if(O!==0){var D=0;for(L=0;L<this.length;L++){var H=this.words[L]&q,R=(this.words[L]|0)-H<<O;this.words[L]=R|D,D=H>>>26-O}D&&(this.words[L]=D,this.length++)}if(P!==0){for(L=this.length-1;L>=0;L--)this.words[L+P]=this.words[L];for(L=0;L<P;L++)this.words[L]=0;this.length+=P}return this._strip()},n.prototype.ishln=function(k){return s(this.negative===0),this.iushln(k)},n.prototype.iushrn=function(k,O,P){s(typeof k=="number"&&k>=0);var q;O?q=(O-O%26)/26:q=0;var L=k%26,D=Math.min((k-L)/26,this.length),H=67108863^67108863>>>L<<L,R=P;if(q-=D,q=Math.max(0,q),R){for(var _=0;_<D;_++)R.words[_]=this.words[_];R.length=D}if(D!==0)if(this.length>D)for(this.length-=D,_=0;_<this.length;_++)this.words[_]=this.words[_+D];else this.words[0]=0,this.length=1;var E=0;for(_=this.length-1;_>=0&&(E!==0||_>=q);_--){var U=this.words[_]|0;this.words[_]=E<<26-L|U>>>L,E=U&H}return R&&E!==0&&(R.words[R.length++]=E),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},n.prototype.ishrn=function(k,O,P){return s(this.negative===0),this.iushrn(k,O,P)},n.prototype.shln=function(k){return this.clone().ishln(k)},n.prototype.ushln=function(k){return this.clone().iushln(k)},n.prototype.shrn=function(k){return this.clone().ishrn(k)},n.prototype.ushrn=function(k){return this.clone().iushrn(k)},n.prototype.testn=function(k){s(typeof k=="number"&&k>=0);var O=k%26,P=(k-O)/26,q=1<<O;if(this.length<=P)return!1;var L=this.words[P];return!!(L&q)},n.prototype.imaskn=function(k){s(typeof k=="number"&&k>=0);var O=k%26,P=(k-O)/26;if(s(this.negative===0,"imaskn works only with positive numbers"),this.length<=P)return this;if(O!==0&&P++,this.length=Math.min(P,this.length),O!==0){var q=67108863^67108863>>>O<<O;this.words[this.length-1]&=q}return this._strip()},n.prototype.maskn=function(k){return this.clone().imaskn(k)},n.prototype.iaddn=function(k){return s(typeof k=="number"),s(k<67108864),k<0?this.isubn(-k):this.negative!==0?this.length===1&&(this.words[0]|0)<=k?(this.words[0]=k-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(k),this.negative=1,this):this._iaddn(k)},n.prototype._iaddn=function(k){this.words[0]+=k;for(var O=0;O<this.length&&this.words[O]>=67108864;O++)this.words[O]-=67108864,O===this.length-1?this.words[O+1]=1:this.words[O+1]++;return this.length=Math.max(this.length,O+1),this},n.prototype.isubn=function(k){if(s(typeof k=="number"),s(k<67108864),k<0)return this.iaddn(-k);if(this.negative!==0)return this.negative=0,this.iaddn(k),this.negative=1,this;if(this.words[0]-=k,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var O=0;O<this.length&&this.words[O]<0;O++)this.words[O]+=67108864,this.words[O+1]-=1;return this._strip()},n.prototype.addn=function(k){return this.clone().iaddn(k)},n.prototype.subn=function(k){return this.clone().isubn(k)},n.prototype.iabs=function(){return this.negative=0,this},n.prototype.abs=function(){return this.clone().iabs()},n.prototype._ishlnsubmul=function(k,O,P){var q=k.length+P,L;this._expand(q);var D,H=0;for(L=0;L<k.length;L++){D=(this.words[L+P]|0)+H;var R=(k.words[L]|0)*O;D-=R&67108863,H=(D>>26)-(R/67108864|0),this.words[L+P]=D&67108863}for(;L<this.length-P;L++)D=(this.words[L+P]|0)+H,H=D>>26,this.words[L+P]=D&67108863;if(H===0)return this._strip();for(s(H===-1),H=0,L=0;L<this.length;L++)D=-(this.words[L]|0)+H,H=D>>26,this.words[L]=D&67108863;return this.negative=1,this._strip()},n.prototype._wordDiv=function(k,O){var P=this.length-k.length,q=this.clone(),L=k,D=L.words[L.length-1]|0,H=this._countBits(D);P=26-H,P!==0&&(L=L.ushln(P),q.iushln(P),D=L.words[L.length-1]|0);var R=q.length-L.length,_;if(O!=="mod"){_=new n(null),_.length=R+1,_.words=new Array(_.length);for(var E=0;E<_.length;E++)_.words[E]=0}var U=q.clone()._ishlnsubmul(L,1,R);U.negative===0&&(q=U,_&&(_.words[R]=1));for(var G=R-1;G>=0;G--){var $=(q.words[L.length+G]|0)*67108864+(q.words[L.length+G-1]|0);for($=Math.min($/D|0,67108863),q._ishlnsubmul(L,$,G);q.negative!==0;)$--,q.negative=0,q._ishlnsubmul(L,1,G),q.isZero()||(q.negative^=1);_&&(_.words[G]=$)}return _&&_._strip(),q._strip(),O!=="div"&&P!==0&&q.iushrn(P),{div:_||null,mod:q}},n.prototype.divmod=function(k,O,P){if(s(!k.isZero()),this.isZero())return{div:new n(0),mod:new n(0)};var q,L,D;return this.negative!==0&&k.negative===0?(D=this.neg().divmod(k,O),O!=="mod"&&(q=D.div.neg()),O!=="div"&&(L=D.mod.neg(),P&&L.negative!==0&&L.iadd(k)),{div:q,mod:L}):this.negative===0&&k.negative!==0?(D=this.divmod(k.neg(),O),O!=="mod"&&(q=D.div.neg()),{div:q,mod:D.mod}):(this.negative&k.negative)!==0?(D=this.neg().divmod(k.neg(),O),O!=="div"&&(L=D.mod.neg(),P&&L.negative!==0&&L.isub(k)),{div:D.div,mod:L}):k.length>this.length||this.cmp(k)<0?{div:new n(0),mod:this}:k.length===1?O==="div"?{div:this.divn(k.words[0]),mod:null}:O==="mod"?{div:null,mod:new n(this.modrn(k.words[0]))}:{div:this.divn(k.words[0]),mod:new n(this.modrn(k.words[0]))}:this._wordDiv(k,O)},n.prototype.div=function(k){return this.divmod(k,"div",!1).div},n.prototype.mod=function(k){return this.divmod(k,"mod",!1).mod},n.prototype.umod=function(k){return this.divmod(k,"mod",!0).mod},n.prototype.divRound=function(k){var O=this.divmod(k);if(O.mod.isZero())return O.div;var P=O.div.negative!==0?O.mod.isub(k):O.mod,q=k.ushrn(1),L=k.andln(1),D=P.cmp(q);return D<0||L===1&&D===0?O.div:O.div.negative!==0?O.div.isubn(1):O.div.iaddn(1)},n.prototype.modrn=function(k){var O=k<0;O&&(k=-k),s(k<=67108863);for(var P=(1<<26)%k,q=0,L=this.length-1;L>=0;L--)q=(P*q+(this.words[L]|0))%k;return O?-q:q},n.prototype.modn=function(k){return this.modrn(k)},n.prototype.idivn=function(k){var O=k<0;O&&(k=-k),s(k<=67108863);for(var P=0,q=this.length-1;q>=0;q--){var L=(this.words[q]|0)+P*67108864;this.words[q]=L/k|0,P=L%k}return this._strip(),O?this.ineg():this},n.prototype.divn=function(k){return this.clone().idivn(k)},n.prototype.egcd=function(k){s(k.negative===0),s(!k.isZero());var O=this,P=k.clone();O.negative!==0?O=O.umod(k):O=O.clone();for(var q=new n(1),L=new n(0),D=new n(0),H=new n(1),R=0;O.isEven()&&P.isEven();)O.iushrn(1),P.iushrn(1),++R;for(var _=P.clone(),E=O.clone();!O.isZero();){for(var U=0,G=1;(O.words[0]&G)===0&&U<26;++U,G<<=1);if(U>0)for(O.iushrn(U);U-- >0;)(q.isOdd()||L.isOdd())&&(q.iadd(_),L.isub(E)),q.iushrn(1),L.iushrn(1);for(var $=0,Z=1;(P.words[0]&Z)===0&&$<26;++$,Z<<=1);if($>0)for(P.iushrn($);$-- >0;)(D.isOdd()||H.isOdd())&&(D.iadd(_),H.isub(E)),D.iushrn(1),H.iushrn(1);O.cmp(P)>=0?(O.isub(P),q.isub(D),L.isub(H)):(P.isub(O),D.isub(q),H.isub(L))}return{a:D,b:H,gcd:P.iushln(R)}},n.prototype._invmp=function(k){s(k.negative===0),s(!k.isZero());var O=this,P=k.clone();O.negative!==0?O=O.umod(k):O=O.clone();for(var q=new n(1),L=new n(0),D=P.clone();O.cmpn(1)>0&&P.cmpn(1)>0;){for(var H=0,R=1;(O.words[0]&R)===0&&H<26;++H,R<<=1);if(H>0)for(O.iushrn(H);H-- >0;)q.isOdd()&&q.iadd(D),q.iushrn(1);for(var _=0,E=1;(P.words[0]&E)===0&&_<26;++_,E<<=1);if(_>0)for(P.iushrn(_);_-- >0;)L.isOdd()&&L.iadd(D),L.iushrn(1);O.cmp(P)>=0?(O.isub(P),q.isub(L)):(P.isub(O),L.isub(q))}var U;return O.cmpn(1)===0?U=q:U=L,U.cmpn(0)<0&&U.iadd(k),U},n.prototype.gcd=function(k){if(this.isZero())return k.abs();if(k.isZero())return this.abs();var O=this.clone(),P=k.clone();O.negative=0,P.negative=0;for(var q=0;O.isEven()&&P.isEven();q++)O.iushrn(1),P.iushrn(1);do{for(;O.isEven();)O.iushrn(1);for(;P.isEven();)P.iushrn(1);var L=O.cmp(P);if(L<0){var D=O;O=P,P=D}else if(L===0||P.cmpn(1)===0)break;O.isub(P)}while(!0);return P.iushln(q)},n.prototype.invm=function(k){return this.egcd(k).a.umod(k)},n.prototype.isEven=function(){return(this.words[0]&1)===0},n.prototype.isOdd=function(){return(this.words[0]&1)===1},n.prototype.andln=function(k){return this.words[0]&k},n.prototype.bincn=function(k){s(typeof k=="number");var O=k%26,P=(k-O)/26,q=1<<O;if(this.length<=P)return this._expand(P+1),this.words[P]|=q,this;for(var L=q,D=P;L!==0&&D<this.length;D++){var H=this.words[D]|0;H+=L,L=H>>>26,H&=67108863,this.words[D]=H}return L!==0&&(this.words[D]=L,this.length++),this},n.prototype.isZero=function(){return this.length===1&&this.words[0]===0},n.prototype.cmpn=function(k){var O=k<0;if(this.negative!==0&&!O)return-1;if(this.negative===0&&O)return 1;this._strip();var P;if(this.length>1)P=1;else{O&&(k=-k),s(k<=67108863,"Number is too big");var q=this.words[0]|0;P=q===k?0:q<k?-1:1}return this.negative!==0?-P|0:P},n.prototype.cmp=function(k){if(this.negative!==0&&k.negative===0)return-1;if(this.negative===0&&k.negative!==0)return 1;var O=this.ucmp(k);return this.negative!==0?-O|0:O},n.prototype.ucmp=function(k){if(this.length>k.length)return 1;if(this.length<k.length)return-1;for(var O=0,P=this.length-1;P>=0;P--){var q=this.words[P]|0,L=k.words[P]|0;if(q!==L){q<L?O=-1:q>L&&(O=1);break}}return O},n.prototype.gtn=function(k){return this.cmpn(k)===1},n.prototype.gt=function(k){return this.cmp(k)===1},n.prototype.gten=function(k){return this.cmpn(k)>=0},n.prototype.gte=function(k){return this.cmp(k)>=0},n.prototype.ltn=function(k){return this.cmpn(k)===-1},n.prototype.lt=function(k){return this.cmp(k)===-1},n.prototype.lten=function(k){return this.cmpn(k)<=0},n.prototype.lte=function(k){return this.cmp(k)<=0},n.prototype.eqn=function(k){return this.cmpn(k)===0},n.prototype.eq=function(k){return this.cmp(k)===0},n.red=function(k){return new N(k)},n.prototype.toRed=function(k){return s(!this.red,"Already a number in reduction context"),s(this.negative===0,"red works only with positives"),k.convertTo(this)._forceRed(k)},n.prototype.fromRed=function(){return s(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},n.prototype._forceRed=function(k){return this.red=k,this},n.prototype.forceRed=function(k){return s(!this.red,"Already a number in reduction context"),this._forceRed(k)},n.prototype.redAdd=function(k){return s(this.red,"redAdd works only with red numbers"),this.red.add(this,k)},n.prototype.redIAdd=function(k){return s(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,k)},n.prototype.redSub=function(k){return s(this.red,"redSub works only with red numbers"),this.red.sub(this,k)},n.prototype.redISub=function(k){return s(this.red,"redISub works only with red numbers"),this.red.isub(this,k)},n.prototype.redShl=function(k){return s(this.red,"redShl works only with red numbers"),this.red.shl(this,k)},n.prototype.redMul=function(k){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,k),this.red.mul(this,k)},n.prototype.redIMul=function(k){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,k),this.red.imul(this,k)},n.prototype.redSqr=function(){return s(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},n.prototype.redISqr=function(){return s(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},n.prototype.redSqrt=function(){return s(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},n.prototype.redInvm=function(){return s(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},n.prototype.redNeg=function(){return s(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},n.prototype.redPow=function(k){return s(this.red&&!k.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,k)};var b={k256:null,p224:null,p192:null,p25519:null};function S(x,k){this.name=x,this.p=new n(k,16),this.n=this.p.bitLength(),this.k=new n(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}S.prototype._tmp=function(){var k=new n(null);return k.words=new Array(Math.ceil(this.n/13)),k},S.prototype.ireduce=function(k){var O=k,P;do this.split(O,this.tmp),O=this.imulK(O),O=O.iadd(this.tmp),P=O.bitLength();while(P>this.n);var q=P<this.n?-1:O.ucmp(this.p);return q===0?(O.words[0]=0,O.length=1):q>0?O.isub(this.p):O._strip(),O},S.prototype.split=function(k,O){k.iushrn(this.n,0,O)},S.prototype.imulK=function(k){return k.imul(this.k)};function v(){S.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}i(v,S),v.prototype.split=function(k,O){for(var P=4194303,q=Math.min(k.length,9),L=0;L<q;L++)O.words[L]=k.words[L];if(O.length=q,k.length<=9){k.words[0]=0,k.length=1;return}var D=k.words[9];for(O.words[O.length++]=D&P,L=10;L<k.length;L++){var H=k.words[L]|0;k.words[L-10]=(H&P)<<4|D>>>22,D=H}D>>>=22,k.words[L-10]=D,D===0&&k.length>10?k.length-=10:k.length-=9},v.prototype.imulK=function(k){k.words[k.length]=0,k.words[k.length+1]=0,k.length+=2;for(var O=0,P=0;P<k.length;P++){var q=k.words[P]|0;O+=q*977,k.words[P]=O&67108863,O=q*64+(O/67108864|0)}return k.words[k.length-1]===0&&(k.length--,k.words[k.length-1]===0&&k.length--),k};function T(){S.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}i(T,S);function I(){S.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}i(I,S);function A(){S.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}i(A,S),A.prototype.imulK=function(k){for(var O=0,P=0;P<k.length;P++){var q=(k.words[P]|0)*19+O,L=q&67108863;q>>>=26,k.words[P]=L,O=q}return O!==0&&(k.words[k.length++]=O),k},n._prime=function(k){if(b[k])return b[k];var O;if(k==="k256")O=new v;else if(k==="p224")O=new T;else if(k==="p192")O=new I;else if(k==="p25519")O=new A;else throw new Error("Unknown prime "+k);return b[k]=O,O};function N(x){if(typeof x=="string"){var k=n._prime(x);this.m=k.p,this.prime=k}else s(x.gtn(1),"modulus must be greater than 1"),this.m=x,this.prime=null}N.prototype._verify1=function(k){s(k.negative===0,"red works only with positives"),s(k.red,"red works only with red numbers")},N.prototype._verify2=function(k,O){s((k.negative|O.negative)===0,"red works only with positives"),s(k.red&&k.red===O.red,"red works only with red numbers")},N.prototype.imod=function(k){return this.prime?this.prime.ireduce(k)._forceRed(this):(k.umod(this.m)._forceRed(this)._move(k),k)},N.prototype.neg=function(k){return k.isZero()?k.clone():this.m.sub(k)._forceRed(this)},N.prototype.add=function(k,O){this._verify2(k,O);var P=k.add(O);return P.cmp(this.m)>=0&&P.isub(this.m),P._forceRed(this)},N.prototype.iadd=function(k,O){this._verify2(k,O);var P=k.iadd(O);return P.cmp(this.m)>=0&&P.isub(this.m),P},N.prototype.sub=function(k,O){this._verify2(k,O);var P=k.sub(O);return P.cmpn(0)<0&&P.iadd(this.m),P._forceRed(this)},N.prototype.isub=function(k,O){this._verify2(k,O);var P=k.isub(O);return P.cmpn(0)<0&&P.iadd(this.m),P},N.prototype.shl=function(k,O){return this._verify1(k),this.imod(k.ushln(O))},N.prototype.imul=function(k,O){return this._verify2(k,O),this.imod(k.imul(O))},N.prototype.mul=function(k,O){return this._verify2(k,O),this.imod(k.mul(O))},N.prototype.isqr=function(k){return this.imul(k,k.clone())},N.prototype.sqr=function(k){return this.mul(k,k)},N.prototype.sqrt=function(k){if(k.isZero())return k.clone();var O=this.m.andln(3);if(s(O%2===1),O===3){var P=this.m.add(new n(1)).iushrn(2);return this.pow(k,P)}for(var q=this.m.subn(1),L=0;!q.isZero()&&q.andln(1)===0;)L++,q.iushrn(1);s(!q.isZero());var D=new n(1).toRed(this),H=D.redNeg(),R=this.m.subn(1).iushrn(1),_=this.m.bitLength();for(_=new n(2*_*_).toRed(this);this.pow(_,R).cmp(H)!==0;)_.redIAdd(H);for(var E=this.pow(_,q),U=this.pow(k,q.addn(1).iushrn(1)),G=this.pow(k,q),$=L;G.cmp(D)!==0;){for(var Z=G,he=0;Z.cmp(D)!==0;he++)Z=Z.redSqr();s(he<$);var me=this.pow(E,new n(1).iushln($-he-1));U=U.redMul(me),E=me.redSqr(),G=G.redMul(E),$=he}return U},N.prototype.invm=function(k){var O=k._invmp(this.m);return O.negative!==0?(O.negative=0,this.imod(O).redNeg()):this.imod(O)},N.prototype.pow=function(k,O){if(O.isZero())return new n(1).toRed(this);if(O.cmpn(1)===0)return k.clone();var P=4,q=new Array(1<<P);q[0]=new n(1).toRed(this),q[1]=k;for(var L=2;L<q.length;L++)q[L]=this.mul(q[L-1],k);var D=q[0],H=0,R=0,_=O.bitLength()%26;for(_===0&&(_=26),L=O.length-1;L>=0;L--){for(var E=O.words[L],U=_-1;U>=0;U--){var G=E>>U&1;if(D!==q[0]&&(D=this.sqr(D)),G===0&&H===0){R=0;continue}H<<=1,H|=G,R++,!(R!==P&&(L!==0||U!==0))&&(D=this.mul(D,q[H]),R=0,H=0)}_=26}return D},N.prototype.convertTo=function(k){var O=k.umod(this.m);return O===k?O.clone():O},N.prototype.convertFrom=function(k){var O=k.clone();return O.red=null,O},n.mont=function(k){return new B(k)};function B(x){N.call(this,x),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new n(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}i(B,N),B.prototype.convertTo=function(k){return this.imod(k.ushln(this.shift))},B.prototype.convertFrom=function(k){var O=this.imod(k.mul(this.rinv));return O.red=null,O},B.prototype.imul=function(k,O){if(k.isZero()||O.isZero())return k.words[0]=0,k.length=1,k;var P=k.imul(O),q=P.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),L=P.isub(q).iushrn(this.shift),D=L;return L.cmp(this.m)>=0?D=L.isub(this.m):L.cmpn(0)<0&&(D=L.iadd(this.m)),D._forceRed(this)},B.prototype.mul=function(k,O){if(k.isZero()||O.isZero())return new n(0)._forceRed(this);var P=k.mul(O),q=P.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),L=P.isub(q).iushrn(this.shift),D=L;return L.cmp(this.m)>=0?D=L.isub(this.m):L.cmpn(0)<0&&(D=L.iadd(this.m)),D._forceRed(this)},B.prototype.invm=function(k){var O=this.imod(k._invmp(this.m).mul(this.r2));return O._forceRed(this)}})(p,Yu)})(mi);(function(p){const e=co.exports,t=iM,s=mi.exports,i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let n=null,r=null;p.exports={json:(o,d=void 0)=>JSON.stringify(o),isJsonEncodedObject:o=>typeof o=="string"&&o.length>=2&&(o[0]==="{"||o[0]==="["),stringToBinary:o=>e.enc.Latin1.parse(o),stringToBase64:o=>e.enc.Latin1.parse(o).toString(e.enc.Base64),base64ToBinary:o=>e.enc.Base64.parse(o),base64ToString:o=>e.enc.Base64.parse(o).toString(e.enc.Utf8),binaryToBase64:o=>o.toString(e.enc.Base64),base16ToBinary:o=>e.enc.Hex.parse(o),binaryToBase16:o=>o.toString(e.enc.Hex),binaryConcat:(...o)=>o.reduce((d,c)=>d.concat(c)),binaryConcatArray:o=>o.reduce((d,c)=>d.concat(c)),urlencode:o=>t.stringify(o),urlencodeNested:o=>t.stringify(o),urlencodeWithArrayRepeat:o=>t.stringify(o,{arrayFormat:"repeat"}),rawencode:o=>t.stringify(o,{encode:!1}),encode:o=>o,decode:o=>o,urlencodeBase64:o=>o.replace(/[=]+$/,"").replace(/\+/g,"-").replace(/\//g,"_"),numberToLE:(o,d)=>{const c=new s(o).toArray("le",d);return a(c)},numberToBE:(o,d)=>{const c=new s(o).toArray("be",d);return a(c)},base58ToBinary:o=>{if(!n){n={},r={};for(let u=0;u<58;u++){const h=i[u],f=new s(u);n[h]=f,r[f]=h}}let d=new s(0);const c=new s(58);for(let u=0;u<o.length;u++){const h=o[u];d.imul(c),d.iadd(n[h])}return a(d.toArray("be"))},binaryToBase58:o=>{if(!r){n={},r={};for(let f=0;f<58;f++){const l=i[f],m=new s(f);n[l]=m,r[m]=l}}const d=new s(58),c=o.toString(e.enc.Hex);let u=new s(c,16),h=[];for(;!u.isZero();){const{div:f,mod:l}=u.divmod(d);u=f,h.push(r[l])}return h.reverse().join("")}};function a(o){const d=[];for(let c=0;c<o.length;c++)d[c/4|0]|=o[c]<<24-8*c;return e.lib.WordArray.create(d,o.length)}p.exports.byteArrayToWordArray=a})(oo);var av={},ri={};ri.linebrk=function(p,e){for(var t="",s=0;s+e<p.length;)t+=p.substring(s,s+e)+`
`,s+=e;return t+p.substring(s,p.length)};ri.get32IntFromBuffer=function(p,e){e=e||0;var t=0;if((t=p.length-e)>0){if(t>=4)return p.readUInt32BE(e);for(var s=0,i=e+t,n=0;i>e;i--,n+=2)s+=p[i-1]*Math.pow(16,n);return s}else return NaN};ri._={isObject:function(p){var e=typeof p;return!!p&&(e=="object"||e=="function")},isString:function(p){return typeof p=="string"||p instanceof String},isNumber:function(p){return typeof p=="number"||!isNaN(parseFloat(p))&&isFinite(p)},omit:function(p,e){var t={};for(var s in p)!p.hasOwnProperty(s)||s===e||(t[s]=p[s]);return t}};ri.trimSurroundingText=function(p,e,t){var s=0,i=p.length,n=p.indexOf(e);n>=0&&(s=n+e.length);var r=p.indexOf(t,n);return r>=0&&(i=r),p.substring(s,i)};var nM=ri._,uo;function pe(p,e){p!=null&&(typeof p=="number"?this.fromNumber(p,e):Buffer.isBuffer(p)?this.fromBuffer(p):e==null&&typeof p!="string"?this.fromByteArray(p):this.fromString(p,e))}function tt(){return new pe(null)}function rM(p,e,t,s,i,n){for(var r=e&16383,a=e>>14;--n>=0;){var o=this[p]&16383,d=this[p++]>>14,c=a*o+d*r;o=r*o+((c&16383)<<14)+t[s]+i,i=(o>>28)+(c>>14)+a*d,t[s++]=o&268435455}return i}pe.prototype.am=rM;uo=28;pe.prototype.DB=uo;pe.prototype.DM=(1<<uo)-1;pe.prototype.DV=1<<uo;var Xm=52;pe.prototype.FV=Math.pow(2,Xm);pe.prototype.F1=Xm-uo;pe.prototype.F2=2*uo-Xm;var aM="0123456789abcdefghijklmnopqrstuvwxyz",yh=new Array,ho,Pi;ho="0".charCodeAt(0);for(Pi=0;Pi<=9;++Pi)yh[ho++]=Pi;ho="a".charCodeAt(0);for(Pi=10;Pi<36;++Pi)yh[ho++]=Pi;ho="A".charCodeAt(0);for(Pi=10;Pi<36;++Pi)yh[ho++]=Pi;function Sm(p){return aM.charAt(p)}function ov(p,e){var t=yh[p.charCodeAt(e)];return t==null?-1:t}function oM(p){for(var e=this.t-1;e>=0;--e)p[e]=this[e];p.t=this.t,p.s=this.s}function dM(p){this.t=1,this.s=p<0?-1:0,p>0?this[0]=p:p<-1?this[0]=p+DV:this.t=0}function wh(p){var e=tt();return e.fromInt(p),e}function cM(p,e,t){var s;switch(e){case 2:s=1;break;case 4:s=2;break;case 8:s=3;break;case 16:s=4;break;case 32:s=5;break;case 256:s=8;break;default:this.fromRadix(p,e);return}this.t=0,this.s=0;for(var i=p.length,n=!1,r=0;--i>=0;){var a=s==8?p[i]&255:ov(p,i);if(a<0){p.charAt(i)=="-"&&(n=!0);continue}n=!1,r===0?this[this.t++]=a:r+s>this.DB?(this[this.t-1]|=(a&(1<<this.DB-r)-1)<<r,this[this.t++]=a>>this.DB-r):this[this.t-1]|=a<<r,r+=s,r>=this.DB&&(r-=this.DB)}!t&&s==8&&(p[0]&128)!=0&&(this.s=-1,r>0&&(this[this.t-1]|=(1<<this.DB-r)-1<<r)),this.clamp(),n&&pe.ZERO.subTo(this,this)}function uM(p,e){this.fromString(p,256,e)}function hM(p){this.fromString(p,256,!0)}function fM(){for(var p=this.s&this.DM;this.t>0&&this[this.t-1]==p;)--this.t}function lM(p){if(this.s<0)return"-"+this.negate().toString(p);var e;if(p==16)e=4;else if(p==8)e=3;else if(p==2)e=1;else if(p==32)e=5;else if(p==4)e=2;else return this.toRadix(p);var t=(1<<e)-1,s,i=!1,n="",r=this.t,a=this.DB-r*this.DB%e;if(r-- >0)for(a<this.DB&&(s=this[r]>>a)>0&&(i=!0,n=Sm(s));r>=0;)a<e?(s=(this[r]&(1<<a)-1)<<e-a,s|=this[--r]>>(a+=this.DB-e)):(s=this[r]>>(a-=e)&t,a<=0&&(a+=this.DB,--r)),s>0&&(i=!0),i&&(n+=Sm(s));return i?n:"0"}function pM(){var p=tt();return pe.ZERO.subTo(this,p),p}function mM(){return this.s<0?this.negate():this}function gM(p){var e=this.s-p.s;if(e!=0)return e;var t=this.t;if(e=t-p.t,e!=0)return this.s<0?-e:e;for(;--t>=0;)if((e=this[t]-p[t])!=0)return e;return 0}function bh(p){var e=1,t;return(t=p>>>16)!=0&&(p=t,e+=16),(t=p>>8)!=0&&(p=t,e+=8),(t=p>>4)!=0&&(p=t,e+=4),(t=p>>2)!=0&&(p=t,e+=2),(t=p>>1)!=0&&(p=t,e+=1),e}function yM(){return this.t<=0?0:this.DB*(this.t-1)+bh(this[this.t-1]^this.s&this.DM)}function wM(p,e){var t;for(t=this.t-1;t>=0;--t)e[t+p]=this[t];for(t=p-1;t>=0;--t)e[t]=0;e.t=this.t+p,e.s=this.s}function bM(p,e){for(var t=p;t<this.t;++t)e[t-p]=this[t];e.t=Math.max(this.t-p,0),e.s=this.s}function kM(p,e){var t=p%this.DB,s=this.DB-t,i=(1<<s)-1,n=Math.floor(p/this.DB),r=this.s<<t&this.DM,a;for(a=this.t-1;a>=0;--a)e[a+n+1]=this[a]>>s|r,r=(this[a]&i)<<t;for(a=n-1;a>=0;--a)e[a]=0;e[n]=r,e.t=this.t+n+1,e.s=this.s,e.clamp()}function SM(p,e){e.s=this.s;var t=Math.floor(p/this.DB);if(t>=this.t){e.t=0;return}var s=p%this.DB,i=this.DB-s,n=(1<<s)-1;e[0]=this[t]>>s;for(var r=t+1;r<this.t;++r)e[r-t-1]|=(this[r]&n)<<i,e[r-t]=this[r]>>s;s>0&&(e[this.t-t-1]|=(this.s&n)<<i),e.t=this.t-t,e.clamp()}function vM(p,e){for(var t=0,s=0,i=Math.min(p.t,this.t);t<i;)s+=this[t]-p[t],e[t++]=s&this.DM,s>>=this.DB;if(p.t<this.t){for(s-=p.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<p.t;)s-=p[t],e[t++]=s&this.DM,s>>=this.DB;s-=p.s}e.s=s<0?-1:0,s<-1?e[t++]=this.DV+s:s>0&&(e[t++]=s),e.t=t,e.clamp()}function TM(p,e){var t=this.abs(),s=p.abs(),i=t.t;for(e.t=i+s.t;--i>=0;)e[i]=0;for(i=0;i<s.t;++i)e[i+t.t]=t.am(0,s[i],e,i,0,t.t);e.s=0,e.clamp(),this.s!=p.s&&pe.ZERO.subTo(e,e)}function OM(p){for(var e=this.abs(),t=p.t=2*e.t;--t>=0;)p[t]=0;for(t=0;t<e.t-1;++t){var s=e.am(t,e[t],p,2*t,0,1);(p[t+e.t]+=e.am(t+1,2*e[t],p,2*t+1,s,e.t-t-1))>=e.DV&&(p[t+e.t]-=e.DV,p[t+e.t+1]=1)}p.t>0&&(p[p.t-1]+=e.am(t,e[t],p,2*t,0,1)),p.s=0,p.clamp()}function IM(p,e,t){var s=p.abs();if(!(s.t<=0)){var i=this.abs();if(i.t<s.t){e!=null&&e.fromInt(0),t!=null&&this.copyTo(t);return}t==null&&(t=tt());var n=tt(),r=this.s,a=p.s,o=this.DB-bh(s[s.t-1]);o>0?(s.lShiftTo(o,n),i.lShiftTo(o,t)):(s.copyTo(n),i.copyTo(t));var d=n.t,c=n[d-1];if(c!==0){var u=c*(1<<this.F1)+(d>1?n[d-2]>>this.F2:0),h=this.FV/u,f=(1<<this.F1)/u,l=1<<this.F2,m=t.t,g=m-d,y=e==null?tt():e;for(n.dlShiftTo(g,y),t.compareTo(y)>=0&&(t[t.t++]=1,t.subTo(y,t)),pe.ONE.dlShiftTo(d,y),y.subTo(n,n);n.t<d;)n[n.t++]=0;for(;--g>=0;){var w=t[--m]==c?this.DM:Math.floor(t[m]*h+(t[m-1]+l)*f);if((t[m]+=n.am(0,w,t,g,0,d))<w)for(n.dlShiftTo(g,y),t.subTo(y,t);t[m]<--w;)t.subTo(y,t)}e!=null&&(t.drShiftTo(d,e),r!=a&&pe.ZERO.subTo(e,e)),t.t=d,t.clamp(),o>0&&t.rShiftTo(o,t),r<0&&pe.ZERO.subTo(t,t)}}}function xM(p){var e=tt();return this.abs().divRemTo(p,null,e),this.s<0&&e.compareTo(pe.ZERO)>0&&p.subTo(e,e),e}function fo(p){this.m=p}function _M(p){return p.s<0||p.compareTo(this.m)>=0?p.mod(this.m):p}function CM(p){return p}function MM(p){p.divRemTo(this.m,null,p)}function PM(p,e,t){p.multiplyTo(e,t),this.reduce(t)}function AM(p,e){p.squareTo(e),this.reduce(e)}fo.prototype.convert=_M;fo.prototype.revert=CM;fo.prototype.reduce=MM;fo.prototype.mulTo=PM;fo.prototype.sqrTo=AM;function BM(){if(this.t<1)return 0;var p=this[0];if((p&1)===0)return 0;var e=p&3;return e=e*(2-(p&15)*e)&15,e=e*(2-(p&255)*e)&255,e=e*(2-((p&65535)*e&65535))&65535,e=e*(2-p*e%this.DV)%this.DV,e>0?this.DV-e:-e}function lo(p){this.m=p,this.mp=p.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<p.DB-15)-1,this.mt2=2*p.t}function NM(p){var e=tt();return p.abs().dlShiftTo(this.m.t,e),e.divRemTo(this.m,null,e),p.s<0&&e.compareTo(pe.ZERO)>0&&this.m.subTo(e,e),e}function VM(p){var e=tt();return p.copyTo(e),this.reduce(e),e}function EM(p){for(;p.t<=this.mt2;)p[p.t++]=0;for(var e=0;e<this.m.t;++e){var t=p[e]&32767,s=t*this.mpl+((t*this.mph+(p[e]>>15)*this.mpl&this.um)<<15)&p.DM;for(t=e+this.m.t,p[t]+=this.m.am(0,s,p,e,0,this.m.t);p[t]>=p.DV;)p[t]-=p.DV,p[++t]++}p.clamp(),p.drShiftTo(this.m.t,p),p.compareTo(this.m)>=0&&p.subTo(this.m,p)}function qM(p,e){p.squareTo(e),this.reduce(e)}function LM(p,e,t){p.multiplyTo(e,t),this.reduce(t)}lo.prototype.convert=NM;lo.prototype.revert=VM;lo.prototype.reduce=EM;lo.prototype.mulTo=LM;lo.prototype.sqrTo=qM;function RM(){return(this.t>0?this[0]&1:this.s)===0}function DM(p,e){if(p>4294967295||p<1)return pe.ONE;var t=tt(),s=tt(),i=e.convert(this),n=bh(p)-1;for(i.copyTo(t);--n>=0;)if(e.sqrTo(t,s),(p&1<<n)>0)e.mulTo(s,i,t);else{var r=t;t=s,s=r}return e.revert(t)}function FM(){var p=tt();return this.copyTo(p),p}function HM(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t===0)return-1}else{if(this.t==1)return this[0];if(this.t===0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function GM(p){return Math.floor(Math.LN2*this.DB/Math.log(p))}function UM(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function $M(p){if(p==null&&(p=10),this.signum()===0||p<2||p>36)return"0";var e=this.chunkSize(p),t=Math.pow(p,e),s=wh(t),i=tt(),n=tt(),r="";for(this.divRemTo(s,i,n);i.signum()>0;)r=(t+n.intValue()).toString(p).substr(1)+r,i.divRemTo(s,i,n);return n.intValue().toString(p)+r}function WM(p,e){this.fromInt(0),e==null&&(e=10);for(var t=this.chunkSize(e),s=Math.pow(e,t),i=!1,n=0,r=0,a=0;a<p.length;++a){var o=ov(p,a);if(o<0){p.charAt(a)=="-"&&this.signum()===0&&(i=!0);continue}r=e*r+o,++n>=t&&(this.dMultiply(s),this.dAddOffset(r,0),n=0,r=0)}n>0&&(this.dMultiply(Math.pow(e,n)),this.dAddOffset(r,0)),i&&pe.ZERO.subTo(this,this)}function zM(){var p=this.t,e=new Array;e[0]=this.s;var t=this.DB-p*this.DB%8,s,i=0;if(p-- >0)for(t<this.DB&&(s=this[p]>>t)!=(this.s&this.DM)>>t&&(e[i++]=s|this.s<<this.DB-t);p>=0;)t<8?(s=(this[p]&(1<<t)-1)<<8-t,s|=this[--p]>>(t+=this.DB-8)):(s=this[p]>>(t-=8)&255,t<=0&&(t+=this.DB,--p)),(s&128)!=0&&(s|=-256),i===0&&(this.s&128)!=(s&128)&&++i,(i>0||s!=this.s)&&(e[i++]=s);return e}function jM(p){var e=Buffer.from(this.toByteArray());if(p===!0&&e[0]===0)e=e.slice(1);else if(nM.isNumber(p)){if(e.length>p){for(var t=0;t<e.length-p;t++)if(e[t]!==0)return null;return e.slice(e.length-p)}else if(e.length<p){var s=Buffer.alloc(p);return s.fill(0,0,p-e.length),e.copy(s,p-e.length),s}}return e}function KM(p){return this.compareTo(p)==0}function XM(p){return this.compareTo(p)<0?this:p}function YM(p){return this.compareTo(p)>0?this:p}function ZM(p,e,t){var s,i,n=Math.min(p.t,this.t);for(s=0;s<n;++s)t[s]=e(this[s],p[s]);if(p.t<this.t){for(i=p.s&this.DM,s=n;s<this.t;++s)t[s]=e(this[s],i);t.t=this.t}else{for(i=this.s&this.DM,s=n;s<p.t;++s)t[s]=e(i,p[s]);t.t=p.t}t.s=e(this.s,p.s),t.clamp()}function QM(p,e){return p&e}function JM(p){var e=tt();return this.bitwiseTo(p,QM,e),e}function eP(p,e){return p|e}function tP(p){var e=tt();return this.bitwiseTo(p,eP,e),e}function sP(p,e){return p^e}function iP(p){var e=tt();return this.bitwiseTo(p,sP,e),e}function nP(){for(var p=tt(),e=0;e<this.t;++e)p[e]=this.DM&~this[e];return p.t=this.t,p.s=~this.s,p}function rP(p){if(p===0)return-1;var e=0;return(p&65535)===0&&(p>>=16,e+=16),(p&255)===0&&(p>>=8,e+=8),(p&15)===0&&(p>>=4,e+=4),(p&3)===0&&(p>>=2,e+=2),(p&1)===0&&++e,e}function aP(){for(var p=0;p<this.t;++p)if(this[p]!=0)return p*this.DB+rP(this[p]);return this.s<0?this.t*this.DB:-1}function oP(p,e){for(var t=0,s=0,i=Math.min(p.t,this.t);t<i;)s+=this[t]+p[t],e[t++]=s&this.DM,s>>=this.DB;if(p.t<this.t){for(s+=p.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<p.t;)s+=p[t],e[t++]=s&this.DM,s>>=this.DB;s+=p.s}e.s=s<0?-1:0,s>0?e[t++]=s:s<-1&&(e[t++]=this.DV+s),e.t=t,e.clamp()}function dP(p){var e=tt();return this.addTo(p,e),e}function cP(p){var e=tt();return this.subTo(p,e),e}function uP(p){var e=tt();return this.multiplyTo(p,e),e}function hP(){var p=tt();return this.squareTo(p),p}function fP(p){var e=tt();return this.divRemTo(p,e,null),e}function lP(p){var e=tt();return this.divRemTo(p,null,e),e}function pP(p){this[this.t]=this.am(0,p-1,this,0,0,this.t),++this.t,this.clamp()}function mP(p,e){if(p!==0){for(;this.t<=e;)this[this.t++]=0;for(this[e]+=p;this[e]>=this.DV;)this[e]-=this.DV,++e>=this.t&&(this[this.t++]=0),++this[e]}}function zd(){}function dv(p){return p}function gP(p,e,t){p.multiplyTo(e,t)}function yP(p,e){p.squareTo(e)}zd.prototype.convert=dv;zd.prototype.revert=dv;zd.prototype.mulTo=gP;zd.prototype.sqrTo=yP;function wP(p){return this.exp(p,new zd)}function bP(p,e,t){var s=Math.min(this.t+p.t,e);for(t.s=0,t.t=s;s>0;)t[--s]=0;var i;for(i=t.t-this.t;s<i;++s)t[s+this.t]=this.am(0,p[s],t,s,0,this.t);for(i=Math.min(p.t,e);s<i;++s)this.am(0,p[s],t,s,0,e-s);t.clamp()}function kP(p,e,t){--e;var s=t.t=this.t+p.t-e;for(t.s=0;--s>=0;)t[s]=0;for(s=Math.max(e-this.t,0);s<p.t;++s)t[this.t+s-e]=this.am(e-s,p[s],t,0,0,this.t+s-e);t.clamp(),t.drShiftTo(1,t)}function po(p){this.r2=tt(),this.q3=tt(),pe.ONE.dlShiftTo(2*p.t,this.r2),this.mu=this.r2.divide(p),this.m=p}function SP(p){if(p.s<0||p.t>2*this.m.t)return p.mod(this.m);if(p.compareTo(this.m)<0)return p;var e=tt();return p.copyTo(e),this.reduce(e),e}function vP(p){return p}function TP(p){for(p.drShiftTo(this.m.t-1,this.r2),p.t>this.m.t+1&&(p.t=this.m.t+1,p.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);p.compareTo(this.r2)<0;)p.dAddOffset(1,this.m.t+1);for(p.subTo(this.r2,p);p.compareTo(this.m)>=0;)p.subTo(this.m,p)}function OP(p,e){p.squareTo(e),this.reduce(e)}function IP(p,e,t){p.multiplyTo(e,t),this.reduce(t)}po.prototype.convert=SP;po.prototype.revert=vP;po.prototype.reduce=TP;po.prototype.mulTo=IP;po.prototype.sqrTo=OP;function xP(p,e){var t=p.bitLength(),s,i=wh(1),n;if(t<=0)return i;t<18?s=1:t<48?s=3:t<144?s=4:t<768?s=5:s=6,t<8?n=new fo(e):e.isEven()?n=new po(e):n=new lo(e);var r=new Array,a=3,o=s-1,d=(1<<s)-1;if(r[1]=n.convert(this),s>1){var c=tt();for(n.sqrTo(r[1],c);a<=d;)r[a]=tt(),n.mulTo(c,r[a-2],r[a]),a+=2}var u=p.t-1,h,f=!0,l=tt(),m;for(t=bh(p[u])-1;u>=0;){for(t>=o?h=p[u]>>t-o&d:(h=(p[u]&(1<<t+1)-1)<<o-t,u>0&&(h|=p[u-1]>>this.DB+t-o)),a=s;(h&1)===0;)h>>=1,--a;if((t-=a)<0&&(t+=this.DB,--u),f)r[h].copyTo(i),f=!1;else{for(;a>1;)n.sqrTo(i,l),n.sqrTo(l,i),a-=2;a>0?n.sqrTo(i,l):(m=i,i=l,l=m),n.mulTo(l,r[h],i)}for(;u>=0&&(p[u]&1<<t)===0;)n.sqrTo(i,l),m=i,i=l,l=m,--t<0&&(t=this.DB-1,--u)}return n.revert(i)}function _P(p){var e=this.s<0?this.negate():this.clone(),t=p.s<0?p.negate():p.clone();if(e.compareTo(t)<0){var s=e;e=t,t=s}var i=e.getLowestSetBit(),n=t.getLowestSetBit();if(n<0)return e;for(i<n&&(n=i),n>0&&(e.rShiftTo(n,e),t.rShiftTo(n,t));e.signum()>0;)(i=e.getLowestSetBit())>0&&e.rShiftTo(i,e),(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),e.compareTo(t)>=0?(e.subTo(t,e),e.rShiftTo(1,e)):(t.subTo(e,t),t.rShiftTo(1,t));return n>0&&t.lShiftTo(n,t),t}pe.prototype.copyTo=oM;pe.prototype.fromInt=dM;pe.prototype.fromString=cM;pe.prototype.fromByteArray=uM;pe.prototype.fromBuffer=hM;pe.prototype.clamp=fM;pe.prototype.dlShiftTo=wM;pe.prototype.drShiftTo=bM;pe.prototype.lShiftTo=kM;pe.prototype.rShiftTo=SM;pe.prototype.subTo=vM;pe.prototype.multiplyTo=TM;pe.prototype.squareTo=OM;pe.prototype.divRemTo=IM;pe.prototype.invDigit=BM;pe.prototype.isEven=RM;pe.prototype.exp=DM;pe.prototype.chunkSize=GM;pe.prototype.toRadix=$M;pe.prototype.fromRadix=WM;pe.prototype.bitwiseTo=ZM;pe.prototype.addTo=oP;pe.prototype.dMultiply=pP;pe.prototype.dAddOffset=mP;pe.prototype.multiplyLowerTo=bP;pe.prototype.multiplyUpperTo=kP;pe.prototype.toString=lM;pe.prototype.negate=pM;pe.prototype.abs=mM;pe.prototype.compareTo=gM;pe.prototype.bitLength=yM;pe.prototype.mod=xM;pe.prototype.clone=FM;pe.prototype.intValue=HM;pe.prototype.signum=UM;pe.prototype.toByteArray=zM;pe.prototype.toBuffer=jM;pe.prototype.equals=KM;pe.prototype.min=XM;pe.prototype.max=YM;pe.prototype.and=JM;pe.prototype.or=tP;pe.prototype.xor=iP;pe.prototype.not=nP;pe.prototype.getLowestSetBit=aP;pe.prototype.add=dP;pe.prototype.subtract=cP;pe.prototype.multiply=uP;pe.prototype.divide=fP;pe.prototype.remainder=lP;pe.prototype.modPow=xP;pe.prototype.pow=wP;pe.prototype.gcd=_P;pe.int2char=Sm;pe.ZERO=wh(0);pe.ONE=wh(1);pe.prototype.square=hP;var cv=pe,Ym={exports:{}},Zm={exports:{}},CP=cv,MP=co.exports,O0={RSA_NO_PADDING:3},PP={md2:Buffer.from("3020300c06082a864886f70d020205000410","hex"),md5:Buffer.from("3020300c06082a864886f70d020505000410","hex"),sha1:Buffer.from("3021300906052b0e03021a05000414","hex"),sha224:Buffer.from("302d300d06096086480165030402040500041c","hex"),sha256:Buffer.from("3031300d060960864801650304020105000420","hex"),sha384:Buffer.from("3041300d060960864801650304020205000430","hex"),sha512:Buffer.from("3051300d060960864801650304020305000440","hex"),ripemd160:Buffer.from("3021300906052b2403020105000414","hex"),rmd160:Buffer.from("3021300906052b2403020105000414","hex")},AP={ripemd160:"rmd160"},BP="sha256";Zm.exports={isEncryption:!0,isSignature:!0};Zm.exports.makeScheme=function(p,e){function t(s,i){this.key=s,this.options=i}return t.prototype.maxMessageLength=function(){return this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==O0.RSA_NO_PADDING?this.key.encryptedDataLength:this.key.encryptedDataLength-11},t.prototype.encUnPad=function(s,i){i=i||{};var n=0;if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==O0.RSA_NO_PADDING){var r;return typeof s.lastIndexOf=="function"?r=s.slice(s.lastIndexOf("\0")+1,s.length):r=s.slice(String.prototype.lastIndexOf.call(s,"\0")+1,s.length),r}if(s.length<4)return null;if(i.type===1){if(s[0]!==0&&s[1]!==1)return null;for(n=3;s[n]!==0;)if(s[n]!=255||++n>=s.length)return null}else{if(s[0]!==0&&s[1]!==2)return null;for(n=3;s[n]!==0;)if(++n>=s.length)return null}return s.slice(n+1,s.length)},t.prototype.sign=function(s){var i=this.options.signingSchemeOptions.hash||BP;if(this.options.environment==="browser"){i=AP[i]||i;var n=MP[i.toUpperCase()](s.toString()),r=VP(n),a=this.pkcs1pad(r,i),o=this.key.$doPrivate(new CP(a)).toBuffer(this.key.encryptedDataLength);return o}else throw new Error("CCXT only supports browser mode :P")},t.prototype.pkcs1pad=function(s,i){var n=PP[i];if(!n)throw Error("Unsupported hash algorithm");var r=Buffer.concat([n,s]);if(r.length+10>this.key.encryptedDataLength)throw Error("Key is too short for signing algorithm ("+i+")");var a=Buffer.alloc(this.key.encryptedDataLength-r.length-1);a.fill(255,0,a.length-1),a[0]=1,a[a.length-1]=0;var o=Buffer.concat([a,r]);return o},new t(p,e)};function NP(p,e){var t=[],s=255;return e>0&&t.push(p>>>24),e>1&&t.push(p>>>16&s),e>2&&t.push(p>>>8&s),e>3&&t.push(p&s),t}function VP(p){let e;if(p.hasOwnProperty("sigBytes")&&p.hasOwnProperty("words"))e=p.sigBytes,p=p.words;else throw Error("Argument not a wordArray");const t=[];let s=[],i=0;for(;e>0;)s=NP(p[i],Math.min(4,e)),e-=s.length,t.push(s),i++;return new Buffer.from([].concat.apply([],t),"hex")}(function(p){p.exports={pkcs1:Zm.exports,isEncryption:function(e){return p.exports[e]&&p.exports[e].isEncryption},isSignature:function(e){return p.exports[e]&&p.exports[e].isSignature}}})(Ym);var I0=ri._,yr=cv,EP=ri,x0=Ym.exports;av.Key=function(){function p(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return p.prototype.setOptions=function(e){var t=x0[e.signingScheme],s=x0[e.encryptionScheme];t===s?this.signingScheme=this.encryptionScheme=s.makeScheme(this,e):(this.encryptionScheme=s.makeScheme(this,e),this.signingScheme=t.makeScheme(this,e))},p.prototype.setPrivate=function(e,t,s,i,n,r,a,o){if(e&&t&&s&&e.length>0&&(I0.isNumber(t)||t.length>0)&&s.length>0)this.n=new yr(e),this.e=I0.isNumber(t)?t:EP.get32IntFromBuffer(t,0),this.d=new yr(s),i&&n&&r&&a&&o&&(this.p=new yr(i),this.q=new yr(n),this.dmp1=new yr(r),this.dmq1=new yr(a),this.coeff=new yr(o)),this.$$recalculateCache();else throw Error("Invalid RSA private key")},p.prototype.$doPrivate=function(e){if(this.p||this.q)return e.modPow(this.d,this.n);for(var t=e.mod(this.p).modPow(this.dmp1,this.p),s=e.mod(this.q).modPow(this.dmq1,this.q);t.compareTo(s)<0;)t=t.add(this.p);return t.subtract(s).multiply(this.coeff).mod(this.p).multiply(this.q).add(s)},p.prototype.sign=function(e){return this.signingScheme.sign.apply(this.signingScheme,arguments)},p.prototype.isPrivate=function(){return this.n&&this.e&&this.d||!1},Object.defineProperty(p.prototype,"keySize",{get:function(){return this.cache.keyBitLength}}),Object.defineProperty(p.prototype,"encryptedDataLength",{get:function(){return this.cache.keyByteLength}}),Object.defineProperty(p.prototype,"maxMessageLength",{get:function(){return this.encryptionScheme.maxMessageLength()}}),p.prototype.$$recalculateCache=function(){this.cache=this.cache||{},this.cache.keyBitLength=this.n.bitLength(),this.cache.keyByteLength=this.cache.keyBitLength+6>>3},p}();var uv={exports:{}},hv={exports:{}},fv={exports:{}},lv={newInvalidAsn1Error:function(p){var e=new Error;return e.name="InvalidAsn1Error",e.message=p||"",e}},pv={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128},qP=ht,jd=pv,LP=lv,to=LP.newInvalidAsn1Error;function Ys(p){if(!p||!Buffer.isBuffer(p))throw new TypeError("data must be a node Buffer");this._buf=p,this._size=p.length,this._len=0,this._offset=0}Object.defineProperty(Ys.prototype,"length",{enumerable:!0,get:function(){return this._len}});Object.defineProperty(Ys.prototype,"offset",{enumerable:!0,get:function(){return this._offset}});Object.defineProperty(Ys.prototype,"remain",{get:function(){return this._size-this._offset}});Object.defineProperty(Ys.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}});Ys.prototype.readByte=function(p){if(this._size-this._offset<1)return null;var e=this._buf[this._offset]&255;return p||(this._offset+=1),e};Ys.prototype.peek=function(){return this.readByte(!0)};Ys.prototype.readLength=function(p){if(p===void 0&&(p=this._offset),p>=this._size)return null;var e=this._buf[p++]&255;if(e===null)return null;if((e&128)===128){if(e&=127,e===0)throw to("Indefinite length not supported");if(e>4)throw to("encoding too long");if(this._size-p<e)return null;this._len=0;for(var t=0;t<e;t++)this._len=(this._len<<8)+(this._buf[p++]&255)}else this._len=e;return p};Ys.prototype.readSequence=function(p){var e=this.peek();if(e===null)return null;if(p!==void 0&&p!==e)throw to("Expected 0x"+p.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);return t===null?null:(this._offset=t,e)};Ys.prototype.readInt=function(){return this._readTag(jd.Integer)};Ys.prototype.readBoolean=function(){return this._readTag(jd.Boolean)!==0};Ys.prototype.readEnumeration=function(){return this._readTag(jd.Enumeration)};Ys.prototype.readString=function(p,e){p||(p=jd.OctetString);var t=this.peek();if(t===null)return null;if(t!==p)throw to("Expected 0x"+p.toString(16)+": got 0x"+t.toString(16));var s=this.readLength(this._offset+1);if(s===null||this.length>this._size-s)return null;if(this._offset=s,this.length===0)return e?Buffer.alloc(0):"";var i=this._buf.slice(this._offset,this._offset+this.length);return this._offset+=this.length,e?i:i.toString("utf8")};Ys.prototype.readOID=function(p){p||(p=jd.OID);var e=this.readString(p,!0);if(e===null)return null;for(var t=[],s=0,i=0;i<e.length;i++){var n=e[i]&255;s<<=7,s+=n&127,(n&128)===0&&(t.push(s),s=0)}return s=t.shift(),t.unshift(s%40),t.unshift(s/40>>0),t.join(".")};Ys.prototype._readTag=function(p){qP.ok(p!==void 0);var e=this.peek();if(e===null)return null;if(e!==p)throw to("Expected 0x"+p.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);if(t===null)return null;if(this.length>4)throw to("Integer too long: "+this.length);if(this.length>this._size-t)return null;this._offset=t;for(var s=this._buf[this._offset],i=0,n=0;n<this.length;n++)i<<=8,i|=this._buf[this._offset++]&255;return(s&128)===128&&n!==4&&(i-=1<<n*8),i>>0};var RP=Ys;(function(p){var e=lv,t=pv,s=RP;p.exports={Reader:s};for(var i in t)t.hasOwnProperty(i)&&(p.exports[i]=t[i]);for(var n in e)e.hasOwnProperty(n)&&(p.exports[n]=e[n])})(fv);var _0=fv.exports,mv={Ber:_0,BerReader:_0.Reader};(function(p){var e=mv.Ber,t=ri._,s=ri;const i="-----BEGIN RSA PRIVATE KEY-----",n="-----END RSA PRIVATE KEY-----",r="-----BEGIN RSA PUBLIC KEY-----",a="-----END RSA PUBLIC KEY-----";p.exports={privateExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=o.d.toBuffer(),h=o.p.toBuffer(),f=o.q.toBuffer(),l=o.dmp1.toBuffer(),m=o.dmq1.toBuffer(),g=o.coeff.toBuffer(),y=c.length+u.length+h.length+f.length+l.length+m.length+g.length+512,w=new e.Writer({size:y});return w.startSequence(),w.writeInt(0),w.writeBuffer(c,2),w.writeInt(o.e),w.writeBuffer(u,2),w.writeBuffer(h,2),w.writeBuffer(f,2),w.writeBuffer(l,2),w.writeBuffer(m,2),w.writeBuffer(g,2),w.endSequence(),d.type==="der"?w.buffer:i+`
`+s.linebrk(w.buffer.toString("base64"),64)+`
`+n},privateImport:function(o,d,c){c=c||{};var u;if(c.type!=="der")if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,i,n).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var f=new e.Reader(u);f.readSequence(),f.readString(2,!0),o.setPrivate(f.readString(2,!0),f.readString(2,!0),f.readString(2,!0),f.readString(2,!0),f.readString(2,!0),f.readString(2,!0),f.readString(2,!0),f.readString(2,!0))},publicExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=c.length+512,h=new e.Writer({size:u});return h.startSequence(),h.writeBuffer(c,2),h.writeInt(o.e),h.endSequence(),d.type==="der"?h.buffer:r+`
`+s.linebrk(h.buffer.toString("base64"),64)+`
`+a},publicImport:function(o,d,c){c=c||{};var u;if(c.type!=="der"){if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,r,a).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}}else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var f=new e.Reader(u);f.readSequence(),o.setPublic(f.readString(2,!0),f.readString(2,!0))},autoImport:function(o,d){return/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(d)?(p.exports.privateImport(o,d),!0):/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(d)?(p.exports.publicImport(o,d),!0):!1}}})(hv);var gv={exports:{}};(function(p){var e=mv.Ber,t=ri._,s="1.2.840.113549.1.1.1",i=ri;const n="-----BEGIN PRIVATE KEY-----",r="-----END PRIVATE KEY-----",a="-----BEGIN PUBLIC KEY-----",o="-----END PUBLIC KEY-----";p.exports={privateExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=d.d.toBuffer(),f=d.p.toBuffer(),l=d.q.toBuffer(),m=d.dmp1.toBuffer(),g=d.dmq1.toBuffer(),y=d.coeff.toBuffer(),w=u.length+h.length+f.length+l.length+m.length+g.length+y.length+512,b=new e.Writer({size:w});b.startSequence(),b.writeInt(0),b.writeBuffer(u,2),b.writeInt(d.e),b.writeBuffer(h,2),b.writeBuffer(f,2),b.writeBuffer(l,2),b.writeBuffer(m,2),b.writeBuffer(g,2),b.writeBuffer(y,2),b.endSequence();var S=new e.Writer({size:w});return S.startSequence(),S.writeInt(0),S.startSequence(),S.writeOID(s),S.writeNull(),S.endSequence(),S.writeBuffer(b.buffer,4),S.endSequence(),c.type==="der"?S.buffer:n+`
`+i.linebrk(S.buffer.toString("base64"),64)+`
`+r},privateImport:function(d,c,u){u=u||{};var h;if(u.type!=="der")if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var f=i.trimSurroundingText(c,n,r).replace("-----END PRIVATE KEY-----","").replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(f,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var l=new e.Reader(h);l.readSequence(),l.readInt(0);var m=new e.Reader(l.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(l.readString(4,!0));g.readSequence(),g.readString(2,!0),d.setPrivate(g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0))},publicExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=u.length+512,f=new e.Writer({size:h});f.writeByte(0),f.startSequence(),f.writeBuffer(u,2),f.writeInt(d.e),f.endSequence();var l=new e.Writer({size:h});return l.startSequence(),l.startSequence(),l.writeOID(s),l.writeNull(),l.endSequence(),l.writeBuffer(f.buffer,3),l.endSequence(),c.type==="der"?l.buffer:a+`
`+i.linebrk(l.buffer.toString("base64"),64)+`
`+o},publicImport:function(d,c,u){u=u||{};var h;if(u.type!=="der"){if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var f=i.trimSurroundingText(c,a,o).replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(f,"base64")}}else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var l=new e.Reader(h);l.readSequence();var m=new e.Reader(l.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(l.readString(3,!0));g.readByte(),g.readSequence(),d.setPublic(g.readString(2,!0),g.readString(2,!0))},autoImport:function(d,c){return/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(c)?(p.exports.privateImport(d,c),!0):/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(c)?(p.exports.publicImport(d,c),!0):!1}}})(gv);var yv={exports:{}};(function(p){ri._,p.exports={privateExport:function(e,t){return{n:e.n.toBuffer(),e:e.e,d:e.d.toBuffer(),p:e.p.toBuffer(),q:e.q.toBuffer(),dmp1:e.dmp1.toBuffer(),dmq1:e.dmq1.toBuffer(),coeff:e.coeff.toBuffer()}},privateImport:function(e,t,s){if(t.n&&t.e&&t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff)e.setPrivate(t.n,t.e,t.d,t.p,t.q,t.dmp1,t.dmq1,t.coeff);else throw Error("Invalid key data")},publicExport:function(e,t){return{n:e.n.toBuffer(),e:e.e}},publicImport:function(e,t,s){if(t.n&&t.e)e.setPublic(t.n,t.e);else throw Error("Invalid key data")},autoImport:function(e,t){return t.n&&t.e?t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff?(p.exports.privateImport(e,t),!0):(p.exports.publicImport(e,t),!0):!1}}})(yv);(function(p){ri._,p.exports={pkcs1:hv.exports,pkcs8:gv.exports,components:yv.exports,detectAndImport:function(e,t,s){if(s===void 0){for(var i in p.exports)if(typeof p.exports[i].autoImport=="function"&&p.exports[i].autoImport(e,t))return!0}else if(s){var n=formatParse(s);if(p.exports[n.scheme])n.keyType==="private"?p.exports[n.scheme].privateImport(e,t,n.keyOpt):p.exports[n.scheme].publicImport(e,t,n.keyOpt);else throw Error("Unsupported key format")}return!1}}})(uv);/*!
 * RSA library for Node.js
 *
 * Author: rzcoder
 * License MIT
 */var DP=av,gi=ri._,C0=Ym.exports,FP=uv.exports,HP=function(){var p={browser:["md5","ripemd160","sha1","sha256","sha512"]},e="pkcs1",t="pkcs1",s={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};function i(n,r,a){if(!(this instanceof i))return new i(n,r,a);gi.isObject(r)&&(a=r,r=void 0),this.$options={signingScheme:t,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:e,encryptionSchemeOptions:{hash:"sha1",label:null},environment:"browser",rsaUtils:this},this.keyPair=new DP.Key,this.$cache={},Buffer.isBuffer(n)||gi.isString(n)?this.importKey(n,r):gi.isObject(n)&&this.generateKeyPair(n.b,n.e),this.setOptions(a)}return i.prototype.setOptions=function(n){if(n=n||{},n.environment&&(this.$options.environment=n.environment),n.signingScheme){if(gi.isString(n.signingScheme)){var r=n.signingScheme.toLowerCase().split("-");r.length==1?p.node.indexOf(r[0])>-1?(this.$options.signingSchemeOptions={hash:r[0]},this.$options.signingScheme=t):(this.$options.signingScheme=r[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:r[1]},this.$options.signingScheme=r[0])}else gi.isObject(n.signingScheme)&&(this.$options.signingScheme=n.signingScheme.scheme||t,this.$options.signingSchemeOptions=gi.omit(n.signingScheme,"scheme"));if(!C0.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&p[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(n.encryptionScheme){if(gi.isString(n.encryptionScheme)?(this.$options.encryptionScheme=n.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):gi.isObject(n.encryptionScheme)&&(this.$options.encryptionScheme=n.encryptionScheme.scheme||e,this.$options.encryptionSchemeOptions=gi.omit(n.encryptionScheme,"scheme")),!C0.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&p[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options)},i.prototype.importKey=function(n,r){if(!n)throw Error("Empty key given");if(r&&(r=s[r]||r),!FP.detectAndImport(this.keyPair,n,r)&&r===void 0)throw Error("Key format must be specified");return this.$cache={},this},i.prototype.isPrivate=function(){return this.keyPair.isPrivate()},i.prototype.isPublic=function(n){return this.keyPair.isPublic(n)},i.prototype.isEmpty=function(n){return!(this.keyPair.n||this.keyPair.e||this.keyPair.d)},i.prototype.sign=function(n,r,a){if(!this.isPrivate())throw Error("This is not private key");var o=this.keyPair.sign(this.$getDataForEncrypt(n,a));return r&&r!="buffer"&&(o=o.toString(r)),o},i.prototype.$getDataForEncrypt=function(n,r){if(gi.isString(n)||gi.isNumber(n))return Buffer.from(""+n,r||"utf8");if(Buffer.isBuffer(n))return n;if(gi.isObject(n))return Buffer.from(JSON.stringify(n));throw Error("Unexpected data type")},i}(),Qi={},oa={};(function(p){var e=p,t=mi.exports;e.assert=function(f,l){if(!f)throw new Error(l)};function s(f,l){for(var m=[],g=1<<l+1,y=f.clone();y.cmpn(1)>=0;){var w;if(y.isOdd()){var b=y.andln(g-1);b>(g>>1)-1?w=(g>>1)-b:w=b,y.isubn(w)}else w=0;m.push(w);for(var S=y.cmpn(0)!==0&&y.andln(g-1)===0?l+1:1,v=1;v<S;v++)m.push(0);y.iushrn(S)}return m}e.getNAF=s;function i(f,l){var m=[[],[]];f=f.clone(),l=l.clone();for(var g=0,y=0;f.cmpn(-g)>0||l.cmpn(-y)>0;){var w=f.andln(3)+g&3,b=l.andln(3)+y&3;w===3&&(w=-1),b===3&&(b=-1);var S;if((w&1)===0)S=0;else{var v=f.andln(7)+g&7;(v===3||v===5)&&b===2?S=-w:S=w}m[0].push(S);var T;if((b&1)===0)T=0;else{var v=l.andln(7)+y&7;(v===3||v===5)&&w===2?T=-b:T=b}m[1].push(T),2*g===S+1&&(g=1-g),2*y===T+1&&(y=1-y),f.iushrn(1),l.iushrn(1)}return m}e.getJSF=i;function n(f,l,m){var g="_"+l;f.prototype[l]=function(){return this[g]!==void 0?this[g]:this[g]=m.call(this)}}e.cachedProperty=n;function r(f){return typeof f=="string"?e.toArray(f,"hex"):f}e.parseBytes=r;function a(f){return new t(f,"hex","le")}e.intFromLE=a;function o(f,l){var m=[],g=255;return l>0&&m.push(f>>>24),l>1&&m.push(f>>>16&g),l>2&&m.push(f>>>8&g),l>3&&m.push(f&g),m}function d(f){let l;if(f.hasOwnProperty("sigBytes")&&f.hasOwnProperty("words"))l=f.sigBytes,f=f.words;else throw Error("Argument not a wordArray");const m=[];let g=[],y=0;for(;l>0;)g=o(f[y],Math.min(4,l)),l-=g.length,m.push(g),y++;return[].concat.apply([],m)}e.wordArrayToBuffer=d;function c(f,l){if(Array.isArray(f))return f.slice();if(!f)return[];var m=[];if(typeof f!="string"){for(var g=0;g<f.length;g++)m[g]=f[g]|0;return m}if(l==="hex"){f=f.replace(/[^a-z0-9]+/ig,""),f.length%2!==0&&(f="0"+f);for(var g=0;g<f.length;g+=2)m.push(parseInt(f[g]+f[g+1],16))}else for(var g=0;g<f.length;g++){var y=f.charCodeAt(g),w=y>>8,b=y&255;w?m.push(w,b):m.push(b)}return m}e.toArray=c;function u(f){return f.length===1?"0"+f:f}e.zero2=u;function h(f){for(var l="",m=0;m<f.length;m++)l+=u(f[m].toString(16));return l}e.toHex=h,e.encode=function(l,m){return m==="hex"?h(l):l}})(oa);var Kd={},wr=mi.exports,GP=Qi,Xd=GP.utils,rh=Xd.getNAF,UP=Xd.getJSF,ah=Xd.assert;function pr(p,e){this.type=p,this.p=new wr(e.p,16),this.red=e.prime?wr.red(e.prime):wr.mont(this.p),this.zero=new wr(0).toRed(this.red),this.one=new wr(1).toRed(this.red),this.two=new wr(2).toRed(this.red),this.n=e.n&&new wr(e.n,16),this.g=e.g&&this.pointFromJSON(e.g,e.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var t=this.n&&this.p.div(this.n);!t||t.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}var $P=pr;pr.prototype.point=function(){throw new Error("Not implemented")};pr.prototype.validate=function(){throw new Error("Not implemented")};pr.prototype._fixedNafMul=function(e,t){ah(e.precomputed);var s=e._getDoubles(),i=rh(t,1),n=(1<<s.step+1)-(s.step%2===0?2:1);n/=3;for(var r=[],a=0;a<i.length;a+=s.step){for(var o=0,t=a+s.step-1;t>=a;t--)o=(o<<1)+i[t];r.push(o)}for(var d=this.jpoint(null,null,null),c=this.jpoint(null,null,null),u=n;u>0;u--){for(var a=0;a<r.length;a++){var o=r[a];o===u?c=c.mixedAdd(s.points[a]):o===-u&&(c=c.mixedAdd(s.points[a].neg()))}d=d.add(c)}return d.toP()};pr.prototype._wnafMul=function(e,t){var s=4,i=e._getNAFPoints(s);s=i.wnd;for(var n=i.points,r=rh(t,s),a=this.jpoint(null,null,null),o=r.length-1;o>=0;o--){for(var t=0;o>=0&&r[o]===0;o--)t++;if(o>=0&&t++,a=a.dblp(t),o<0)break;var d=r[o];ah(d!==0),e.type==="affine"?d>0?a=a.mixedAdd(n[d-1>>1]):a=a.mixedAdd(n[-d-1>>1].neg()):d>0?a=a.add(n[d-1>>1]):a=a.add(n[-d-1>>1].neg())}return e.type==="affine"?a.toP():a};pr.prototype._wnafMulAdd=function(e,t,s,i,n){for(var r=this._wnafT1,a=this._wnafT2,o=this._wnafT3,d=0,c=0;c<i;c++){var u=t[c],h=u._getNAFPoints(e);r[c]=h.wnd,a[c]=h.points}for(var c=i-1;c>=1;c-=2){var f=c-1,l=c;if(r[f]!==1||r[l]!==1){o[f]=rh(s[f],r[f]),o[l]=rh(s[l],r[l]),d=Math.max(o[f].length,d),d=Math.max(o[l].length,d);continue}var m=[t[f],null,null,t[l]];t[f].y.cmp(t[l].y)===0?(m[1]=t[f].add(t[l]),m[2]=t[f].toJ().mixedAdd(t[l].neg())):t[f].y.cmp(t[l].y.redNeg())===0?(m[1]=t[f].toJ().mixedAdd(t[l]),m[2]=t[f].add(t[l].neg())):(m[1]=t[f].toJ().mixedAdd(t[l]),m[2]=t[f].toJ().mixedAdd(t[l].neg()));var g=[-3,-1,-5,-7,0,7,5,1,3],y=UP(s[f],s[l]);d=Math.max(y[0].length,d),o[f]=new Array(d),o[l]=new Array(d);for(var w=0;w<d;w++){var b=y[0][w]|0,S=y[1][w]|0;o[f][w]=g[(b+1)*3+(S+1)],o[l][w]=0,a[f]=m}}for(var v=this.jpoint(null,null,null),T=this._wnafT4,c=d;c>=0;c--){for(var I=0;c>=0;){for(var A=!0,w=0;w<i;w++)T[w]=o[w][c]|0,T[w]!==0&&(A=!1);if(!A)break;I++,c--}if(c>=0&&I++,v=v.dblp(I),c<0)break;for(var w=0;w<i;w++){var N=T[w],u;N!==0&&(N>0?u=a[w][N-1>>1]:N<0&&(u=a[w][-N-1>>1].neg()),u.type==="affine"?v=v.mixedAdd(u):v=v.add(u))}}for(var c=0;c<i;c++)a[c]=null;return n?v:v.toP()};function Ni(p,e){this.curve=p,this.type=e,this.precomputed=null}pr.BasePoint=Ni;Ni.prototype.eq=function(){throw new Error("Not implemented")};Ni.prototype.validate=function(){return this.curve.validate(this)};pr.prototype.decodePoint=function(e,t){e=Xd.toArray(e,t);var s=this.p.byteLength();if((e[0]===4||e[0]===6||e[0]===7)&&e.length-1===2*s){e[0]===6?ah(e[e.length-1]%2===0):e[0]===7&&ah(e[e.length-1]%2===1);var i=this.point(e.slice(1,1+s),e.slice(1+s,1+2*s));return i}else if((e[0]===2||e[0]===3)&&e.length-1===s)return this.pointFromX(e.slice(1,1+s),e[0]===3);throw new Error("Unknown point format")};Ni.prototype.encodeCompressed=function(e){return this.encode(e,!0)};Ni.prototype._encode=function(e){var t=this.curve.p.byteLength(),s=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(s):[4].concat(s,this.getY().toArray("be",t))};Ni.prototype.encode=function(e,t){return Xd.encode(this._encode(t),e)};Ni.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this};Ni.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return t?t.points.length>=Math.ceil((e.bitLength()+1)/t.step):!1};Ni.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var s=[this],i=this,n=0;n<t;n+=e){for(var r=0;r<e;r++)i=i.dbl();s.push(i)}return{step:e,points:s}};Ni.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],s=(1<<e)-1,i=s===1?null:this.dbl(),n=1;n<s;n++)t[n]=t[n-1].add(i);return{wnd:e,points:t}};Ni.prototype._getBeta=function(){return null};Ni.prototype.dblp=function(e){for(var t=this,s=0;s<e;s++)t=t.dbl();return t};var WP=Kd,wv=Qi,Ut=mi.exports,Qm=wv.inherits,mo=WP.base,zP=wv.utils.assert;function Vi(p){mo.call(this,"short",p),this.a=new Ut(p.a,16).toRed(this.red),this.b=new Ut(p.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=this.a.fromRed().cmpn(0)===0,this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0,this.endo=this._getEndomorphism(p),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}Qm(Vi,mo);var jP=Vi;Vi.prototype._getEndomorphism=function(e){if(!(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)){var t,s;if(e.beta)t=new Ut(e.beta,16).toRed(this.red);else{var i=this._getEndoRoots(this.p);t=i[0].cmp(i[1])<0?i[0]:i[1],t=t.toRed(this.red)}if(e.lambda)s=new Ut(e.lambda,16);else{var n=this._getEndoRoots(this.n);this.g.mul(n[0]).x.cmp(this.g.x.redMul(t))===0?s=n[0]:(s=n[1],zP(this.g.mul(s).x.cmp(this.g.x.redMul(t))===0))}var r;return e.basis?r=e.basis.map(function(a){return{a:new Ut(a.a,16),b:new Ut(a.b,16)}}):r=this._getEndoBasis(s),{beta:t,lambda:s,basis:r}}};Vi.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:Ut.mont(e),s=new Ut(2).toRed(t).redInvm(),i=s.redNeg(),n=new Ut(3).toRed(t).redNeg().redSqrt().redMul(s),r=i.redAdd(n).fromRed(),a=i.redSub(n).fromRed();return[r,a]};Vi.prototype._getEndoBasis=function(e){for(var t=this.n.ushrn(Math.floor(this.n.bitLength()/2)),s=e,i=this.n.clone(),n=new Ut(1),r=new Ut(0),a=new Ut(0),o=new Ut(1),d,c,u,h,f,l,m,g=0,y,w;s.cmpn(0)!==0;){var b=i.div(s);y=i.sub(b.mul(s)),w=a.sub(b.mul(n));var S=o.sub(b.mul(r));if(!u&&y.cmp(t)<0)d=m.neg(),c=n,u=y.neg(),h=w;else if(u&&++g===2)break;m=y,i=s,s=y,a=n,n=w,o=r,r=S}f=y.neg(),l=w;var v=u.sqr().add(h.sqr()),T=f.sqr().add(l.sqr());return T.cmp(v)>=0&&(f=d,l=c),u.negative&&(u=u.neg(),h=h.neg()),f.negative&&(f=f.neg(),l=l.neg()),[{a:u,b:h},{a:f,b:l}]};Vi.prototype._endoSplit=function(e){var t=this.endo.basis,s=t[0],i=t[1],n=i.b.mul(e).divRound(this.n),r=s.b.neg().mul(e).divRound(this.n),a=n.mul(s.a),o=r.mul(i.a),d=n.mul(s.b),c=r.mul(i.b),u=e.sub(a).sub(o),h=d.add(c).neg();return{k1:u,k2:h}};Vi.prototype.pointFromX=function(e,t){e=new Ut(e,16),e.red||(e=e.toRed(this.red));var s=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),i=s.redSqrt();if(i.redSqr().redSub(s).cmp(this.zero)!==0)throw new Error("invalid point");var n=i.fromRed().isOdd();return(t&&!n||!t&&n)&&(i=i.redNeg()),this.point(e,i)};Vi.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,s=e.y,i=this.a.redMul(t),n=t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);return s.redSqr().redISub(n).cmpn(0)===0};Vi.prototype._endoWnafMulAdd=function(e,t,s){for(var i=this._endoWnafT1,n=this._endoWnafT2,r=0;r<e.length;r++){var a=this._endoSplit(t[r]),o=e[r],d=o._getBeta();a.k1.negative&&(a.k1.ineg(),o=o.neg(!0)),a.k2.negative&&(a.k2.ineg(),d=d.neg(!0)),i[r*2]=o,i[r*2+1]=d,n[r*2]=a.k1,n[r*2+1]=a.k2}for(var c=this._wnafMulAdd(1,i,n,r*2,s),u=0;u<r*2;u++)i[u]=null,n[u]=null;return c};function Ts(p,e,t,s){mo.BasePoint.call(this,p,"affine"),e===null&&t===null?(this.x=null,this.y=null,this.inf=!0):(this.x=new Ut(e,16),this.y=new Ut(t,16),s&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}Qm(Ts,mo.BasePoint);Vi.prototype.point=function(e,t,s){return new Ts(this,e,t,s)};Vi.prototype.pointFromJSON=function(e,t){return Ts.fromJSON(this,e,t)};Ts.prototype._getBeta=function(){if(!!this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(e){var s=this.curve,i=function(n){return s.point(n.x.redMul(s.endo.beta),n.y)};e.beta=t,t.precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(i)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(i)}}}return t}};Ts.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]};Ts.fromJSON=function(e,t,s){typeof t=="string"&&(t=JSON.parse(t));var i=e.point(t[0],t[1],s);if(!t[2])return i;function n(a){return e.point(a[0],a[1],s)}var r=t[2];return i.precomputed={beta:null,doubles:r.doubles&&{step:r.doubles.step,points:[i].concat(r.doubles.points.map(n))},naf:r.naf&&{wnd:r.naf.wnd,points:[i].concat(r.naf.points.map(n))}},i};Ts.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"};Ts.prototype.isInfinity=function(){return this.inf};Ts.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(this.x.cmp(e.x)===0)return this.curve.point(null,null);var t=this.y.redSub(e.y);t.cmpn(0)!==0&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var s=t.redSqr().redISub(this.x).redISub(e.x),i=t.redMul(this.x.redSub(s)).redISub(this.y);return this.curve.point(s,i)};Ts.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(e.cmpn(0)===0)return this.curve.point(null,null);var t=this.curve.a,s=this.x.redSqr(),i=e.redInvm(),n=s.redAdd(s).redIAdd(s).redIAdd(t).redMul(i),r=n.redSqr().redISub(this.x.redAdd(this.x)),a=n.redMul(this.x.redSub(r)).redISub(this.y);return this.curve.point(r,a)};Ts.prototype.getX=function(){return this.x.fromRed()};Ts.prototype.getY=function(){return this.y.fromRed()};Ts.prototype.mul=function(e){return e=new Ut(e,16),this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)};Ts.prototype.mulAdd=function(e,t,s){var i=[this,t],n=[e,s];return this.curve.endo?this.curve._endoWnafMulAdd(i,n):this.curve._wnafMulAdd(1,i,n,2)};Ts.prototype.jmulAdd=function(e,t,s){var i=[this,t],n=[e,s];return this.curve.endo?this.curve._endoWnafMulAdd(i,n,!0):this.curve._wnafMulAdd(1,i,n,2,!0)};Ts.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||this.x.cmp(e.x)===0&&this.y.cmp(e.y)===0)};Ts.prototype.neg=function(e){if(this.inf)return this;var t=this.curve.point(this.x,this.y.redNeg());if(e&&this.precomputed){var s=this.precomputed,i=function(n){return n.neg()};t.precomputed={naf:s.naf&&{wnd:s.naf.wnd,points:s.naf.points.map(i)},doubles:s.doubles&&{step:s.doubles.step,points:s.doubles.points.map(i)}}}return t};Ts.prototype.toJ=function(){if(this.inf)return this.curve.jpoint(null,null,null);var e=this.curve.jpoint(this.x,this.y,this.curve.one);return e};function Cs(p,e,t,s){mo.BasePoint.call(this,p,"jacobian"),e===null&&t===null&&s===null?(this.x=this.curve.one,this.y=this.curve.one,this.z=new Ut(0)):(this.x=new Ut(e,16),this.y=new Ut(t,16),this.z=new Ut(s,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}Qm(Cs,mo.BasePoint);Vi.prototype.jpoint=function(e,t,s){return new Cs(this,e,t,s)};Cs.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),s=this.x.redMul(t),i=this.y.redMul(t).redMul(e);return this.curve.point(s,i)};Cs.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)};Cs.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),s=this.z.redSqr(),i=this.x.redMul(t),n=e.x.redMul(s),r=this.y.redMul(t.redMul(e.z)),a=e.y.redMul(s.redMul(this.z)),o=i.redSub(n),d=r.redSub(a);if(o.cmpn(0)===0)return d.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var c=o.redSqr(),u=c.redMul(o),h=i.redMul(c),f=d.redSqr().redIAdd(u).redISub(h).redISub(h),l=d.redMul(h.redISub(f)).redISub(r.redMul(u)),m=this.z.redMul(e.z).redMul(o);return this.curve.jpoint(f,l,m)};Cs.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),s=this.x,i=e.x.redMul(t),n=this.y,r=e.y.redMul(t).redMul(this.z),a=s.redSub(i),o=n.redSub(r);if(a.cmpn(0)===0)return o.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var d=a.redSqr(),c=d.redMul(a),u=s.redMul(d),h=o.redSqr().redIAdd(c).redISub(u).redISub(u),f=o.redMul(u.redISub(h)).redISub(n.redMul(c)),l=this.z.redMul(a);return this.curve.jpoint(h,f,l)};Cs.prototype.dblp=function(e){if(e===0)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,s=0;s<e;s++)t=t.dbl();return t}for(var i=this.curve.a,n=this.curve.tinv,r=this.x,a=this.y,o=this.z,d=o.redSqr().redSqr(),c=a.redAdd(a),s=0;s<e;s++){var u=r.redSqr(),h=c.redSqr(),f=h.redSqr(),l=u.redAdd(u).redIAdd(u).redIAdd(i.redMul(d)),m=r.redMul(h),g=l.redSqr().redISub(m.redAdd(m)),y=m.redISub(g),w=l.redMul(y);w=w.redIAdd(w).redISub(f);var b=c.redMul(o);s+1<e&&(d=d.redMul(f)),r=g,o=b,c=w}return this.curve.jpoint(r,c.redMul(n),o)};Cs.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()};Cs.prototype._zeroDbl=function(){var e,t,s;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),r=n.redSqr(),a=this.x.redAdd(n).redSqr().redISub(i).redISub(r);a=a.redIAdd(a);var o=i.redAdd(i).redIAdd(i),d=o.redSqr().redISub(a).redISub(a),c=r.redIAdd(r);c=c.redIAdd(c),c=c.redIAdd(c),e=d,t=o.redMul(a.redISub(d)).redISub(c),s=this.y.redAdd(this.y)}else{var u=this.x.redSqr(),h=this.y.redSqr(),f=h.redSqr(),l=this.x.redAdd(h).redSqr().redISub(u).redISub(f);l=l.redIAdd(l);var m=u.redAdd(u).redIAdd(u),g=m.redSqr(),y=f.redIAdd(f);y=y.redIAdd(y),y=y.redIAdd(y),e=g.redISub(l).redISub(l),t=m.redMul(l.redISub(e)).redISub(y),s=this.y.redMul(this.z),s=s.redIAdd(s)}return this.curve.jpoint(e,t,s)};Cs.prototype._threeDbl=function(){var e,t,s;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),r=n.redSqr(),a=this.x.redAdd(n).redSqr().redISub(i).redISub(r);a=a.redIAdd(a);var o=i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),d=o.redSqr().redISub(a).redISub(a);e=d;var c=r.redIAdd(r);c=c.redIAdd(c),c=c.redIAdd(c),t=o.redMul(a.redISub(d)).redISub(c),s=this.y.redAdd(this.y)}else{var u=this.z.redSqr(),h=this.y.redSqr(),f=this.x.redMul(h),l=this.x.redSub(u).redMul(this.x.redAdd(u));l=l.redAdd(l).redIAdd(l);var m=f.redIAdd(f);m=m.redIAdd(m);var g=m.redAdd(m);e=l.redSqr().redISub(g),s=this.y.redAdd(this.z).redSqr().redISub(h).redISub(u);var y=h.redSqr();y=y.redIAdd(y),y=y.redIAdd(y),y=y.redIAdd(y),t=l.redMul(m.redISub(e)).redISub(y)}return this.curve.jpoint(e,t,s)};Cs.prototype._dbl=function(){var e=this.curve.a,t=this.x,s=this.y,i=this.z,n=i.redSqr().redSqr(),r=t.redSqr(),a=s.redSqr(),o=r.redAdd(r).redIAdd(r).redIAdd(e.redMul(n)),d=t.redAdd(t);d=d.redIAdd(d);var c=d.redMul(a),u=o.redSqr().redISub(c.redAdd(c)),h=c.redISub(u),f=a.redSqr();f=f.redIAdd(f),f=f.redIAdd(f),f=f.redIAdd(f);var l=o.redMul(h).redISub(f),m=s.redAdd(s).redMul(i);return this.curve.jpoint(u,l,m)};Cs.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),s=this.z.redSqr(),i=t.redSqr(),n=e.redAdd(e).redIAdd(e),r=n.redSqr(),a=this.x.redAdd(t).redSqr().redISub(e).redISub(i);a=a.redIAdd(a),a=a.redAdd(a).redIAdd(a),a=a.redISub(r);var o=a.redSqr(),d=i.redIAdd(i);d=d.redIAdd(d),d=d.redIAdd(d),d=d.redIAdd(d);var c=n.redIAdd(a).redSqr().redISub(r).redISub(o).redISub(d),u=t.redMul(c);u=u.redIAdd(u),u=u.redIAdd(u);var h=this.x.redMul(o).redISub(u);h=h.redIAdd(h),h=h.redIAdd(h);var f=this.y.redMul(c.redMul(d.redISub(c)).redISub(a.redMul(o)));f=f.redIAdd(f),f=f.redIAdd(f),f=f.redIAdd(f);var l=this.z.redAdd(a).redSqr().redISub(s).redISub(o);return this.curve.jpoint(h,f,l)};Cs.prototype.mul=function(e,t){return e=new Ut(e,t),this.curve._wnafMul(this,e)};Cs.prototype.eq=function(e){if(e.type==="affine")return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),s=e.z.redSqr();if(this.x.redMul(s).redISub(e.x.redMul(t)).cmpn(0)!==0)return!1;var i=t.redMul(this.z),n=s.redMul(e.z);return this.y.redMul(n).redISub(e.y.redMul(i)).cmpn(0)===0};Cs.prototype.eqXToP=function(e){var t=this.z.redSqr(),s=e.toRed(this.curve.red).redMul(t);if(this.x.cmp(s)===0)return!0;for(var i=e.clone(),n=this.curve.redN.redMul(t);;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return!1;if(s.redIAdd(n),this.x.cmp(s)===0)return!0}return!1};Cs.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"};Cs.prototype.isInfinity=function(){return this.z.cmpn(0)===0};var KP=Kd,za=mi.exports,bv=Qi.inherits,kh=KP.base,XP=Qi,YP=XP.utils;function go(p){kh.call(this,"mont",p),this.a=new za(p.a,16).toRed(this.red),this.b=new za(p.b,16).toRed(this.red),this.i4=new za(4).toRed(this.red).redInvm(),this.two=new za(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}bv(go,kh);var ZP=go;go.prototype.validate=function(e){var t=e.normalize().x,s=t.redSqr(),i=s.redMul(t).redAdd(s.redMul(this.a)).redAdd(t),n=i.redSqrt();return n.redSqr().cmp(i)===0};function vs(p,e,t){kh.BasePoint.call(this,p,"projective"),e===null&&t===null?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new za(e,16),this.z=new za(t,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}bv(vs,kh.BasePoint);go.prototype.decodePoint=function(e,t){return this.point(YP.toArray(e,t),1)};go.prototype.point=function(e,t){return new vs(this,e,t)};go.prototype.pointFromJSON=function(e){return vs.fromJSON(this,e)};vs.prototype.precompute=function(){};vs.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())};vs.fromJSON=function(e,t){return new vs(e,t[0],t[1]||e.one)};vs.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"};vs.prototype.isInfinity=function(){return this.z.cmpn(0)===0};vs.prototype.dbl=function(){var e=this.x.redAdd(this.z),t=e.redSqr(),s=this.x.redSub(this.z),i=s.redSqr(),n=t.redSub(i),r=t.redMul(i),a=n.redMul(i.redAdd(this.curve.a24.redMul(n)));return this.curve.point(r,a)};vs.prototype.add=function(){throw new Error("Not supported on Montgomery curve")};vs.prototype.diffAdd=function(e,t){var s=this.x.redAdd(this.z),i=this.x.redSub(this.z),n=e.x.redAdd(e.z),r=e.x.redSub(e.z),a=r.redMul(s),o=n.redMul(i),d=t.z.redMul(a.redAdd(o).redSqr()),c=t.x.redMul(a.redISub(o).redSqr());return this.curve.point(d,c)};vs.prototype.mul=function(e){for(var t=e.clone(),s=this,i=this.curve.point(null,null),n=this,r=[];t.cmpn(0)!==0;t.iushrn(1))r.push(t.andln(1));for(var a=r.length-1;a>=0;a--)r[a]===0?(s=s.diffAdd(i,n),i=i.dbl()):(i=s.diffAdd(i,n),s=s.dbl());return i};vs.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")};vs.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")};vs.prototype.eq=function(e){return this.getX().cmp(e.getX())===0};vs.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this};vs.prototype.getX=function(){return this.normalize(),this.x.fromRed()};var QP=Kd,kv=Qi,Vn=mi.exports,Sv=kv.inherits,Sh=QP.base,JP=kv.utils.assert;function Sn(p){this.twisted=(p.a|0)!==1,this.mOneA=this.twisted&&(p.a|0)===-1,this.extended=this.mOneA,Sh.call(this,"edwards",p),this.a=new Vn(p.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new Vn(p.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new Vn(p.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),JP(!this.twisted||this.c.fromRed().cmpn(1)===0),this.oneC=(p.c|0)===1}Sv(Sn,Sh);var e2=Sn;Sn.prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)};Sn.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)};Sn.prototype.jpoint=function(e,t,s,i){return this.point(e,t,s,i)};Sn.prototype.pointFromX=function(e,t){e=new Vn(e,16),e.red||(e=e.toRed(this.red));var s=e.redSqr(),i=this.c2.redSub(this.a.redMul(s)),n=this.one.redSub(this.c2.redMul(this.d).redMul(s)),r=i.redMul(n.redInvm()),a=r.redSqrt();if(a.redSqr().redSub(r).cmp(this.zero)!==0)throw new Error("invalid point");var o=a.fromRed().isOdd();return(t&&!o||!t&&o)&&(a=a.redNeg()),this.point(e,a)};Sn.prototype.pointFromY=function(e,t){e=new Vn(e,16),e.red||(e=e.toRed(this.red));var s=e.redSqr(),i=s.redSub(this.one),n=s.redMul(this.d).redAdd(this.one),r=i.redMul(n.redInvm());if(r.cmp(this.zero)===0){if(t)throw new Error("invalid point");return this.point(this.zero,e)}var a=r.redSqrt();if(a.redSqr().redSub(r).cmp(this.zero)!==0)throw new Error("invalid point");return a.isOdd()!==t&&(a=a.redNeg()),this.point(a,e)};Sn.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),s=e.y.redSqr(),i=t.redMul(this.a).redAdd(s),n=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(s)));return i.cmp(n)===0};function ut(p,e,t,s,i){Sh.BasePoint.call(this,p,"projective"),e===null&&t===null&&s===null?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new Vn(e,16),this.y=new Vn(t,16),this.z=s?new Vn(s,16):this.curve.one,this.t=i&&new Vn(i,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}Sv(ut,Sh.BasePoint);Sn.prototype.pointFromJSON=function(e){return ut.fromJSON(this,e)};Sn.prototype.point=function(e,t,s,i){return new ut(this,e,t,s,i)};ut.fromJSON=function(e,t){return new ut(e,t[0],t[1],t[2])};ut.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"};ut.prototype.isInfinity=function(){return this.x.cmpn(0)===0&&this.y.cmp(this.z)===0};ut.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),s=this.z.redSqr();s=s.redIAdd(s);var i=this.curve._mulA(e),n=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),r=i.redAdd(t),a=r.redSub(s),o=i.redSub(t),d=n.redMul(a),c=r.redMul(o),u=n.redMul(o),h=a.redMul(r);return this.curve.point(d,c,h,u)};ut.prototype._projDbl=function(){var e=this.x.redAdd(this.y).redSqr(),t=this.x.redSqr(),s=this.y.redSqr(),i,n,r;if(this.curve.twisted){var a=this.curve._mulA(t),o=a.redAdd(s);if(this.zOne)i=e.redSub(t).redSub(s).redMul(o.redSub(this.curve.two)),n=o.redMul(a.redSub(s)),r=o.redSqr().redSub(o).redSub(o);else{var d=this.z.redSqr(),c=o.redSub(d).redISub(d);i=e.redSub(t).redISub(s).redMul(c),n=o.redMul(a.redSub(s)),r=o.redMul(c)}}else{var a=t.redAdd(s),d=this.curve._mulC(this.c.redMul(this.z)).redSqr(),c=a.redSub(d).redSub(d);i=this.curve._mulC(e.redISub(a)).redMul(c),n=this.curve._mulC(a).redMul(t.redISub(s)),r=a.redMul(c)}return this.curve.point(i,n,r)};ut.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()};ut.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),s=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),i=this.t.redMul(this.curve.dd).redMul(e.t),n=this.z.redMul(e.z.redAdd(e.z)),r=s.redSub(t),a=n.redSub(i),o=n.redAdd(i),d=s.redAdd(t),c=r.redMul(a),u=o.redMul(d),h=r.redMul(d),f=a.redMul(o);return this.curve.point(c,u,f,h)};ut.prototype._projAdd=function(e){var t=this.z.redMul(e.z),s=t.redSqr(),i=this.x.redMul(e.x),n=this.y.redMul(e.y),r=this.curve.d.redMul(i).redMul(n),a=s.redSub(r),o=s.redAdd(r),d=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(n),c=t.redMul(a).redMul(d),u,h;return this.curve.twisted?(u=t.redMul(o).redMul(n.redSub(this.curve._mulA(i))),h=a.redMul(o)):(u=t.redMul(o).redMul(n.redSub(i)),h=this.curve._mulC(a).redMul(o)),this.curve.point(c,u,h)};ut.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)};ut.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)};ut.prototype.mulAdd=function(e,t,s){return this.curve._wnafMulAdd(1,[this,t],[e,s],2,!1)};ut.prototype.jmulAdd=function(e,t,s){return this.curve._wnafMulAdd(1,[this,t],[e,s],2,!0)};ut.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this};ut.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())};ut.prototype.getX=function(){return this.normalize(),this.x.fromRed()};ut.prototype.getY=function(){return this.normalize(),this.y.fromRed()};ut.prototype.eq=function(e){return this===e||this.getX().cmp(e.getX())===0&&this.getY().cmp(e.getY())===0};ut.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(this.x.cmp(t)===0)return!0;for(var s=e.clone(),i=this.curve.redN.redMul(this.z);;){if(s.iadd(this.curve.n),s.cmp(this.curve.p)>=0)return!1;if(t.redIAdd(i),this.x.cmp(t)===0)return!0}return!1};ut.prototype.toP=ut.prototype.normalize;ut.prototype.mixedAdd=ut.prototype.add;(function(p){var e=p;e.base=$P,e.short=jP,e.mont=ZP,e.edwards=e2})(Kd);var Jm={};(function(p){var e=p,t=Qi,s=t.utils.assert;function i(a){a.type==="short"?this.curve=new t.curve.short(a):a.type==="edwards"?this.curve=new t.curve.edwards(a):this.curve=new t.curve.mont(a),this.g=this.curve.g,this.n=this.curve.n,this.hash=a.hash,s(this.g.validate(),"Invalid curve"),s(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}e.PresetCurve=i;function n(a,o){Object.defineProperty(e,a,{configurable:!0,enumerable:!0,get:function(){var d=new i(o);return Object.defineProperty(e,a,{configurable:!0,enumerable:!0,value:d}),d}})}n("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:"SHA256",gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),n("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:"SHA256",gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),n("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:"SHA256",gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),n("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:"SHA384",gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),n("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:"SHA512",gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),n("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["9"]}),n("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var r;try{r=require("./precomputed/secp256k1")}catch{r=void 0}n("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:"SHA256",beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})})(Jm);var Ai=co.exports,vv=oa.assert,t2=oa,{byteArrayToWordArray:M0}=oo.exports;const s2=Ai.enc.Utf8.parse(""),i2=Ai.enc.Utf8.parse("\0");function lr(p){if(!(this instanceof lr))return new lr(p);this.hash=p.hash,this.predResist=!!p.predResist,this.outLen=this.hash.slice(3,6),this.minEntropy=p.minEntropy||192,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var e=p.entropy,t=p.nonce,s=[];vv(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(e,t,s)}var n2=lr;lr.prototype._init=function(e,t,s){var i=e.concat(t).concat(s);this.K=new Ai.lib.WordArray.init,this.V=new Ai.lib.WordArray.init;const n=(1<<24)+(1<<16)+(1<<8)+1;this.V.words=Array(this.outLen/32).fill(n),this.V.sigBytes=32,this._update(i),this._reseed=1,this.reseedInterval=281474976710656};lr.prototype._hmac=function(){return new Ai.lib.WordArray.init};lr.prototype._update=function(e){var t=this._hmac();t.concat(this.V),t.concat(i2),e&&t.concat(M0(e)),this.K=Ai["Hmac"+this.hash](t,this.K),this.V=Ai["Hmac"+this.hash](this.V,this.K),e&&(t=this._hmac(),t.concat(this.V),t.concat(s2),t.concat(M0(e)),this.K=Ai["Hmac"+this.hash](t,this.K),this.V=Ai["Hmac"+this.hash](this.V,this.K))};lr.prototype.reseed=function(e,t,s,i){typeof t!="string"&&(s=t,t=null),vv(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(s||[])),this._reseed=1};lr.prototype.generate=function(e,t,s,i){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");typeof t!="string"&&(s=t,t=null),s&&(s=Ai.enc.Utf8.parse(s),this._update(s));for(var n=new Ai.lib.WordArray.init;n.sigBytes<e;)this.V=Ai["Hmac"+this.hash](this.V,this.K),n.concat(this.V);return this._update(s),this._reseed++,t2.wordArrayToBuffer(n)};var r2=mi.exports,a2=Qi,o2=a2.utils,P0=o2.assert;function Ds(p,e){this.ec=p,this.priv=null,this.pub=null,e.priv&&this._importPrivate(e.priv,e.privEnc),e.pub&&this._importPublic(e.pub,e.pubEnc)}var d2=Ds;Ds.fromPublic=function(e,t,s){return t instanceof Ds?t:new Ds(e,{pub:t,pubEnc:s})};Ds.fromPrivate=function(e,t,s){return t instanceof Ds?t:new Ds(e,{priv:t,privEnc:s})};Ds.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}};Ds.prototype.getPublic=function(e,t){return typeof e=="string"&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub};Ds.prototype.getPrivate=function(e){return e==="hex"?this.priv.toString(16,2):this.priv};Ds.prototype._importPrivate=function(e,t){this.priv=new r2(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)};Ds.prototype._importPublic=function(e,t){if(e.x||e.y){this.ec.curve.type==="mont"?P0(e.x,"Need x coordinate"):(this.ec.curve.type==="short"||this.ec.curve.type==="edwards")&&P0(e.x&&e.y,"Need both x and y coordinate"),this.pub=this.ec.curve.point(e.x,e.y);return}this.pub=this.ec.curve.decodePoint(e,t)};Ds.prototype.derive=function(e){return e.mul(this.priv).getX()};Ds.prototype.sign=function(e,t,s){return this.ec.sign(e,this,t,s)};Ds.prototype.verify=function(e,t){return this.ec.verify(e,t,this)};Ds.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"};var A0=mi.exports,c2=Qi,u2=c2.utils,h2=u2.assert;function Tv(p,e){if(p instanceof Tv)return p;h2(p.r&&p.s,"Signature without r or s"),this.r=new A0(p.r,16),this.s=new A0(p.s,16),p.recoveryParam===void 0?this.recoveryParam=null:this.recoveryParam=p.recoveryParam}var f2=Tv,ea=mi.exports,Ov=n2,Wu=Qi,l2=Wu.utils,Iv=l2.assert,eg=d2,vh=f2;function Bi(p){if(!(this instanceof Bi))return new Bi(p);typeof p=="string"&&(Iv(Wu.curves.hasOwnProperty(p),"Unknown curve "+p),p=Wu.curves[p]),p instanceof Wu.curves.PresetCurve&&(p={curve:p}),this.curve=p.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=p.curve.g,this.g.precompute(p.curve.n.bitLength()+1),this.hash=p.hash||p.curve.hash}var p2=Bi;Bi.prototype.keyPair=function(e){return new eg(this,e)};Bi.prototype.keyFromPrivate=function(e,t){return eg.fromPrivate(this,e,t)};Bi.prototype.keyFromPublic=function(e,t){return eg.fromPublic(this,e,t)};Bi.prototype.genKeyPair=function(e){e||(e={});var t=new Ov({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||null,entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),s=this.n.byteLength(),i=this.n.sub(new ea(2));do{var n=new ea(t.generate(s));if(!(n.cmp(i)>0))return n.iaddn(1),this.keyFromPrivate(n)}while(!0)};Bi.prototype._truncateToN=function(e,t){var s=e.byteLength()*8-this.n.bitLength();return s>0&&(e=e.ushrn(s)),!t&&e.cmp(this.n)>=0?e.sub(this.n):e};Bi.prototype.sign=function(e,t,s,i){typeof s=="object"&&(i=s,s=null),i||(i={}),t=this.keyFromPrivate(t,s),e=this._truncateToN(new ea(e,16));for(var n=this.n.byteLength(),r=t.getPrivate().toArray("be",n),a=e.toArray("be",n),o=new Ov({hash:this.hash,entropy:i.extraEntropy?r.concat(i.extraEntropy):r,nonce:a,pers:i.pers,persEnc:i.persEnc||"utf8"}),d=this.n.sub(new ea(1)),c=0;;c++){var u=i.k?i.k(c):new ea(o.generate(this.n.byteLength()));if(u=this._truncateToN(u,!0),!(u.cmpn(1)<=0||u.cmp(d)>=0)){var h=this.g.mul(u);if(!h.isInfinity()){var f=h.getX(),l=f.umod(this.n);if(l.cmpn(0)!==0){var m=u.invm(this.n).mul(l.mul(t.getPrivate()).iadd(e));if(m=m.umod(this.n),m.cmpn(0)!==0){var g=(h.getY().isOdd()?1:0)|(f.cmp(l)!==0?2:0);return i.canonical&&m.cmp(this.nh)>0&&(m=this.n.sub(m),g^=1),new vh({r:l,s:m,recoveryParam:g})}}}}}};Bi.prototype.verify=function(e,t,s,i){e=this._truncateToN(new ea(e,16)),s=this.keyFromPublic(s,i),t=new vh(t);var n=t.r,r=t.s;if(n.cmpn(1)<0||n.cmp(this.n)>=0||r.cmpn(1)<0||r.cmp(this.n)>=0)return!1;var a=r.invm(this.n),o=a.mul(e).umod(this.n),d=a.mul(n).umod(this.n);if(!this.curve._maxwellTrick){var c=this.g.mulAdd(o,s.getPublic(),d);return c.isInfinity()?!1:c.getX().umod(this.n).cmp(n)===0}var c=this.g.jmulAdd(o,s.getPublic(),d);return c.isInfinity()?!1:c.eqXToP(n)};Bi.prototype.recoverPubKey=function(p,e,t,s){Iv((3&t)===t,"The recovery param is more than two bits"),e=new vh(e);var i=this.n,n=new ea(p),r=e.r,a=e.s,o=t&1,d=t>>1;if(r.cmp(this.curve.p.umod(this.curve.n))>=0&&d)throw new Error("Unable to find sencond key candinate");d?r=this.curve.pointFromX(r.add(this.curve.n),o):r=this.curve.pointFromX(r,o);var c=e.r.invm(i),u=i.sub(n).mul(c).umod(i),h=a.mul(c).umod(i);return this.g.mulAdd(u,r,h)};Bi.prototype.getKeyRecoveryParam=function(p,e,t,s){if(e=new vh(e),e.recoveryParam!==null)return e.recoveryParam;for(var i=0;i<4;i++){var n;try{n=this.recoverPubKey(p,e,i)}catch{continue}if(n.eq(t))return i}throw new Error("Unable to find valid recovery factor")};var Yd=oa,tg=Yd.assert,B0=Yd.parseBytes,yo=Yd.cachedProperty;function gs(p,e){this.eddsa=p,this._secret=B0(e.secret),p.isPoint(e.pub)?this._pub=e.pub:this._pubBytes=B0(e.pub)}gs.fromPublic=function(e,t){return t instanceof gs?t:new gs(e,{pub:t})};gs.fromSecret=function(e,t){return t instanceof gs?t:new gs(e,{secret:t})};gs.prototype.secret=function(){return this._secret};yo(gs,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())});yo(gs,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())});yo(gs,"privBytes",function(){var e=this.eddsa,t=this.hash(),s=e.encodingLength-1,i=t.slice(0,e.encodingLength);return i[0]&=248,i[s]&=127,i[s]|=64,i});yo(gs,"priv",function(){return this.eddsa.decodeInt(this.privBytes())});yo(gs,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()});yo(gs,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)});gs.prototype.sign=function(e){return tg(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)};gs.prototype.signModified=function(e){return tg(this._secret,"KeyPair can only verify"),this.eddsa.signModified(e,this)};gs.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)};gs.prototype.getSecret=function(e){return tg(this._secret,"KeyPair is public only"),Yd.encode(this.secret(),e)};gs.prototype.getPublic=function(e){return Yd.encode(this.pubBytes(),e)};var m2=gs,g2=mi.exports,Th=oa,y2=Th.assert,Oh=Th.cachedProperty,w2=Th.parseBytes;function da(p,e){this.eddsa=p,typeof e!="object"&&(e=w2(e)),Array.isArray(e)&&(e={R:e.slice(0,p.encodingLength),S:e.slice(p.encodingLength)}),y2(e.R&&e.S,"Signature without R or S"),p.isPoint(e.R)&&(this._R=e.R),e.S instanceof g2&&(this._S=e.S),this._Rencoded=Array.isArray(e.R)?e.R:e.Rencoded,this._Sencoded=Array.isArray(e.S)?e.S:e.Sencoded}Oh(da,"S",function(){return this.eddsa.decodeInt(this.Sencoded())});Oh(da,"R",function(){return this.eddsa.decodePoint(this.Rencoded())});Oh(da,"Rencoded",function(){return this.eddsa.encodePoint(this.R())});Oh(da,"Sencoded",function(){return this.eddsa.encodeInt(this.S())});da.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())};da.prototype.toHex=function(){return Th.encode(this.toBytes(),"hex").toUpperCase()};var b2=da,k2=Jm,so=oa,S2=so.assert,sg=so.parseBytes,xv=m2,N0=b2;const v2=mi.exports,{byteArrayToWordArray:T2}=oo.exports,V0=co.exports;function Xs(p){if(S2(p==="ed25519","only tested with ed25519 so far"),!(this instanceof Xs))return new Xs(p);var e=k2[p].curve;this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8)}var O2=Xs;Xs.prototype.sign=function(e,t){e=sg(e);var s=this.keyFromSecret(t),i=this.hashInt(s.secret(),e),n=this.g.mul(i),r=this.encodePoint(n),a=this.hashInt(r,s.pubBytes(),e);a=a.mul(s.priv());var o=i.add(a).umod(this.curve.n);return this.makeSignature({R:n,S:o,Rencoded:r})};Xs.prototype.signModified=function(e,t){e=sg(e);var s=this.keyFromSecret(t);const i=new v2(s.secret(),16,"le"),n=this.encodePoint(this.g.mul(i)),r=n[31]&128;var a=this.hashInt(s.secret(),e),o=this.g.mul(a),d=this.encodePoint(o);let c=this.hashInt(d,n,e);c=c.mul(i);var u=a.add(c).umod(this.curve.n),h=u.toArray("le",32);return h[31]|=r,this.makeSignature({R:o,S:u,Rencoded:d,Sencoded:h})};Xs.prototype.verify=function(e,t,s){e=sg(e),t=this.makeSignature(t);var i=this.keyFromPublic(s),n=this.hashInt(t.Rencoded(),i.pubBytes(),e),r=this.g.mul(t.S()),a=t.R().add(i.pub().mul(n));return a.eq(r)};Xs.prototype.hashInt=function(){let e=Array.from(arguments).reduce((s,i)=>s.concat(i));e=T2(e);const t=V0.SHA512(e).toString(V0.enc.Hex);return so.intFromLE(t).umod(this.curve.n)};Xs.prototype.keyFromPublic=function(e){return xv.fromPublic(this,e)};Xs.prototype.keyFromSecret=function(e){return xv.fromSecret(this,e)};Xs.prototype.makeSignature=function(e){return e instanceof N0?e:new N0(this,e)};Xs.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t};Xs.prototype.decodePoint=function(e){e=so.parseBytes(e);var t=e.length-1,s=e.slice(0,t).concat(e[t]&-129),i=(e[t]&128)!==0,n=so.intFromLE(s);return this.curve.pointFromY(n,i)};Xs.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)};Xs.prototype.decodeInt=function(e){return so.intFromLE(e)};Xs.prototype.isPoint=function(e){return e instanceof this.pointClass};(function(p){var e=p;function t(s,i){s.super_=i;var n=function(){};n.prototype=i.prototype,s.prototype=new n,s.prototype.constructor=s}e.inherits=t,e.version="6.5.0",e.utils=oa,e.curve=Kd,e.curves=Jm,e.ec=p2,e.eddsa=O2})(Qi);const I2={BaseError:{ExchangeError:{AuthenticationError:{PermissionDenied:{AccountNotEnabled:{}},AccountSuspended:{}},ArgumentsRequired:{},BadRequest:{BadSymbol:{},MarginModeAlreadySet:{}},BadResponse:{NullResponse:{}},InsufficientFunds:{},InvalidAddress:{AddressPending:{}},InvalidOrder:{OrderNotFound:{},OrderNotCached:{},CancelPending:{},OrderImmediatelyFillable:{},OrderNotFillable:{},DuplicateOrderId:{}},NotSupported:{}},NetworkError:{DDoSProtection:{RateLimitExceeded:{}},ExchangeNotAvailable:{OnMaintenance:{}},InvalidNonce:{},RequestTimeout:{}}}};var x2=I2;const _2=x2;function _v(p,e,t={}){for(const[s,i]of Object.entries(e)){const n=Object.assign(t,{[s]:class extends p{constructor(r){super(r),this.constructor=n,this.__proto__=n.prototype,this.name=s,this.message=r,Object.setPrototypeOf(this,n.prototype)}}})[s];_v(n,i,t)}return t}var Q=_v(Error,_2);const io=co.exports,{capitalize:vm}=Wm,{stringToBase64:E0,urlencodeBase64:uc}=oo.exports,C2=HP,{binaryToBase58:M2,byteArrayToWordArray:P2}=oo.exports,Cv=Qi,A2=Cv.ec,B2=Cv.eddsa,hc=mi.exports,Mv=(p,e="md5",t="hex")=>{const s={};e==="keccak"&&(e="SHA3",s.outputLength=256);const i=io[e.toUpperCase()](p,s);return t==="binary"?i:i.toString(io.enc[vm(t)])},ig=(p,e,t="sha256",s="hex")=>{const i=io["Hmac"+t.toUpperCase()](p,e);if(s){const n=s==="binary"?"Latin1":vm(s);return i.toString(io.enc[vm(n)])}return i};function Pv(p,e,t="RS256"){const s={RS256:"pkcs1-sha256",RS512:"pkcs1-sha512"};if(!(t in s))throw new ExchangeError(t+" is not a supported rsa signing algorithm.");const i=s[t];return new C2(e,{environment:"browser",signingScheme:i}).sign(p,"base64","binary")}function N2(p,e,t="HS256"){const s={HS256:"sha256",HS384:"sha384",HS512:"sha512"},i=uc(E0(JSON.stringify({alg:t,typ:"JWT"}))),n=uc(E0(JSON.stringify(p))),r=[i,n].join("."),a=t.slice(0,2),o=s[t];let d;return a==="HS"?d=uc(ig(r,e,o,"base64")):a==="RS"&&(d=uc(Pv(r,e,t))),[r,d].join(".")}function V2(p,e,t="p256",s=void 0,i=!1){let n=p;s!==void 0&&(n=Mv(p,s,"hex"));const r=new A2(t);let a=r.sign(n,e,"hex",{canonical:!0}),o=new hc("0");const d=new hc("1").shln(8*31).sub(new hc("1"));for(;i&&(a.r.gt(r.nh)||a.r.lte(d)||a.s.lte(d));)a=r.sign(n,e,"hex",{canonical:!0,extraEntropy:o.toArray("le",32)}),o=o.add(new hc("1"));return{r:a.r.toString(16).padStart(64,"0"),s:a.s.toString(16).padStart(64,"0"),v:a.recoveryParam}}function E2(p,e,t="ed25519"){const i=new B2(t).signModified(p,e);return M2(P2(i.toBytes()))}const q2=p=>{const e=r=>(r<15.5?"0":"")+Math.round(r).toString(16),t=r=>parseInt(r,16),s=(r,a)=>(a+r).slice(-a.length),i=r=>{let a="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",o="",d="";for(let c=0;c<r.length;c++){let u=a.indexOf(r.charAt(c).toUpperCase());o+=s(u.toString(2),"00000")}for(let c=0;c+4<=o.length;c+=4){let u=o.substr(c,4);d=d+parseInt(u,2).toString(16)}return d};return(r=>{r=r.replace(" ","");let a=Math.round(new Date().getTime()/1e3),o=s(e(Math.floor(a/30)),"0000000000000000"),d=ig(io.enc.Hex.parse(o),io.enc.Hex.parse(i(r)),"sha1","hex"),c=t(d.substring(d.length-1)),u=(t(d.substr(c*2,8))&t("7fffffff"))+"";return u=u.substr(u.length-6,6),u})(p)};function zu(p,e=!1){const t="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";zu.table===void 0&&(zu.table=t.split(" ").map(n=>parseInt(n,16)));let s=-1;for(let n=0;n<p.length;n++)s=s>>>8^zu.table[(s^p.charCodeAt(n))&255];const i=(s^-1)>>>0;return e&&i>=2147483648?i-4294967296:i}var L2={hash:Mv,hmac:ig,jwt:N2,totp:q2,rsa:Pv,ecdsa:V2,eddsa:E2,crc32:zu};const no=Date.now,Av=()=>no()*1e3,R2=no,D2=()=>Math.floor(no()/1e3),F2=()=>{const s=(Av()*10+122192928e9).toString(16),i=s.slice(7,15)+s.slice(3,7)+"1"+s.slice(0,3),n="9696",r="ff".repeat(6);return i+n+r},H2=setTimeout,ju=(p,e,t=H2,s=no()+e)=>{if(e>=2147483647)throw new Error("setTimeout() function was called with unrealistic value of "+e.toString());let i=()=>{},n=!0;const r=t(()=>{n=!0;const a=s-no();a>0?i=ju(p,a,t,s):p()},e);return function(){n&&(n=!1,clearTimeout(r)),i()}};class Ud extends Error{constructor(){const e="timed out";super(e),this.constructor=Ud,this.__proto__=Ud.prototype,this.message=e}}const G2=p=>{let e;if(typeof p=="number"?e=Math.floor(p):e=parseInt(p,10),!(Number.isNaN(e)||e<0))try{return new Date(e).toISOString()}catch{return}},Bv=p=>{if(!(typeof p!="string"||!p)&&!p.match(/^[0-9]+$/)&&!(p.indexOf("-")<0||p.indexOf(":")<0))try{const e=Date.parse(p.indexOf("+")>=0||p.slice(-1)==="Z"?p:(p+"Z").replace(/\s(\d\d):/,"T$1:"));return Number.isNaN(e)?void 0:e}catch{return}},U2=p=>{if(!(typeof p!="string"||!p)){if(p.indexOf("GMT")>=0)try{return Date.parse(p)}catch{return}return Bv(p)}},$2=(p=void 0)=>new Date(p).toUTCString(),W2=(p,e="-")=>{e=e||"";const t=new Date(p),s=t.getUTCFullYear().toString();let i=t.getUTCMonth()+1,n=t.getUTCDate();return i=i<10?"0"+i:i.toString(),n=n<10?"0"+n:n.toString(),i+e+n+e+s},ng=(p,e,t=!0)=>{e=e||"";const s=new Date(p),i=s.getUTCFullYear(),r=(t?i:i-2e3).toString();let a=s.getUTCMonth()+1,o=s.getUTCDate();return a=a<10?"0"+a:a.toString(),o=o<10?"0"+o:o.toString(),r+e+a+e+o},z2=(p,e="")=>ng(p,e,!1),j2=(p,e="-")=>ng(p,e,!0),K2=(p,e=" ")=>{const t=new Date(p),s=t.getUTCFullYear();let i=t.getUTCMonth()+1,n=t.getUTCDate(),r=t.getUTCHours(),a=t.getUTCMinutes(),o=t.getUTCSeconds();return i=i<10?"0"+i:i,n=n<10?"0"+n:n,r=r<10?"0"+r:r,a=a<10?"0"+a:a,o=o<10?"0"+o:o,s+"-"+i+"-"+n+e+r+":"+a+":"+o};var rg={now:no,microseconds:Av,milliseconds:R2,seconds:D2,iso8601:G2,parse8601:Bv,rfc2616:$2,uuidv1:F2,parseDate:U2,mdy:W2,ymd:ng,yymmdd:z2,yyyymmdd:j2,ymdhms:K2,setTimeout_safe:ju,sleep:p=>new Promise(e=>ju(e,p)),TimedOut:Ud,timeout:async(p,e)=>{let t=()=>{};const s=new Promise(i=>t=ju(i,p));try{return await Promise.race([e,s.then(()=>{throw new Ud})])}finally{t()}}};const{now:q0,sleep:X2}=rg;class Y2{constructor(e){this.config={refillRate:1,delay:.001,capacity:1,maxCapacity:2e3,tokens:0,cost:1},Object.assign(this.config,e),this.queue=[],this.running=!1}async loop(){let e=q0();for(;this.running;){const{resolver:t,cost:s}=this.queue[0];if(this.config.tokens>=0)this.config.tokens-=s,t(),this.queue.shift(),await Promise.resolve(),this.queue.length===0&&(this.running=!1);else{await X2(this.config.delay*1e3);const i=q0(),n=i-e;e=i;const r=this.config.tokens+this.config.refillRate*n;this.config.tokens=Math.min(r,this.config.capacity)}}}}function Z2(p){function e(i=void 0){let n;const r=new Promise((a,o)=>{n=a});if(this.queue.length>this.config.maxCapacity)throw new Error("throttle queue is over maxCapacity ("+this.config.maxCapacity.toString()+"), see https://github.com/ccxt/ccxt/issues/11645#issuecomment-1195695526");return i=i===void 0?this.config.cost:i,this.queue.push({resolver:n,cost:i}),this.running||(this.running=!0,this.loop()),r}const t=new Y2(p),s=e.bind(t);return s.config=t.config,s.queue=t.queue,s}var Q2={throttle:Z2};const{ROUND_UP:Nv,ROUND_DOWN:Vv}=ne,{NotSupported:J2}=Q,ag=p=>{const e=p.slice(0,-1),t=p.slice(-1);let s;if(t==="y")s=60*60*24*365;else if(t==="M")s=60*60*24*30;else if(t==="w")s=60*60*24*7;else if(t==="d")s=60*60*24;else if(t==="h")s=60*60;else if(t==="m")s=60;else if(t==="s")s=1;else throw new J2("timeframe unit "+t+" is not supported");return e*s},eA=(p,e,t=Vv)=>{const s=ag(p)*1e3,i=e%s;return e-i+(t===Nv?s:0)},tA=(p,e="1m",t=-1/0,s=1/0)=>{const i=ag(e)*1e3,n=[],[r,,a,o,d,c,u]=[0,1,2,3,4,5,6],h=Math.min(p.length-1,s);for(let f=0;f<=h;f++){const l=p[f];if(l.timestamp<t)continue;const m=Math.floor(l.timestamp/i)*i,g=n.length-1;g===-1||m>=n[g][r]+i?n.push([m,l.price,l.price,l.price,l.price,l.amount,1]):(n[g][a]=Math.max(n[g][a],l.price),n[g][o]=Math.min(n[g][o],l.price),n[g][d]=l.price,n[g][c]+=l.amount,n[g][u]++)}return n},sA=p=>{const e=/{([\w-]+)}/g,t=[];let s=e.exec(p);for(;s;)t.push(s[1]),s=e.exec(p);return t},iA=(p,e)=>{if(!Array.isArray(e)){const t=Object.keys(e);for(let s=0;s<t.length;s++){const i=t[s];Array.isArray(e[i])||(p=p.replace("{"+i+"}",e[i]))}}return p};function nA(p,e){return p!==void 0&&e!==void 0&&p>0?e/p:void 0}var rA={aggregate(p){const e={};for(let t=0;t<p.length;t++){const[s,i]=p[t];i>0&&(e[s]=(e[s]||0)+i)}return Object.keys(e).map(t=>[parseFloat(t),parseFloat(e[t])])},parseTimeframe:ag,roundTimeframe:eA,buildOHLCVC:tA,ROUND_UP:Nv,ROUND_DOWN:Vv,implodeParams:iA,extractParams:sA,vwap:nA};const{unCamelCase:aA}=Wm,oA=p=>{for(const e in p)p[aA(e)]=p[e];return p};var Zd=oA(Object.assign({},SC,ZS,Wm,XS,ne,oo.exports,L2,rg,Q2,rA));const dA=BigInt(0),cA=BigInt(-1),To=BigInt(10);class Le{constructor(e,t=void 0){if(t===void 0){let s=0;e=e.toLowerCase(),e.indexOf("e")>-1&&([e,s]=e.split("e"),s=parseInt(s));const i=e.indexOf(".");this.decimals=i>-1?e.length-i-1:0;const n=e.replace(".","");this.integer=BigInt(n),this.decimals=this.decimals-s}else this.integer=e,this.decimals=t}mul(e){const t=this.integer*e.integer;return new Le(t,this.decimals+e.decimals)}div(e,t=18){const s=t-this.decimals+e.decimals;let i;if(s===0)i=this.integer;else if(s<0){const r=To**BigInt(-s);i=this.integer/r}else{const r=To**BigInt(s);i=this.integer*r}const n=i/e.integer;return new Le(n,t)}add(e){if(this.decimals===e.decimals){const t=this.integer+e.integer;return new Le(t,this.decimals)}else{const[t,s]=this.decimals>e.decimals?[e,this]:[this,e],i=s.decimals-t.decimals,r=t.integer*To**BigInt(i)+s.integer;return new Le(r,s.decimals)}}mod(e){const t=Math.max(-this.decimals+e.decimals,0),s=this.integer*To**BigInt(t),i=Math.max(-e.decimals+this.decimals,0),n=e.integer*To**BigInt(i),r=s%n;return new Le(r,i+e.decimals)}sub(e){const t=new Le(-e.integer,e.decimals);return this.add(t)}abs(){return new Le(this.integer<0?this.integer*cA:this.integer,this.decimals)}neg(){return new Le(-this.integer,this.decimals)}min(e){return this.lt(e)?this:e}max(e){return this.gt(e)?this:e}gt(e){return this.sub(e).integer>0}ge(e){return this.sub(e).integer>=0}lt(e){return e.gt(this)}le(e){return e.ge(this)}reduce(){const e=this.integer.toString(),t=e.length-1;if(t===0)return e==="0"&&(this.decimals=0),this;let s;for(s=t;s>=0&&e.charAt(s)==="0";s--);const i=t-s;if(i===0)return this;this.decimals-=i,this.integer=BigInt(e.slice(0,s+1))}equals(e){return this.reduce(),e.reduce(),this.decimals===e.decimals&&this.integer===e.integer}toString(){this.reduce();let e,t;this.integer<0?(e="-",t=-this.integer):(e="",t=this.integer);const s=Array.from(t.toString(this.base).padStart(this.decimals,"0")),i=s.length-this.decimals;let n;return i===0?n="0.":this.decimals<0?n="0".repeat(-this.decimals):this.decimals===0?n="":n=".",s.splice(i,0,n),e+s.join("")}static stringMul(e,t){if(!(e===void 0||t===void 0))return new Le(e).mul(new Le(t)).toString()}static stringDiv(e,t,s=18){if(e===void 0||t===void 0)return;const i=new Le(t);if(i.integer!==dA)return new Le(e).div(i,s).toString()}static stringAdd(e,t){if(!(e===void 0&&t===void 0))return e===void 0?t:t===void 0?e:new Le(e).add(new Le(t)).toString()}static stringSub(e,t){if(!(e===void 0||t===void 0))return new Le(e).sub(new Le(t)).toString()}static stringAbs(e){if(e!==void 0)return new Le(e).abs().toString()}static stringNeg(e){if(e!==void 0)return new Le(e).neg().toString()}static stringMod(e,t){if(!(e===void 0||t===void 0))return new Le(e).mod(new Le(t)).toString()}static stringEquals(e,t){if(!(e===void 0||t===void 0))return new Le(e).equals(new Le(t))}static stringEq(e,t){if(!(e===void 0||t===void 0))return new Le(e).equals(new Le(t))}static stringMin(e,t){if(!(e===void 0||t===void 0))return new Le(e).min(new Le(t)).toString()}static stringMax(e,t){if(!(e===void 0||t===void 0))return new Le(e).max(new Le(t)).toString()}static stringGt(e,t){if(!(e===void 0||t===void 0))return new Le(e).gt(new Le(t))}static stringGe(e,t){if(!(e===void 0||t===void 0))return new Le(e).ge(new Le(t))}static stringLt(e,t){if(!(e===void 0||t===void 0))return new Le(e).lt(new Le(t))}static stringLe(e,t){if(!(e===void 0||t===void 0))return new Le(e).le(new Le(t))}}var ae=Le;const og=Zd,{isNode:fa,clone:bf,unCamelCase:uA,throttle:hA,timeout:fA,TimedOut:lA,defaultFetch:Oo}=og,{ExchangeError:br,BadSymbol:kf,NullResponse:L0,InvalidAddress:Sf,InvalidOrder:R0,NotSupported:Oe,AuthenticationError:fc,DDoSProtection:pA,RequestTimeout:vf,ExchangeNotAvailable:ys,RateLimitExceeded:mA,ArgumentsRequired:nn}=Q,{TRUNCATE:D0,ROUND:Tf,DECIMAL_PLACES:F0,NO_PADDING:gA,TICK_SIZE:yA}=og.precisionConstants,Ve=ae;var re=class Tm{describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!0,rateLimit:2e3,certified:!1,pro:!1,alias:!1,has:{publicAPI:!0,privateAPI:!0,CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createPostOnlyOrder:void 0,createReduceOnlyOrder:void 0,createStopOrder:void 0,createStopLimitOrder:void 0,createStopMarketOrder:void 0,editOrder:"emulated",fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRatesPerSymbol:void 0,fetchBorrowRates:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:"emulated",fetchDeposit:void 0,fetchDepositAddress:void 0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:"emulated",fetchOpenInterest:void 0,fetchOpenInterestHistory:void 0,fetchOpenOrder:void 0,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPermissions:void 0,fetchPosition:void 0,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:"emulated",fetchTicker:!0,fetchTickers:void 0,fetchTime:void 0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:void 0,fetchTradingLimits:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawAddresses:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,reduceMargin:void 0,setLeverage:void 0,setMargin:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:br,418:pA,429:mA,404:ys,409:ys,410:ys,451:ys,500:ys,501:ys,502:ys,520:ys,521:ys,522:ys,525:ys,526:ys,400:ys,403:ys,405:ys,503:ys,530:ys,408:vf,504:vf,401:fc,407:fc,511:fc},commonCurrencies:{XBT:"BTC",BCC:"BCH",BCHABC:"BCH",BCHSV:"BSV"},precisionMode:F0,paddingMode:gA,limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}constructor(e={}){Object.assign(this,og),this.options=this.getDefaultOptions(),this.fetchOptions={},this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36",chrome100:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36"},this.headers={},this.proxy="",this.origin="*",this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.fetchImplementation=Oo,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.debug=!1,this.userAgent=void 0,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.orders=void 0,this.trades={},this.transactions={},this.ohlcvs={},this.myTrades=void 0,this.positions={},this.requiresWeb3=!1,this.requiresEddsa=!1,this.precision={},this.lastRestRequestTimestamp=0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0;const t=(r=this)=>{if(r!==null){const a=Object.getOwnPropertyNames(r);for(let o=0;o<a.length;o++){const d=a[o];this[uA(d)]=this[d]}t(Object.getPrototypeOf(r))}};t();const s=Object.entries(this.describe()).concat(Object.entries(e));for(let r=0;r<s.length;r++){const[a,o]=s[r];o&&Object.getPrototypeOf(o)===Object.prototype?this[a]=this.deepExtend(this[a],o):this[a]=o}const i={keepAlive:!0};this.validateServerSsl||(i.rejectUnauthorized=!1),!this.httpAgent&&Oo.http&&fa&&(this.httpAgent=new Oo.http.Agent(i)),!this.httpsAgent&&Oo.https&&fa&&(this.httpsAgent=new Oo.https.Agent(i));const n=Object.keys(this.has);for(let r=0;r<n.length;r++){const a=n[r];this["has"+this.capitalize(a)]=!!this.has[a]}this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets)}encodeURIComponent(...e){return encodeURIComponent(...e)}checkRequiredVersion(e,t=!0){let s=!0;const[i,n,r]=e.split("."),[a,o,d]=Tm.ccxtVersion.split("."),c=parseInt(i),u=parseInt(n),h=parseInt(r),f=parseInt(a),l=parseInt(o),m=parseInt(d);if(c>f&&(s=!1),c===f&&(u>l||u===l&&h>m)&&(s=!1),!s){if(t)throw new Oe("Your current version of CCXT is "+Tm.ccxtVersion+", a newer version "+e+" is required, please, upgrade your version of CCXT");return t}return s}checkAddress(e){if(e===void 0)throw new Sf(this.id+" address is undefined");if(this.unique(e).length===1||e.length<this.minFundingAddressLength||e.includes(" "))throw new Sf(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+this.json(e)+'"');return e}initRestRateLimiter(){if(this.rateLimit===void 0)throw new Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({delay:.001,capacity:1,cost:1,maxCapacity:1e3,refillRate:this.rateLimit>0?1/this.rateLimit:Number.MAX_VALUE},this.tokenBucket),this.throttle=hA(this.tokenBucket),this.executeRestRequest=(e,t="GET",s=void 0,i=void 0)=>{const n=this.fetchImplementation,r={method:t,headers:s,body:i,timeout:this.timeout};this.agent?r.agent=this.agent:this.httpAgent&&e.indexOf("http://")===0?r.agent=this.httpAgent:this.httpsAgent&&e.indexOf("https://")===0&&(r.agent=this.httpsAgent);const a=n(e,this.extend(r,this.fetchOptions)).catch(o=>{throw fa?new ys([this.id,t,e,o.type,o.message].join(" ")):o}).then(o=>this.handleRestResponse(o,e,t,s,i));return fA(this.timeout,a).catch(o=>{throw o instanceof lA?new vf(this.id+" "+t+" "+e+" request timed out ("+this.timeout+" ms)"):o})}}setSandboxMode(e){if(e)if("test"in this.urls)typeof this.urls.api=="string"?(this.urls.apiBackup=this.urls.api,this.urls.api=this.urls.test):(this.urls.apiBackup=bf(this.urls.api),this.urls.api=bf(this.urls.test));else throw new Oe(this.id+" does not have a sandbox URL");else"apiBackup"in this.urls&&(typeof this.urls.api=="string"?this.urls.api=this.urls.apiBackup:this.urls.api=bf(this.urls.apiBackup))}defineRestApiEndpoint(e,t,s,i,n,r,a={}){const o=n.split(/[^a-zA-Z0-9]/),d=o.map(this.capitalize).join(""),c=o.map(y=>y.trim().toLowerCase()).filter(y=>y.length>0).join("_"),u=[r[0]].concat(r.slice(1).map(this.capitalize)).join(""),h=[r[0]].concat(r.slice(1).map(y=>y.trim()).filter(y=>y.length>0)).join("_"),f=u+i+this.capitalize(d),l=h+"_"+s+"_"+c,m=r.length>1?r:r[0],g=async(y={},w={})=>this[e](n,m,t,y,void 0,void 0,a,w);this[f]=g,this[l]=g}defineRestApi(e,t,s=[]){const i=Object.keys(e);for(let n=0;n<i.length;n++){const r=i[n],a=e[r],o=r.toUpperCase(),d=r.toLowerCase(),c=this.capitalize(d);if(Array.isArray(a))for(let u=0;u<a.length;u++){const h=a[u].trim();this.defineRestApiEndpoint(t,o,d,c,h,s)}else if(r.match(/^(?:get|post|put|delete|head|patch)$/i)){const u=Object.keys(a);for(let h=0;h<u.length;h++){const f=u[h],l=f.trim(),m=a[f];if(typeof m=="object")this.defineRestApiEndpoint(t,o,d,c,l,s,m);else if(typeof m=="number")this.defineRestApiEndpoint(t,o,d,c,l,s,{cost:m});else throw new Oe(this.id+" defineRestApi() API format is not supported, API leafs must strings, objects or numbers")}}else this.defineRestApi(a,t,s.concat([r]))}}log(...e){console.log(...e)}fetch(e,t="GET",s=void 0,i=void 0){return fa&&this.userAgent&&(typeof this.userAgent=="string"?s=this.extend({"User-Agent":this.userAgent},s):typeof this.userAgent=="object"&&"User-Agent"in this.userAgent&&(s=this.extend(this.userAgent,s))),typeof this.proxy=="function"?(e=this.proxy(e),fa&&(s=this.extend({Origin:this.origin},s))):typeof this.proxy=="string"&&(this.proxy.length&&fa&&(s=this.extend({Origin:this.origin},s)),e=this.proxy+e),s=this.extend(this.headers,s),s=this.setHeaders(s),this.verbose&&this.log(`fetch Request:
`,this.id,t,e,`
RequestHeaders:
`,s,`
RequestBody:
`,i,`
`),this.executeRestRequest(e,t,s,i)}parseJson(e){try{if(this.isJsonEncodedObject(e))return JSON.parse(this.onJsonResponse(e))}catch{return}}getResponseHeaders(e){const t={};return e.headers.forEach((s,i)=>{i=i.split("-").map(n=>this.capitalize(n)).join("-"),t[i]=s}),t}handleRestResponse(e,t,s="GET",i=void 0,n=void 0){const r=this.getResponseHeaders(e);if(this.handleContentTypeApplicationZip&&r["Content-Type"]==="application/zip"){const a=e.buffer();return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,"ZIP redacted",`
`),a}return e.text().then(a=>{const o=this.onRestResponse(e.status,e.statusText,t,s,r,a,i,n),d=this.parseJson(o);return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.enableLastJsonResponse&&(this.last_json_response=d),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,`
ResponseBody:
`,a,`
`),this.handleErrors(e.status,e.statusText,t,s,r,a,d,i,n)||this.handleHttpStatusCode(e.status,e.statusText,t,s,a),d||a})}onRestResponse(e,t,s,i,n,r,a,o){return r.trim()}onJsonResponse(e){return this.quoteJsonNumbers?e.replace(/":([+.0-9eE-]+)([,}])/g,'":"$1"$2'):e}async loadMarketsHelper(e=!1,t={}){if(!e&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);let s;this.has.fetchCurrencies===!0&&(s=await this.fetchCurrencies());const i=await this.fetchMarkets(t);return this.setMarkets(i,s)}loadMarkets(e=!1,t={}){return(e&&!this.reloadingMarkets||!this.marketsLoading)&&(this.reloadingMarkets=!0,this.marketsLoading=this.loadMarketsHelper(e,t).then(s=>(this.reloadingMarkets=!1,s),s=>{throw this.reloadingMarkets=!1,s})),this.marketsLoading}fetchCurrencies(e={}){return new Promise((t,s)=>t(this.currencies))}fetchMarkets(e={}){return new Promise((t,s)=>t(Object.values(this.markets)))}filterBySinceLimit(e,t=void 0,s=void 0,i="timestamp",n=!1){return t!=null&&(e=e.filter(a=>a[i]>=t)),s!=null&&(e=n?e.slice(-s):e.slice(0,s)),e}filterByValueSinceLimit(e,t,s=void 0,i=void 0,n=void 0,r="timestamp",a=!1){const o=s!=null,d=i!=null;return(o||d)&&(e=e.filter(c=>(o?c[t]===s:!0)&&(d?c[r]>=i:!0))),n!=null&&(e=a?e.slice(-n):e.slice(0,n)),e}checkRequiredDependencies(){}remove0xPrefix(e){return e.slice(0,2)==="0x"?e.slice(2):e}hashMessage(e){const t=this.base16ToBinary(this.remove0xPrefix(e)),s=this.stringToBinary(`Ethereum Signed Message:
`+t.sigBytes);return"0x"+this.hash(this.binaryConcat(s,t),"keccak","hex")}signHash(e,t){const s=this.ecdsa(e.slice(-64),t.slice(-64),"secp256k1",void 0);return{r:"0x"+s.r,s:"0x"+s.s,v:27+s.v}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}signMessageString(e,t){const s=this.signMessage(e,t);return s.r+this.remove0xPrefix(s.s)+this.binaryToBase16(this.numberToBE(s.v))}parseNumber(e,t=void 0){if(e===void 0)return t;try{return this.number(e)}catch{return t}}checkOrderArguments(e,t,s,i,n,r){if(n===void 0&&t==="limit")throw new nn(this.id+" createOrder() requires a price argument for a limit order");if(i<=0)throw new nn(this.id+" createOrder() amount should be above 0")}handleHttpStatusCode(e,t,s,i,n){const r=e.toString();if(r in this.httpExceptions){const a=this.httpExceptions[r];throw new a(this.id+" "+i+" "+s+" "+r+" "+t+" "+n)}}getDefaultOptions(){return{defaultNetworkCodeReplacements:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"},CRO:{CRC20:"CRONOS"}}}}safeLedgerEntry(e,t=void 0){t=this.safeCurrency(void 0,t);let s=this.safeString(e,"direction"),i=this.safeString(e,"before"),n=this.safeString(e,"after");const r=this.safeString(e,"amount");r!==void 0&&(i===void 0&&n!==void 0?i=Ve.stringSub(n,r):i!==void 0&&n===void 0&&(n=Ve.stringAdd(i,r))),i!==void 0&&n!==void 0&&s===void 0&&(Ve.stringGt(i,n)&&(s="out"),Ve.stringGt(n,i)&&(s="in"));const a=this.safeValue(e,"fee");a!==void 0&&(a.cost=this.safeNumber(a,"cost"));const o=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"id"),timestamp:o,datetime:this.iso8601(o),direction:s,account:this.safeString(e,"account"),referenceId:this.safeString(e,"referenceId"),referenceAccount:this.safeString(e,"referenceAccount"),type:this.safeString(e,"type"),currency:t.code,amount:this.parseNumber(r),before:this.parseNumber(i),after:this.parseNumber(n),status:this.safeString(e,"status"),fee:a,info:e}}setMarkets(e,t=void 0){const s=[];this.markets_by_id={};const i=this.sortBy(this.toArray(e),"spot",!0);for(let o=0;o<i.length;o++){const d=i[o];d.id in this.markets_by_id?this.markets_by_id[d.id].push(d):this.markets_by_id[d.id]=[d];const c=this.deepExtend(this.safeMarket(),{precision:this.precision,limits:this.limits},this.fees.trading,d);s.push(c)}this.markets=this.indexBy(s,"symbol");const n=this.keysort(this.markets),r=this.keysort(this.markets_by_id);if(this.symbols=Object.keys(n),this.ids=Object.keys(r),t!==void 0)this.currencies=this.deepExtend(this.currencies,t);else{let o=[],d=[];for(let m=0;m<s.length;m++){const g=s[m],y=this.precisionMode===F0?8:this.parseNumber("1e-8"),w=this.safeValue(g,"precision",{});if("base"in g){const b=this.safeValue2(w,"base","amount",y),S={id:this.safeString2(g,"baseId","base"),numericId:this.safeString(g,"baseNumericId"),code:this.safeString(g,"base"),precision:b};o.push(S)}if("quote"in g){const b=this.safeValue2(w,"quote","price",y),S={id:this.safeString2(g,"quoteId","quote"),numericId:this.safeString(g,"quoteNumericId"),code:this.safeString(g,"quote"),precision:b};d.push(S)}}o=this.sortBy(o,"code"),d=this.sortBy(d,"code"),this.baseCurrencies=this.indexBy(o,"code"),this.quoteCurrencies=this.indexBy(d,"code");const c=this.arrayConcat(o,d),u=this.groupBy(c,"code"),h=Object.keys(u),f=[];for(let m=0;m<h.length;m++){const g=h[m],y=this.safeValue(u,g,[]);let w=this.safeValue(y,0);for(let b=1;b<y.length;b++){const S=y[b];this.precisionMode===yA?w=S.precision<w.precision?S:w:w=S.precision>w.precision?S:w}f.push(w)}const l=this.sortBy(f,"code");this.currencies=this.deepExtend(this.currencies,this.indexBy(l,"code"))}this.currencies_by_id=this.indexBy(this.currencies,"id");const a=this.keysort(this.currencies);return this.codes=Object.keys(a),this.markets}safeBalance(e){const t=this.omit(e,["info","timestamp","datetime","free","used","total"]),s=Object.keys(t);e.free={},e.used={},e.total={};const i={};for(let a=0;a<s.length;a++){const o=s[a];let d=this.safeString(e[o],"total"),c=this.safeString(e[o],"free"),u=this.safeString(e[o],"used");const h=this.safeString(e[o],"debt");d===void 0&&c!==void 0&&u!==void 0&&(d=Ve.stringAdd(c,u)),c===void 0&&d!==void 0&&u!==void 0&&(c=Ve.stringSub(d,u)),u===void 0&&d!==void 0&&c!==void 0&&(u=Ve.stringSub(d,c)),e[o].free=this.parseNumber(c),e[o].used=this.parseNumber(u),e[o].total=this.parseNumber(d),e.free[o]=e[o].free,e.used[o]=e[o].used,e.total[o]=e[o].total,h!==void 0&&(e[o].debt=this.parseNumber(h),i[o]=e[o].debt)}return Object.keys(i).length&&(e.debt=i),e}safeOrder(e,t=void 0){let s=this.omitZero(this.safeString(e,"amount")),i=this.safeString(e,"remaining"),n=this.safeString(e,"filled"),r=this.safeString(e,"cost"),a=this.omitZero(this.safeString(e,"average")),o=this.omitZero(this.safeString(e,"price")),d=this.safeInteger(e,"lastTradeTimestamp"),c=this.safeString(e,"symbol"),u=this.safeString(e,"side");const h=n===void 0,f=r===void 0,l=d===void 0,m=this.safeValue(e,"fee"),g=m===void 0,y=this.safeValue(e,"fees")===void 0,w=c===void 0,b=u===void 0,S=g||y,v=this.safeValue(e,"fees",[]);let T=[];if(h||f||S){const P=this.safeValue(e,"trades",T),q=this.number;this.number=String,T=this.parseTrades(P,t),this.number=q;let L=0;const D=Array.isArray(T);if(D&&(L=T.length),D&&L>0){e.symbol===void 0&&(e.symbol=T[0].symbol),e.side===void 0&&(e.side=T[0].side),e.type===void 0&&(e.type=T[0].type),e.id===void 0&&(e.id=T[0].order),h&&(n="0"),f&&(r="0");for(let H=0;H<T.length;H++){const R=T[H],_=this.safeString(R,"amount");h&&_!==void 0&&(n=Ve.stringAdd(n,_));const E=this.safeString(R,"cost");f&&E!==void 0&&(r=Ve.stringAdd(r,E)),w&&(c=this.safeString(R,"symbol")),b&&(u=this.safeString(R,"side"));const U=this.safeValue(R,"timestamp");if(l&&U!==void 0&&(d===void 0?d=U:d=Math.max(d,U)),S){const G=this.safeValue(R,"fees");if(G!==void 0)for(let $=0;$<G.length;$++){const Z=G[$];v.push(this.extend({},Z))}else{const $=this.safeValue(R,"fee");$!==void 0&&v.push(this.extend({},$))}}}}}if(S){const P=this.reduceFees?this.reduceFeesByCurrency(v):v,q=P.length;for(let L=0;L<q;L++)P[L].cost=this.safeNumber(P[L],"cost"),"rate"in P[L]&&(P[L].rate=this.safeNumber(P[L],"rate"));!g&&q===0&&(m.cost=this.safeNumber(m,"cost"),"rate"in m&&(m.rate=this.safeNumber(m,"rate")),P.push(m)),e.fees=P,g&&q===1&&(e.fee=P[0])}s===void 0&&(n!==void 0&&i!==void 0?s=Ve.stringAdd(n,i):this.safeString(e,"status")==="closed"&&(s=n)),n===void 0&&s!==void 0&&i!==void 0&&(n=Ve.stringSub(s,i)),i===void 0&&s!==void 0&&n!==void 0&&(i=Ve.stringSub(s,n));const I=this.safeValue(t,"inverse",!1),A=this.numberToString(this.safeValue(t,"contractSize",1));if(a===void 0&&n!==void 0&&r!==void 0&&Ve.stringGt(n,"0")){const P=Ve.stringMul(n,A);I?a=Ve.stringDiv(P,r):a=Ve.stringDiv(r,P)}if(f&&n!==void 0&&(a!==void 0||o!==void 0)){let P;a===void 0?P=o:P=a;const q=Ve.stringMul(n,A);I?r=Ve.stringDiv(q,P):r=Ve.stringMul(q,P)}const B=this.safeValue(e,"type");(o===void 0||Ve.stringEquals(o,"0"))&&B==="market"&&(o=a);for(let P=0;P<T.length;P++){const q=T[P];q.amount=this.safeNumber(q,"amount"),q.price=this.safeNumber(q,"price"),q.cost=this.safeNumber(q,"cost");const L=this.safeValue(q,"fee",{});L.cost=this.safeNumber(L,"cost"),"rate"in L&&(L.rate=this.safeNumber(L,"rate")),q.fee=L}let k=this.safeString(e,"timeInForce"),O=this.safeValue(e,"postOnly");return k===void 0?(this.safeString(e,"type")==="market"&&(k="IOC"),O&&(k="PO")):O===void 0&&(O=k==="PO"),this.extend(e,{symbol:c,side:u,lastTradeTimestamp:d,price:this.parseNumber(o),amount:this.parseNumber(s),cost:this.parseNumber(r),average:this.parseNumber(a),filled:this.parseNumber(n),remaining:this.parseNumber(i),timeInForce:k,postOnly:O,trades:T})}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];if(Array.isArray(e))for(let d=0;d<e.length;d++){const c=this.extend(this.parseOrder(e[d],t),n);r.push(c)}else{const d=Object.keys(e);for(let c=0;c<d.length;c++){const u=d[c],h=this.extend(this.parseOrder(this.extend({id:u},e[u]),t),n);r.push(h)}}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}calculateFee(e,t,s,i,n,r="taker",a={}){if(t==="market"&&r==="maker")throw new nn(this.id+' calculateFee() - you have provided incompatible arguments - "market" type order can not be "maker". Change either the "type" or the "takerOrMaker" argument to calculate the fee.');const o=this.markets[e],d=this.safeString(o,"feeSide","quote");let c="quote",u;const h=this.numberToString(i),f=this.numberToString(n);d==="quote"?u=Ve.stringMul(h,f):d==="base"?u=h:d==="get"?(u=h,s==="sell"?u=Ve.stringMul(u,f):c="base"):d==="give"&&(u=h,s==="buy"?u=Ve.stringMul(u,f):c="base"),o.spot||(c="settle"),t==="market"&&(r="taker");const l=this.safeString(o,r);return u!==void 0&&(u=Ve.stringMul(u,l)),{type:r,currency:o[c],rate:this.parseNumber(l),cost:this.parseNumber(u)}}safeTrade(e,t=void 0){const s=this.safeString(e,"amount"),i=this.safeString(e,"price");let n=this.safeString(e,"cost");if(n===void 0){const u=this.safeString(t,"contractSize");let h=i;u!==void 0&&(this.safeValue(t,"inverse",!1)&&(h=Ve.stringDiv("1",i)),h=Ve.stringMul(h,u)),n=Ve.stringMul(h,s)}const r=this.safeValue(e,"fee")===void 0,a=this.safeValue(e,"fees")===void 0,o=r||a,d=[],c=this.safeValue(e,"fee");if(o){const u=this.reduceFees?this.reduceFeesByCurrency(d):d,h=u.length;for(let l=0;l<h;l++)u[l].cost=this.safeNumber(u[l],"cost"),"rate"in u[l]&&(u[l].rate=this.safeNumber(u[l],"rate"));!r&&h===0&&(c.cost=this.safeNumber(c,"cost"),"rate"in c&&(c.rate=this.safeNumber(c,"rate")),u.push(c)),a&&(e.fees=u),r&&h===1&&(e.fee=u[0]);const f=this.safeValue(e,"fee");f!==void 0&&(f.cost=this.safeNumber(f,"cost"),"rate"in f&&(f.rate=this.safeNumber(f,"rate")),e.fee=f)}return e.amount=this.parseNumber(s),e.price=this.parseNumber(i),e.cost=this.parseNumber(n),e}reduceFeesByCurrency(e){const t={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,"currency");if(a!==void 0){const o=this.safeString(r,"rate"),d=this.safeValue(r,"cost");if(Ve.stringEq(d,"0"))continue;a in t||(t[a]={});const c=o===void 0?"":o;c in t[a]?t[a][c].cost=Ve.stringAdd(t[a][c].cost,d):(t[a][c]={currency:a,cost:d},o!==void 0&&(t[a][c].rate=o))}}let s=[];const i=Object.values(t);for(let n=0;n<i.length;n++){const r=Object.values(i[n]);s=this.arrayConcat(s,r)}return s}safeTicker(e,t=void 0){let s=this.safeValue(e,"open"),i=this.safeValue(e,"close"),n=this.safeValue(e,"last"),r=this.safeValue(e,"change"),a=this.safeValue(e,"percentage"),o=this.safeValue(e,"average"),d=this.safeValue(e,"vwap");const c=this.safeValue(e,"baseVolume"),u=this.safeValue(e,"quoteVolume");return d===void 0&&(d=Ve.stringDiv(u,c)),n!==void 0&&i===void 0?i=n:n===void 0&&i!==void 0&&(n=i),n!==void 0&&s!==void 0&&(r===void 0&&(r=Ve.stringSub(n,s)),o===void 0&&(o=Ve.stringDiv(Ve.stringAdd(n,s),"2"))),a===void 0&&r!==void 0&&s!==void 0&&Ve.stringGt(s,"0")&&(a=Ve.stringMul(Ve.stringDiv(r,s),"100")),r===void 0&&a!==void 0&&s!==void 0&&(r=Ve.stringDiv(Ve.stringMul(a,s),"100")),s===void 0&&n!==void 0&&r!==void 0&&(s=Ve.stringSub(n,r)),this.extend(e,{bid:this.safeNumber(e,"bid"),bidVolume:this.safeNumber(e,"bidVolume"),ask:this.safeNumber(e,"ask"),askVolume:this.safeNumber(e,"askVolume"),high:this.safeNumber(e,"high"),low:this.safeNumber(e,"low"),open:this.parseNumber(s),close:this.parseNumber(i),last:this.parseNumber(n),change:this.parseNumber(r),percentage:this.parseNumber(a),average:this.parseNumber(o),vwap:this.parseNumber(d),baseVolume:this.parseNumber(c),quoteVolume:this.parseNumber(u),previousClose:this.safeNumber(e,"previousClose")})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new Oe(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++)o.push([this.safeInteger(a[d],0),this.safeNumber(a[d],1),this.safeNumber(a[d],2),this.safeNumber(a[d],3),this.safeNumber(a[d],4),this.safeNumber(a[d],5)]);return o}convertTradingViewToOHLCV(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d=[],c=this.safeValue(e,t,[]),u=this.safeValue(e,s,[]),h=this.safeValue(e,i,[]),f=this.safeValue(e,n,[]),l=this.safeValue(e,r,[]),m=this.safeValue(e,a,[]);for(let g=0;g<c.length;g++)d.push([o?this.safeInteger(c,g):this.safeTimestamp(c,g),this.safeValue(u,g),this.safeValue(h,g),this.safeValue(f,g),this.safeValue(l,g),this.safeValue(m,g)]);return d}convertOHLCVToTradingView(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d={};d[t]=[],d[s]=[],d[i]=[],d[n]=[],d[r]=[],d[a]=[];for(let c=0;c<e.length;c++){const u=o?e[c][0]:parseInt(e[c][0]/1e3);d[t].push(u),d[s].push(e[c][1]),d[i].push(e[c][2]),d[n].push(e[c][3]),d[r].push(e[c][4]),d[a].push(e[c][5])}return d}marketIds(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.marketId(e[s]));return t}marketSymbols(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.symbol(e[s]));return t}marketCodes(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.commonCurrencyCode(e[s]));return t}parseBidsAsks(e,t=0,s=1){e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++)i.push(this.parseBidAsk(e[n],t,s));return i}async fetchL2OrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBook(e,t,s);return this.extend(i,{asks:this.sortBy(this.aggregate(i.asks),0),bids:this.sortBy(this.aggregate(i.bids),0,!0)})}filterBySymbol(e,t=void 0){if(t===void 0)return e;const s=[];for(let i=0;i<e.length;i++)this.safeString(e[i],"symbol")===t&&s.push(e[i]);return s}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:e}getNetwork(e,t){e=e.toUpperCase();const s={ETHEREUM:"ETH",ETHER:"ETH",ERC20:"ETH",ETH:"ETH",TRC20:"TRX",TRON:"TRX",TRX:"TRX",BEP20:"BSC",BSC:"BSC",HRC20:"HT",HECO:"HT",SPL:"SOL",SOL:"SOL",TERRA:"LUNA",LUNA:"LUNA",POLYGON:"MATIC",MATIC:"MATIC",EOS:"EOS",WAVES:"WAVES",AVALANCHE:"AVAX",AVAX:"AVAX",QTUM:"QTUM",CHZ:"CHZ",NEO:"NEO",ONT:"ONT",RON:"RON"};if(e===t)return e;if(e in s)return s[e];throw new Oe(this.id+" network "+e+" is not yet supported")}networkCodeToId(e,t=void 0){const s=this.safeValue(this.options,"networks",{});let i=this.safeString(s,e);if(i===void 0)if(t===void 0)i=e;else{const n=this.safeValue(this.options,"defaultNetworkCodeReplacements",{});if(t in n){const r=n[t],a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o];if(r[d]===e){i=this.safeString(s,d);break}}}i===void 0&&(i=e)}return i}networkIdToCode(e,t=void 0){const s=this.safeValue(this.options,"networksById",{});let i=this.safeString(s,e,e);if(t!==void 0){const n=this.safeValue(this.options,"defaultNetworkCodeReplacements",{});if(t in n){const r=this.safeValue(n,t,{});i=this.safeString(r,i,i)}}return i}networkCodesToIds(e=void 0){if(e===void 0)return;const t=[];for(let s=0;s<e.length;s++){const i=e[s];t.push(this.networkCodeToId(i))}return t}handleNetworkCodeAndParams(e){const t=this.safeString2(e,"networkCode","network");return t!==void 0&&(e=this.omit(e,["networkCode","network"])),[t,e]}defaultNetworkCode(e){let t;const s=this.safeValue(this.options,"defaultNetworks",{});if(e in s)t=s[e];else{const i=this.safeValue(this.options,"defaultNetwork");i!==void 0&&(t=i)}return t}selectNetworkCodeFromUnifiedNetworks(e,t,s){return this.selectNetworkKeyFromNetworks(e,t,s,!0)}selectNetworkIdFromRawNetworks(e,t,s){return this.selectNetworkKeyFromNetworks(e,t,s,!1)}selectNetworkKeyFromNetworks(e,t,s,i=!1){let n;const r=Object.keys(s),a=r.length;if(t!==void 0){if(a===0)throw new Oe(this.id+" - "+t+" network did not return any result for "+e);{const o=i?t:this.networkCodeToId(t,e);if(o in s)n=o;else throw new Oe(this.id+" - "+o+" network was not found for "+e+", use one of "+r.join(", "))}}else{if(a===0)throw new Oe(this.id+" - no networks were returned for "+e);{const o=this.defaultNetworkCode(e),d=i?o:this.networkCodeToId(o,e);n=d in s?d:r[0]}}return n}safeNumber2(e,t,s,i=void 0){const n=this.safeString2(e,t,s);return this.parseNumber(n,i)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1){const o=this.parseBidsAsks(this.safeValue(e,i,[]),r,a),d=this.parseBidsAsks(this.safeValue(e,n,[]),r,a);return{symbol:t,bids:this.sortBy(o,0,!0),asks:this.sortBy(d,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[];for(let d=0;d<e.length;d++)r.push(this.parseOHLCV(e[d],t));const a=this.sortBy(r,0),o=i===void 0;return this.filterBySinceLimit(a,i,n,0,o)}parseLeverageTiers(e,t=void 0,s=void 0){t=this.marketSymbols(t);const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,s),o=this.safeMarket(a,void 0,void 0,this.safeString(this.options,"defaultType")),d=o.symbol;this.safeValue(o,"contract",!1)&&(t===void 0||this.inArray(d,t))&&(i[d]=this.parseMarketLeverageTiers(r,o))}return i}async loadTradingLimits(e=void 0,t=!1,s={}){if(this.has.fetchTradingLimits&&(t||!("limitsLoaded"in this.options))){const i=await this.fetchTradingLimits(e);for(let n=0;n<e.length;n++){const r=e[n];this.markets[r]=this.deepExtend(this.markets[r],i[r])}this.options.limitsLoaded=this.milliseconds()}return this.markets}parsePositions(e,t=void 0,s={}){t=this.marketSymbols(t),e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++){const r=this.extend(this.parsePosition(e[n],void 0),s);i.push(r)}return this.filterByArray(i,"symbol",t,!1)}parseAccounts(e,t={}){e=this.toArray(e);const s=[];for(let i=0;i<e.length;i++){const n=this.extend(this.parseAccount(e[i]),t);s.push(n)}return s}parseTrades(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTrade(e[d],t),n);r.push(c)}r=this.sortBy2(r,"timestamp","id");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}parseTransactions(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransaction(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseTransfers(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransfer(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseLedger(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];const a=this.toArray(e);for(let c=0;c<a.length;c++){const u=this.parseLedgerEntry(a[c],t);if(Array.isArray(u))for(let h=0;h<u.length;h++)r.push(this.extend(u[h],n));else r.push(this.extend(u,n))}r=this.sortBy(r,"timestamp");const o=t!==void 0?t.code:void 0,d=s===void 0;return this.filterByCurrencySinceLimit(r,o,s,i,d)}nonce(){return this.seconds()}setHeaders(e){return e}marketId(e){const t=this.market(e);return t!==void 0?t.id:e}symbol(e){const t=this.market(e);return this.safeString(t,"symbol",e)}resolvePath(e,t){return[this.implodeParams(e,t),this.omit(t,this.extractParams(e))]}filterByArray(e,t,s=void 0,i=!0){if(e=this.toArray(e),s===void 0||!s)return i?this.indexBy(e,t):e;const n=[];for(let r=0;r<e.length;r++)this.inArray(e[r][t],s)&&n.push(e[r]);return i?this.indexBy(n,t):n}async fetch2(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){if(this.enableRateLimit){const c=this.calculateRateLimiterCost(t,s,e,i,a,o);await this.throttle(c)}this.lastRestRequestTimestamp=this.milliseconds();const d=this.sign(e,t,s,i,n,r);return await this.fetch(d.url,d.method,d.headers,d.body)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){return await this.fetch2(e,t,s,i,n,r,a,o)}async loadAccounts(e=!1,t={}){if(e)this.accounts=await this.fetchAccounts(t);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(t)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}async fetchTrades(e,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchTrades() is not supported yet")}async fetchOHLCVC(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new Oe(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n);return this.buildOHLCVC(r,t,s,i)}parseTradingViewOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){const r=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(r,t,s,i,n)}async editLimitBuyOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"buy",s,i,n)}async editLimitSellOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"sell",s,i,n)}async editLimitOrder(e,t,s,i,n=void 0,r={}){return await this.editOrder(e,t,"limit",s,i,n,r)}async editOrder(e,t,s,i,n,r=void 0,a={}){return await this.cancelOrder(e,t),await this.createOrder(t,s,i,n,r,a)}async fetchPermissions(e={}){throw new Oe(this.id+" fetchPermissions() is not supported yet")}async fetchPosition(e,t={}){throw new Oe(this.id+" fetchPosition() is not supported yet")}async fetchPositions(e=void 0,t={}){throw new Oe(this.id+" fetchPositions() is not supported yet")}async fetchPositionsRisk(e=void 0,t={}){throw new Oe(this.id+" fetchPositionsRisk() is not supported yet")}async fetchBidsAsks(e=void 0,t={}){throw new Oe(this.id+" fetchBidsAsks() is not supported yet")}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s);return[i,n]}safeCurrency(e,t=void 0){if(e===void 0&&t!==void 0)return t;if(this.currencies_by_id!==void 0&&e in this.currencies_by_id&&this.currencies_by_id[e]!==void 0)return this.currencies_by_id[e];let s=e;return e!==void 0&&(s=this.commonCurrencyCode(e.toUpperCase())),{id:e,code:s}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){const n={id:e,symbol:e,base:void 0,quote:void 0,baseId:void 0,quoteId:void 0,active:void 0,type:void 0,linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!1,margin:!1,contract:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,settle:void 0,settleId:void 0,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0};if(e!==void 0){if(this.markets_by_id!==void 0&&e in this.markets_by_id){const r=this.markets_by_id[e];if(r.length===1)return r[0];if(i===void 0)throw new nn(this.id+" safeMarket() requires a fourth argument for "+e+" to disambiguate between different markets with the same market id");for(let o=0;o<r.length;o++){const d=r[o];if(d[i])return d}}else if(s!==void 0){const r=e.split(s);return r.length===2&&(n.baseId=this.safeString(r,0),n.quoteId=this.safeString(r,1),n.base=this.safeCurrencyCode(n.baseId),n.quote=this.safeCurrencyCode(n.quoteId),n.symbol=n.base+"/"+n.quote),n}}return t!==void 0?t:n}checkRequiredCredentials(e=!0){const t=Object.keys(this.requiredCredentials);for(let s=0;s<t.length;s++){const i=t[s];if(this.requiredCredentials[i]&&!this[i]){if(e)throw new fc(this.id+' requires "'+i+'" credential');return!1}}return!0}oath(){if(this.twofa!==void 0)return this.totp(this.twofa);throw new br(this.id+" exchange.twofa has not been set for 2FA Two-Factor Authentication")}async fetchBalance(e={}){throw new Oe(this.id+" fetchBalance() is not supported yet")}async fetchPartialBalance(e,t={}){return(await this.fetchBalance(t))[e]}async fetchFreeBalance(e={}){return await this.fetchPartialBalance("free",e)}async fetchUsedBalance(e={}){return await this.fetchPartialBalance("used",e)}async fetchTotalBalance(e={}){return await this.fetchPartialBalance("total",e)}async fetchStatus(e={}){if(this.has.fetchTime){const t=await this.fetchTime(e);this.status=this.extend(this.status,{updated:t})}return this.status}async fetchFundingFee(e,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFee",!0))throw new Oe(this.id+' fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning');return await this.fetchTransactionFee(e,t)}async fetchFundingFees(e=void 0,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFees",!0))throw new Oe(this.id+' fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning');return await this.fetchTransactionFees(e,t)}async fetchTransactionFee(e,t={}){if(!this.has.fetchTransactionFees)throw new Oe(this.id+" fetchTransactionFee() is not supported yet");return await this.fetchTransactionFees([e],t)}async fetchTransactionFees(e=void 0,t={}){throw new Oe(this.id+" fetchTransactionFees() is not supported yet")}async fetchDepositWithdrawFee(e,t={}){if(!this.has.fetchDepositWithdrawFees)throw new Oe(this.id+" fetchDepositWithdrawFee() is not supported yet");const s=await this.fetchDepositWithdrawFees([e],t);return this.safeValue(s,e)}getSupportedMapping(e,t={}){if(e in t)return t[e];throw new Oe(this.id+" "+e+" does not have a value in mapping")}async fetchBorrowRate(e,t={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new Oe(this.id+" fetchBorrowRate() is not supported yet");const s=await this.fetchBorrowRates(t),i=this.safeValue(s,e);if(i===void 0)throw new br(this.id+" fetchBorrowRate() could not find the borrow rate for currency code "+e);return i}handleOptionAndParams(e,t,s,i=void 0){const n="default"+this.capitalize(s);let r=this.safeValue2(e,s,n);if(r!==void 0)e=this.omit(e,[s,n]);else{const a=this.safeValue(this.options,t);a!==void 0&&(r=this.safeValue2(a,s,n)),r===void 0&&(r=this.safeValue2(this.options,s,n)),r=r!==void 0?r:i}return[r,e]}handleOption(e,t,s=void 0){const[i,n]=this.handleOptionAndParams({},e,t,s);return i}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString2(this.options,"defaultType","type","spot"),n=this.safeValue(this.options,e);let r=i;n!==void 0&&(typeof n=="string"?r=n:r=this.safeString2(n,"defaultType","type",r));const a=t===void 0?r:t.type,o=this.safeString2(s,"defaultType","type",a);return s=this.omit(s,["defaultType","type"]),[o,s]}handleSubTypeAndParams(e,t=void 0,s={},i=void 0){let n;const r=this.safeString2(s,"subType","defaultSubType");return r!==void 0?(n=r,s=this.omit(s,["subType","defaultSubType"])):(t!==void 0&&(t.linear?n="linear":t.inverse&&(n="inverse")),n===void 0&&(n=this.handleOptionAndParams(void 0,e,"subType",i)[0])),[n,s]}handleMarginModeAndParams(e,t={},s=void 0){return this.handleOptionAndParams(t,e,"marginMode",s)}throwExactlyMatchedException(e,t,s){if(t in e)throw new e[t](s)}throwBroadlyMatchedException(e,t,s){const i=this.findBroadlyMatchedKey(e,t);if(i!==void 0)throw new e[i](s)}findBroadlyMatchedKey(e,t){const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(t!==void 0&&t.indexOf(n)>=0)return n}}handleErrors(e,t,s,i,n,r,a,o,d){}calculateRateLimiterCost(e,t,s,i,n={},r={}){return this.safeValue(n,"cost",1)}async fetchTicker(e,t={}){if(this.has.fetchTickers){const s=await this.fetchTickers([e],t),i=this.safeValue(s,e);if(i===void 0)throw new L0(this.id+" fetchTickers() could not find a ticker for "+e);return i}else throw new Oe(this.id+" fetchTicker() is not supported yet")}async fetchTickers(e=void 0,t={}){throw new Oe(this.id+" fetchTickers() is not supported yet")}async fetchOrder(e,t=void 0,s={}){throw new Oe(this.id+" fetchOrder() is not supported yet")}async fetchOrderStatus(e,t=void 0,s={}){return(await this.fetchOrder(e,t,s)).status}async fetchUnifiedOrder(e,t={}){return await this.fetchOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async createOrder(e,t,s,i,n=void 0,r={}){throw new Oe(this.id+" createOrder() is not supported yet")}async cancelOrder(e,t=void 0,s={}){throw new Oe(this.id+" cancelOrder() is not supported yet")}async cancelUnifiedOrder(e,t={}){return this.cancelOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchOrders() is not supported yet")}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchOpenOrders() is not supported yet")}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchClosedOrders() is not supported yet")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchMyTrades() is not supported yet")}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchTransactions() is not supported yet")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchDeposits() is not supported yet")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){throw new Oe(this.id+" fetchWithdrawals() is not supported yet")}async fetchDepositAddress(e,t={}){if(this.has.fetchDepositAddresses){const s=await this.fetchDepositAddresses([e],t),i=this.safeValue(s,e);if(i===void 0)throw new Sf(this.id+" fetchDepositAddress() could not find a deposit address for "+e+", make sure you have created a corresponding deposit address in your wallet on the exchange website");return i}else throw new Oe(this.id+" fetchDepositAddress() is not supported yet")}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(e){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,e,e):e}currency(e){if(this.currencies===void 0)throw new br(this.id+" currencies not loaded");if(typeof e=="string"){if(e in this.currencies)return this.currencies[e];if(e in this.currencies_by_id)return this.currencies_by_id[e]}throw new br(this.id+" does not have currency code "+e)}market(e){if(this.markets===void 0)throw new br(this.id+" markets not loaded");if(typeof e=="string"){if(e in this.markets)return this.markets[e];if(e in this.markets_by_id){const t=this.markets_by_id[e],s=this.safeString2(this.options,"defaultType","defaultSubType","spot");for(let i=0;i<t.length;i++){const n=t[i];if(n[s])return n}return t[0]}}throw new kf(this.id+" does not have market symbol "+e)}handleWithdrawTagAndParams(e,t){return typeof e=="object"&&(t=this.extend(e,t),e=void 0),e===void 0&&(e=this.safeString(t,"tag"),e!==void 0&&(t=this.omit(t,"tag"))),[e,t]}async createLimitOrder(e,t,s,i,n={}){return await this.createOrder(e,"limit",t,s,i,n)}async createMarketOrder(e,t,s,i=void 0,n={}){return await this.createOrder(e,"market",t,s,i,n)}async createLimitBuyOrder(e,t,s,i={}){return await this.createOrder(e,"limit","buy",t,s,i)}async createLimitSellOrder(e,t,s,i={}){return await this.createOrder(e,"limit","sell",t,s,i)}async createMarketBuyOrder(e,t,s={}){return await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrder(e,t,s={}){return await this.createOrder(e,"market","sell",t,void 0,s)}costToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,D0,s.precision.price,this.precisionMode,this.paddingMode)}priceToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,Tf,s.precision.price,this.precisionMode,this.paddingMode);if(i==="0")throw new nn(this.id+" price of "+s.symbol+" must be greater than minimum price precision of "+this.numberToString(s.precision.price));return i}amountToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,D0,s.precision.amount,this.precisionMode,this.paddingMode);if(i==="0")throw new nn(this.id+" amount of "+s.symbol+" must be greater than minimum amount precision of "+this.numberToString(s.precision.amount));return i}feeToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,Tf,s.precision.price,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){const i=this.currencies[e];let n=this.safeValue(i,"precision");if(s!==void 0){const r=this.safeValue(i,"networks",{}),a=this.safeValue(r,s,{});n=this.safeValue(a,"precision",n)}return n===void 0?t:this.decimalToPrecision(t,Tf,n,this.precisionMode,this.paddingMode)}safeNumber(e,t,s=void 0){const i=this.safeString(e,t);return this.parseNumber(i,s)}safeNumberN(e,t,s=void 0){const i=this.safeStringN(e,t);return this.parseNumber(i,s)}parsePrecision(e){if(e!==void 0)return"1e"+Ve.stringNeg(e)}async loadTimeDifference(e={}){const t=await this.fetchTime(e),s=this.milliseconds();return this.options.timeDifference=s-t,this.options.timeDifference}implodeHostname(e){return this.implodeParams(e,{hostname:this.hostname})}async fetchMarketLeverageTiers(e,t={}){if(this.has.fetchLeverageTiers){if(!(await this.market(e)).contract)throw new kf(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i=await this.fetchLeverageTiers([e]);return this.safeValue(i,e)}else throw new Oe(this.id+" fetchMarketLeverageTiers() is not supported yet")}async createPostOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createPostOnlyOrder)throw new Oe(this.id+"createPostOnlyOrder() is not supported yet");const a=this.extend(r,{postOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createReduceOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createReduceOnlyOrder)throw new Oe(this.id+"createReduceOnlyOrder() is not supported yet");const a=this.extend(r,{reduceOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createStopOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(!this.has.createStopOrder)throw new Oe(this.id+" createStopOrder() is not supported yet");if(r===void 0)throw new nn(this.id+" create_stop_order() requires a stopPrice argument");const o=this.extend(a,{stopPrice:r});return await this.createOrder(e,t,s,i,n,o)}async createStopLimitOrder(e,t,s,i,n,r={}){if(!this.has.createStopLimitOrder)throw new Oe(this.id+" createStopLimitOrder() is not supported yet");const a=this.extend(r,{stopPrice:n});return await this.createOrder(e,"limit",t,s,i,a)}async createStopMarketOrder(e,t,s,i,n={}){if(!this.has.createStopMarketOrder)throw new Oe(this.id+" createStopMarketOrder() is not supported yet");const r=this.extend(n,{stopPrice:i});return await this.createOrder(e,"market",t,s,void 0,r)}safeCurrencyCode(e,t=void 0){return t=this.safeCurrency(e,t),t.code}filterBySymbolSinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"symbol",t,s,i,"timestamp",n)}filterByCurrencySinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"currency",t,s,i,"timestamp",n)}parseTickers(e,t=void 0,s={}){const i=[];if(Array.isArray(e))for(let n=0;n<e.length;n++){const r=this.extend(this.parseTicker(e[n]),s);i.push(r)}else{const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a),d=this.extend(this.parseTicker(e[a],o),s);i.push(d)}}return t=this.marketSymbols(t),this.filterByArray(i,"symbol",t)}parseDepositAddresses(e,t=void 0,s=!0,i={}){let n=[];for(let r=0;r<e.length;r++){const a=this.extend(this.parseDepositAddress(e[r]),i);n.push(a)}return t!==void 0&&(n=this.filterByArray(n,"currency",t,!1)),n=s?this.indexBy(n,"currency"):n,n}parseBorrowInterests(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push(this.parseBorrowInterest(n,t))}return s}parseFundingRateHistories(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o];n.push(this.parseFundingRateHistory(d,t))}const r=this.sortBy(n,"timestamp"),a=t===void 0?void 0:t.symbol;return this.filterBySymbolSinceLimit(r,a,s,i)}safeSymbol(e,t=void 0,s=void 0,i=void 0){return t=this.safeMarket(e,t,s,i),t.symbol}parseFundingRate(e,t=void 0){throw new Oe(this.id+" parseFundingRate() is not supported yet")}parseFundingRates(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=this.parseFundingRate(e[i],t);s[n.symbol]=n}return s}isTriggerOrder(e){const t=this.safeValue2(e,"trigger","stop");return t&&(e=this.omit(e,["trigger","stop"])),[t,e]}isPostOnly(e,t,s={}){const i=this.safeStringUpper(s,"timeInForce");let n=this.safeValue2(s,"postOnly","post_only",!1);const r=i==="IOC",a=i==="FOK";if(n=n||i==="PO"||t,n){if(r||a)throw new R0(this.id+" postOnly orders cannot have timeInForce equal to "+i);if(e)throw new R0(this.id+" market orders cannot be postOnly");return!0}else return!1}async fetchTradingFees(e={}){throw new Oe(this.id+" fetchTradingFees() is not supported yet")}async fetchTradingFee(e,t={}){if(!this.has.fetchTradingFees)throw new Oe(this.id+" fetchTradingFee() is not supported yet");return await this.fetchTradingFees(t)}parseOpenInterest(e,t=void 0){throw new Oe(this.id+" parseOpenInterest () is not supported yet")}parseOpenInterests(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.parseOpenInterest(d,t);n.push(c)}const r=this.sortBy(n,"timestamp"),a=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(r,a,s,i)}async fetchFundingRate(e,t={}){if(this.has.fetchFundingRates){if(await this.loadMarkets(),!this.market(e).contract)throw new kf(this.id+" fetchFundingRate() supports contract markets only");const i=await this.fetchFundingRates([e],t),n=this.safeValue(i,e);if(n===void 0)throw new L0(this.id+" fetchFundingRate () returned no data for "+e);return n}else throw new Oe(this.id+" fetchFundingRate () is not supported yet")}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchMarkOHLCV){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new Oe(this.id+" fetchMarkOHLCV () is not supported yet")}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchIndexOHLCV){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new Oe(this.id+" fetchIndexOHLCV () is not supported yet")}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchPremiumIndexOHLCV){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new Oe(this.id+" fetchPremiumIndexOHLCV () is not supported yet")}handleTimeInForce(e={}){const t=this.safeStringUpper(e,"timeInForce");if(t!==void 0){const s=this.safeString(this.options.timeInForce,t);if(s===void 0)throw new br(this.id+' does not support timeInForce "'+t+'"');return s}}convertTypeToAccount(e){const t=this.safeValue(this.options,"accountsByType",{}),s=e.toLowerCase();return s in t?t[s]:e in this.markets||e in this.markets_by_id?this.market(e).id:e}checkRequiredArgument(e,t,s,i=[]){if(t===void 0||i.length>0&&!this.inArray(t,i)){const n=i.join(", ");let r=this.id+" "+e+"() requires a "+s+" argument";throw n!==""&&(r+=", one of ("+n+")"),new nn(r)}}checkRequiredMarginArgument(e,t,s){if(s==="isolated"&&t===void 0)throw new nn(this.id+" "+e+"() requires a symbol argument for isolated margin");if(s==="cross"&&t!==void 0)throw new nn(this.id+" "+e+"() cannot have a symbol argument for cross margin")}checkRequiredSymbol(e,t){this.checkRequiredArgument(e,t,"symbol")}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const n=Array.isArray(e);let r=e;n||(r=Object.keys(e));for(let a=0;a<r.length;a++){const o=r[a],d=n?o:e[o],c=n?this.safeString(d,s):o,u=this.safeValue(this.currencies_by_id,c),h=this.safeString(u,"code",c);(t===void 0||this.inArray(h,t))&&(i[h]=this.parseDepositWithdrawFee(d,u))}return i}depositWithdrawFee(e){return{info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}assignDefaultDepositWithdrawFees(e,t=void 0){const s=Object.keys(e.networks),i=s.length;if(i===1)return e.withdraw=e.networks[s[0]].withdraw,e.deposit=e.networks[s[0]].deposit,e;const n=this.safeString(t,"code");for(let r=0;r<i;r++)s[r]===n&&(e.withdraw=e.networks[s[r]].withdraw,e.deposit=e.networks[s[r]].deposit);return e}};const{inflateRawSync:wA,gunzipSync:bA}=ht;function Ev(p){return wA(p).toString()}function kA(p){return Ev(Buffer.from(p,"base64"))}function SA(p){return bA(p).toString()}var qv={inflate:Ev,inflate64:kA,gunzip:SA},Lv=function(){let e,t;const s=new Promise((i,n)=>{e=i,t=n});return s.resolve=function(){e.apply(this,arguments)},s.reject=function(){t.apply(this,arguments)},s};const vA=Q,TA=Zd,{isNode:OA,isJsonEncodedObject:IA,deepExtend:xA,milliseconds:Of}=TA,{RequestTimeout:H0,NetworkError:G0,NotSupported:If,BaseError:_A}=vA,{inflate:CA,gunzip:MA}=qv,U0=Lv;var PA=class{constructor(e,t,s,i,n,r={}){Object.assign(this,xA({url:e,onMessageCallback:t,onErrorCallback:s,onCloseCallback:i,onConnectedCallback:n,verbose:!1,protocols:void 0,options:void 0,futures:{},subscriptions:{},rejections:{},connected:void 0,error:void 0,connectionStarted:void 0,connectionEstablished:void 0,isConnected:!1,connectionTimer:void 0,connectionTimeout:1e4,pingInterval:void 0,ping:void 0,keepAlive:3e4,maxPingPongMisses:2,connection:void 0,startedConnecting:!1,gunzip:!1,inflate:!1},r)),this.connected=U0()}future(e){e in this.futures||(this.futures[e]=U0());const t=this.futures[e];return e in this.rejections&&(t.reject(this.rejections[e]),delete this.rejections[e]),t}resolve(e,t){return this.verbose&&t===void 0&&this.log(new Date,"resolve received undefined messageHash"),t in this.futures&&(this.futures[t].resolve(e),delete this.futures[t]),e}reject(e,t=void 0){if(t)t in this.futures?(this.futures[t].reject(e),delete this.futures[t]):this.rejections[t]=e;else{const s=Object.keys(this.futures);for(let i=0;i<s.length;i++)this.reject(e,s[i])}return e}log(...e){console.log(...e)}connect(e=0){throw new If("connect() not implemented yet")}isOpen(){throw new If("isOpen() not implemented yet")}reset(e){this.clearConnectionTimeout(),this.clearPingInterval(),this.reject(e)}onConnectionTimeout(){if(!this.isOpen()){const e=new H0("Connection to "+this.url+" failed due to a connection timeout");this.onError(e),this.connection.close(1006)}}setConnectionTimeout(){if(this.connectionTimeout){const e=this.onConnectionTimeout.bind(this);this.connectionTimer=setTimeout(e,this.connectionTimeout)}}clearConnectionTimeout(){this.connectionTimer&&(this.connectionTimer=clearTimeout(this.connectionTimer))}setPingInterval(){if(this.keepAlive){const e=this.onPingInterval.bind(this);this.pingInterval=setInterval(e,this.keepAlive)}}clearPingInterval(){this.pingInterval&&(this.pingInterval=clearInterval(this.pingInterval))}onPingInterval(){if(this.keepAlive&&this.isOpen()){const e=Of();this.lastPong=this.lastPong||e,this.lastPong+this.keepAlive*this.maxPingPongMisses<e?this.onError(new H0("Connection to "+this.url+" timed out due to a ping-pong keepalive missing on time")):this.ping?this.send(this.ping(this)):OA?this.connection.ping():this.lastPong=e}}onOpen(){this.verbose&&this.log(new Date,"onOpen"),this.connectionEstablished=Of(),this.isConnected=!0,this.connected.resolve(this.url),this.clearConnectionTimeout(),this.setPingInterval(),this.onConnectedCallback(this)}onPing(){this.verbose&&this.log(new Date,"onPing")}onPong(){this.lastPong=Of(),this.verbose&&this.log(new Date,"onPong")}onError(e){this.verbose&&this.log(new Date,"onError",e.message),e instanceof _A||(e=new G0(e.message)),this.error=e,this.reset(this.error),this.onErrorCallback(this,this.error)}onClose(e){this.verbose&&this.log(new Date,"onClose",e),this.error||this.reset(new G0("connection closed by remote server, closing code "+String(e.code))),this.onCloseCallback(this,e)}onUpgrade(e){this.verbose&&this.log(new Date,"onUpgrade")}send(e){this.verbose&&this.log(new Date,"sending",e),e=typeof e=="string"?e:JSON.stringify(e),this.connection.send(e)}close(){throw new If("close() not implemented yet")}onMessage(e){e=e.data,e.byteLength!==void 0&&(this.gunzip?e=MA(e):this.inflate&&(e=CA(e)));try{e instanceof Buffer&&(e=e.toString()),IA(e)&&(e=JSON.parse(e.replace(/:(\d{15,}),/g,':"$1",'))),this.verbose&&this.log(new Date,"onMessage",e)}catch(t){this.log(new Date,"onMessage JSON.parse",t)}this.onMessageCallback(this,e)}},na={exports:{}},ca={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}},AA,BA;const{EMPTY_BUFFER:NA}=ca,Om=Buffer[Symbol.species];function VA(p,e){if(p.length===0)return NA;if(p.length===1)return p[0];const t=Buffer.allocUnsafe(e);let s=0;for(let i=0;i<p.length;i++){const n=p[i];t.set(n,s),s+=n.length}return s<e?new Om(t.buffer,t.byteOffset,s):t}function Rv(p,e,t,s,i){for(let n=0;n<i;n++)t[s+n]=p[n]^e[n&3]}function Dv(p,e){for(let t=0;t<p.length;t++)p[t]^=e[t&3]}function EA(p){return p.length===p.buffer.byteLength?p.buffer:p.buffer.slice(p.byteOffset,p.byteOffset+p.length)}function Im(p){if(Im.readOnly=!0,Buffer.isBuffer(p))return p;let e;return p instanceof ArrayBuffer?e=new Om(p):ArrayBuffer.isView(p)?e=new Om(p.buffer,p.byteOffset,p.byteLength):(e=Buffer.from(p),Im.readOnly=!1),e}na.exports={concat:VA,mask:Rv,toArrayBuffer:EA,toBuffer:Im,unmask:Dv};if(!{}.WS_NO_BUFFER_UTIL)try{const p=require("bufferutil");BA=na.exports.mask=function(e,t,s,i,n){n<48?Rv(e,t,s,i,n):p.mask(e,t,s,i,n)},AA=na.exports.unmask=function(e,t){e.length<32?Dv(e,t):p.unmask(e,t)}}catch{}const $0=Symbol("kDone"),xf=Symbol("kRun");class qA{constructor(e){this[$0]=()=>{this.pending--,this[xf]()},this.concurrency=e||1/0,this.jobs=[],this.pending=0}add(e){this.jobs.push(e),this[xf]()}[xf](){if(this.pending!==this.concurrency&&this.jobs.length){const e=this.jobs.shift();this.pending++,e(this[$0])}}}var LA=qA;const Io=ht,W0=na.exports,RA=LA,{kStatusCode:Fv}=ca,DA=Buffer[Symbol.species],FA=Buffer.from([0,0,255,255]),oh=Symbol("permessage-deflate"),Nn=Symbol("total-length"),qd=Symbol("callback"),cr=Symbol("buffers"),Ku=Symbol("error");let lc;class HA{constructor(e,t,s){if(this._maxPayload=s|0,this._options=e||{},this._threshold=this._options.threshold!==void 0?this._options.threshold:1024,this._isServer=!!t,this._deflate=null,this._inflate=null,this.params=null,!lc){const i=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;lc=new RA(i)}}static get extensionName(){return"permessage-deflate"}offer(){const e={};return this._options.serverNoContextTakeover&&(e.server_no_context_takeover=!0),this._options.clientNoContextTakeover&&(e.client_no_context_takeover=!0),this._options.serverMaxWindowBits&&(e.server_max_window_bits=this._options.serverMaxWindowBits),this._options.clientMaxWindowBits?e.client_max_window_bits=this._options.clientMaxWindowBits:this._options.clientMaxWindowBits==null&&(e.client_max_window_bits=!0),e}accept(e){return e=this.normalizeParams(e),this.params=this._isServer?this.acceptAsServer(e):this.acceptAsClient(e),this.params}cleanup(){if(this._inflate&&(this._inflate.close(),this._inflate=null),this._deflate){const e=this._deflate[qd];this._deflate.close(),this._deflate=null,e&&e(new Error("The deflate stream was closed while data was being processed"))}}acceptAsServer(e){const t=this._options,s=e.find(i=>!(t.serverNoContextTakeover===!1&&i.server_no_context_takeover||i.server_max_window_bits&&(t.serverMaxWindowBits===!1||typeof t.serverMaxWindowBits=="number"&&t.serverMaxWindowBits>i.server_max_window_bits)||typeof t.clientMaxWindowBits=="number"&&!i.client_max_window_bits));if(!s)throw new Error("None of the extension offers can be accepted");return t.serverNoContextTakeover&&(s.server_no_context_takeover=!0),t.clientNoContextTakeover&&(s.client_no_context_takeover=!0),typeof t.serverMaxWindowBits=="number"&&(s.server_max_window_bits=t.serverMaxWindowBits),typeof t.clientMaxWindowBits=="number"?s.client_max_window_bits=t.clientMaxWindowBits:(s.client_max_window_bits===!0||t.clientMaxWindowBits===!1)&&delete s.client_max_window_bits,s}acceptAsClient(e){const t=e[0];if(this._options.clientNoContextTakeover===!1&&t.client_no_context_takeover)throw new Error('Unexpected parameter "client_no_context_takeover"');if(!t.client_max_window_bits)typeof this._options.clientMaxWindowBits=="number"&&(t.client_max_window_bits=this._options.clientMaxWindowBits);else if(this._options.clientMaxWindowBits===!1||typeof this._options.clientMaxWindowBits=="number"&&t.client_max_window_bits>this._options.clientMaxWindowBits)throw new Error('Unexpected or invalid parameter "client_max_window_bits"');return t}normalizeParams(e){return e.forEach(t=>{Object.keys(t).forEach(s=>{let i=t[s];if(i.length>1)throw new Error(`Parameter "${s}" must have only a single value`);if(i=i[0],s==="client_max_window_bits"){if(i!==!0){const n=+i;if(!Number.isInteger(n)||n<8||n>15)throw new TypeError(`Invalid value for parameter "${s}": ${i}`);i=n}else if(!this._isServer)throw new TypeError(`Invalid value for parameter "${s}": ${i}`)}else if(s==="server_max_window_bits"){const n=+i;if(!Number.isInteger(n)||n<8||n>15)throw new TypeError(`Invalid value for parameter "${s}": ${i}`);i=n}else if(s==="client_no_context_takeover"||s==="server_no_context_takeover"){if(i!==!0)throw new TypeError(`Invalid value for parameter "${s}": ${i}`)}else throw new Error(`Unknown parameter "${s}"`);t[s]=i})}),e}decompress(e,t,s){lc.add(i=>{this._decompress(e,t,(n,r)=>{i(),s(n,r)})})}compress(e,t,s){lc.add(i=>{this._compress(e,t,(n,r)=>{i(),s(n,r)})})}_decompress(e,t,s){const i=this._isServer?"client":"server";if(!this._inflate){const n=`${i}_max_window_bits`,r=typeof this.params[n]!="number"?Io.Z_DEFAULT_WINDOWBITS:this.params[n];this._inflate=Io.createInflateRaw({...this._options.zlibInflateOptions,windowBits:r}),this._inflate[oh]=this,this._inflate[Nn]=0,this._inflate[cr]=[],this._inflate.on("error",UA),this._inflate.on("data",Hv)}this._inflate[qd]=s,this._inflate.write(e),t&&this._inflate.write(FA),this._inflate.flush(()=>{const n=this._inflate[Ku];if(n){this._inflate.close(),this._inflate=null,s(n);return}const r=W0.concat(this._inflate[cr],this._inflate[Nn]);this._inflate._readableState.endEmitted?(this._inflate.close(),this._inflate=null):(this._inflate[Nn]=0,this._inflate[cr]=[],t&&this.params[`${i}_no_context_takeover`]&&this._inflate.reset()),s(null,r)})}_compress(e,t,s){const i=this._isServer?"server":"client";if(!this._deflate){const n=`${i}_max_window_bits`,r=typeof this.params[n]!="number"?Io.Z_DEFAULT_WINDOWBITS:this.params[n];this._deflate=Io.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits:r}),this._deflate[Nn]=0,this._deflate[cr]=[],this._deflate.on("data",GA)}this._deflate[qd]=s,this._deflate.write(e),this._deflate.flush(Io.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let n=W0.concat(this._deflate[cr],this._deflate[Nn]);t&&(n=new DA(n.buffer,n.byteOffset,n.length-4)),this._deflate[qd]=null,this._deflate[Nn]=0,this._deflate[cr]=[],t&&this.params[`${i}_no_context_takeover`]&&this._deflate.reset(),s(null,n)})}}var Ih=HA;function GA(p){this[cr].push(p),this[Nn]+=p.length}function Hv(p){if(this[Nn]+=p.length,this[oh]._maxPayload<1||this[Nn]<=this[oh]._maxPayload){this[cr].push(p);return}this[Ku]=new RangeError("Max payload size exceeded"),this[Ku].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",this[Ku][Fv]=1009,this.removeListener("data",Hv),this.reset()}function UA(p){this[oh]._inflate=null,p[Fv]=1007,this[qd](p)}var ra={exports:{}},Gv={},xh={};xh.byteLength=zA;xh.toByteArray=KA;xh.fromByteArray=ZA;var yn=[],Mi=[],$A=typeof Uint8Array!="undefined"?Uint8Array:Array,_f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var la=0,WA=_f.length;la<WA;++la)yn[la]=_f[la],Mi[_f.charCodeAt(la)]=la;Mi["-".charCodeAt(0)]=62;Mi["_".charCodeAt(0)]=63;function Uv(p){var e=p.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var t=p.indexOf("=");t===-1&&(t=e);var s=t===e?0:4-t%4;return[t,s]}function zA(p){var e=Uv(p),t=e[0],s=e[1];return(t+s)*3/4-s}function jA(p,e,t){return(e+t)*3/4-t}function KA(p){var e,t=Uv(p),s=t[0],i=t[1],n=new $A(jA(p,s,i)),r=0,a=i>0?s-4:s,o;for(o=0;o<a;o+=4)e=Mi[p.charCodeAt(o)]<<18|Mi[p.charCodeAt(o+1)]<<12|Mi[p.charCodeAt(o+2)]<<6|Mi[p.charCodeAt(o+3)],n[r++]=e>>16&255,n[r++]=e>>8&255,n[r++]=e&255;return i===2&&(e=Mi[p.charCodeAt(o)]<<2|Mi[p.charCodeAt(o+1)]>>4,n[r++]=e&255),i===1&&(e=Mi[p.charCodeAt(o)]<<10|Mi[p.charCodeAt(o+1)]<<4|Mi[p.charCodeAt(o+2)]>>2,n[r++]=e>>8&255,n[r++]=e&255),n}function XA(p){return yn[p>>18&63]+yn[p>>12&63]+yn[p>>6&63]+yn[p&63]}function YA(p,e,t){for(var s,i=[],n=e;n<t;n+=3)s=(p[n]<<16&16711680)+(p[n+1]<<8&65280)+(p[n+2]&255),i.push(XA(s));return i.join("")}function ZA(p){for(var e,t=p.length,s=t%3,i=[],n=16383,r=0,a=t-s;r<a;r+=n)i.push(YA(p,r,r+n>a?a:r+n));return s===1?(e=p[t-1],i.push(yn[e>>2]+yn[e<<4&63]+"==")):s===2&&(e=(p[t-2]<<8)+p[t-1],i.push(yn[e>>10]+yn[e>>4&63]+yn[e<<2&63]+"=")),i.join("")}var dg={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */dg.read=function(p,e,t,s,i){var n,r,a=i*8-s-1,o=(1<<a)-1,d=o>>1,c=-7,u=t?i-1:0,h=t?-1:1,f=p[e+u];for(u+=h,n=f&(1<<-c)-1,f>>=-c,c+=a;c>0;n=n*256+p[e+u],u+=h,c-=8);for(r=n&(1<<-c)-1,n>>=-c,c+=s;c>0;r=r*256+p[e+u],u+=h,c-=8);if(n===0)n=1-d;else{if(n===o)return r?NaN:(f?-1:1)*(1/0);r=r+Math.pow(2,s),n=n-d}return(f?-1:1)*r*Math.pow(2,n-s)};dg.write=function(p,e,t,s,i,n){var r,a,o,d=n*8-i-1,c=(1<<d)-1,u=c>>1,h=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,f=s?0:n-1,l=s?1:-1,m=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,r=c):(r=Math.floor(Math.log(e)/Math.LN2),e*(o=Math.pow(2,-r))<1&&(r--,o*=2),r+u>=1?e+=h/o:e+=h*Math.pow(2,1-u),e*o>=2&&(r++,o/=2),r+u>=c?(a=0,r=c):r+u>=1?(a=(e*o-1)*Math.pow(2,i),r=r+u):(a=e*Math.pow(2,u-1)*Math.pow(2,i),r=0));i>=8;p[t+f]=a&255,f+=l,a/=256,i-=8);for(r=r<<i|a,d+=i;d>0;p[t+f]=r&255,f+=l,r/=256,d-=8);p[t+f-l]|=m*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(p){var e=xh,t=dg,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;p.Buffer=a,p.SlowBuffer=w,p.INSPECT_MAX_BYTES=50;var i=2147483647;p.kMaxLength=i,a.TYPED_ARRAY_SUPPORT=n(),!a.TYPED_ARRAY_SUPPORT&&typeof console!="undefined"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function n(){try{var V=new Uint8Array(1),C={foo:function(){return 42}};return Object.setPrototypeOf(C,Uint8Array.prototype),Object.setPrototypeOf(V,C),V.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.byteOffset}});function r(V){if(V>i)throw new RangeError('The value "'+V+'" is invalid for option "size"');var C=new Uint8Array(V);return Object.setPrototypeOf(C,a.prototype),C}function a(V,C,M){if(typeof V=="number"){if(typeof C=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return u(V)}return o(V,C,M)}a.poolSize=8192;function o(V,C,M){if(typeof V=="string")return h(V,C);if(ArrayBuffer.isView(V))return l(V);if(V==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof V);if(ge(V,ArrayBuffer)||V&&ge(V.buffer,ArrayBuffer)||typeof SharedArrayBuffer!="undefined"&&(ge(V,SharedArrayBuffer)||V&&ge(V.buffer,SharedArrayBuffer)))return m(V,C,M);if(typeof V=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');var F=V.valueOf&&V.valueOf();if(F!=null&&F!==V)return a.from(F,C,M);var j=g(V);if(j)return j;if(typeof Symbol!="undefined"&&Symbol.toPrimitive!=null&&typeof V[Symbol.toPrimitive]=="function")return a.from(V[Symbol.toPrimitive]("string"),C,M);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof V)}a.from=function(V,C,M){return o(V,C,M)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function d(V){if(typeof V!="number")throw new TypeError('"size" argument must be of type number');if(V<0)throw new RangeError('The value "'+V+'" is invalid for option "size"')}function c(V,C,M){return d(V),V<=0?r(V):C!==void 0?typeof M=="string"?r(V).fill(C,M):r(V).fill(C):r(V)}a.alloc=function(V,C,M){return c(V,C,M)};function u(V){return d(V),r(V<0?0:y(V)|0)}a.allocUnsafe=function(V){return u(V)},a.allocUnsafeSlow=function(V){return u(V)};function h(V,C){if((typeof C!="string"||C==="")&&(C="utf8"),!a.isEncoding(C))throw new TypeError("Unknown encoding: "+C);var M=b(V,C)|0,F=r(M),j=F.write(V,C);return j!==M&&(F=F.slice(0,j)),F}function f(V){for(var C=V.length<0?0:y(V.length)|0,M=r(C),F=0;F<C;F+=1)M[F]=V[F]&255;return M}function l(V){if(ge(V,Uint8Array)){var C=new Uint8Array(V);return m(C.buffer,C.byteOffset,C.byteLength)}return f(V)}function m(V,C,M){if(C<0||V.byteLength<C)throw new RangeError('"offset" is outside of buffer bounds');if(V.byteLength<C+(M||0))throw new RangeError('"length" is outside of buffer bounds');var F;return C===void 0&&M===void 0?F=new Uint8Array(V):M===void 0?F=new Uint8Array(V,C):F=new Uint8Array(V,C,M),Object.setPrototypeOf(F,a.prototype),F}function g(V){if(a.isBuffer(V)){var C=y(V.length)|0,M=r(C);return M.length===0||V.copy(M,0,0,C),M}if(V.length!==void 0)return typeof V.length!="number"||K(V.length)?r(0):f(V);if(V.type==="Buffer"&&Array.isArray(V.data))return f(V.data)}function y(V){if(V>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return V|0}function w(V){return+V!=V&&(V=0),a.alloc(+V)}a.isBuffer=function(C){return C!=null&&C._isBuffer===!0&&C!==a.prototype},a.compare=function(C,M){if(ge(C,Uint8Array)&&(C=a.from(C,C.offset,C.byteLength)),ge(M,Uint8Array)&&(M=a.from(M,M.offset,M.byteLength)),!a.isBuffer(C)||!a.isBuffer(M))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(C===M)return 0;for(var F=C.length,j=M.length,X=0,J=Math.min(F,j);X<J;++X)if(C[X]!==M[X]){F=C[X],j=M[X];break}return F<j?-1:j<F?1:0},a.isEncoding=function(C){switch(String(C).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(C,M){if(!Array.isArray(C))throw new TypeError('"list" argument must be an Array of Buffers');if(C.length===0)return a.alloc(0);var F;if(M===void 0)for(M=0,F=0;F<C.length;++F)M+=C[F].length;var j=a.allocUnsafe(M),X=0;for(F=0;F<C.length;++F){var J=C[F];if(ge(J,Uint8Array))X+J.length>j.length?a.from(J).copy(j,X):Uint8Array.prototype.set.call(j,J,X);else if(a.isBuffer(J))J.copy(j,X);else throw new TypeError('"list" argument must be an Array of Buffers');X+=J.length}return j};function b(V,C){if(a.isBuffer(V))return V.length;if(ArrayBuffer.isView(V)||ge(V,ArrayBuffer))return V.byteLength;if(typeof V!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof V);var M=V.length,F=arguments.length>2&&arguments[2]===!0;if(!F&&M===0)return 0;for(var j=!1;;)switch(C){case"ascii":case"latin1":case"binary":return M;case"utf8":case"utf-8":return ye(V).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return M*2;case"hex":return M>>>1;case"base64":return Mt(V).length;default:if(j)return F?-1:ye(V).length;C=(""+C).toLowerCase(),j=!0}}a.byteLength=b;function S(V,C,M){var F=!1;if((C===void 0||C<0)&&(C=0),C>this.length||((M===void 0||M>this.length)&&(M=this.length),M<=0)||(M>>>=0,C>>>=0,M<=C))return"";for(V||(V="utf8");;)switch(V){case"hex":return R(this,C,M);case"utf8":case"utf-8":return P(this,C,M);case"ascii":return D(this,C,M);case"latin1":case"binary":return H(this,C,M);case"base64":return O(this,C,M);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return _(this,C,M);default:if(F)throw new TypeError("Unknown encoding: "+V);V=(V+"").toLowerCase(),F=!0}}a.prototype._isBuffer=!0;function v(V,C,M){var F=V[C];V[C]=V[M],V[M]=F}a.prototype.swap16=function(){var C=this.length;if(C%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var M=0;M<C;M+=2)v(this,M,M+1);return this},a.prototype.swap32=function(){var C=this.length;if(C%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var M=0;M<C;M+=4)v(this,M,M+3),v(this,M+1,M+2);return this},a.prototype.swap64=function(){var C=this.length;if(C%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var M=0;M<C;M+=8)v(this,M,M+7),v(this,M+1,M+6),v(this,M+2,M+5),v(this,M+3,M+4);return this},a.prototype.toString=function(){var C=this.length;return C===0?"":arguments.length===0?P(this,0,C):S.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(C){if(!a.isBuffer(C))throw new TypeError("Argument must be a Buffer");return this===C?!0:a.compare(this,C)===0},a.prototype.inspect=function(){var C="",M=p.INSPECT_MAX_BYTES;return C=this.toString("hex",0,M).replace(/(.{2})/g,"$1 ").trim(),this.length>M&&(C+=" ... "),"<Buffer "+C+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(C,M,F,j,X){if(ge(C,Uint8Array)&&(C=a.from(C,C.offset,C.byteLength)),!a.isBuffer(C))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof C);if(M===void 0&&(M=0),F===void 0&&(F=C?C.length:0),j===void 0&&(j=0),X===void 0&&(X=this.length),M<0||F>C.length||j<0||X>this.length)throw new RangeError("out of range index");if(j>=X&&M>=F)return 0;if(j>=X)return-1;if(M>=F)return 1;if(M>>>=0,F>>>=0,j>>>=0,X>>>=0,this===C)return 0;for(var J=X-j,be=F-M,le=Math.min(J,be),Te=this.slice(j,X),Re=C.slice(M,F),ve=0;ve<le;++ve)if(Te[ve]!==Re[ve]){J=Te[ve],be=Re[ve];break}return J<be?-1:be<J?1:0};function T(V,C,M,F,j){if(V.length===0)return-1;if(typeof M=="string"?(F=M,M=0):M>2147483647?M=2147483647:M<-2147483648&&(M=-2147483648),M=+M,K(M)&&(M=j?0:V.length-1),M<0&&(M=V.length+M),M>=V.length){if(j)return-1;M=V.length-1}else if(M<0)if(j)M=0;else return-1;if(typeof C=="string"&&(C=a.from(C,F)),a.isBuffer(C))return C.length===0?-1:I(V,C,M,F,j);if(typeof C=="number")return C=C&255,typeof Uint8Array.prototype.indexOf=="function"?j?Uint8Array.prototype.indexOf.call(V,C,M):Uint8Array.prototype.lastIndexOf.call(V,C,M):I(V,[C],M,F,j);throw new TypeError("val must be string, number or Buffer")}function I(V,C,M,F,j){var X=1,J=V.length,be=C.length;if(F!==void 0&&(F=String(F).toLowerCase(),F==="ucs2"||F==="ucs-2"||F==="utf16le"||F==="utf-16le")){if(V.length<2||C.length<2)return-1;X=2,J/=2,be/=2,M/=2}function le(Ji,Ze){return X===1?Ji[Ze]:Ji.readUInt16BE(Ze*X)}var Te;if(j){var Re=-1;for(Te=M;Te<J;Te++)if(le(V,Te)===le(C,Re===-1?0:Te-Re)){if(Re===-1&&(Re=Te),Te-Re+1===be)return Re*X}else Re!==-1&&(Te-=Te-Re),Re=-1}else for(M+be>J&&(M=J-be),Te=M;Te>=0;Te--){for(var ve=!0,Ue=0;Ue<be;Ue++)if(le(V,Te+Ue)!==le(C,Ue)){ve=!1;break}if(ve)return Te}return-1}a.prototype.includes=function(C,M,F){return this.indexOf(C,M,F)!==-1},a.prototype.indexOf=function(C,M,F){return T(this,C,M,F,!0)},a.prototype.lastIndexOf=function(C,M,F){return T(this,C,M,F,!1)};function A(V,C,M,F){M=Number(M)||0;var j=V.length-M;F?(F=Number(F),F>j&&(F=j)):F=j;var X=C.length;F>X/2&&(F=X/2);for(var J=0;J<F;++J){var be=parseInt(C.substr(J*2,2),16);if(K(be))return J;V[M+J]=be}return J}function N(V,C,M,F){return Me(ye(C,V.length-M),V,M,F)}function B(V,C,M,F){return Me(xe(C),V,M,F)}function x(V,C,M,F){return Me(Mt(C),V,M,F)}function k(V,C,M,F){return Me(Ae(C,V.length-M),V,M,F)}a.prototype.write=function(C,M,F,j){if(M===void 0)j="utf8",F=this.length,M=0;else if(F===void 0&&typeof M=="string")j=M,F=this.length,M=0;else if(isFinite(M))M=M>>>0,isFinite(F)?(F=F>>>0,j===void 0&&(j="utf8")):(j=F,F=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var X=this.length-M;if((F===void 0||F>X)&&(F=X),C.length>0&&(F<0||M<0)||M>this.length)throw new RangeError("Attempt to write outside buffer bounds");j||(j="utf8");for(var J=!1;;)switch(j){case"hex":return A(this,C,M,F);case"utf8":case"utf-8":return N(this,C,M,F);case"ascii":case"latin1":case"binary":return B(this,C,M,F);case"base64":return x(this,C,M,F);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return k(this,C,M,F);default:if(J)throw new TypeError("Unknown encoding: "+j);j=(""+j).toLowerCase(),J=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function O(V,C,M){return C===0&&M===V.length?e.fromByteArray(V):e.fromByteArray(V.slice(C,M))}function P(V,C,M){M=Math.min(V.length,M);for(var F=[],j=C;j<M;){var X=V[j],J=null,be=X>239?4:X>223?3:X>191?2:1;if(j+be<=M){var le,Te,Re,ve;switch(be){case 1:X<128&&(J=X);break;case 2:le=V[j+1],(le&192)===128&&(ve=(X&31)<<6|le&63,ve>127&&(J=ve));break;case 3:le=V[j+1],Te=V[j+2],(le&192)===128&&(Te&192)===128&&(ve=(X&15)<<12|(le&63)<<6|Te&63,ve>2047&&(ve<55296||ve>57343)&&(J=ve));break;case 4:le=V[j+1],Te=V[j+2],Re=V[j+3],(le&192)===128&&(Te&192)===128&&(Re&192)===128&&(ve=(X&15)<<18|(le&63)<<12|(Te&63)<<6|Re&63,ve>65535&&ve<1114112&&(J=ve))}}J===null?(J=65533,be=1):J>65535&&(J-=65536,F.push(J>>>10&1023|55296),J=56320|J&1023),F.push(J),j+=be}return L(F)}var q=4096;function L(V){var C=V.length;if(C<=q)return String.fromCharCode.apply(String,V);for(var M="",F=0;F<C;)M+=String.fromCharCode.apply(String,V.slice(F,F+=q));return M}function D(V,C,M){var F="";M=Math.min(V.length,M);for(var j=C;j<M;++j)F+=String.fromCharCode(V[j]&127);return F}function H(V,C,M){var F="";M=Math.min(V.length,M);for(var j=C;j<M;++j)F+=String.fromCharCode(V[j]);return F}function R(V,C,M){var F=V.length;(!C||C<0)&&(C=0),(!M||M<0||M>F)&&(M=F);for(var j="",X=C;X<M;++X)j+=z[V[X]];return j}function _(V,C,M){for(var F=V.slice(C,M),j="",X=0;X<F.length-1;X+=2)j+=String.fromCharCode(F[X]+F[X+1]*256);return j}a.prototype.slice=function(C,M){var F=this.length;C=~~C,M=M===void 0?F:~~M,C<0?(C+=F,C<0&&(C=0)):C>F&&(C=F),M<0?(M+=F,M<0&&(M=0)):M>F&&(M=F),M<C&&(M=C);var j=this.subarray(C,M);return Object.setPrototypeOf(j,a.prototype),j};function E(V,C,M){if(V%1!==0||V<0)throw new RangeError("offset is not uint");if(V+C>M)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(C,M,F){C=C>>>0,M=M>>>0,F||E(C,M,this.length);for(var j=this[C],X=1,J=0;++J<M&&(X*=256);)j+=this[C+J]*X;return j},a.prototype.readUintBE=a.prototype.readUIntBE=function(C,M,F){C=C>>>0,M=M>>>0,F||E(C,M,this.length);for(var j=this[C+--M],X=1;M>0&&(X*=256);)j+=this[C+--M]*X;return j},a.prototype.readUint8=a.prototype.readUInt8=function(C,M){return C=C>>>0,M||E(C,1,this.length),this[C]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(C,M){return C=C>>>0,M||E(C,2,this.length),this[C]|this[C+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(C,M){return C=C>>>0,M||E(C,2,this.length),this[C]<<8|this[C+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(C,M){return C=C>>>0,M||E(C,4,this.length),(this[C]|this[C+1]<<8|this[C+2]<<16)+this[C+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(C,M){return C=C>>>0,M||E(C,4,this.length),this[C]*16777216+(this[C+1]<<16|this[C+2]<<8|this[C+3])},a.prototype.readIntLE=function(C,M,F){C=C>>>0,M=M>>>0,F||E(C,M,this.length);for(var j=this[C],X=1,J=0;++J<M&&(X*=256);)j+=this[C+J]*X;return X*=128,j>=X&&(j-=Math.pow(2,8*M)),j},a.prototype.readIntBE=function(C,M,F){C=C>>>0,M=M>>>0,F||E(C,M,this.length);for(var j=M,X=1,J=this[C+--j];j>0&&(X*=256);)J+=this[C+--j]*X;return X*=128,J>=X&&(J-=Math.pow(2,8*M)),J},a.prototype.readInt8=function(C,M){return C=C>>>0,M||E(C,1,this.length),this[C]&128?(255-this[C]+1)*-1:this[C]},a.prototype.readInt16LE=function(C,M){C=C>>>0,M||E(C,2,this.length);var F=this[C]|this[C+1]<<8;return F&32768?F|4294901760:F},a.prototype.readInt16BE=function(C,M){C=C>>>0,M||E(C,2,this.length);var F=this[C+1]|this[C]<<8;return F&32768?F|4294901760:F},a.prototype.readInt32LE=function(C,M){return C=C>>>0,M||E(C,4,this.length),this[C]|this[C+1]<<8|this[C+2]<<16|this[C+3]<<24},a.prototype.readInt32BE=function(C,M){return C=C>>>0,M||E(C,4,this.length),this[C]<<24|this[C+1]<<16|this[C+2]<<8|this[C+3]},a.prototype.readFloatLE=function(C,M){return C=C>>>0,M||E(C,4,this.length),t.read(this,C,!0,23,4)},a.prototype.readFloatBE=function(C,M){return C=C>>>0,M||E(C,4,this.length),t.read(this,C,!1,23,4)},a.prototype.readDoubleLE=function(C,M){return C=C>>>0,M||E(C,8,this.length),t.read(this,C,!0,52,8)},a.prototype.readDoubleBE=function(C,M){return C=C>>>0,M||E(C,8,this.length),t.read(this,C,!1,52,8)};function U(V,C,M,F,j,X){if(!a.isBuffer(V))throw new TypeError('"buffer" argument must be a Buffer instance');if(C>j||C<X)throw new RangeError('"value" argument is out of bounds');if(M+F>V.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(C,M,F,j){if(C=+C,M=M>>>0,F=F>>>0,!j){var X=Math.pow(2,8*F)-1;U(this,C,M,F,X,0)}var J=1,be=0;for(this[M]=C&255;++be<F&&(J*=256);)this[M+be]=C/J&255;return M+F},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(C,M,F,j){if(C=+C,M=M>>>0,F=F>>>0,!j){var X=Math.pow(2,8*F)-1;U(this,C,M,F,X,0)}var J=F-1,be=1;for(this[M+J]=C&255;--J>=0&&(be*=256);)this[M+J]=C/be&255;return M+F},a.prototype.writeUint8=a.prototype.writeUInt8=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,1,255,0),this[M]=C&255,M+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,2,65535,0),this[M]=C&255,this[M+1]=C>>>8,M+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,2,65535,0),this[M]=C>>>8,this[M+1]=C&255,M+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,4,4294967295,0),this[M+3]=C>>>24,this[M+2]=C>>>16,this[M+1]=C>>>8,this[M]=C&255,M+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,4,4294967295,0),this[M]=C>>>24,this[M+1]=C>>>16,this[M+2]=C>>>8,this[M+3]=C&255,M+4},a.prototype.writeIntLE=function(C,M,F,j){if(C=+C,M=M>>>0,!j){var X=Math.pow(2,8*F-1);U(this,C,M,F,X-1,-X)}var J=0,be=1,le=0;for(this[M]=C&255;++J<F&&(be*=256);)C<0&&le===0&&this[M+J-1]!==0&&(le=1),this[M+J]=(C/be>>0)-le&255;return M+F},a.prototype.writeIntBE=function(C,M,F,j){if(C=+C,M=M>>>0,!j){var X=Math.pow(2,8*F-1);U(this,C,M,F,X-1,-X)}var J=F-1,be=1,le=0;for(this[M+J]=C&255;--J>=0&&(be*=256);)C<0&&le===0&&this[M+J+1]!==0&&(le=1),this[M+J]=(C/be>>0)-le&255;return M+F},a.prototype.writeInt8=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,1,127,-128),C<0&&(C=255+C+1),this[M]=C&255,M+1},a.prototype.writeInt16LE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,2,32767,-32768),this[M]=C&255,this[M+1]=C>>>8,M+2},a.prototype.writeInt16BE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,2,32767,-32768),this[M]=C>>>8,this[M+1]=C&255,M+2},a.prototype.writeInt32LE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,4,2147483647,-2147483648),this[M]=C&255,this[M+1]=C>>>8,this[M+2]=C>>>16,this[M+3]=C>>>24,M+4},a.prototype.writeInt32BE=function(C,M,F){return C=+C,M=M>>>0,F||U(this,C,M,4,2147483647,-2147483648),C<0&&(C=4294967295+C+1),this[M]=C>>>24,this[M+1]=C>>>16,this[M+2]=C>>>8,this[M+3]=C&255,M+4};function G(V,C,M,F,j,X){if(M+F>V.length)throw new RangeError("Index out of range");if(M<0)throw new RangeError("Index out of range")}function $(V,C,M,F,j){return C=+C,M=M>>>0,j||G(V,C,M,4),t.write(V,C,M,F,23,4),M+4}a.prototype.writeFloatLE=function(C,M,F){return $(this,C,M,!0,F)},a.prototype.writeFloatBE=function(C,M,F){return $(this,C,M,!1,F)};function Z(V,C,M,F,j){return C=+C,M=M>>>0,j||G(V,C,M,8),t.write(V,C,M,F,52,8),M+8}a.prototype.writeDoubleLE=function(C,M,F){return Z(this,C,M,!0,F)},a.prototype.writeDoubleBE=function(C,M,F){return Z(this,C,M,!1,F)},a.prototype.copy=function(C,M,F,j){if(!a.isBuffer(C))throw new TypeError("argument should be a Buffer");if(F||(F=0),!j&&j!==0&&(j=this.length),M>=C.length&&(M=C.length),M||(M=0),j>0&&j<F&&(j=F),j===F||C.length===0||this.length===0)return 0;if(M<0)throw new RangeError("targetStart out of bounds");if(F<0||F>=this.length)throw new RangeError("Index out of range");if(j<0)throw new RangeError("sourceEnd out of bounds");j>this.length&&(j=this.length),C.length-M<j-F&&(j=C.length-M+F);var X=j-F;return this===C&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(M,F,j):Uint8Array.prototype.set.call(C,this.subarray(F,j),M),X},a.prototype.fill=function(C,M,F,j){if(typeof C=="string"){if(typeof M=="string"?(j=M,M=0,F=this.length):typeof F=="string"&&(j=F,F=this.length),j!==void 0&&typeof j!="string")throw new TypeError("encoding must be a string");if(typeof j=="string"&&!a.isEncoding(j))throw new TypeError("Unknown encoding: "+j);if(C.length===1){var X=C.charCodeAt(0);(j==="utf8"&&X<128||j==="latin1")&&(C=X)}}else typeof C=="number"?C=C&255:typeof C=="boolean"&&(C=Number(C));if(M<0||this.length<M||this.length<F)throw new RangeError("Out of range index");if(F<=M)return this;M=M>>>0,F=F===void 0?this.length:F>>>0,C||(C=0);var J;if(typeof C=="number")for(J=M;J<F;++J)this[J]=C;else{var be=a.isBuffer(C)?C:a.from(C,j),le=be.length;if(le===0)throw new TypeError('The value "'+C+'" is invalid for argument "value"');for(J=0;J<F-M;++J)this[J+M]=be[J%le]}return this};var he=/[^+/0-9A-Za-z-_]/g;function me(V){if(V=V.split("=")[0],V=V.trim().replace(he,""),V.length<2)return"";for(;V.length%4!==0;)V=V+"=";return V}function ye(V,C){C=C||1/0;for(var M,F=V.length,j=null,X=[],J=0;J<F;++J){if(M=V.charCodeAt(J),M>55295&&M<57344){if(!j){if(M>56319){(C-=3)>-1&&X.push(239,191,189);continue}else if(J+1===F){(C-=3)>-1&&X.push(239,191,189);continue}j=M;continue}if(M<56320){(C-=3)>-1&&X.push(239,191,189),j=M;continue}M=(j-55296<<10|M-56320)+65536}else j&&(C-=3)>-1&&X.push(239,191,189);if(j=null,M<128){if((C-=1)<0)break;X.push(M)}else if(M<2048){if((C-=2)<0)break;X.push(M>>6|192,M&63|128)}else if(M<65536){if((C-=3)<0)break;X.push(M>>12|224,M>>6&63|128,M&63|128)}else if(M<1114112){if((C-=4)<0)break;X.push(M>>18|240,M>>12&63|128,M>>6&63|128,M&63|128)}else throw new Error("Invalid code point")}return X}function xe(V){for(var C=[],M=0;M<V.length;++M)C.push(V.charCodeAt(M)&255);return C}function Ae(V,C){for(var M,F,j,X=[],J=0;J<V.length&&!((C-=2)<0);++J)M=V.charCodeAt(J),F=M>>8,j=M%256,X.push(j),X.push(F);return X}function Mt(V){return e.toByteArray(me(V))}function Me(V,C,M,F){for(var j=0;j<F&&!(j+M>=C.length||j>=V.length);++j)C[j+M]=V[j];return j}function ge(V,C){return V instanceof C||V!=null&&V.constructor!=null&&V.constructor.name!=null&&V.constructor.name===C.name}function K(V){return V!==V}var z=function(){for(var V="0123456789abcdef",C=new Array(256),M=0;M<16;++M)for(var F=M*16,j=0;j<16;++j)C[F+j]=V[M]+V[j];return C}()})(Gv);var z0;const{isUtf8:j0}=Gv,QA=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function JA(p){return p>=1e3&&p<=1014&&p!==1004&&p!==1005&&p!==1006||p>=3e3&&p<=4999}function xm(p){const e=p.length;let t=0;for(;t<e;)if((p[t]&128)===0)t++;else if((p[t]&224)===192){if(t+1===e||(p[t+1]&192)!==128||(p[t]&254)===192)return!1;t+=2}else if((p[t]&240)===224){if(t+2>=e||(p[t+1]&192)!==128||(p[t+2]&192)!==128||p[t]===224&&(p[t+1]&224)===128||p[t]===237&&(p[t+1]&224)===160)return!1;t+=3}else if((p[t]&248)===240){if(t+3>=e||(p[t+1]&192)!==128||(p[t+2]&192)!==128||(p[t+3]&192)!==128||p[t]===240&&(p[t+1]&240)===128||p[t]===244&&p[t+1]>143||p[t]>244)return!1;t+=4}else return!1;return!0}ra.exports={isValidStatusCode:JA,isValidUTF8:xm,tokenChars:QA};if(j0)z0=ra.exports.isValidUTF8=function(p){return p.length<24?xm(p):j0(p)};else if(!{}.WS_NO_UTF_8_VALIDATE)try{const p=require("utf-8-validate");z0=ra.exports.isValidUTF8=function(e){return e.length<32?xm(e):p(e)}}catch{}const{Writable:eB}=ht,K0=Ih,{BINARY_TYPES:tB,EMPTY_BUFFER:X0,kStatusCode:sB,kWebSocket:iB}=ca,{concat:Cf,toArrayBuffer:nB,unmask:rB}=na.exports,{isValidStatusCode:aB,isValidUTF8:Y0}=ra.exports,pc=Buffer[Symbol.species],xo=0,Z0=1,Q0=2,J0=3,Mf=4,oB=5;class dB extends eB{constructor(e={}){super(),this._binaryType=e.binaryType||tB[0],this._extensions=e.extensions||{},this._isServer=!!e.isServer,this._maxPayload=e.maxPayload|0,this._skipUTF8Validation=!!e.skipUTF8Validation,this[iB]=void 0,this._bufferedBytes=0,this._buffers=[],this._compressed=!1,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=!1,this._fin=!1,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._state=xo,this._loop=!1}_write(e,t,s){if(this._opcode===8&&this._state==xo)return s();this._bufferedBytes+=e.length,this._buffers.push(e),this.startLoop(s)}consume(e){if(this._bufferedBytes-=e,e===this._buffers[0].length)return this._buffers.shift();if(e<this._buffers[0].length){const s=this._buffers[0];return this._buffers[0]=new pc(s.buffer,s.byteOffset+e,s.length-e),new pc(s.buffer,s.byteOffset,e)}const t=Buffer.allocUnsafe(e);do{const s=this._buffers[0],i=t.length-e;e>=s.length?t.set(this._buffers.shift(),i):(t.set(new Uint8Array(s.buffer,s.byteOffset,e),i),this._buffers[0]=new pc(s.buffer,s.byteOffset+e,s.length-e)),e-=s.length}while(e>0);return t}startLoop(e){let t;this._loop=!0;do switch(this._state){case xo:t=this.getInfo();break;case Z0:t=this.getPayloadLength16();break;case Q0:t=this.getPayloadLength64();break;case J0:this.getMask();break;case Mf:t=this.getData(e);break;default:this._loop=!1;return}while(this._loop);e(t)}getInfo(){if(this._bufferedBytes<2){this._loop=!1;return}const e=this.consume(2);if((e[0]&48)!==0)return this._loop=!1,ks(RangeError,"RSV2 and RSV3 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_2_3");const t=(e[0]&64)===64;if(t&&!this._extensions[K0.extensionName])return this._loop=!1,ks(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._fin=(e[0]&128)===128,this._opcode=e[0]&15,this._payloadLength=e[1]&127,this._opcode===0){if(t)return this._loop=!1,ks(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(!this._fragmented)return this._loop=!1,ks(RangeError,"invalid opcode 0",!0,1002,"WS_ERR_INVALID_OPCODE");this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented)return this._loop=!1,ks(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");this._compressed=t}else if(this._opcode>7&&this._opcode<11){if(!this._fin)return this._loop=!1,ks(RangeError,"FIN must be set",!0,1002,"WS_ERR_EXPECTED_FIN");if(t)return this._loop=!1,ks(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._payloadLength>125||this._opcode===8&&this._payloadLength===1)return this._loop=!1,ks(RangeError,`invalid payload length ${this._payloadLength}`,!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH")}else return this._loop=!1,ks(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");if(!this._fin&&!this._fragmented&&(this._fragmented=this._opcode),this._masked=(e[1]&128)===128,this._isServer){if(!this._masked)return this._loop=!1,ks(RangeError,"MASK must be set",!0,1002,"WS_ERR_EXPECTED_MASK")}else if(this._masked)return this._loop=!1,ks(RangeError,"MASK must be clear",!0,1002,"WS_ERR_UNEXPECTED_MASK");if(this._payloadLength===126)this._state=Z0;else if(this._payloadLength===127)this._state=Q0;else return this.haveLength()}getPayloadLength16(){if(this._bufferedBytes<2){this._loop=!1;return}return this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength()}getPayloadLength64(){if(this._bufferedBytes<8){this._loop=!1;return}const e=this.consume(8),t=e.readUInt32BE(0);return t>Math.pow(2,53-32)-1?(this._loop=!1,ks(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",!1,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")):(this._payloadLength=t*Math.pow(2,32)+e.readUInt32BE(4),this.haveLength())}haveLength(){if(this._payloadLength&&this._opcode<8&&(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0))return this._loop=!1,ks(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");this._masked?this._state=J0:this._state=Mf}getMask(){if(this._bufferedBytes<4){this._loop=!1;return}this._mask=this.consume(4),this._state=Mf}getData(e){let t=X0;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=!1;return}t=this.consume(this._payloadLength),this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0&&rB(t,this._mask)}if(this._opcode>7)return this.controlMessage(t);if(this._compressed){this._state=oB,this.decompress(t,e);return}return t.length&&(this._messageLength=this._totalPayloadLength,this._fragments.push(t)),this.dataMessage()}decompress(e,t){this._extensions[K0.extensionName].decompress(e,this._fin,(i,n)=>{if(i)return t(i);if(n.length){if(this._messageLength+=n.length,this._messageLength>this._maxPayload&&this._maxPayload>0)return t(ks(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));this._fragments.push(n)}const r=this.dataMessage();if(r)return t(r);this.startLoop(t)})}dataMessage(){if(this._fin){const e=this._messageLength,t=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],this._opcode===2){let s;this._binaryType==="nodebuffer"?s=Cf(t,e):this._binaryType==="arraybuffer"?s=nB(Cf(t,e)):s=t,this.emit("message",s,!0)}else{const s=Cf(t,e);if(!this._skipUTF8Validation&&!Y0(s))return this._loop=!1,ks(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("message",s,!1)}}this._state=xo}controlMessage(e){if(this._opcode===8)if(this._loop=!1,e.length===0)this.emit("conclude",1005,X0),this.end();else{const t=e.readUInt16BE(0);if(!aB(t))return ks(RangeError,`invalid status code ${t}`,!0,1002,"WS_ERR_INVALID_CLOSE_CODE");const s=new pc(e.buffer,e.byteOffset+2,e.length-2);if(!this._skipUTF8Validation&&!Y0(s))return ks(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("conclude",t,s),this.end()}else this._opcode===9?this.emit("ping",e):this.emit("pong",e);this._state=xo}}var $v=dB;function ks(p,e,t,s,i){const n=new p(t?`Invalid WebSocket frame: ${e}`:e);return Error.captureStackTrace(n,ks),n.code=i,n[sB]=s,n}const{randomFillSync:cB}=ht,ey=Ih,{EMPTY_BUFFER:uB}=ca,{isValidStatusCode:hB}=ra.exports,{mask:ty,toBuffer:pa}=na.exports,Ri=Symbol("kByteLength"),fB=Buffer.alloc(4);class ur{constructor(e,t,s){this._extensions=t||{},s&&(this._generateMask=s,this._maskBuffer=Buffer.alloc(4)),this._socket=e,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._deflating=!1,this._queue=[]}static frame(e,t){let s,i=!1,n=2,r=!1;t.mask&&(s=t.maskBuffer||fB,t.generateMask?t.generateMask(s):cB(s,0,4),r=(s[0]|s[1]|s[2]|s[3])===0,n=6);let a;typeof e=="string"?(!t.mask||r)&&t[Ri]!==void 0?a=t[Ri]:(e=Buffer.from(e),a=e.length):(a=e.length,i=t.mask&&t.readOnly&&!r);let o=a;a>=65536?(n+=8,o=127):a>125&&(n+=2,o=126);const d=Buffer.allocUnsafe(i?a+n:n);return d[0]=t.fin?t.opcode|128:t.opcode,t.rsv1&&(d[0]|=64),d[1]=o,o===126?d.writeUInt16BE(a,2):o===127&&(d[2]=d[3]=0,d.writeUIntBE(a,4,6)),t.mask?(d[1]|=128,d[n-4]=s[0],d[n-3]=s[1],d[n-2]=s[2],d[n-1]=s[3],r?[d,e]:i?(ty(e,s,d,n,a),[d]):(ty(e,s,e,0,a),[d,e])):[d,e]}close(e,t,s,i){let n;if(e===void 0)n=uB;else{if(typeof e!="number"||!hB(e))throw new TypeError("First argument must be a valid error code number");if(t===void 0||!t.length)n=Buffer.allocUnsafe(2),n.writeUInt16BE(e,0);else{const a=Buffer.byteLength(t);if(a>123)throw new RangeError("The message must not be greater than 123 bytes");n=Buffer.allocUnsafe(2+a),n.writeUInt16BE(e,0),typeof t=="string"?n.write(t,2):n.set(t,2)}}const r={[Ri]:n.length,fin:!0,generateMask:this._generateMask,mask:s,maskBuffer:this._maskBuffer,opcode:8,readOnly:!1,rsv1:!1};this._deflating?this.enqueue([this.dispatch,n,!1,r,i]):this.sendFrame(ur.frame(n,r),i)}ping(e,t,s){let i,n;if(typeof e=="string"?(i=Buffer.byteLength(e),n=!1):(e=pa(e),i=e.length,n=pa.readOnly),i>125)throw new RangeError("The data size must not be greater than 125 bytes");const r={[Ri]:i,fin:!0,generateMask:this._generateMask,mask:t,maskBuffer:this._maskBuffer,opcode:9,readOnly:n,rsv1:!1};this._deflating?this.enqueue([this.dispatch,e,!1,r,s]):this.sendFrame(ur.frame(e,r),s)}pong(e,t,s){let i,n;if(typeof e=="string"?(i=Buffer.byteLength(e),n=!1):(e=pa(e),i=e.length,n=pa.readOnly),i>125)throw new RangeError("The data size must not be greater than 125 bytes");const r={[Ri]:i,fin:!0,generateMask:this._generateMask,mask:t,maskBuffer:this._maskBuffer,opcode:10,readOnly:n,rsv1:!1};this._deflating?this.enqueue([this.dispatch,e,!1,r,s]):this.sendFrame(ur.frame(e,r),s)}send(e,t,s){const i=this._extensions[ey.extensionName];let n=t.binary?2:1,r=t.compress,a,o;if(typeof e=="string"?(a=Buffer.byteLength(e),o=!1):(e=pa(e),a=e.length,o=pa.readOnly),this._firstFragment?(this._firstFragment=!1,r&&i&&i.params[i._isServer?"server_no_context_takeover":"client_no_context_takeover"]&&(r=a>=i._threshold),this._compress=r):(r=!1,n=0),t.fin&&(this._firstFragment=!0),i){const d={[Ri]:a,fin:t.fin,generateMask:this._generateMask,mask:t.mask,maskBuffer:this._maskBuffer,opcode:n,readOnly:o,rsv1:r};this._deflating?this.enqueue([this.dispatch,e,this._compress,d,s]):this.dispatch(e,this._compress,d,s)}else this.sendFrame(ur.frame(e,{[Ri]:a,fin:t.fin,generateMask:this._generateMask,mask:t.mask,maskBuffer:this._maskBuffer,opcode:n,readOnly:o,rsv1:!1}),s)}dispatch(e,t,s,i){if(!t){this.sendFrame(ur.frame(e,s),i);return}const n=this._extensions[ey.extensionName];this._bufferedBytes+=s[Ri],this._deflating=!0,n.compress(e,s.fin,(r,a)=>{if(this._socket.destroyed){const o=new Error("The socket was closed while data was being compressed");typeof i=="function"&&i(o);for(let d=0;d<this._queue.length;d++){const c=this._queue[d],u=c[c.length-1];typeof u=="function"&&u(o)}return}this._bufferedBytes-=s[Ri],this._deflating=!1,s.readOnly=!1,this.sendFrame(ur.frame(a,s),i),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){const e=this._queue.shift();this._bufferedBytes-=e[3][Ri],Reflect.apply(e[0],this,e.slice(1))}}enqueue(e){this._bufferedBytes+=e[3][Ri],this._queue.push(e)}sendFrame(e,t){e.length===2?(this._socket.cork(),this._socket.write(e[0]),this._socket.write(e[1],t),this._socket.uncork()):this._socket.write(e[0],t)}}var Wv=ur;const{kForOnEventAttribute:_o,kListener:Pf}=ca,sy=Symbol("kCode"),iy=Symbol("kData"),ny=Symbol("kError"),ry=Symbol("kMessage"),ay=Symbol("kReason"),ja=Symbol("kTarget"),oy=Symbol("kType"),dy=Symbol("kWasClean");class ua{constructor(e){this[ja]=null,this[oy]=e}get target(){return this[ja]}get type(){return this[oy]}}Object.defineProperty(ua.prototype,"target",{enumerable:!0});Object.defineProperty(ua.prototype,"type",{enumerable:!0});class Qd extends ua{constructor(e,t={}){super(e),this[sy]=t.code===void 0?0:t.code,this[ay]=t.reason===void 0?"":t.reason,this[dy]=t.wasClean===void 0?!1:t.wasClean}get code(){return this[sy]}get reason(){return this[ay]}get wasClean(){return this[dy]}}Object.defineProperty(Qd.prototype,"code",{enumerable:!0});Object.defineProperty(Qd.prototype,"reason",{enumerable:!0});Object.defineProperty(Qd.prototype,"wasClean",{enumerable:!0});class _h extends ua{constructor(e,t={}){super(e),this[ny]=t.error===void 0?null:t.error,this[ry]=t.message===void 0?"":t.message}get error(){return this[ny]}get message(){return this[ry]}}Object.defineProperty(_h.prototype,"error",{enumerable:!0});Object.defineProperty(_h.prototype,"message",{enumerable:!0});class cg extends ua{constructor(e,t={}){super(e),this[iy]=t.data===void 0?null:t.data}get data(){return this[iy]}}Object.defineProperty(cg.prototype,"data",{enumerable:!0});const lB={addEventListener(p,e,t={}){for(const i of this.listeners(p))if(!t[_o]&&i[Pf]===e&&!i[_o])return;let s;if(p==="message")s=function(n,r){const a=new cg("message",{data:r?n:n.toString()});a[ja]=this,mc(e,this,a)};else if(p==="close")s=function(n,r){const a=new Qd("close",{code:n,reason:r.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});a[ja]=this,mc(e,this,a)};else if(p==="error")s=function(n){const r=new _h("error",{error:n,message:n.message});r[ja]=this,mc(e,this,r)};else if(p==="open")s=function(){const n=new ua("open");n[ja]=this,mc(e,this,n)};else return;s[_o]=!!t[_o],s[Pf]=e,t.once?this.once(p,s):this.on(p,s)},removeEventListener(p,e){for(const t of this.listeners(p))if(t[Pf]===e&&!t[_o]){this.removeListener(p,t);break}}};var pB={CloseEvent:Qd,ErrorEvent:_h,Event:ua,EventTarget:lB,MessageEvent:cg};function mc(p,e,t){typeof p=="object"&&p.handleEvent?p.handleEvent.call(p,t):p.call(e,t)}const{tokenChars:Co}=ra.exports;function rn(p,e,t){p[e]===void 0?p[e]=[t]:p[e].push(t)}function mB(p){const e=Object.create(null);let t=Object.create(null),s=!1,i=!1,n=!1,r,a,o=-1,d=-1,c=-1,u=0;for(;u<p.length;u++)if(d=p.charCodeAt(u),r===void 0)if(c===-1&&Co[d]===1)o===-1&&(o=u);else if(u!==0&&(d===32||d===9))c===-1&&o!==-1&&(c=u);else if(d===59||d===44){if(o===-1)throw new SyntaxError(`Unexpected character at index ${u}`);c===-1&&(c=u);const f=p.slice(o,c);d===44?(rn(e,f,t),t=Object.create(null)):r=f,o=c=-1}else throw new SyntaxError(`Unexpected character at index ${u}`);else if(a===void 0)if(c===-1&&Co[d]===1)o===-1&&(o=u);else if(d===32||d===9)c===-1&&o!==-1&&(c=u);else if(d===59||d===44){if(o===-1)throw new SyntaxError(`Unexpected character at index ${u}`);c===-1&&(c=u),rn(t,p.slice(o,c),!0),d===44&&(rn(e,r,t),t=Object.create(null),r=void 0),o=c=-1}else if(d===61&&o!==-1&&c===-1)a=p.slice(o,u),o=c=-1;else throw new SyntaxError(`Unexpected character at index ${u}`);else if(i){if(Co[d]!==1)throw new SyntaxError(`Unexpected character at index ${u}`);o===-1?o=u:s||(s=!0),i=!1}else if(n)if(Co[d]===1)o===-1&&(o=u);else if(d===34&&o!==-1)n=!1,c=u;else if(d===92)i=!0;else throw new SyntaxError(`Unexpected character at index ${u}`);else if(d===34&&p.charCodeAt(u-1)===61)n=!0;else if(c===-1&&Co[d]===1)o===-1&&(o=u);else if(o!==-1&&(d===32||d===9))c===-1&&(c=u);else if(d===59||d===44){if(o===-1)throw new SyntaxError(`Unexpected character at index ${u}`);c===-1&&(c=u);let f=p.slice(o,c);s&&(f=f.replace(/\\/g,""),s=!1),rn(t,a,f),d===44&&(rn(e,r,t),t=Object.create(null),r=void 0),a=void 0,o=c=-1}else throw new SyntaxError(`Unexpected character at index ${u}`);if(o===-1||n||d===32||d===9)throw new SyntaxError("Unexpected end of input");c===-1&&(c=u);const h=p.slice(o,c);return r===void 0?rn(e,h,t):(a===void 0?rn(t,h,!0):s?rn(t,a,h.replace(/\\/g,"")):rn(t,a,h),rn(e,r,t)),e}function gB(p){return Object.keys(p).map(e=>{let t=p[e];return Array.isArray(t)||(t=[t]),t.map(s=>[e].concat(Object.keys(s).map(i=>{let n=s[i];return Array.isArray(n)||(n=[n]),n.map(r=>r===!0?i:`${i}=${r}`).join("; ")})).join("; ")).join(", ")}).join(", ")}var zv={format:gB,parse:mB};const yB=ht,wB=ht,bB=ht,jv=ht,kB=ht,{randomBytes:SB,createHash:vB}=ht,{URL:Af}=ht,hr=Ih,TB=$v,OB=Wv,{BINARY_TYPES:cy,EMPTY_BUFFER:gc,GUID:IB,kForOnEventAttribute:Bf,kListener:xB,kStatusCode:_B,kWebSocket:Fs,NOOP:Kv}=ca,{EventTarget:{addEventListener:CB,removeEventListener:MB}}=pB,{format:PB,parse:AB}=zv,{toBuffer:BB}=na.exports,NB=30*1e3,Xv=Symbol("kAborted"),Nf=[8,13],qn=["CONNECTING","OPEN","CLOSING","CLOSED"],VB=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;class Be extends yB{constructor(e,t,s){super(),this._binaryType=cy[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage=gc,this._closeTimer=null,this._extensions={},this._paused=!1,this._protocol="",this._readyState=Be.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,e!==null?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,t===void 0?t=[]:Array.isArray(t)||(typeof t=="object"&&t!==null?(s=t,t=[]):t=[t]),Zv(this,e,t,s)):this._isServer=!0}get binaryType(){return this._binaryType}set binaryType(e){!cy.includes(e)||(this._binaryType=e,this._receiver&&(this._receiver._binaryType=e))}get bufferedAmount(){return this._socket?this._socket._writableState.length+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(e,t,s){const i=new TB({binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:s.maxPayload,skipUTF8Validation:s.skipUTF8Validation});this._sender=new OB(e,this._extensions,s.generateMask),this._receiver=i,this._socket=e,i[Fs]=this,e[Fs]=this,i.on("conclude",LB),i.on("drain",RB),i.on("error",DB),i.on("message",FB),i.on("ping",HB),i.on("pong",GB),e.setTimeout(0),e.setNoDelay(),t.length>0&&e.unshift(t),e.on("close",Jv),e.on("data",Ch),e.on("end",eT),e.on("error",tT),this._readyState=Be.OPEN,this.emit("open")}emitClose(){if(!this._socket){this._readyState=Be.CLOSED,this.emit("close",this._closeCode,this._closeMessage);return}this._extensions[hr.extensionName]&&this._extensions[hr.extensionName].cleanup(),this._receiver.removeAllListeners(),this._readyState=Be.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(e,t){if(this.readyState!==Be.CLOSED){if(this.readyState===Be.CONNECTING){const s="WebSocket was closed before the connection was established";li(this,this._req,s);return}if(this.readyState===Be.CLOSING){this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end();return}this._readyState=Be.CLOSING,this._sender.close(e,t,!this._isServer,s=>{s||(this._closeFrameSent=!0,(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),NB)}}pause(){this.readyState===Be.CONNECTING||this.readyState===Be.CLOSED||(this._paused=!0,this._socket.pause())}ping(e,t,s){if(this.readyState===Be.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof e=="function"?(s=e,e=t=void 0):typeof t=="function"&&(s=t,t=void 0),typeof e=="number"&&(e=e.toString()),this.readyState!==Be.OPEN){Vf(this,e,s);return}t===void 0&&(t=!this._isServer),this._sender.ping(e||gc,t,s)}pong(e,t,s){if(this.readyState===Be.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof e=="function"?(s=e,e=t=void 0):typeof t=="function"&&(s=t,t=void 0),typeof e=="number"&&(e=e.toString()),this.readyState!==Be.OPEN){Vf(this,e,s);return}t===void 0&&(t=!this._isServer),this._sender.pong(e||gc,t,s)}resume(){this.readyState===Be.CONNECTING||this.readyState===Be.CLOSED||(this._paused=!1,this._receiver._writableState.needDrain||this._socket.resume())}send(e,t,s){if(this.readyState===Be.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof t=="function"&&(s=t,t={}),typeof e=="number"&&(e=e.toString()),this.readyState!==Be.OPEN){Vf(this,e,s);return}const i={binary:typeof e!="string",mask:!this._isServer,compress:!0,fin:!0,...t};this._extensions[hr.extensionName]||(i.compress=!1),this._sender.send(e||gc,i,s)}terminate(){if(this.readyState!==Be.CLOSED){if(this.readyState===Be.CONNECTING){const e="WebSocket was closed before the connection was established";li(this,this._req,e);return}this._socket&&(this._readyState=Be.CLOSING,this._socket.destroy())}}}Object.defineProperty(Be,"CONNECTING",{enumerable:!0,value:qn.indexOf("CONNECTING")});Object.defineProperty(Be.prototype,"CONNECTING",{enumerable:!0,value:qn.indexOf("CONNECTING")});Object.defineProperty(Be,"OPEN",{enumerable:!0,value:qn.indexOf("OPEN")});Object.defineProperty(Be.prototype,"OPEN",{enumerable:!0,value:qn.indexOf("OPEN")});Object.defineProperty(Be,"CLOSING",{enumerable:!0,value:qn.indexOf("CLOSING")});Object.defineProperty(Be.prototype,"CLOSING",{enumerable:!0,value:qn.indexOf("CLOSING")});Object.defineProperty(Be,"CLOSED",{enumerable:!0,value:qn.indexOf("CLOSED")});Object.defineProperty(Be.prototype,"CLOSED",{enumerable:!0,value:qn.indexOf("CLOSED")});["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach(p=>{Object.defineProperty(Be.prototype,p,{enumerable:!0})});["open","error","close","message"].forEach(p=>{Object.defineProperty(Be.prototype,`on${p}`,{enumerable:!0,get(){for(const e of this.listeners(p))if(e[Bf])return e[xB];return null},set(e){for(const t of this.listeners(p))if(t[Bf]){this.removeListener(p,t);break}typeof e=="function"&&this.addEventListener(p,e,{[Bf]:!0})}})});Be.prototype.addEventListener=CB;Be.prototype.removeEventListener=MB;var Yv=Be;function Zv(p,e,t,s){const i={protocolVersion:Nf[1],maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...s,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:"GET",host:void 0,path:void 0,port:void 0};if(!Nf.includes(i.protocolVersion))throw new RangeError(`Unsupported protocol version: ${i.protocolVersion} (supported versions: ${Nf.join(", ")})`);let n;if(e instanceof Af)n=e,p._url=e.href;else{try{n=new Af(e)}catch{throw new SyntaxError(`Invalid URL: ${e}`)}p._url=e}const r=n.protocol==="wss:",a=n.protocol==="ws+unix:";let o;if(n.protocol!=="ws:"&&!r&&!a?o=`The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`:a&&!n.pathname?o="The URL's pathname is empty":n.hash&&(o="The URL contains a fragment identifier"),o){const m=new SyntaxError(o);if(p._redirects===0)throw m;Xu(p,m);return}const d=r?443:80,c=SB(16).toString("base64"),u=r?wB.request:bB.request,h=new Set;let f;if(i.createConnection=r?qB:EB,i.defaultPort=i.defaultPort||d,i.port=n.port||d,i.host=n.hostname.startsWith("[")?n.hostname.slice(1,-1):n.hostname,i.headers={...i.headers,"Sec-WebSocket-Version":i.protocolVersion,"Sec-WebSocket-Key":c,Connection:"Upgrade",Upgrade:"websocket"},i.path=n.pathname+n.search,i.timeout=i.handshakeTimeout,i.perMessageDeflate&&(f=new hr(i.perMessageDeflate!==!0?i.perMessageDeflate:{},!1,i.maxPayload),i.headers["Sec-WebSocket-Extensions"]=PB({[hr.extensionName]:f.offer()})),t.length){for(const m of t){if(typeof m!="string"||!VB.test(m)||h.has(m))throw new SyntaxError("An invalid or duplicated subprotocol was specified");h.add(m)}i.headers["Sec-WebSocket-Protocol"]=t.join(",")}if(i.origin&&(i.protocolVersion<13?i.headers["Sec-WebSocket-Origin"]=i.origin:i.headers.Origin=i.origin),(n.username||n.password)&&(i.auth=`${n.username}:${n.password}`),a){const m=i.path.split(":");i.socketPath=m[0],i.path=m[1]}let l;if(i.followRedirects){if(p._redirects===0){p._originalIpc=a,p._originalSecure=r,p._originalHostOrSocketPath=a?i.socketPath:n.host;const m=s&&s.headers;if(s={...s,headers:{}},m)for(const[g,y]of Object.entries(m))s.headers[g.toLowerCase()]=y}else if(p.listenerCount("redirect")===0){const m=a?p._originalIpc?i.socketPath===p._originalHostOrSocketPath:!1:p._originalIpc?!1:n.host===p._originalHostOrSocketPath;(!m||p._originalSecure&&!r)&&(delete i.headers.authorization,delete i.headers.cookie,m||delete i.headers.host,i.auth=void 0)}i.auth&&!s.headers.authorization&&(s.headers.authorization="Basic "+Buffer.from(i.auth).toString("base64")),l=p._req=u(i),p._redirects&&p.emit("redirect",p.url,l)}else l=p._req=u(i);i.timeout&&l.on("timeout",()=>{li(p,l,"Opening handshake has timed out")}),l.on("error",m=>{l===null||l[Xv]||(l=p._req=null,Xu(p,m))}),l.on("response",m=>{const g=m.headers.location,y=m.statusCode;if(g&&i.followRedirects&&y>=300&&y<400){if(++p._redirects>i.maxRedirects){li(p,l,"Maximum redirects exceeded");return}l.abort();let w;try{w=new Af(g,e)}catch{const S=new SyntaxError(`Invalid URL: ${g}`);Xu(p,S);return}Zv(p,w,t,s)}else p.emit("unexpected-response",l,m)||li(p,l,`Unexpected server response: ${m.statusCode}`)}),l.on("upgrade",(m,g,y)=>{if(p.emit("upgrade",m),p.readyState!==Be.CONNECTING)return;if(l=p._req=null,m.headers.upgrade.toLowerCase()!=="websocket"){li(p,g,"Invalid Upgrade header");return}const w=vB("sha1").update(c+IB).digest("base64");if(m.headers["sec-websocket-accept"]!==w){li(p,g,"Invalid Sec-WebSocket-Accept header");return}const b=m.headers["sec-websocket-protocol"];let S;if(b!==void 0?h.size?h.has(b)||(S="Server sent an invalid subprotocol"):S="Server sent a subprotocol but none was requested":h.size&&(S="Server sent no subprotocol"),S){li(p,g,S);return}b&&(p._protocol=b);const v=m.headers["sec-websocket-extensions"];if(v!==void 0){if(!f){li(p,g,"Server sent a Sec-WebSocket-Extensions header but no extension was requested");return}let T;try{T=AB(v)}catch{li(p,g,"Invalid Sec-WebSocket-Extensions header");return}const I=Object.keys(T);if(I.length!==1||I[0]!==hr.extensionName){li(p,g,"Server indicated an extension that was not requested");return}try{f.accept(T[hr.extensionName])}catch{li(p,g,"Invalid Sec-WebSocket-Extensions header");return}p._extensions[hr.extensionName]=f}p.setSocket(g,y,{generateMask:i.generateMask,maxPayload:i.maxPayload,skipUTF8Validation:i.skipUTF8Validation})}),l.end()}function Xu(p,e){p._readyState=Be.CLOSING,p.emit("error",e),p.emitClose()}function EB(p){return p.path=p.socketPath,jv.connect(p)}function qB(p){return p.path=void 0,!p.servername&&p.servername!==""&&(p.servername=jv.isIP(p.host)?"":p.host),kB.connect(p)}function li(p,e,t){p._readyState=Be.CLOSING;const s=new Error(t);Error.captureStackTrace(s,li),e.setHeader?(e[Xv]=!0,e.abort(),e.socket&&!e.socket.destroyed&&e.socket.destroy(),process.nextTick(Xu,p,s)):(e.destroy(s),e.once("error",p.emit.bind(p,"error")),e.once("close",p.emitClose.bind(p)))}function Vf(p,e,t){if(e){const s=BB(e).length;p._socket?p._sender._bufferedBytes+=s:p._bufferedAmount+=s}if(t){const s=new Error(`WebSocket is not open: readyState ${p.readyState} (${qn[p.readyState]})`);process.nextTick(t,s)}}function LB(p,e){const t=this[Fs];t._closeFrameReceived=!0,t._closeMessage=e,t._closeCode=p,t._socket[Fs]!==void 0&&(t._socket.removeListener("data",Ch),process.nextTick(Qv,t._socket),p===1005?t.close():t.close(p,e))}function RB(){const p=this[Fs];p.isPaused||p._socket.resume()}function DB(p){const e=this[Fs];e._socket[Fs]!==void 0&&(e._socket.removeListener("data",Ch),process.nextTick(Qv,e._socket),e.close(p[_B])),e.emit("error",p)}function uy(){this[Fs].emitClose()}function FB(p,e){this[Fs].emit("message",p,e)}function HB(p){const e=this[Fs];e.pong(p,!e._isServer,Kv),e.emit("ping",p)}function GB(p){this[Fs].emit("pong",p)}function Qv(p){p.resume()}function Jv(){const p=this[Fs];this.removeListener("close",Jv),this.removeListener("data",Ch),this.removeListener("end",eT),p._readyState=Be.CLOSING;let e;!this._readableState.endEmitted&&!p._closeFrameReceived&&!p._receiver._writableState.errorEmitted&&(e=p._socket.read())!==null&&p._receiver.write(e),p._receiver.end(),this[Fs]=void 0,clearTimeout(p._closeTimer),p._receiver._writableState.finished||p._receiver._writableState.errorEmitted?p.emitClose():(p._receiver.on("error",uy),p._receiver.on("finish",uy))}function Ch(p){this[Fs]._receiver.write(p)||this.pause()}function eT(){const p=this[Fs];p._readyState=Be.CLOSING,p._receiver.end(),this.end()}function tT(){const p=this[Fs];this.removeListener("error",tT),this.on("error",Kv),p&&(p._readyState=Be.CLOSING,this.destroy())}const{Duplex:UB}=ht;function hy(p){p.emit("close")}function $B(){!this.destroyed&&this._writableState.finished&&this.destroy()}function sT(p){this.removeListener("error",sT),this.destroy(),this.listenerCount("error")===0&&this.emit("error",p)}function WB(p,e){let t=!0;const s=new UB({...e,autoDestroy:!1,emitClose:!1,objectMode:!1,writableObjectMode:!1});return p.on("message",function(n,r){const a=!r&&s._readableState.objectMode?n.toString():n;s.push(a)||p.pause()}),p.once("error",function(n){s.destroyed||(t=!1,s.destroy(n))}),p.once("close",function(){s.destroyed||s.push(null)}),s._destroy=function(i,n){if(p.readyState===p.CLOSED){n(i),process.nextTick(hy,s);return}let r=!1;p.once("error",function(o){r=!0,n(o)}),p.once("close",function(){r||n(i),process.nextTick(hy,s)}),t&&p.terminate()},s._final=function(i){if(p.readyState===p.CONNECTING){p.once("open",function(){s._final(i)});return}p._socket!==null&&(p._socket._writableState.finished?(i(),s._readableState.endEmitted&&s.destroy()):(p._socket.once("finish",function(){i()}),p.close()))},s._read=function(){p.isPaused&&p.resume()},s._write=function(i,n,r){if(p.readyState===p.CONNECTING){p.once("open",function(){s._write(i,n,r)});return}p.send(i,r)},s.on("end",$B),s.on("error",sT),s}var zB=WB;const{tokenChars:jB}=ra.exports;function KB(p){const e=new Set;let t=-1,s=-1,i=0;for(i;i<p.length;i++){const r=p.charCodeAt(i);if(s===-1&&jB[r]===1)t===-1&&(t=i);else if(i!==0&&(r===32||r===9))s===-1&&t!==-1&&(s=i);else if(r===44){if(t===-1)throw new SyntaxError(`Unexpected character at index ${i}`);s===-1&&(s=i);const a=p.slice(t,s);if(e.has(a))throw new SyntaxError(`The "${a}" subprotocol is duplicated`);e.add(a),t=s=-1}else throw new SyntaxError(`Unexpected character at index ${i}`)}if(t===-1||s!==-1)throw new SyntaxError("Unexpected end of input");const n=p.slice(t,i);if(e.has(n))throw new SyntaxError(`The "${n}" subprotocol is duplicated`);return e.add(n),e}var XB={parse:KB};const YB=ht,dh=ht,{createHash:ZB}=ht,fy=zv,kr=Ih,QB=XB,JB=Yv,{GUID:eN,kWebSocket:tN}=ca,sN=/^[+/0-9A-Za-z]{22}==$/,ly=0,py=1,iT=2;class iN extends YB{constructor(e,t){if(super(),e={maxPayload:100*1024*1024,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,WebSocket:JB,...e},e.port==null&&!e.server&&!e.noServer||e.port!=null&&(e.server||e.noServer)||e.server&&e.noServer)throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(e.port!=null?(this._server=dh.createServer((s,i)=>{const n=dh.STATUS_CODES[426];i.writeHead(426,{"Content-Length":n.length,"Content-Type":"text/plain"}),i.end(n)}),this._server.listen(e.port,e.host,e.backlog,t)):e.server&&(this._server=e.server),this._server){const s=this.emit.bind(this,"connection");this._removeListeners=rN(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(i,n,r)=>{this.handleUpgrade(i,n,r,s)}})}e.perMessageDeflate===!0&&(e.perMessageDeflate={}),e.clientTracking&&(this.clients=new Set,this._shouldEmitClose=!1),this.options=e,this._state=ly}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');return this._server?this._server.address():null}close(e){if(this._state===iT){e&&this.once("close",()=>{e(new Error("The server is not running"))}),process.nextTick(Mo,this);return}if(e&&this.once("close",e),this._state!==py)if(this._state=py,this.options.noServer||this.options.server)this._server&&(this._removeListeners(),this._removeListeners=this._server=null),this.clients?this.clients.size?this._shouldEmitClose=!0:process.nextTick(Mo,this):process.nextTick(Mo,this);else{const t=this._server;this._removeListeners(),this._removeListeners=this._server=null,t.close(()=>{Mo(this)})}}shouldHandle(e){if(this.options.path){const t=e.url.indexOf("?");if((t!==-1?e.url.slice(0,t):e.url)!==this.options.path)return!1}return!0}handleUpgrade(e,t,s,i){t.on("error",my);const n=e.headers["sec-websocket-key"],r=+e.headers["sec-websocket-version"];if(e.method!=="GET"){Yr(this,e,t,405,"Invalid HTTP method");return}if(e.headers.upgrade.toLowerCase()!=="websocket"){Yr(this,e,t,400,"Invalid Upgrade header");return}if(!n||!sN.test(n)){Yr(this,e,t,400,"Missing or invalid Sec-WebSocket-Key header");return}if(r!==8&&r!==13){Yr(this,e,t,400,"Missing or invalid Sec-WebSocket-Version header");return}if(!this.shouldHandle(e)){Ld(t,400);return}const a=e.headers["sec-websocket-protocol"];let o=new Set;if(a!==void 0)try{o=QB.parse(a)}catch{Yr(this,e,t,400,"Invalid Sec-WebSocket-Protocol header");return}const d=e.headers["sec-websocket-extensions"],c={};if(this.options.perMessageDeflate&&d!==void 0){const u=new kr(this.options.perMessageDeflate,!0,this.options.maxPayload);try{const h=fy.parse(d);h[kr.extensionName]&&(u.accept(h[kr.extensionName]),c[kr.extensionName]=u)}catch{Yr(this,e,t,400,"Invalid or unacceptable Sec-WebSocket-Extensions header");return}}if(this.options.verifyClient){const u={origin:e.headers[`${r===8?"sec-websocket-origin":"origin"}`],secure:!!(e.socket.authorized||e.socket.encrypted),req:e};if(this.options.verifyClient.length===2){this.options.verifyClient(u,(h,f,l,m)=>{if(!h)return Ld(t,f||401,l,m);this.completeUpgrade(c,n,o,e,t,s,i)});return}if(!this.options.verifyClient(u))return Ld(t,401)}this.completeUpgrade(c,n,o,e,t,s,i)}completeUpgrade(e,t,s,i,n,r,a){if(!n.readable||!n.writable)return n.destroy();if(n[tN])throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");if(this._state>ly)return Ld(n,503);const o=ZB("sha1").update(t+eN).digest("base64"),d=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${o}`],c=new this.options.WebSocket(null);if(s.size){const u=this.options.handleProtocols?this.options.handleProtocols(s,i):s.values().next().value;u&&(d.push(`Sec-WebSocket-Protocol: ${u}`),c._protocol=u)}if(e[kr.extensionName]){const u=e[kr.extensionName].params,h=fy.format({[kr.extensionName]:[u]});d.push(`Sec-WebSocket-Extensions: ${h}`),c._extensions=e}this.emit("headers",d,i),n.write(d.concat(`\r
`).join(`\r
`)),n.removeListener("error",my),c.setSocket(n,r,{maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation}),this.clients&&(this.clients.add(c),c.on("close",()=>{this.clients.delete(c),this._shouldEmitClose&&!this.clients.size&&process.nextTick(Mo,this)})),a(c,i)}}var nN=iN;function rN(p,e){for(const t of Object.keys(e))p.on(t,e[t]);return function(){for(const s of Object.keys(e))p.removeListener(s,e[s])}}function Mo(p){p._state=iT,p.emit("close")}function my(){this.destroy()}function Ld(p,e,t,s){t=t||dh.STATUS_CODES[e],s={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(t),...s},p.once("finish",p.destroy),p.end(`HTTP/1.1 ${e} ${dh.STATUS_CODES[e]}\r
`+Object.keys(s).map(i=>`${i}: ${s[i]}`).join(`\r
`)+`\r
\r
`+t)}function Yr(p,e,t,s,i){if(p.listenerCount("wsClientError")){const n=new Error(i);Error.captureStackTrace(n,Yr),p.emit("wsClientError",n,t,e)}else Ld(t,s,i)}const En=Yv;En.createWebSocketStream=zB;En.Server=nN;En.Receiver=$v;En.Sender=Wv;En.WebSocket=En;En.WebSocketServer=En.Server;var aN=En;const oN=Zd,{sleep:dN,isNode:_m,milliseconds:cN}=oN,uN=PA,yc=_m?aN:self.WebSocket;var hN=class extends uN{createConnection(){this.verbose&&this.log(new Date,"connecting to",this.url),this.connectionStarted=cN(),this.setConnectionTimeout(),_m?this.connection=new yc(this.url,this.protocols,this.options):this.connection=new yc(this.url,this.protocols),this.connection.onopen=this.onOpen.bind(this),this.connection.onmessage=this.onMessage.bind(this),this.connection.onerror=this.onError.bind(this),this.connection.onclose=this.onClose.bind(this),_m&&this.connection.on("ping",this.onPing.bind(this)).on("pong",this.onPong.bind(this)).on("upgrade",this.onUpgrade.bind(this))}connect(e=0){return this.startedConnecting||(this.startedConnecting=!0,e?dN(e).then(this.createConnection.bind(this)):this.createConnection()),this.connected}isOpen(){return this.connection.readyState===yc.OPEN}close(){if(this.connection instanceof yc)return this.connection.close()}};function Ka(p,e){let t=0,s=p.length-1;for(;t<=s;){const i=t+s>>>1;p[i]-e<0?t=i+1:s=i-1}return t}const fN=1024,nT=new Float64Array(new Array(fN).fill(Number.MAX_VALUE));class Mh extends Array{constructor(e=[],t=void 0){super(),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(nT),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),this.length=0;for(let s=0;s<e.length;s++)this.storeArray(e[s].slice())}storeArray(e){const t=e[0],s=e[1],i=this.side?-t:t,n=Ka(this.index,i);if(s){if(this.index[n]===i)this[n][1]=s;else if(this.length++,this.index.copyWithin(n+1,n,this.index.length),this.index[n]=i,this.copyWithin(n+1,n,this.length),this[n]=e,this.length>this.index.length-1){const r=Array.from(this.index);r.length=this.length*2,r.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(r)}}else this.index[n]===i&&(this.index.copyWithin(n,n+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(n,n+1,this.length),this.length--)}store(e,t){this.storeArray([e,t])}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class ug extends Mh{store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2],n=this.side?-t:t,r=Ka(this.index,n);if(s&&i){if(this.index[r]===n){const a=this[r];a[1]=s,a[2]=i}else if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else this.index[r]===n&&(this.index.copyWithin(r,r+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(r,r+1,this.length),this.length--)}}class hg extends Array{constructor(e=[],t=Number.MAX_SAFE_INTEGER){super(e.length),Object.defineProperty(this,"hashmap",{__proto__:null,value:new Map,writable:!0}),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(nT),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0});for(let s=0;s<e.length;s++)this.length=s,this.storeArray(e[s].slice())}store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2];let n;if(t!==void 0?n=this.side?-t:t:n=void 0,s){if(this.hashmap.has(i)){const a=this.hashmap.get(i);if(n=n||a,e[0]=Math.abs(n),n===a){const o=Ka(this.index,n);this.index[o]=n,this[o]=e;return}else{const o=Ka(this.index,a);this.index.copyWithin(o,o+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(o,o+1,this.length),this.length--}}this.hashmap.set(i,n);const r=Ka(this.index,n);if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else if(this.hashmap.has(i)){const r=this.hashmap.get(i),a=Ka(this.index,r);this.index.copyWithin(a,a+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(a,a+1,this.length),this.length--,this.hashmap.delete(i)}}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.hashmap.delete(this.index[e]),this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class lN extends Mh{get side(){return!1}}class pN extends Mh{get side(){return!0}}class mN extends ug{get side(){return!1}}class gN extends ug{get side(){return!0}}class yN extends hg{get side(){return!1}}class wN extends hg{get side(){return!0}}var bN={Asks:lN,Bids:pN,OrderBookSide:Mh,CountedAsks:mN,CountedBids:gN,CountedOrderBookSide:ug,IndexedAsks:yN,IndexedBids:wN,IndexedOrderBookSide:hg};const{iso8601:Ef}=rg,{extend:Jd,deepExtend:OW}=ZS,{Asks:kN,Bids:SN,CountedAsks:vN,CountedBids:TN,IndexedAsks:ON,IndexedBids:IN,IncrementalAsks:xN,IncrementalBids:_N,IncrementalIndexedAsks:CN,IncrementalIndexedBids:MN}=bN;class ec{constructor(e={},t=void 0){Object.defineProperty(this,"cache",{__proto__:null,value:[],writable:!0}),t=t||Number.MAX_SAFE_INTEGER;const i=Object.entries(Jd({bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0,symbol:void 0},e));for(let n=0;n<i.length;n++){const[r,a]=i[n];this[r]=a}this.asks.constructor.name==="Array"&&(this.asks=new kN(this.asks,t)),this.bids.constructor.name==="Array"&&(this.bids=new SN(this.bids,t)),this.timestamp&&(this.datetime=Ef(this.timestamp))}limit(){return this.asks.limit(),this.bids.limit(),this}update(e){return e.nonce!==void 0&&this.nonce!==void 0&&e.nonce<=this.nonce?this:(this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=Ef(this.timestamp),this.reset(e))}reset(e={}){if(this.asks.index.fill(Number.MAX_VALUE),this.asks.length=0,e.asks)for(let t=0;t<e.asks.length;t++)this.asks.storeArray(e.asks[t]);if(this.bids.index.fill(Number.MAX_VALUE),this.bids.length=0,e.bids)for(let t=0;t<e.bids.length;t++)this.bids.storeArray(e.bids[t]);return this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=Ef(this.timestamp),this.symbol=e.symbol,this}}class PN extends ec{constructor(e={},t=void 0){super(Jd(e,{asks:new vN(e.asks||[],t),bids:new TN(e.bids||[],t)}))}}class AN extends ec{constructor(e={},t=void 0){super(Jd(e,{asks:new ON(e.asks||[],t),bids:new IN(e.bids||[],t)}))}}class BN extends ec{constructor(e={},t=void 0){super(Jd(e,{asks:new xN(e.asks||[],t),bids:new _N(e.bids||[],t)}))}}class NN extends ec{constructor(e={},t=void 0){super(Jd(e,{asks:new CN(e.asks||[],t),bids:new MN(e.bids||[],t)}))}}var VN={OrderBook:ec,CountedOrderBook:PN,IndexedOrderBook:AN,IncrementalOrderBook:BN,IncrementalIndexedOrderBook:NN};const EN=re,qN=Zd.throttle,LN=hN,{OrderBook:RN,IndexedOrderBook:DN,CountedOrderBook:FN}=VN,qf=qv,{ExchangeError:gy,NotSupported:IW}=Q,HN=Lv;var GN=class extends EN{constructor(e={}){super(e),this.newUpdates=e.newUpdates||!0}inflate(e){return qf.inflate(e)}inflate64(e){return qf.inflate64(e)}gunzip(e){return qf.gunzip(e)}orderBook(e={},t=Number.MAX_SAFE_INTEGER){return new RN(e,t)}indexedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new DN(e,t)}countedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new FN(e,t)}client(e){if(this.clients=this.clients||{},!this.clients[e]){const t=this.handleMessage.bind(this),s=this.onError.bind(this),i=this.onClose.bind(this),n=this.onConnected.bind(this),r=this.safeValue(this.options,"ws",{}),a=this.deepExtend(this.streaming,{log:this.log?this.log.bind(this):this.log,ping:this.ping?this.ping.bind(this):this.ping,verbose:this.verbose,throttle:qN(this.tokenBucket),options:{agent:this.agent||this.httpsAgent||this.httpAgent}},r);this.clients[e]=new LN(e,t,s,i,n,a)}return this.clients[e]}spawn(e,...t){const s=HN();return e.apply(this,t).then(s.resolve).catch(s.reject),s}delay(e,t,...s){setTimeout(()=>{this.spawn(t,...s)},e)}watch(e,t,s=void 0,i=void 0,n=void 0){const r=this.client(e),a=0,o=r.future(t);return r.connect(a).then(()=>{if(!r.subscriptions[i]){r.subscriptions[i]=n||!0;const c=this.safeValue(this.options,"ws"),u=this.safeValue(c,"cost",1);s&&(this.enableRateLimit&&r.throttle?r.throttle(u).then(()=>{r.send(s)}).catch(h=>{throw h}):r.send(s))}}),o}onConnected(e,t=void 0){}onError(e,t){e.url in this.clients&&this.clients[e.url].error&&delete this.clients[e.url]}onClose(e,t){e.error||this.clients[e.url]&&delete this.clients[e.url]}async close(){const e=Object.values(this.clients||{});for(let t=0;t<e.length;t++){const s=e[t];delete this.clients[s.url],await s.close()}}findTimeframe(e,t=void 0){t=t||this.timeframes;const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}async loadOrderBook(e,t,s,i=void 0,n={}){if(!(s in this.orderbooks)){e.reject(new gy(this.id+" loadOrderBook() orderbook is not initiated"),t);return}const r=this.handleOption("watchOrderBook","maxRetries",3);let a=0;try{const o=this.orderbooks[s];for(;a<r;){const d=o.cache,c=await this.fetchOrderBook(s,i,n),u=this.getCacheIndex(c,d);if(u>=0){o.reset(c),this.handleDeltas(o,d.slice(u)),o.cache.length=0,e.resolve(o,t);return}a++}e.reject(new gy(this.id+" nonce is behind the cache after "+r.toString()+" tries."),t),delete this.clients[e.url]}catch(o){e.reject(o,t),await this.loadOrderBook(e,t,s,i,n)}}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}getCacheIndex(e,t){return-1}};const UN=re,{ExchangeError:$N,BadRequest:yy,PermissionDenied:wy,BadSymbol:WN,NotSupported:zN,InsufficientFunds:jN,InvalidOrder:KN}=Q,{TICK_SIZE:XN}=ne;var rT=class extends UN{describe(){return this.deepExtend(super.describe(),{id:"alpaca",name:"Alpaca",countries:["US"],rateLimit:333,hostname:"alpaca.markets",pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/187234005-b864db3d-f1e3-447a-aaf9-a9fc7b955d07.jpg",www:"https://alpaca.markets",api:{public:"https://api.{hostname}/{version}",private:"https://api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},test:{public:"https://paper-api.{hostname}/{version}",private:"https://paper-api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},doc:"https://alpaca.markets/docs/",fees:"https://alpaca.markets/support/what-are-the-fees-associated-with-crypto-trading/"},has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchL1OrderBook:!0,fetchL2OrderBook:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!1},api:{markets:{get:["assets/public/beta"]},private:{get:["account","orders","orders/{order_id}","positions","positions/{symbol}","account/activities/{activity_type}"],post:["orders"],delete:["orders","orders/{order_id}"]},cryptoPublic:{get:["crypto/latest/orderbooks","crypto/trades","crypto/quotes","crypto/latest/quotes","crypto/bars","crypto/snapshots"]}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1H","2h":"2H","4h":"4H","6h":"6H","8h":"8H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},precisionMode:XN,requiredCredentials:{apiKey:!0,secret:!0},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.003"),taker:this.parseNumber("0.003"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]]}}},headers:{"APCA-PARTNER-ID":"ccxt"},options:{fetchTradesMethod:"cryptoPublicGetCryptoTrades",fetchOHLCVMethod:"cryptoPublicGetCryptoBars",versions:{public:"v2",private:"v2",cryptoPublic:"v1beta2",markets:"v2"},defaultExchange:"CBSE",exchanges:["CBSE","FTX","GNSS","ERSX"],defaultTimeInForce:"gtc",clientOrderId:"ccxt_{id}"},exceptions:{exact:{"forbidden.":wy,4041e4:KN,40010001:yy,4011e4:wy,4031e4:jN},broad:{"Invalid format for parameter":yy,"Invalid symbol":WN}}})}async fetchMarkets(e={}){const t={asset_class:"crypto",tradeable:!0},s=await this.marketsGetAssetsPublicBeta(this.extend(t,e)),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("/"),d=this.safeString(o,0),c=this.safeString(o,1),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=u+"/"+h,m=this.safeString(r,"status")==="active",g=this.safeNumber(r,"min_order_size"),y=this.safeNumber(r,"min_trade_increment"),w=this.safeNumber(r,"price_increment");i.push({id:a,symbol:f,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:m,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:w},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbols:n.id};t!==void 0&&(a.start=this.iso8601(t)),s!==void 0&&(a.limit=parseInt(s));const o=this.safeString(this.options,"fetchTradesMethod","cryptoPublicGetCryptoTrades"),d=await this[o](this.extend(a,i)),c=this.safeValue(d,"trades",{}),u=this.safeValue(c,n.id,{});return this.parseTrades(u,n,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=i.id,r={symbols:n},a=await this.cryptoPublicGetCryptoLatestOrderbooks(this.extend(r,s)),o=this.safeValue(a,"orderbooks",{}),d=this.safeValue(o,n,{}),c=this.parse8601(this.safeString(d,"t"));return this.parseOrderBook(d,i.symbol,c,"b","a","p","s")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,timeframe:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.start=this.yyyymmdd(s));const o=this.safeString(this.options,"fetchOHLCVMethod","cryptoPublicGetCryptoBars"),d=await this[o](this.extend(a,n)),c=this.safeValue(d,"bars",{}),u=this.safeValue(c,r.id,{});return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"t");return[this.parse8601(s),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d={symbol:a.id,qty:this.amountToPrecision(e,i),side:s,type:t},c=this.safeStringN(r,["triggerPrice","stop_price"]);if(c!==void 0){let b;if(t.indexOf("limit")>=0)b="stop_limit";else throw new zN(this.id+" createOrder() does not support stop orders for "+t+" orders, only stop_limit orders are supported");d.stop_price=this.priceToPrecision(e,c),d.type=b}t.indexOf("limit")>=0&&(d.limit_price=this.priceToPrecision(e,n));const u=this.safeString(this.options,"defaultTimeInForce");d.time_in_force=this.safeString(r,"timeInForce",u),r=this.omit(r,["timeInForce","triggerPrice"]);const h=this.safeString(this.options,"clientOrderId"),m=this.uuid().split("-").join(""),g=this.implodeParams(h,{id:m}),y=this.safeString(r,"clientOrderId",g);d.client_order_id=y,r=this.omit(r,["clientOrderId"]);const w=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(w,a)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"message",{})}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeString(n,"symbol"),a=this.safeMarket(r);return this.parseOrder(n,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetOrders(i);return this.parseOrders(r,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"status"),r=this.parseOrderStatus(n),a=this.safeString(e,"commission");let o;a!==void 0&&(o={cost:a,currency:"USD"});let d=this.safeString(e,"order_type");d.indexOf("limit")>=0&&(d="limit");const c=this.safeString(e,"submitted_at"),u=this.parse8601(c);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:u,datetime:c,lastTradeTimeStamp:void 0,status:r,symbol:i,type:d,timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:void 0,side:this.safeString(e,"side"),price:this.safeNumber(e,"limit_price"),stopPrice:this.safeNumber(e,"stop_price"),triggerPrice:this.safeNumber(e,"stop_price"),cost:void 0,average:this.safeNumber(e,"filled_avg_price"),amount:this.safeNumber(e,"qty"),filled:this.safeNumber(e,"filled_qty"),remaining:void 0,trades:void 0,fee:o,info:e},t)}parseOrderStatus(e){const t={pending_new:"open",accepted:"open",new:"open",partially_filled:"open",activated:"open",filled:"closed"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={day:"Day"};return this.safeString(t,e,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"S"),i=this.safeSymbol(s,t),n=this.safeString(e,"t"),r=this.parse8601(n),a=this.safeString(e,"tks");let o;a==="B"?o="buy":a==="S"&&(o="sell");const d=this.safeString(e,"p"),c=this.safeString(e,"s");return this.safeTrade({info:e,id:this.safeString(e,"i"),timestamp:r,datetime:this.iso8601(r),symbol:i,order:void 0,type:void 0,side:o,takerOrMaker:"taker",price:d,amount:c,cost:void 0,fee:void 0},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions"),o=this.safeString(a,t);let d="/"+this.implodeParams(e,i),c=this.implodeParams(this.urls.api[t],{version:o});c=this.implodeHostname(c),n=n!==void 0?n:{},t==="private"&&(n["APCA-API-KEY-ID"]=this.apiKey,n["APCA-API-SECRET-KEY"]=this.secret);const u=this.omit(i,this.extractParams(e));return Object.keys(u).length&&(s==="GET"||s==="DELETE"?d+="?"+this.urlencode(u):(r=this.json(u),n["Content-Type"]="application/json")),c=c+d,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"code");e!==void 0&&this.throwExactlyMatchedException(this.exceptions.exact,u,c);const h=this.safeValue(a,"message",void 0);if(h!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new $N(c)}};const YN=re,{ArgumentsRequired:Lf,AuthenticationError:wc,ExchangeError:Ms,InsufficientFunds:Rf,InvalidOrder:ss,BadSymbol:Sr,PermissionDenied:by,BadRequest:Hs}=Q,{TICK_SIZE:ZN}=ne,Df=ae;var aT=class extends YN{describe(){return this.deepExtend(super.describe(),{id:"ascendex",name:"AscendEX",countries:["SG"],rateLimit:400,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:"emulated",fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1d","1w":"1w","1M":"1m"},version:"v2",urls:{logo:"https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg",api:{rest:"https://ascendex.com"},test:{rest:"https://api-test.ascendex-sandbox.com"},www:"https://ascendex.com",doc:["https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"],fees:"https://ascendex.com/en/feerate/transactionfee-traderate",referral:{url:"https://ascendex.com/en-us/register?inviteCode=EL6BXBQM",discount:.25}},api:{v1:{public:{get:{assets:1,products:1,ticker:1,"barhist/info":1,barhist:1,depth:1,trades:1,"cash/assets":1,"cash/products":1,"margin/assets":1,"margin/products":1,"futures/collateral":1,"futures/contracts":1,"futures/ref-px":1,"futures/market-data":1,"futures/funding-rates":1,"risk-limit-info":1,"exchange-info":1}},private:{get:{info:1,"wallet/transactions":1,"wallet/deposit/address":1,"data/balance/snapshot":1,"data/balance/history":1},accountCategory:{get:{balance:1,"order/open":1,"order/status":1,"order/hist/current":1,risk:1},post:{order:1,"order/batch":1},delete:{order:1,"order/all":1,"order/batch":1}},accountGroup:{get:{"cash/balance":1,"margin/balance":1,"margin/risk":1,"futures/collateral-balance":1,"futures/position":1,"futures/risk":1,"futures/funding-payments":1,"order/hist":1,"spot/fee":1},post:{transfer:1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1}}}},v2:{public:{get:{assets:1,"futures/contract":1,"futures/collateral":1,"futures/pricing-data":1,"futures/ticker":1}},private:{get:{"account/info":1},accountGroup:{get:{"order/hist":1,"futures/position":1,"futures/free-margin":1,"futures/order/hist/current":1,"futures/order/open":1,"futures/order/status":1},post:{"futures/isolated-position-margin":1,"futures/margin-type":1,"futures/leverage":1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1,"futures/order":1,"futures/order/batch":1,"futures/order/open":1,"subuser/subuser-transfer":1,"subuser/subuser-transfer-hist":1},delete:{"futures/order":1,"futures/order/batch":1,"futures/order/all":1}}}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:ZN,options:{"account-category":"cash","account-group":void 0,fetchClosedOrders:{method:"v1PrivateAccountGroupGetOrderHist"},defaultType:"spot",accountsByType:{spot:"cash",swap:"futures",future:"futures",margin:"margin"},transfer:{fillResponseFromRequest:!0}},exceptions:{exact:{1900:Hs,2100:wc,5002:Sr,6001:Sr,6010:Rf,60060:ss,600503:ss,100001:Hs,100002:Hs,100003:Hs,100004:Hs,100005:Hs,100006:Hs,100007:Hs,100008:Sr,100009:wc,100010:Hs,100011:Hs,100012:Hs,100013:Hs,100101:Ms,150001:Hs,200001:wc,200002:Ms,200003:Ms,200004:Ms,200005:Ms,200006:Ms,200007:Ms,200008:Ms,200009:Ms,200010:wc,200011:Ms,200012:Ms,200013:Ms,200014:by,200015:by,300001:ss,300002:ss,300003:ss,300004:ss,300005:ss,300006:ss,300007:ss,300008:ss,300009:ss,300011:Rf,300012:Sr,300013:ss,300014:ss,300020:ss,300021:ss,300031:ss,310001:Rf,310002:ss,310003:ss,310004:Sr,310005:ss,510001:Ms,900001:Ms},broad:{}},commonCurrencies:{BOND:"BONDED",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",PLN:"Pollen"}})}getAccount(e={}){const s=this.safeValue(e,"account",this.options.account).toLowerCase();return this.capitalize(s)}async fetchCurrencies(e={}){const t=await this.v1PublicGetAssets(e),s=await this.v1PublicGetMarginAssets(e),i=await this.v1PublicGetCashAssets(e),n=this.safeValue(t,"data",[]),r=this.safeValue(s,"data",[]),a=this.safeValue(i,"data",[]),o=this.indexBy(n,"assetCode"),d=this.indexBy(r,"assetCode"),c=this.indexBy(a,"assetCode"),u=this.deepExtend(o,d,c),h=Object.keys(u),f={};for(let l=0;l<h.length;l++){const m=h[l],g=u[m],y=this.safeCurrencyCode(m),w=this.safeString2(g,"precisionScale","nativeScale"),b=this.parseNumber(this.parsePrecision(w)),S=this.safeNumber2(g,"withdrawFee","withdrawalFee"),T=this.safeString2(g,"status","statusCode")==="Normal",I="borrowAssetCode"in g;f[y]={id:m,code:y,info:g,type:void 0,margin:I,name:this.safeString(g,"assetName"),active:T,deposit:void 0,withdraw:void 0,fee:S,precision:b,limits:{amount:{min:b,max:void 0},withdraw:{min:this.safeNumber(g,"minWithdrawalAmt"),max:void 0}}}}return f}async fetchMarkets(e={}){const t=await this.v1PublicGetProducts(e),s=await this.v1PublicGetCashProducts(e),i=await this.v2PublicGetFuturesContract(e),n=this.safeValue(t,"data",[]),r=this.indexBy(n,"symbol"),a=this.safeValue(s,"data",[]),o=this.safeValue(i,"data",[]),d=this.arrayConcat(a,o),c=this.indexBy(d,"symbol"),u=this.deepExtend(r,c),h=Object.keys(u),f=[];for(let l=0;l<h.length;l++){const m=h[l],g=u[m],y=this.safeValue(g,"settlementAsset"),w=this.safeCurrencyCode(y),b=this.safeString(g,"status"),S=this.safeString(g,"domain");let v=!1;(b==="Normal"||b==="InternalTrading")&&S!=="LeveragedETF"&&(v=!0);const T=w===void 0,I=!T,A=I?!0:void 0;let N=this.safeNumber(g,"minQty"),B=this.safeNumber(g,"maxQty"),x=this.safeNumber(g,"tickSize"),k;const P=this.safeString2(g,"underlying","symbol").split("/"),q=this.safeString(P,0),L=this.safeString(P,1),D=this.safeCurrencyCode(q),H=this.safeCurrencyCode(L);let R=D+"/"+H;if(I){const U=this.safeValue(g,"lotSizeFilter");N=this.safeNumber(U,"minQty"),B=this.safeNumber(U,"maxQty");const G=this.safeValue(g,"priceFilter");x=this.safeNumber(G,"minPrice"),k=this.safeNumber(G,"maxPrice"),R=D+"/"+H+":"+w}const _=this.safeNumber(g,"commissionReserveRate"),E=this.safeValue(g,"marginTradable",!1);f.push({id:m,symbol:R,base:D,quote:H,settle:w,baseId:q,quoteId:L,settleId:y,type:I?"swap":"spot",spot:T,margin:T?E:void 0,swap:I,future:!1,option:!1,active:v,contract:I,linear:A,inverse:I?!A:void 0,taker:_,maker:_,contractSize:I?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(g,"lotSize"),price:this.safeNumber(g,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:N,max:B},price:{min:x,max:k},cost:{min:this.safeNumber(g,"minNotional"),max:this.safeNumber(g,"maxNotional")}},info:g})}return f}async fetchTime(e={}){const t={requestTime:this.milliseconds()},s=await this.v1PublicGetExchangeInfo(this.extend(t,e)),i=this.safeValue(s,"data");return this.safeInteger(i,"requestReceiveAt")}async fetchAccounts(e={}){let t=this.safeString(this.options,"account-group"),s;if(t===void 0){s=await this.v1PrivateGetInfo(e);const i=this.safeValue(s,"data",{});t=this.safeString(i,"accountGroup"),this.options["account-group"]=t}return[{id:t,type:void 0,currency:void 0,info:s}]}parseBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(this.safeString(r,"asset")),o=this.account();o.free=this.safeString(r,"availableBalance"),o.total=this.safeString(r,"totalBalance"),s[a]=o}return this.safeBalance(s)}parseMarginBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(this.safeString(r,"asset")),o=this.account();o.free=this.safeString(r,"availableBalance"),o.total=this.safeString(r,"totalBalance");const d=this.safeString(r,"borrowed"),c=this.safeString(r,"interest");o.debt=Df.stringAdd(d,c),s[a]=o}return this.safeBalance(s)}parseSwapBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",{}),n=this.safeValue(i,"collaterals",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(this.safeString(a,"asset")),d=this.account();d.total=this.safeString(a,"balance"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();let t,s;[s,t]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),s=this.safeValue(e,"margin",!1)?"margin":s,e=this.omit(e,"margin");const n=this.safeValue(this.options,"fetchBalance",{}),r=this.safeValue(this.options,"accountsByType",{}),a=this.safeString(r,s,"cash"),o=this.safeValue(this.accounts,0,{}),c={"account-group":this.safeString(o,"id")},u=this.safeString(n,"method","v1PrivateAccountCategoryGetBalance"),h=this.getSupportedMapping(s,{spot:u,margin:u,swap:"v2PrivateAccountGroupGetFuturesPosition"});(a==="cash"||a==="margin")&&(c["account-category"]=a);const f=await this[h](this.extend(c,t));return s==="swap"?this.parseSwapBalance(f):s==="margin"?this.parseMarginBalance(f):this.parseBalance(f)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id},r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"ts"),c=this.parseOrderBook(o,e,d);return c.nonce=this.safeInteger(o,"seqnum"),c}parseTicker(e,t=void 0){const i=this.safeString(e,"symbol"),r=this.safeString(e,"type")==="spot"?"/":void 0,a=this.safeSymbol(i,t,r),o=this.safeString(e,"close"),d=this.safeValue(e,"bid",[]),c=this.safeValue(e,"ask",[]),u=this.safeString(e,"open");return this.safeTicker({symbol:a,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(d,0),bidVolume:this.safeString(d,1),ask:this.safeString(c,0),askVolume:this.safeString(c,1),vwap:void 0,open:u,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e!==void 0){const o=this.safeValue(e,0);i=this.market(o);const d=this.marketIds(e);s.symbol=d.join(",")}let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r;n==="spot"?r=await this.v1PublicGetTicker(this.extend(s,t)):r=await this.v2PublicGetFuturesTicker(this.extend(s,t));const a=this.safeValue(r,"data",[]);return Array.isArray(a)?this.parseTickers(a,e):this.parseTickers([a],e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.safeInteger(s,"ts"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]},o=this.parseTimeframe(t),d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeInteger(d,"limit",500);s!==void 0?(a.from=s,i===void 0?i=c:i=Math.min(i,c),a.to=this.sum(s,i*o*1e3,1)):i!==void 0&&(a.n=i);const u=await this.v1PublicGetBarhist(this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString2(e,"price","p"),n=this.safeString(e,"q"),a=this.safeValue(e,"bm",!1)?"sell":"buy";return t=this.safeMarket(void 0,t),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:void 0,order:void 0,type:void 0,takerOrMaker:void 0,side:a,price:i,amount:n,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.n=s);const a=await this.v1PublicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOrderStatus(e){const t={PendingNew:"open",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",Rejected:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"/");let r=this.safeInteger2(e,"timestamp","sendingTime");const a=this.safeInteger(e,"lastExecTime");r===void 0&&(r=a);const o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"avgPx"),u=this.safeString2(e,"cumFilledQty","cumQty"),h=this.safeString(e,"orderId");let f=this.safeString(e,"id");f!==void 0&&f.length<1&&(f=void 0);const l=this.safeStringLower(e,"orderType");let m=l;l!==void 0&&(l==="stoplimit"&&(m="limit"),l==="stopmarket"&&(m="market"));const g=this.safeStringLower(e,"side"),y=this.safeNumber(e,"cumFee");let w;if(y!==void 0){const I=this.safeString(e,"feeAsset"),A=this.safeCurrencyCode(I);w={cost:y,currency:A}}const b=this.safeNumber(e,"stopPrice");let S;const v=this.safeString(e,"execInst");v==="reduceOnly"&&(S=!0);let T;return v==="Post"&&(T=!0),this.safeOrder({info:e,id:h,clientOrderId:f,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:m,timeInForce:void 0,postOnly:T,reduceOnly:S,side:g,price:o,stopPrice:b,triggerPrice:b,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:w,trades:void 0},t)}async fetchTradingFees(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.safeValue(this.accounts,0,{}),i={"account-group":this.safeString(t,"id")},n=await this.v1PrivateAccountGroupGetSpotFee(this.extend(i,e)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"fees",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u,void 0,"/"),f=this.safeValue(c,"fee",{});o[h]={info:c,symbol:h,maker:this.safeNumber(f,"maker"),taker:this.safeNumber(f,"taker")}}return o}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e);let o;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);const d=this.safeValue(this.options,"createOrder",{}),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h=this.safeValue(this.accounts,0,{}),f=this.safeValue(h,"id"),l=this.safeString2(r,"clientOrderId","id"),m={"account-group":f,"account-category":u,symbol:a.id,time:this.milliseconds(),orderQty:this.amountToPrecision(e,i),orderType:t,side:s},g=t==="market"||t==="stop_market",y=t==="limit"||t==="stop_limit",w=this.safeString(r,"timeInForce"),b=this.isPostOnly(g,!1,r),S=this.safeValue(r,"reduceOnly",!1),v=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["timeInForce","postOnly","reduceOnly","stopPrice","triggerPrice"]),S){if(o!=="swap")throw new ss(this.id+" createOrder() does not support reduceOnly for "+o+" orders, reduceOnly orders are supported for perpetuals only");m.execInst="ReduceOnly"}y&&(m.orderPrice=this.priceToPrecision(e,n)),w==="IOC"&&(m.timeInForce="IOC"),w==="FOK"&&(m.timeInForce="FOK"),b&&(m.postOnly=!0),v!==void 0&&(m.stopPrice=this.priceToPrecision(e,v),y?m.orderType="stop_limit":g&&(m.orderType="stop_market")),l!==void 0&&(m.id=l);const T=this.safeString(d,"method","v1PrivateAccountCategoryPostOrder"),I=this.getSupportedMapping(o,{spot:T,margin:T,swap:"v2PrivateAccountGroupPostFuturesOrder"});I==="v1PrivateAccountCategoryPostOrder"?u!==void 0&&(m.category=u):m["account-category"]=u;const A=await this[I](this.extend(m,r)),N=this.safeValue(A,"data",{}),B=this.safeValue2(N,"order","info",{});return this.parseOrder(B,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),await this.loadAccounts();let i;t!==void 0&&(i=this.market(t));const[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,orderId:e},f=this.safeString(a,"method","v1PrivateAccountCategoryGetOrderStatus"),l=this.getSupportedMapping(n,{spot:f,margin:f,swap:"v2PrivateAccountGroupGetFuturesOrderStatus"});l==="v1PrivateAccountCategoryGetOrderStatus"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=await this[l](this.extend(h,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const r=this.safeValue(this.accounts,0,{}),a=this.safeValue(r,"id"),[o,d]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h={"account-group":a,"account-category":u},f=this.safeValue(this.options,"fetchOpenOrders",{}),l=this.safeString(f,"method","v1PrivateAccountCategoryGetOrderOpen"),m=this.getSupportedMapping(o,{spot:l,margin:l,swap:"v2PrivateAccountGroupGetFuturesOrderOpen"});m==="v1PrivateAccountCategoryGetOrderOpen"?u!==void 0&&(h.category=u):h["account-category"]=u;const g=await this[m](this.extend(h,d)),y=this.safeValue(g,"data",[]);if(u==="futures")return this.parseOrders(y,n,t,s);const w=[];for(let b=0;b<y.length;b++){const S=this.parseOrder(y[b],n);w.push(S)}return this.filterBySymbolSinceLimit(w,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeValue(n,"id")};let o;e!==void 0&&(o=this.market(e),a.symbol=o.id);const[d,c]=this.handleMarketTypeAndParams("fetchClosedOrders",o,i),u=this.safeValue(this.options,"fetchClosedOrders",{}),h=this.safeString(u,"method","v1PrivateAccountGroupGetOrderHist"),f=this.getSupportedMapping(d,{spot:h,margin:h,swap:"v2PrivateAccountGroupGetFuturesOrderHistCurrent"}),l=this.safeValue(this.options,"accountsByType",{}),m=this.safeString(l,d,"cash");f==="v1PrivateAccountGroupGetOrderHist"?m!==void 0&&(a.category=m):a["account-category"]=m,t!==void 0&&(a.startTime=t),s!==void 0&&(a.pageSize=s);const g=await this[f](this.extend(a,c));let y=this.safeValue(g,"data");return Array.isArray(y)||(y=this.safeValue(y,"data",[])),this.parseOrders(y,o,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Lf(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s),a=this.safeValue(this.options,"cancelOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,symbol:i.id,time:this.milliseconds(),id:"foobar"},f=this.safeString(a,"method","v1PrivateAccountCategoryDeleteOrder"),l=this.getSupportedMapping(n,{spot:f,margin:f,swap:"v2PrivateAccountGroupDeleteFuturesOrder"});l==="v1PrivateAccountCategoryDeleteOrder"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=this.safeString2(s,"clientOrderId","id");m===void 0?h.orderId=e:(h.id=m,s=this.omit(s,["clientOrderId","id"]));const g=await this[l](this.extend(h,r)),y=this.safeValue(g,"data",{}),w=this.safeValue2(y,"order","info",{});return this.parseOrder(w,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();let s;e!==void 0&&(s=this.market(e));const[i,n]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),r=this.safeValue(this.options,"cancelAllOrders",{}),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,i,"cash"),d=this.safeValue(this.accounts,0,{}),u={"account-group":this.safeValue(d,"id"),"account-category":o,time:this.milliseconds()};e!==void 0&&(u.symbol=s.id);const h=this.safeString(r,"method","v1PrivateAccountCategoryDeleteOrderAll"),f=this.getSupportedMapping(i,{spot:h,margin:h,swap:"v2PrivateAccountGroupDeleteFuturesOrderAll"});return f==="v1PrivateAccountCategoryDeleteOrderAll"?o!==void 0&&(u.category=o):u["account-category"]=o,await this[f](this.extend(u,n))}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tagId"),n=this.safeString(e,i);this.checkAddress(s);const r=t===void 0?void 0:t.code,a=this.safeString(e,"chainName"),o=this.safeNetwork(a);return{currency:r,address:s,tag:n,network:o,info:e}}safeNetwork(e){const t={TRC20:"TRC20",ERC20:"ERC20",GO20:"GO20",BEP2:"BEP2","BEP20 (BSC)":"BEP20",Bitcoin:"BTC","Bitcoin ABC":"BCH",Litecoin:"LTC","Matic Network":"MATIC",Solana:"SOL",xDai:"STAKE",Akash:"AKT"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"chainName");t=this.omit(t,"chainName");const n={asset:s.id},r=await this.v1PrivateGetWalletDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"address",[]),d=o.length;let c;if(d>1){const h=this.indexBy(o,"chainName");if(i===void 0){const l=Object.keys(h).join(", ");throw new Lf(this.id+" fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "+l)}c=this.safeValue(h,i,{})}else c=this.safeValue(o,0,{});const u=this.parseDepositAddress(c,s);return this.extend(u,{info:r})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"deposit"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"withdrawal"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.startTs=t),s!==void 0&&(n.pageSize=s);const a=await this.v1PrivateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={reviewing:"pending",pending:"pending",confirmed:"ok",rejected:"rejected"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"destAddress",{}),i=this.safeString(s,"address"),n=this.safeString(s,"destTag"),r=this.safeInteger(e,"time"),a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t);return{info:e,id:this.safeString(e,"requestId"),txid:this.safeString(e,"networkTransactionId"),type:this.safeString(e,"transactionType"),currency:o,network:void 0,amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:r,datetime:this.iso8601(r),address:i,addressFrom:void 0,addressTo:i,tag:n,tagFrom:void 0,tagTo:n,updated:void 0,comment:void 0,fee:{currency:o,cost:this.safeNumber(e,"commission"),rate:void 0}}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeValue(this.accounts,0,{}),n={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"contracts",[]),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return e=this.marketSymbols(e),this.filterByArray(d,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeNumber(e,"buyOpenOrderNotional");i===0&&(i=this.safeNumber(e,"sellOpenOrderNotional"));const n=this.safeString(e,"marginType");let r;return n==="isolated"&&(r=this.safeNumber(e,"isolatedMargin")),{info:e,id:void 0,symbol:t.symbol,notional:i,marginMode:n,liquidationPrice:void 0,entryPrice:this.safeNumber(e,"avgOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPnl"),percentage:void 0,contracts:this.safeNumber(e,"position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"markPrice"),side:this.safeStringLower(e,"side"),hedged:void 0,timestamp:void 0,datetime:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:r,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeInteger(e,"leverage"),marginRatio:void 0}}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"time"),r=this.safeNumber(e,"fundingRate"),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),previousFundingRate:void 0,nextFundingRate:void 0,previousFundingTimestamp:void 0,nextFundingTimestamp:void 0,previousFundingDatetime:void 0,nextFundingDatetime:void 0,fundingRate:r,fundingTimestamp:a,fundingDatetime:this.iso8601(a)}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v2PublicGetFuturesPricingData(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"contracts",[]),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.market(e),r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id");t=this.amountToPrecision(e,t);const o={"account-group":a,symbol:n.id,amount:t},d=await this.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.extend(o,i));return s==="reduce"&&(t=Df.stringAbs(t)),this.extend(this.parseMarginModification(d,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="0"?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Lf(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new Hs(this.id+" leverage should be between 1 and 100");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t);if(i.type!=="future")throw new Sr(this.id+" setLeverage() supports futures contracts only");const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,leverage:e};return await this.v2PrivateAccountGroupPostFuturesLeverage(this.extend(a,s))}async setMarginMode(e,t=void 0,s={}){if(e=e.toLowerCase(),e==="cross"&&(e="crossed"),e!=="isolated"&&e!=="crossed")throw new Hs(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,marginMode:e};if(i.type!=="future")throw new Sr(this.id+" setMarginMode() supports futures contracts only");return await this.v2PrivateAccountGroupPostFuturesMarginType(this.extend(a,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PublicGetFuturesContract(t),i=this.safeValue(s,"data");return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeValue(e,"marginRequirements",[]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"initialMarginRate");n.push({tier:this.sum(r,1),currency:t.quote,minNotional:this.safeNumber(a,"positionNotionalLowerBound"),maxNotional:this.safeNumber(a,"positionNotionalUpperBound"),maintenanceMarginRate:this.safeNumber(a,"maintenanceMarginRate"),maxLeverage:this.parseNumber(Df.stringDiv("1",o)),info:a})}return n}async transfer(e,t,s,i,n={}){await this.loadMarkets(),await this.loadAccounts();const r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id"),o=this.currency(e);t=this.currencyToPrecision(e,t);const d=this.safeValue(this.options,"accountsByType",{}),c=this.safeString(d,s,s),u=this.safeString(d,i,i);if(c!=="cash"&&u!=="cash")throw new Ms(this.id+" transfer() only supports direct balance transfer between spot and future, spot and margin");const h={"account-group":a,amount:t,asset:o.id,fromAccount:c,toAccount:u},f=await this.v1PrivateAccountGroupPostTransfer(this.extend(h,n)),l=this.safeValue(this.options,"transfer",{}),m=this.safeValue(l,"fillResponseFromRequest",!0),g=this.parseTransfer(f,o);return m&&(g.fromAccount=s,g.toAccount=i,g.amount=t,g.currency=e),g}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"code"),i=this.safeCurrencyCode(void 0,t),n=this.milliseconds();return{info:e,id:void 0,timestamp:n,datetime:this.iso8601(n),currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return e===0?"ok":"failed"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1],d=this.safeString(t,2);let c="";const u=d==="accountCategory";(u||d==="accountGroup")&&(c+=this.implodeParams("/{account-group}",i),i=this.omit(i,"account-group"));let h=this.implodeParams(e,i);if(c+="/api/pro/",a==="v2"?h=a+"/"+h:c+=a+"/",u&&(c+=this.implodeParams("{account-category}/",i)),i=this.omit(i,"account-category"),c+=h,(a==="v1"&&h==="cash/balance"||h==="margin/balance")&&(h="balance"),a==="v1"&&h==="spot/fee"&&(h="fee"),h.indexOf("subuser")>=0&&(h=h.split("/")[2]),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(c+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const f=this.milliseconds().toString(),l=f+"+"+h,m=this.hmac(this.encode(l),this.encode(this.secret),"sha256","base64");n={"x-auth-key":this.apiKey,"x-auth-timestamp":f,"x-auth-signature":m},s==="GET"?Object.keys(i).length&&(c+="?"+this.urlencode(i)):(n["Content-Type"]="application/json",r=this.json(i))}return c=this.urls.api.rest+c,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"||u!==void 0){const f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,f),this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwBroadlyMatchedException(this.exceptions.broad,u,f),new Ms(f)}}};const QN=re,{BadSymbol:ky,PermissionDenied:JN,ExchangeError:Po,ExchangeNotAvailable:eV,OrderNotFound:Ff,InsufficientFunds:tV,InvalidOrder:ma,RequestTimeout:sV,AuthenticationError:iV}=Q,{TRUNCATE:nV,TICK_SIZE:Sy}=ne,rV=ae;var Ph=class extends QN{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"2",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com",private:"https://api.demo.hitbtc.com"},api:{public:"https://api.hitbtc.com",private:"https://api.hitbtc.com"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com/v2"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{currency:3,"currency/{currency}":3,symbol:3,"symbol/{symbol}":3,ticker:3,"ticker/{symbol}":3,trades:3,"trades/{symbol}":3,orderbook:3,"orderbook/{symbol}":3,candles:3,"candles/{symbol}":3}},private:{get:{"trading/balance":15.0015,order:15.0015,"order/{clientOrderId}":15.0015,"trading/fee/all":15.0015,"trading/fee/{symbol}":15.0015,"margin/account":15.0015,"margin/account/{symbol}":15.0015,"margin/position":15.0015,"margin/position/{symbol}":15.0015,"margin/order":15.0015,"margin/order/{clientOrderId}":15.0015,"history/order":15.0015,"history/trades":15.0015,"history/order/{orderId}/trades":15.0015,"account/balance":15.0015,"account/crypto/address/{currency}":15.0015,"account/crypto/addresses/{currency}":15.0015,"account/crypto/used-addresses/{currency}":15.0015,"account/crypto/estimate-withdraw":15.0015,"account/crypto/is-mine/{address}":15.0015,"account/transactions":15.0015,"account/transactions/{id}":15.0015,"sub-acc":15.0015,"sub-acc/acl":15.0015,"sub-acc/balance/{subAccountUserID}":15.0015,"sub-acc/deposit-address/{subAccountUserId}/{currency}":15.0015},post:{order:1,"margin/order":1,"account/crypto/address/{currency}":1,"account/crypto/withdraw":1,"account/crypto/transfer-convert":1,"account/transfer":1,"account/transfer/internal":1,"sub-acc/freeze":1,"sub-acc/activate":1,"sub-acc/transfer":1},put:{"order/{clientOrderId}":1,"margin/account/{symbol}":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1,"sub-acc/acl/{subAccountUserId}":1},delete:{order:1,"order/{clientOrderId}":1,"margin/account":1,"margin/account/{symbol}":1,"margin/position":1,"margin/position/{symbol}":1,"margin/order":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1},patch:{"order/{clientOrderId}":1}}},precisionMode:Sy,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002")}},options:{networks:{ETH:"T20",ERC20:"T20",TRX:"TTRX",TRC20:"TTRX",OMNI:""},defaultTimeInForce:"FOK",accountsByType:{funding:"bank",spot:"exchange"},fetchBalanceMethod:{account:"account",bank:"account",main:"account",funding:"account",exchange:"trading",spot:"trading",trade:"trading",trading:"trading"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"},exceptions:{504:sV,1002:iV,1003:JN,2010:ma,2001:ky,2011:ma,2020:ma,20002:Ff,20001:tV,20010:ky,20045:ma}})}feeToPrecision(e,t){return this.decimalToPrecision(t,nV,1e-8,Sy)}async fetchMarkets(e={}){const t=await this.publicGetSymbol(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"baseCurrency"),o=this.safeString(n,"quoteCurrency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);let u=d+"/"+c;r.indexOf("_")>=0&&(u=r);const h=this.safeString(n,"quantityIncrement"),f=this.safeString(n,"tickSize"),l=this.parseNumber(h),m=this.parseNumber(f),g=this.safeString(n,"feeCurrency");s.push(this.extend(this.fees.trading,{id:r,symbol:u,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"takeLiquidityRate"),maker:this.safeNumber(n,"provideLiquidityRate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:this.safeCurrencyCode(g),precision:{amount:l,price:m},limits:{leverage:{min:void 0,max:void 0},amount:{min:l,max:void 0},price:{min:m,max:void 0},cost:{min:this.parseNumber(rV.stringMul(h,f)),max:void 0}},info:n}))}return s}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:r.id,amount:a};let d=this.safeString(n,"type");if(d===void 0){const h=this.safeValue(this.options,"accountsByType",{}),f=this.safeString(h,s,s),l=this.safeString(h,i,i);if(f===l)throw new Po(this.id+" transfer() from and to cannot be the same account");d=f+"To"+this.capitalize(l)}o.type=d;const c=await this.privatePostAccountTransfer(this.extend(o,n)),u=this.parseTransfer(c,r);return this.extend(u,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"precisionTransfer","8"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"payinEnabled"),c=this.safeValue(n,"payoutEnabled"),u=this.safeValue(n,"transferEnabled");let h=d&&c&&u;"disabled"in n&&n.disabled&&(h=!1);let f="fiat";"crypto"in n&&n.crypto&&(f="crypto");const l=this.safeString(n,"fullName");s[o]={id:r,code:o,type:f,payin:d,payout:c,transfer:u,info:n,name:l,active:h,deposit:d,withdraw:c,fee:this.safeNumber(n,"payoutFee"),precision:this.parseNumber(this.parsePrecision(a)),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.safeNumber(e,"provideLiquidityRate"),taker:this.safeNumber(e,"takeLiquidityRate"),percentage:!0,tierBased:!0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.privateGetTradingFeeSymbol(i);return this.parseTradingFee(n,s)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","trading"),s=this.safeValue(this.options,"fetchBalanceMethod",{}),i=this.safeString(s,t);if(i===void 0)throw new Po(this.id+" fetchBalance() account type must be either main or trading");const n="privateGet"+this.capitalize(i)+"Balance",r=this.omit(e,"type"),a=await this[n](r);return this.parseBalance(a)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetCandlesSymbol(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bid","ask","price","size")}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volumeQuote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a),d=o.symbol;i[d]=this.parseTicker(r,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));if("message"in n)throw new Po(this.id+" "+n.message);return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee");if(a!==void 0){const f=t?t.feeCurrency:void 0;r={cost:a,currency:f}}const o=this.safeString(e,"clientOrderId"),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"side"),h=this.safeString(e,"id");return this.safeTrade({info:e,id:h,order:o,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:u,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:r},t)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.asset=n.id),t!==void 0&&(r.startTime=t);const a=await this.privateGetAccountTransactions(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"createdAt")),n=this.parse8601(this.safeString(e,"updatedAt")),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.parseTransactionStatus(this.safeString(e,"status")),d=this.safeNumber(e,"amount"),c=this.safeString(e,"address"),u=this.safeString(e,"hash"),h={currency:void 0,cost:void 0,rate:void 0},f=this.safeNumber(e,"fee");f!==void 0&&(h.cost=f,h.currency=a);const l=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,type:l,currency:a,network:void 0,amount:d,status:o,timestamp:i,datetime:this.iso8601(i),address:c,addressFrom:void 0,addressTo:void 0,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:n,comment:void 0,fee:h}}parseTransactionStatus(e){const t={pending:"pending",failed:"failed",success:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={payin:"deposit",payout:"withdrawal",withdraw:"withdrawal"};return this.safeString(t,e,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=this.iso8601(t));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let c=this.uuid().split("-").join("");c=c.slice(0,32),i=parseFloat(i);const u={clientOrderId:c,symbol:a.id,side:s,quantity:this.amountToPrecision(e,i),type:t};t==="limit"?u.price=this.priceToPrecision(e,n):u.timeInForce=this.options.defaultTimeInForce;const h=await this.privatePostOrder(this.extend(u,r)),f=this.parseOrder(h);if(f.status==="rejected")throw new ma(this.id+" order was rejected by the exchange "+this.json(f));return f}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();let c=this.uuid().split("-").join("");c=c.slice(0,32);const u={clientOrderId:e,requestClientId:c};n!==void 0&&(u.quantity=this.amountToPrecision(t,n)),r!==void 0&&(u.price=this.priceToPrecision(t,r));const h=await this.privatePatchOrderClientOrderId(this.extend(u,a));return this.parseOrder(h)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateDeleteOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"createdAt")),i=this.parse8601(this.safeString(e,"updatedAt")),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"quantity"),o=this.safeString(e,"cumQuantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"clientOrderId"),u=c,h=this.safeString(e,"price"),f=this.safeString(e,"type"),l=this.safeString(e,"side"),m=this.safeValue(e,"tradesReport"),g=void 0,y=this.safeString(e,"avgPrice"),w=this.safeString(e,"timeInForce");return this.safeOrder({id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:f,timeInForce:w,side:l,price:h,stopPrice:void 0,triggerPrice:void 0,average:y,amount:a,cost:void 0,filled:o,remaining:void 0,fee:g,trades:m,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetHistoryOrder(this.extend(i,s));if(n.length>0)return this.parseOrder(n[0]);throw new Ff(this.id+" order "+e+" not found")}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);const a=await this.privateGetOrder(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=this.iso8601(t));const a=await this.privateGetHistoryOrder(this.extend(r,i)),o=this.parseOrders(a,n),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=u.status;(h==="closed"||h==="canceled")&&d.push(u)}return this.filterBySinceLimit(d,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.from=this.iso8601(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetHistoryTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={orderId:e},o=await this.privateGetHistoryOrderOrderIdTrades(this.extend(a,n));if(o.length>0)return this.parseTrades(o,r,s,i);throw new Ff(this.id+" order "+e+" not found, "+this.id+'.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]')}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountCryptoAddressCurrency(this.extend(i,t)),r=this.safeString(n,"address");this.checkAddress(r);const a=this.safeString(n,"paymentId");return{currency:s,address:r,tag:a,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeString(t,"network");if(n!==void 0){t=this.omit(t,"network");const d=this.safeValue(this.options,"networks"),c=this.safeString(d,n,n);i.currency+=c}const r=await this.privateGetAccountCryptoAddressCurrency(this.extend(i,t)),a=this.safeString(r,"address");this.checkAddress(a);const o=this.safeString(r,"paymentId");return{currency:s.code,address:a,tag:o,network:void 0,info:r}}async convertCurrencyNetwork(e,t,s,i,n){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"networks",{});if(s=this.safeString(a,s,s),i=this.safeString(a,i,i),s===i)throw new Po(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");const o={fromCurrency:r.id+s,toCurrency:r.id+i,amount:parseFloat(this.currencyToPrecision(e,t))};return{info:await this.privatePostAccountCryptoTransferConvert(this.extend(o,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:parseFloat(t),address:s};i&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostAccountCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/";const o=this.omit(i,this.extractParams(e));if(t==="public")a+=t+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o));const d=this.encode(this.apiKey+":"+this.secret),c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"}}return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;if(e===503||e===504)throw new eV(c);if(e===429)return;if(r[0]==="{"&&"error"in a){const u=this.safeString(a.error,"code");if(this.throwExactlyMatchedException(this.exceptions,u,c),this.safeString(a.error,"message")==="Duplicate clientOrderId")throw new ma(c)}throw new Po(c)}}};const aV=Ph;var oV=class extends aV{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const dV=re,{ExchangeError:vr,ArgumentsRequired:Hf,AuthenticationError:Gf,InsufficientFunds:vy,PermissionDenied:Ty,BadRequest:Oy,BadSymbol:Iy,RateLimitExceeded:cV,InvalidOrder:ga}=Q,{TICK_SIZE:uV}=ne;var hV=class extends dV{describe(){return this.deepExtend(super.describe(),{id:"bigone",name:"BigONE",countries:["CN"],version:"v3",rateLimit:1200,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"min1","5m":"min5","15m":"min15","30m":"min30","1h":"hour1","3h":"hour3","4h":"hour4","6h":"hour6","12h":"hour12","1d":"day1","1w":"week1","1M":"month1"},hostname:"big.one",urls:{logo:"https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg",api:{public:"https://{hostname}/api/v3",private:"https://{hostname}/api/v3/viewer"},www:"https://big.one",doc:"https://open.big.one/docs/api.html",fees:"https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",referral:"https://b1.run/users/new?code=D3LLBVFT"},api:{public:{get:["ping","asset_pairs","asset_pairs/{asset_pair_name}/depth","asset_pairs/{asset_pair_name}/trades","asset_pairs/{asset_pair_name}/ticker","asset_pairs/{asset_pair_name}/candles","asset_pairs/tickers"]},private:{get:["accounts","fund/accounts","assets/{asset_symbol}/address","orders","orders/{id}","orders/multi","trades","withdrawals","deposits"],post:["orders","orders/{id}/cancel","orders/cancel","withdrawals","transfer"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},options:{accountsByType:{spot:"SPOT",funding:"FUND",future:"CONTRACT",swap:"CONTRACT"},transfer:{fillResponseFromRequest:!0},exchangeMillisecondsCorrection:-100},precisionMode:uV,exceptions:{exact:{10001:Oy,10005:vr,"Amount's scale must greater than AssetPair's base scale":ga,"Price mulit with amount should larger than AssetPair's min_quote_value":ga,10007:Oy,10011:vr,10013:Iy,10014:vy,10403:Ty,10429:cV,40004:Gf,40103:Gf,40104:Gf,40301:Ty,40302:vr,40601:vr,40602:vr,40603:vy,40604:ga,40605:ga,40120:ga,40121:ga,60100:Iy},broad:{}},commonCurrencies:{CRE:"Cybereits",FXT:"FXTTOKEN",FREE:"FreeRossDAO",MBN:"Mobilian Coin",ONE:"BigONE Token"}})}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"id"),d=this.safeValue(r,"base_asset",{}),c=this.safeValue(r,"quote_asset",{}),u=this.safeString(d,"symbol"),h=this.safeString(c,"symbol"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h),m={id:a,uuid:o,symbol:f+"/"+l,base:f,quote:l,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"base_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quote_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_quote_value"),max:this.safeNumber(r,"max_quote_value")}},info:r};i.push(m)}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByUuid");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r],o=this.safeString(a,"uuid");i[o]=a}this.options.marketsByUuid=i}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"asset_pair_name"),i=this.safeSymbol(s,t,"-"),n=void 0,r=this.safeString(e,"close"),a=this.safeValue(e,"bid",{}),o=this.safeValue(e,"ask",{});return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(a,"price"),bidVolume:this.safeString(a,"quantity"),ask:this.safeString(o,"price"),askVolume:this.safeString(o,"quantity"),vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily_change"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={asset_pair_name:s.id},n=await this.publicGetAssetPairsAssetPairNameTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e=this.marketSymbols(e),e!==void 0){const a=this.marketIds(e);s.pair_names=a.join(",")}const i=await this.publicGetAssetPairsTickers(this.extend(s,t)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"timestamp");return parseInt(i/1e6)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={asset_pair_name:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetAssetPairsAssetPairNameDepth(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","quantity")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"created_at","inserted_at")),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString(e,"asset_pair_name");t=this.safeMarket(r,t,"-");let a=this.safeString(e,"side");const o=this.safeString(e,"taker_side");let d;o!==void 0&&a!==void 0&&a!=="SELF_TRADING"&&(d=o===a?"taker":"maker"),a===void 0?a=o==="ASK"?"sell":"buy":a==="BID"?a="buy":a==="ASK"&&(a="sell");const c=this.safeString(e,"maker_order_id"),u=this.safeString(e,"taker_order_id");let h;c!==void 0?u!==void 0?h=[c,u]:h=c:u!==void 0&&(h=u);const l={id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:h,type:"limit",side:a,takerOrMaker:d,price:i,amount:n,cost:void 0,info:e};let m,g;d!==void 0?a==="buy"?d==="maker"?(m=t.base,g=t.quote):(m=t.quote,g=t.base):d==="maker"?(m=t.quote,g=t.base):(m=t.base,g=t.quote):a==="SELF_TRADING"&&(o==="BID"?(m=t.quote,g=t.base):o==="ASK"&&(m=t.base,g=t.quote));const y=this.safeString(e,"maker_fee"),w=this.safeString(e,"taker_fee");return y!==void 0?w!==void 0?l.fees=[{cost:y,currency:m},{cost:w,currency:g}]:l.fee={cost:y,currency:m}:w!==void 0?l.fee={cost:w,currency:g}:l.fee=void 0,this.safeTrade(l,t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id},a=await this.publicGetAssetPairsAssetPairNameTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=100);const a={asset_pair_name:r.id,period:this.timeframes[t],limit:i};if(s!==void 0){const c=this.parseTimeframe(t),u=this.sum(s,i*c*1e3);a.time=this.iso8601(u)}const o=await this.publicGetAssetPairsAssetPairNameCandles(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"asset_symbol"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.used=this.safeString(n,"locked_balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","");e=this.omit(e,"type");const s="privateGet"+this.capitalize(t)+"Accounts",i=await this[s](e);return this.parseBalance(i)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"asset_pair_name"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"avg_deal_price"),c=this.safeString(e,"filled_amount"),u=this.parseOrderStatus(this.safeString(e,"state"));let h=this.safeString(e,"side");h==="BID"?h="buy":h="sell";const f=this.parse8601(this.safeString(e,"updated_at"));return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:f,symbol:n,type:void 0,timeInForce:void 0,postOnly:void 0,side:h,price:a,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:void 0,average:d,filled:c,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=s==="buy"?"BID":"ASK";const o=t.toUpperCase(),d={asset_pair_name:a.id,side:s,amount:this.amountToPrecision(e,i),type:o};if(o==="LIMIT")d.price=this.priceToPrecision(e,n);else{const h=o==="STOP_LIMIT";if(h||o==="STOP_MARKET"){const l=this.safeNumber2(r,"stop_price","stopPrice");if(l===void 0)throw new Hf(this.id+" createOrder() requires a stop_price parameter");d.stop_price=this.priceToPrecision(e,l),r=this.omit(r,["stop_price","stopPrice"])}h&&(d.price=this.priceToPrecision(e,n))}const c=await this.privatePostOrders(this.extend(d,r)),u=this.safeValue(c,"data");return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersIdCancel(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const i={asset_pair_name:this.market(e).id};return await this.privatePostOrdersCancel(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hf(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Hf(this.id+" fetchMyTrades() requires a symbol argument");const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={PENDING:"open",FILLED:"closed",CANCELLED:"canceled"};return this.safeString(t,e)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"PENDING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"FILLED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}nonce(){const e=this.safeInteger(this.options,"exchangeMillisecondsCorrection",0)*1e6;return this.microseconds()*1e3+e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let d=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);if(n={},t==="public")Object.keys(a).length&&(d+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u={type:"OpenAPIV2",sub:this.apiKey,nonce:c},h=this.jwt(u,this.encode(this.secret));n.Authorization="Bearer "+h,s==="GET"?Object.keys(a).length&&(d+="?"+this.urlencode(a)):s==="POST"&&(n["Content-Type"]="application/json",r=this.json(a))}return n["User-Agent"]="ccxt/"+this.id+"-"+this.version,{url:d,method:s,body:r,headers:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset_symbol:this.currency(e).id},n=await this.privateGetAssetsAssetSymbolAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]);if(r.length<1)throw new vr(this.id+" fetchDepositAddress() returned empty address response");const o=r[0],d=this.safeString(o,"value"),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:n}}parseTransactionStatus(e){const t={WITHHOLD:"ok",UNCONFIRMED:"pending",CONFIRMED:"ok",COMPLETED:"ok",PENDING:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"asset_symbol"),i=this.safeCurrencyCode(s),n=this.safeInteger(e,"id"),r=this.safeNumber(e,"amount"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.parse8601(this.safeString(e,"inserted_at")),d=this.parse8601(this.safeString2(e,"updated_at","completed_at")),c=this.safeString(e,"txid"),u=this.safeString(e,"target_address"),h=this.safeString(e,"memo"),f="customer_id"in e?"deposit":"withdrawal";return{info:e,id:n,txid:c,timestamp:o,datetime:this.iso8601(o),network:void 0,addressFrom:void 0,address:void 0,addressTo:u,tagFrom:void 0,tag:h,tagTo:void 0,type:f,amount:r,currency:i,status:a,updated:d,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.safeString(n,"guid",this.uuid()),u={symbol:r.id,amount:this.currencyToPrecision(e,t),from:o,to:d,guid:c},h=await this.privatePostTransfer(this.extend(u,n)),f=this.parseTransfer(h,r),l=this.safeValue(this.options,"transfer",{});return this.safeValue(l,"fillResponseFromRequest",!0)&&(f.fromAccount=s,f.toAccount=i,f.amount=t,f.id=c),f}parseTransfer(e,t=void 0){const s=this.safeNumber(e,"code");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:s,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,target_address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=await this.privatePostWithdrawals(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new vr(h)}}};const fV=re,{ExchangeError:He,ArgumentsRequired:Zs,ExchangeNotAvailable:Ao,InsufficientFunds:St,OrderNotFound:xy,InvalidOrder:Rt,DDoSProtection:Bo,InvalidNonce:lV,AuthenticationError:ds,RateLimitExceeded:No,PermissionDenied:an,NotSupported:Ps,BadRequest:ie,BadSymbol:Tr,AccountSuspended:ya,OrderImmediatelyFillable:bc,OnMaintenance:pV,BadResponse:_y,RequestTimeout:mV,OrderNotFillable:gV,MarginModeAlreadySet:Cy}=Q,{TRUNCATE:wa,DECIMAL_PLACES:yV}=ne,fe=ae;var tc=class extends fV{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:["JP","MT"],rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,editOrder:!0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:void 0,fetchPositions:!0,fetchPositionsRisk:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1s":"1s","1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",test:{dapiPublic:"https://testnet.binancefuture.com/dapi/v1",dapiPrivate:"https://testnet.binancefuture.com/dapi/v1",dapiPrivateV2:"https://testnet.binancefuture.com/dapi/v2",eapiPublic:"https://testnet.binanceops.com/eapi/v1",eapiPrivate:"https://testnet.binanceops.com/eapi/v1",fapiPublic:"https://testnet.binancefuture.com/fapi/v1",fapiPrivate:"https://testnet.binancefuture.com/fapi/v1",fapiPrivateV2:"https://testnet.binancefuture.com/fapi/v2",public:"https://testnet.binance.vision/api/v3",private:"https://testnet.binance.vision/api/v3",v1:"https://testnet.binance.vision/api/v1"},api:{wapi:"https://api.binance.com/wapi/v3",sapi:"https://api.binance.com/sapi/v1",sapiV2:"https://api.binance.com/sapi/v2",sapiV3:"https://api.binance.com/sapi/v3",dapiPublic:"https://dapi.binance.com/dapi/v1",dapiPrivate:"https://dapi.binance.com/dapi/v1",eapiPublic:"https://eapi.binance.com/eapi/v1",eapiPrivate:"https://eapi.binance.com/eapi/v1",dapiPrivateV2:"https://dapi.binance.com/dapi/v2",dapiData:"https://dapi.binance.com/futures/data",fapiPublic:"https://fapi.binance.com/fapi/v1",fapiPrivate:"https://fapi.binance.com/fapi/v1",fapiData:"https://fapi.binance.com/futures/data",fapiPrivateV2:"https://fapi.binance.com/fapi/v2",public:"https://api.binance.com/api/v3",private:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1"},www:"https://www.binance.com",referral:{url:"https://accounts.binance.com/en/register?ref=D7YA7CLY",discount:.1},doc:["https://binance-docs.github.io/apidocs/spot/en"],api_management:"https://www.binance.com/en/usercenter/settings/api-management",fees:"https://www.binance.com/en/fee/schedule"},depth:1,api:{sapi:{get:{"system/status":.1,accountSnapshot:240,"margin/asset":1,"margin/pair":1,"margin/allAssets":.1,"margin/allPairs":.1,"margin/priceIndex":1,"asset/assetDividend":1,"asset/dribblet":.1,"asset/transfer":.1,"asset/assetDetail":.1,"asset/tradeFee":.1,"asset/ledger-transfer/cloud-mining/queryByPage":4,"margin/loan":1,"margin/repay":1,"margin/account":1,"margin/transfer":.1,"margin/interestHistory":.1,"margin/forceLiquidationRec":.1,"margin/order":1,"margin/openOrders":1,"margin/allOrders":20,"margin/myTrades":1,"margin/maxBorrowable":5,"margin/maxTransferable":5,"margin/tradeCoeff":1,"margin/isolated/transfer":.1,"margin/isolated/account":1,"margin/isolated/pair":1,"margin/isolated/allPairs":1,"margin/isolated/accountLimit":.1,"margin/interestRateHistory":.1,"margin/orderList":1,"margin/allOrderList":20,"margin/openOrderList":1,"margin/crossMarginData":{cost:.1,noCoin:.5},"margin/isolatedMarginData":{cost:.1,noCoin:1},"margin/isolatedMarginTier":.1,"margin/rateLimit/order":2,"margin/dribblet":.1,"margin/crossMarginCollateralRatio":10,"loan/income":40,"loan/ongoing/orders":40,"loan/ltv/adjustment/history":40,"loan/borrow/history":40,"loan/repay/history":40,"loan/loanable/data":40,"loan/collateral/data":40,"loan/repay/collateral/rate":600,"loan/vip/ongoing/orders":40,"loan/vip/repay/history":40,"loan/vip/collateral/account":600,"fiat/orders":600.03,"fiat/payments":.1,"futures/transfer":1,"futures/loan/borrow/history":1,"futures/loan/repay/history":1,"futures/loan/wallet":1,"futures/loan/adjustCollateral/history":1,"futures/loan/liquidationHistory":1,"rebate/taxQuery":20.001,"capital/config/getall":1,"capital/deposit/address":1,"capital/deposit/hisrec":.1,"capital/deposit/subAddress":.1,"capital/deposit/subHisrec":.1,"capital/withdraw/history":.1,"capital/contract/convertible-coins":4.0002,"convert/tradeFlow":.6667,"convert/exchangeInfo":50,"convert/assetInfo":10,"convert/orderStatus":.6667,"account/status":.1,"account/apiTradingStatus":.1,"account/apiRestrictions/ipRestriction":.1,bnbBurn:.1,"sub-account/futures/account":1,"sub-account/futures/accountSummary":.1,"sub-account/futures/positionRisk":1,"sub-account/futures/internalTransfer":.1,"sub-account/list":.1,"sub-account/margin/account":1,"sub-account/margin/accountSummary":1,"sub-account/spotSummary":.1,"sub-account/status":1,"sub-account/sub/transfer/history":.1,"sub-account/transfer/subUserHistory":.1,"sub-account/universalTransfer":.1,"sub-account/apiRestrictions/ipRestriction/thirdPartyList":1,"managed-subaccount/asset":.1,"managed-subaccount/accountSnapshot":240,"managed-subaccount/queryTransLogForInvestor":.1,"managed-subaccount/queryTransLogForTradeParent":.1,"managed-subaccount/fetch-future-asset":.1,"managed-subaccount/marginAsset":.1,"lending/daily/product/list":.1,"lending/daily/userLeftQuota":.1,"lending/daily/userRedemptionQuota":.1,"lending/daily/token/position":.1,"lending/union/account":.1,"lending/union/purchaseRecord":.1,"lending/union/redemptionRecord":.1,"lending/union/interestHistory":.1,"lending/project/list":.1,"lending/project/position/list":.1,"mining/pub/algoList":.1,"mining/pub/coinList":.1,"mining/worker/detail":.5,"mining/worker/list":.5,"mining/payment/list":.5,"mining/statistics/user/status":.5,"mining/statistics/user/list":.5,"mining/payment/uid":.5,"bswap/pools":.1,"bswap/liquidity":{cost:.1,noPoolId:1},"bswap/liquidityOps":20.001,"bswap/quote":1.00005,"bswap/swap":20.001,"bswap/poolConfigure":1.00005,"bswap/addLiquidityPreview":1.00005,"bswap/removeLiquidityPreview":1.00005,"bswap/unclaimedRewards":6.667,"bswap/claimedHistory":6.667,"blvt/tokenInfo":.1,"blvt/subscribe/record":.1,"blvt/redeem/record":.1,"blvt/userLimit":.1,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/recentRecord":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/recentRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccountApi":1,"broker/subAccount":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/info":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/recentRecord":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/status":1,"broker/subAccount/depositHist":1,"broker/subAccount/spotSummary":1,"broker/subAccount/marginSummary":1,"broker/subAccount/futuresSummary":1,"broker/rebate/futures/recentRecord":1,"broker/subAccountApi/ipRestriction":1,"broker/universalTransfer":1,"account/apiRestrictions":.1,"c2c/orderMatch/listUserOrderHistory":.1,"nft/history/transactions":20.001,"nft/history/deposit":20.001,"nft/history/withdraw":20.001,"nft/user/getAsset":20.001,"pay/transactions":20.001,"giftcard/verify":.1,"giftcard/cryptography/rsa-public-key":.1,"giftcard/buyCode/token-limit":.1,"algo/futures/openOrders":.1,"algo/futures/historicalOrders":.1,"algo/futures/subOrders":.1,"portfolio/account":.1,"portfolio/collateralRate":5,"portfolio/pmLoan":3.3335,"staking/productList":.1,"staking/position":.1,"staking/stakingRecord":.1,"staking/personalLeftQuota":.1},post:{"asset/dust":1,"asset/dust-btc":.1,"asset/transfer":.1,"asset/get-funding-asset":.1,"asset/convert-transfer":.033335,"asset/convert-transfer/queryByPage":.033335,"account/disableFastWithdrawSwitch":.1,"account/enableFastWithdrawSwitch":.1,"capital/withdraw/apply":4.0002,"capital/contract/convertible-coins":4.0002,"margin/transfer":1,"margin/loan":20.001,"margin/repay":20.001,"margin/order":.040002,"margin/order/oco":.040002,"margin/isolated/transfer":4.0002,"margin/isolated/account":2.0001,bnbBurn:.1,"sub-account/virtualSubAccount":.1,"sub-account/margin/transfer":4.0002,"sub-account/margin/enable":.1,"sub-account/futures/enable":.1,"sub-account/futures/transfer":.1,"sub-account/futures/internalTransfer":.1,"sub-account/transfer/subToSub":.1,"sub-account/transfer/subToMaster":.1,"sub-account/universalTransfer":.1,"managed-subaccount/deposit":.1,"managed-subaccount/withdraw":.1,userDataStream:.1,"userDataStream/isolated":.1,"futures/transfer":.1,"lending/customizedFixed/purchase":.1,"lending/daily/purchase":.1,"lending/daily/redeem":.1,"bswap/liquidityAdd":60,"bswap/liquidityRemove":60,"bswap/swap":60,"bswap/claimRewards":6.667,"blvt/subscribe":.1,"blvt/redeem":.1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccount":1,"broker/subAccount/margin":1,"broker/subAccount/futures":1,"broker/subAccountApi":1,"broker/subAccountApi/permission":1,"broker/subAccountApi/commission":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/spot":1,"broker/subAccount/bnbBurn/marginInterest":1,"broker/subAccount/blvt":1,"broker/subAccountApi/ipRestriction":1,"broker/subAccountApi/ipRestriction/ipList":1,"broker/universalTransfer":1,"broker/subAccountApi/permission/universalTransfer":1,"broker/subAccountApi/permission/vanillaOptions":1,"giftcard/createCode":.1,"giftcard/redeemCode":.1,"giftcard/buyCode":.1,"algo/futures/newOrderVp":20.001,"algo/futures/newOrderTwap":20.001,"staking/purchase":.1,"staking/redeem":.1,"staking/setAutoStaking":.1,"portfolio/repay":20.001,"loan/borrow":40,"loan/repay":40,"loan/adjust/ltv":40,"loan/customize/margin_call":40,"loan/vip/repay":40,"convert/getQuote":20.001,"convert/acceptQuote":3.3335},put:{userDataStream:.1,"userDataStream/isolated":.1},delete:{"margin/openOrders":.1,"margin/order":.0066667,"margin/orderList":.0066667,"margin/isolated/account":2.0001,userDataStream:.1,"userDataStream/isolated":.1,"broker/subAccountApi":1,"broker/subAccountApi/ipRestriction/ipList":1,"algo/futures/order":.1}},sapiV2:{get:{"sub-account/futures/account":.1,"sub-account/futures/positionRisk":.1}},sapiV3:{get:{"sub-account/assets":1},post:{"asset/getUserAsset":.5}},wapi:{post:{withdraw:1,"sub-account/transfer":1},get:{depositHistory:1,withdrawHistory:1,depositAddress:1,accountStatus:1,systemStatus:1,apiTradingStatus:1,userAssetDribbletLog:1,tradeFee:1,assetDetail:1,"sub-account/list":1,"sub-account/transfer/history":1,"sub-account/assets":1}},dapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,premiumIndex:10,fundingRate:1,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,pmExchangeInfo:1}},dapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerBuySellVol:1,basis:1}},dapiPrivate:{get:{"positionSide/dual":30,order:1,openOrder:1,openOrders:{cost:1,noSymbol:5},allOrders:{cost:20,noSymbol:40},balance:1,account:5,"positionMargin/history":1,positionRisk:1,userTrades:{cost:20,noSymbol:40},income:20,leverageBracket:1,forceOrders:{cost:20,noSymbol:50},adlQuantile:5,orderAmendment:1,pmAccountInfo:5},post:{"positionSide/dual":1,order:4,batchOrders:5,countdownCancelAll:10,leverage:1,marginType:1,positionMargin:1,listenKey:1},put:{listenKey:1,order:1,batchOrders:5},delete:{order:1,allOpenOrders:1,batchOrders:5,listenKey:1}},dapiPrivateV2:{get:{leverageBracket:1}},fapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},fundingRate:1,premiumIndex:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,indexInfo:1,apiTradingStatus:{cost:1,noSymbol:10},lvtKlines:1,pmExchangeInfo:1}},fapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerlongshortRatio:1}},fapiPrivate:{get:{forceOrders:{cost:20,noSymbol:50},allOrders:5,openOrder:1,openOrders:1,order:1,account:5,balance:5,leverageBracket:1,"positionMargin/history":1,positionRisk:5,"positionSide/dual":30,userTrades:5,income:30,commissionRate:20,apiTradingStatus:1,multiAssetsMargin:30,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/traderNum":1,"apiReferral/overview":1,"apiReferral/tradeVol":1,"apiReferral/rebateVol":1,"apiReferral/traderSummary":1,adlQuantile:5,pmAccountInfo:5},post:{batchOrders:5,"positionSide/dual":1,positionMargin:1,marginType:1,order:4,leverage:1,listenKey:1,countdownCancelAll:10,multiAssetsMargin:1,"apiReferral/customization":1,"apiReferral/userCustomization":1},put:{listenKey:1},delete:{batchOrders:1,order:1,allOpenOrders:1,listenKey:1}},fapiPrivateV2:{get:{account:1,balance:1,positionRisk:1}},eapiPublic:{get:{ping:1,time:1,exchangeInfo:1,index:1,ticker:5,mark:5,depth:1,klines:1,trades:5,historicalTrades:20,exerciseHistory:3,openInterest:3}},eapiPrivate:{get:{account:3,position:5,openOrders:{cost:1,noSymbol:40},historyOrders:3,userTrades:5,exerciseRecord:5,bill:1,marginAccount:3,mmp:1,countdownCancelAll:1,order:1},post:{transfer:1,order:1,batchOrders:5,listenKey:1,mmpSet:1,mmpReset:1,countdownCancelAll:1,countdownCancelAllHeartBeat:10},put:{listenKey:1},delete:{order:1,batchOrders:1,allOpenOrders:1,allOpenOrdersByUnderlying:1,listenKey:1}},public:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},private:{get:{allOrderList:10,openOrderList:3,orderList:2,order:2,openOrders:{cost:3,noSymbol:40},allOrders:10,account:10,myTrades:10,"rateLimit/order":20},post:{"order/oco":1,order:1,"order/cancelReplace":1,"order/test":1},delete:{openOrders:1,orderList:1,order:1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")},linear:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},inverse:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}},option:{}},commonCurrencies:{BCC:"BCC",YOYO:"YOYOW"},precisionMode:yV,options:{fetchMarkets:["spot","linear","inverse"],fetchCurrencies:!0,defaultTimeInForce:"GTC",defaultType:"spot",defaultSubType:void 0,hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,throwMarginModeAlreadySet:!1,fetchPositions:"positionRisk",recvWindow:10*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!0,broker:{spot:"x-R4BD3S82",margin:"x-R4BD3S82",future:"x-xcKtGhcu",delivery:"x-xcKtGhcu"},accountsByType:{main:"MAIN",spot:"MAIN",funding:"FUNDING",margin:"MARGIN",cross:"MARGIN",future:"UMFUTURE",delivery:"CMFUTURE",linear:"UMFUTURE",inverse:"CMFUTURE"},accountsById:{MAIN:"spot",FUNDING:"funding",MARGIN:"margin",UMFUTURE:"linear",CMFUTURE:"inverse"},networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},networksById:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0},legalMoneyCurrenciesById:{BUSD:"USD"}},exceptions:{exact:{"System is under maintenance.":pV,"System abnormality":He,"You are not authorized to execute this request.":an,"API key does not exist":ds,"Order would trigger immediately.":bc,"Stop price would trigger immediately.":bc,"Order would immediately match and take.":bc,"Account has insufficient balance for requested action.":St,"Rest API trading is not enabled.":Ao,"You don't have permission.":an,"Market is closed.":Ao,"Too many requests. Please try again later.":Bo,"This action is disabled on this account.":ya,"This type of sub-account exceeds the maximum number limit":ie,"This symbol is not permitted for this account.":an,"-1000":Ao,"-1001":Ao,"-1002":ds,"-1003":No,"-1004":Bo,"-1005":an,"-1006":_y,"-1007":mV,"-1010":_y,"-1011":an,"-1013":Rt,"-1014":Rt,"-1015":No,"-1016":Ao,"-1020":ie,"-1021":lV,"-1022":ds,"-1023":ie,"-1099":ds,"-1100":ie,"-1101":ie,"-1102":ie,"-1103":ie,"-1104":ie,"-1105":ie,"-1106":ie,"-1108":ie,"-1109":ds,"-1110":ie,"-1111":ie,"-1112":Rt,"-1113":ie,"-1114":ie,"-1115":ie,"-1116":ie,"-1117":ie,"-1118":ie,"-1119":ie,"-1120":ie,"-1121":Tr,"-1125":ds,"-1127":ie,"-1128":ie,"-1130":ie,"-1131":ie,"-1135":ie,"-1136":ie,"-2008":ds,"-2010":He,"-2011":xy,"-2013":xy,"-2014":ds,"-2015":ds,"-2016":ie,"-2018":St,"-2019":St,"-2020":gV,"-2021":bc,"-2022":Rt,"-2023":St,"-2024":St,"-2025":Rt,"-2026":Rt,"-2027":Rt,"-2028":St,"-3000":He,"-3001":ds,"-3002":Tr,"-3003":ie,"-3004":He,"-3005":St,"-3006":St,"-3007":He,"-3008":St,"-3009":ie,"-3010":ie,"-3011":ie,"-3012":St,"-3013":ie,"-3014":ya,"-3015":ie,"-3016":ie,"-3017":He,"-3018":ya,"-3019":ya,"-3020":St,"-3021":ie,"-3022":ya,"-3023":ie,"-3024":He,"-3025":ie,"-3026":ie,"-3027":Tr,"-3028":Tr,"-3029":He,"-3036":ya,"-3037":He,"-3038":ie,"-3041":St,"-3042":ie,"-3043":ie,"-3044":Bo,"-3045":He,"-3999":He,"-4001":ie,"-4002":ie,"-4003":ie,"-4004":ds,"-4005":No,"-4006":ie,"-4007":ie,"-4008":ie,"-4010":ie,"-4011":ie,"-4012":ie,"-4013":ds,"-4014":an,"-4015":He,"-4016":an,"-4017":an,"-4018":Tr,"-4019":Tr,"-4021":ie,"-4022":ie,"-4023":He,"-4024":St,"-4025":St,"-4026":St,"-4027":He,"-4028":ie,"-4029":ie,"-4030":He,"-4031":He,"-4032":He,"-4033":ie,"-4034":He,"-4035":an,"-4036":ie,"-4037":He,"-4038":He,"-4039":ie,"-4040":ie,"-4041":He,"-4042":He,"-4043":ie,"-4044":ie,"-4045":He,"-4046":ds,"-4047":ie,"-5001":ie,"-5002":St,"-5003":St,"-5004":ie,"-5005":St,"-5006":ie,"-5007":ie,"-5008":St,"-5009":ie,"-5010":He,"-5011":ie,"-5012":He,"-5013":St,"-5021":ie,"-6001":ie,"-6003":ie,"-6004":He,"-6005":Rt,"-6006":ie,"-6007":ie,"-6008":ie,"-6009":No,"-6011":ie,"-6012":St,"-6013":He,"-6014":ie,"-6015":ie,"-6016":ie,"-6017":ie,"-6018":ie,"-6019":ds,"-6020":ie,"-7001":ie,"-7002":ie,"-9000":St,"-10017":ie,"-11008":St,"-12014":No,"-13000":ie,"-13001":ie,"-13002":ie,"-13003":ie,"-13004":ie,"-13005":ie,"-13006":Rt,"-13007":ds,"-21001":ie,"-21002":ie,"-21003":ie,100001003:ds,200003903:ds},broad:{"has no operation privilege":an,MAX_POSITION:Rt}}})}isInverse(e,t=void 0){return t===void 0?e==="delivery":t==="inverse"}isLinear(e,t=void 0){return t===void 0?e==="future"||e==="swap":t==="linear"}market(e){if(this.markets===void 0)throw new He(this.id+" markets not loaded");let t=this.safeString(this.options,"defaultType");const s=this.safeString(this.options,"defaultSubType"),i=t==="future",n=t==="delivery",r=i||n;if(typeof e=="string"){if(e in this.markets){const a=this.markets[e];if(r&&a.spot){const o=i?a.quote:a.base,d=e+":"+o;if(d in this.markets)return this.markets[d]}else return a}else if(e in this.markets_by_id){const a=this.markets_by_id[e];i?t="linear":n?t="inverse":t===void 0&&(t=s);for(let o=0;o<a.length;o++){const d=a[o];if(d[t])return d}return a[0]}else if(e.indexOf("/")>-1&&e.indexOf(":")<0){const[a,o]=e.split("/"),d=o==="USD"?a:o,c=e+":"+d;if(c in this.markets)return this.markets[c]}}throw new Tr(this.id+" does not have market symbol "+e)}costToPrecision(e,t){return this.decimalToPrecision(t,wa,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,wa,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=this.safeString2(this.options,"fetchTime","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type");let n;[n,e]=this.handleSubTypeAndParams("fetchTime",void 0,e);let r="publicGetTime";this.isLinear(s,n)?r="fapiPublicGetTime":this.isInverse(s,n)&&(r="dapiPublicGetTime");const a=await this[r](i);return this.safeInteger(a,"serverTime")}async fetchCurrencies(e={}){if(!this.safeValue(this.options,"fetchCurrencies")||!this.checkRequiredCredentials(!1)||this.safeString(this.urls,"apiBackup")!==void 0)return;const i=await this.sapiGetCapitalConfigGetall(e),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o);let u,h=!0,f=!0;const l=this.safeValue(a,"networkList",[]),m={};let g;for(let S=0;S<l.length;S++){const v=l[S],T=this.safeString(v,"network"),I=this.safeNumber(v,"withdrawFee"),A=this.safeValue(v,"depositEnable"),N=this.safeValue(v,"withdrawEnable");f=f||A,h=h||N,m[T]=I,(this.safeValue(v,"isDefault")||g===void 0)&&(g=I);const x=this.safeString(v,"withdrawIntegerMultiple");fe.stringEq(x,"0")||(u=u===void 0?x:fe.stringMin(u,x))}const y=this.safeValue(a,"trading"),w=h&&f&&y;let b;u!==void 0&&(b=parseInt(this.numberToString(this.precisionFromString(u)))),n[c]={id:o,name:d,code:c,precision:b,info:a,active:w,deposit:f,withdraw:h,networks:l,fee:g,fees:m,limits:this.limits}}return n}async fetchMarkets(e={}){let t=[];const s=this.safeValue(this.options,"fetchMarkets",["spot","linear","inverse"]);for(let d=0;d<s.length;d++){const c=s[d];if(c==="spot")t.push(this.publicGetExchangeInfo(e));else if(c==="linear")t.push(this.fapiPublicGetExchangeInfo(e));else if(c==="inverse")t.push(this.dapiPublicGetExchangeInfo(e));else throw new He(this.id+' fetchMarkets() this.options fetchMarkets "'+c+'" is not a supported market type')}t=await Promise.all(t);const i=this.safeValue(this.safeValue(t,0),"symbols",[]),n=this.safeValue(this.safeValue(t,1),"symbols",[]),r=this.safeValue(this.safeValue(t,2),"symbols",[]);let a=i;a=this.arrayConcat(a,n),a=this.arrayConcat(a,r),this.options.adjustForTimeDifference&&await this.loadTimeDifference();const o=[];for(let d=0;d<a.length;d++)o.push(this.parseMarket(a[d]));return o}parseMarket(e){let t=!1,s=!1;const i=this.safeString(e,"symbol"),n=this.safeStringLower(e,"symbol"),r=this.safeString(e,"baseAsset"),a=this.safeString(e,"quoteAsset"),o=this.safeString(e,"marginAsset"),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeString(e,"contractType"),f="contractType"in e,l=!f;let m=this.safeInteger(e,"deliveryDate");h==="PERPETUAL"||m===41334048e5?(m=void 0,t=!0):s=!0;const g=this.safeValue(e,"filters",[]),y=this.indexBy(g,"filterType"),w=this.safeString2(e,"status","contractStatus");let b,S=this.fees,v,T,I=d+"/"+c;if(f){t?I=I+":"+u:s&&(I=I+":"+u+"-"+this.yymmdd(m)),b=this.safeNumber(e,"contractSize",this.parseNumber("1")),v=u===c,T=u===d;const k=v?"linear":"inverse";S=this.safeValue(this.fees,k,{})}let A=w==="TRADING";if(l){const k=this.safeValue(e,"permissions",[]);for(let O=0;O<k.length;O++)if(k[O]==="TRD_GRP_003"){A=!1;break}}const N=this.safeValue(e,"isMarginTradingAllowed",!1);let B;l?B="spot":t?B="swap":s&&(B="future");const x={id:i,lowercaseId:n,symbol:I,base:d,quote:c,settle:u,baseId:r,quoteId:a,settleId:o,type:B,spot:l,margin:l&&N,swap:t,future:s,option:!1,active:A,contract:f,linear:v,inverse:T,taker:S.trading.taker,maker:S.trading.maker,contractSize:b,expiry:m,expiryDatetime:this.iso8601(m),strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(e,"quantityPrecision"),price:this.safeInteger(e,"pricePrecision"),base:this.safeInteger(e,"baseAssetPrecision"),quote:this.safeInteger(e,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e};if("PRICE_FILTER"in y){const k=this.safeValue(y,"PRICE_FILTER",{});x.limits.price={min:this.safeNumber(k,"minPrice"),max:this.safeNumber(k,"maxPrice")},x.precision.price=this.precisionFromString(k.tickSize)}if("LOT_SIZE"in y){const k=this.safeValue(y,"LOT_SIZE",{}),O=this.safeString(k,"stepSize");x.precision.amount=this.precisionFromString(O),x.limits.amount={min:this.safeNumber(k,"minQty"),max:this.safeNumber(k,"maxQty")}}if("MARKET_LOT_SIZE"in y){const k=this.safeValue(y,"MARKET_LOT_SIZE",{});x.limits.market={min:this.safeNumber(k,"minQty"),max:this.safeNumber(k,"maxQty")}}if("MIN_NOTIONAL"in y){const k=this.safeValue(y,"MIN_NOTIONAL",{});x.limits.cost.min=this.safeNumber2(k,"minNotional","notional")}return x}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free");const s=this.safeString(e,"interest"),i=this.safeString(e,"borrowed");return t.debt=fe.stringAdd(i,s),t}parseBalance(e,t=void 0,s=void 0){const i={info:e};let n;const r=s==="isolated",a=t==="margin"||s==="cross";if(!r&&(t==="spot"||a)){n=this.safeInteger(e,"updateTime");const o=this.safeValue2(e,"balances","userAssets",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),f=this.account();if(f.free=this.safeString(c,"free"),f.used=this.safeString(c,"locked"),a){const l=this.safeString(c,"borrowed"),m=this.safeString(c,"interest");f.debt=fe.stringAdd(l,m)}i[h]=f}}else if(r){const o=this.safeValue(e,"assets");for(let d=0;d<o.length;d++){const c=o[d],u=this.safeValue(c,"symbol"),h=this.safeSymbol(u,void 0,void 0,"margin"),f=this.safeValue(c,"baseAsset",{}),l=this.safeValue(c,"quoteAsset",{}),m=this.safeCurrencyCode(this.safeString(f,"asset")),g=this.safeCurrencyCode(this.safeString(l,"asset")),y={};y[m]=this.parseBalanceHelper(f),y[g]=this.parseBalanceHelper(l),i[h]=this.safeBalance(y)}}else if(t==="savings"){const o=this.safeValue(e,"positionAmountVos",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),f=this.account(),l=this.safeString(c,"amount");f.total=l,f.used=l,i[h]=f}}else if(t==="funding")for(let o=0;o<e.length;o++){const d=e[o],c=this.account(),u=this.safeString(d,"asset"),h=this.safeCurrencyCode(u);c.free=this.safeString(d,"free");const f=this.safeString(d,"freeze"),l=this.safeString(d,"withdrawing"),m=this.safeString(d,"locked");c.used=fe.stringAdd(f,fe.stringAdd(m,l)),i[h]=c}else{let o=e;Array.isArray(e)||(o=this.safeValue(e,"assets",[]));for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),f=this.account();f.free=this.safeString(c,"availableBalance"),f.used=this.safeString(c,"initialMargin"),f.total=this.safeString2(c,"marginBalance","balance"),i[h]=f}}return i.timestamp=n,i.datetime=this.iso8601(n),r?i:this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot");let s=this.safeString(e,"type",t),i;[i,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e);const[n,r]=this.handleMarginModeAndParams("fetchBalance",e);let a="privateGetAccount";const o={};if(this.isLinear(s,i)){const u=this.safeValue(this.options,s,{}),h=this.safeValue(u,"fetchBalance",{});a=this.safeString(h,"method","fapiPrivateV2GetAccount"),s="linear"}else if(this.isInverse(s,i)){const u=this.safeValue(this.options,s,{}),h=this.safeValue(u,"fetchBalance",{});a=this.safeString(h,"method","dapiPrivateGetAccount"),s="inverse"}else if(s==="margin"||n==="cross")a="sapiGetMarginAccount";else if(s==="savings")a="sapiGetLendingUnionAccount";else if(s==="funding")a="sapiPostAssetGetFundingAsset";else if(n==="isolated"){a="sapiGetMarginIsolatedAccount";const u=this.safeValue(e,"symbols");if(u!==void 0){let h="";if(Array.isArray(u)){h=this.marketId(u[0]);for(let f=1;f<u.length;f++){const l=u[f],m=this.marketId(l);h+=","+m}}else h=u;o.symbols=h}}const d=this.omit(r,["type","symbols"]),c=await this[a](this.extend(o,d));return this.parseBalance(c,s,n)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r="publicGetDepth";i.linear?r="fapiPublicGetDepth":i.inverse&&(r="dapiPublicGetDepth");const a=await this[r](this.extend(n,s)),o=this.safeInteger(a,"T"),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"lastUpdateId"),d}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime");let i;"time"in e&&(i="contract"),i===void 0&&(i="bidQty"in e?"spot":"contract");const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t,void 0,i),a=this.safeString(e,"lastPrice"),o="baseVolume"in e;let d,c;return o?(d=this.safeString(e,"baseVolume"),c=this.safeString(e,"volume")):(d=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:a,last:a,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchStatus(e={}){const t=await this.sapiGetSystemStatus(e),s=this.safeString(t,"status");return{status:this.safeString({0:"ok",1:"maintenance"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n="publicGetTicker24hr";s.linear?n="fapiPublicGetTicker24hr":s.inverse&&(n="dapiPublicGetTicker24hr");const r=await this[n](this.extend(i,t));if(Array.isArray(r)){const a=this.safeValue(r,0,{});return this.parseTicker(a,s)}return this.parseTicker(r,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const o=this.safeString(e,0);s=this.market(o)}let i,n;[n,t]=this.handleSubTypeAndParams("fetchBidsAsks",s,t),[i,t]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t);let r;this.isLinear(i,n)?r="fapiPublicGetTickerBookTicker":this.isInverse(i,n)?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](t);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchTickers","defaultType","spot"),i=this.safeString(t,"type",s);let n;[n,t]=this.handleSubTypeAndParams("fetchTickers",void 0,t);const r=this.omit(t,"type");let a;this.isLinear(i,n)?a="fapiPublicGetTicker24hr":this.isInverse(i,n)?a="dapiPublicGetTicker24hr":a="publicGetTicker24hr";const o=this.safeString(this.options,"fetchTickersMethod",a),d=await this[o](r);return this.parseTickers(d,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};if(d==="index"?u.pair=r.id:u.symbol=r.id,s!==void 0&&(u.startTime=s,r.inverse&&s>0)){const l=this.parseTimeframe(t),m=this.sum(s,i*l*1e3-1),g=this.milliseconds();u.endTime=Math.min(g,m)}c!==void 0&&(u.endTime=c);let h="publicGetKlines";d==="mark"?r.inverse?h="dapiPublicGetMarkPriceKlines":h="fapiPublicGetMarkPriceKlines":d==="index"?r.inverse?h="dapiPublicGetIndexPriceKlines":h="fapiPublicGetIndexPriceKlines":r.linear?h="fapiPublicGetKlines":r.inverse&&(h="dapiPublicGetKlines");const f=await this[h](this.extend(u,n));return this.parseOHLCVs(f,r,t,s,i)}parseTrade(e,t=void 0){if("isDustTrade"in e)return this.parseDustTrade(e,t);const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o="M"in e||"orderListId"in e?"spot":"contract",d=this.safeSymbol(a,t,void 0,o);let c=this.safeString2(e,"t","a");c=this.safeString2(e,"id","tradeId",c);let u;const h=this.safeString(e,"orderId"),f=this.safeValue2(e,"m","isBuyerMaker");let l;f!==void 0?u=f?"sell":"buy":"side"in e?u=this.safeStringLower(e,"side"):"isBuyer"in e&&(u=e.isBuyer?"buy":"sell");let m;return"commission"in e&&(m={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(l=e.isMaker?"maker":"taker"),"maker"in e&&(l=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,id:c,order:h,type:void 0,side:u,takerOrMaker:l,price:i,amount:n,cost:r,fee:m},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};let a;n.linear?a="fapiPublicGetAggTrades":n.inverse?a="dapiPublicGetAggTrades":a="publicGetAggTrades";let o=this.safeString(this.options,"fetchTradesMethod",a);o==="publicGetAggTrades"?n.linear?o="fapiPublicGetAggTrades":n.inverse&&(o="dapiPublicGetAggTrades"):o==="publicGetHistoricalTrades"&&(n.linear?o="fapiPublicGetHistoricalTrades":n.inverse&&(o="dapiPublicGetHistoricalTrades")),t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const d=await this[o](this.extend(r,i));return this.parseTrades(d,n,t,s)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);if(!o.spot)throw new Ps(this.id+" editOrder() does not support "+o.type+" orders, only spot orders are accepted");const d={symbol:o.id,side:i.toUpperCase(),cancelOrderId:e,cancelReplaceMode:"STOP_ON_FAILURE"},c=this.safeString2(a,"newClientOrderId","clientOrderId");this.safeValue(a,"postOnly",!1)&&(s="LIMIT_MAKER");const h=s.toUpperCase();let f=h;d.type=f;const l=this.safeNumber(a,"stopPrice");l!==void 0&&(f==="MARKET"?f="STOP_LOSS":f==="LIMIT"&&(f="STOP_LOSS_LIMIT"));const m=this.safeValue(o.info,"orderTypes");if(!this.inArray(f,m))throw h!==f?new Rt(this.id+" stopPrice parameter is not allowed for "+t+" "+s+" orders"):new Rt(this.id+" "+s+" is not a valid order type for the "+t+" market");if(c===void 0){const I=this.safeValue(this.options,"broker");if(I!==void 0){const A=this.safeString(I,"spot");A!==void 0&&(d.newClientOrderId=A+this.uuid22())}}else d.newClientOrderId=c;d.newOrderRespType=this.safeValue(this.options.newOrderRespType,s,"RESULT");let g=!1,y=!1,w=!1,b=!1;if(f==="MARKET")if(this.safeValue(this.options,"quoteOrderQty",!0)){const A=this.safeValue2(a,"quoteOrderQty","cost"),N=o.precision.price;if(A!==void 0)d.quoteOrderQty=this.decimalToPrecision(A,wa,N,this.precisionMode);else if(r!==void 0){const B=this.numberToString(n),x=this.numberToString(r),k=fe.stringMul(B,x);d.quoteOrderQty=this.decimalToPrecision(k,wa,N,this.precisionMode)}else b=!0}else b=!0;else f==="LIMIT"?(y=!0,g=!0,b=!0):f==="STOP_LOSS"||f==="TAKE_PROFIT"?(w=!0,b=!0):f==="STOP_LOSS_LIMIT"||f==="TAKE_PROFIT_LIMIT"?(b=!0,w=!0,y=!0,g=!0):f==="LIMIT_MAKER"&&(y=!0,b=!0);if(b&&(d.quantity=this.amountToPrecision(t,n)),y){if(r===void 0)throw new Rt(this.id+" editOrder() requires a price argument for a "+s+" order");d.price=this.priceToPrecision(t,r)}if(g&&(d.timeInForce=this.options.defaultTimeInForce),w){if(l===void 0)throw new Rt(this.id+" editOrder() requires a stopPrice extra param for a "+s+" order");d.stopPrice=this.priceToPrecision(t,l)}const S=this.omit(a,["quoteOrderQty","cost","stopPrice","newClientOrderId","clientOrderId","postOnly"]),v=await this.privatePostOrderCancelReplace(this.extend(d,S)),T=this.safeValue(v,"newOrderResponse");return this.parseOrder(T,o)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n="closePosition"in e?"contract":"spot",r=this.safeSymbol(i,t,void 0,n),a=this.safeString(e,"executedQty","0");let o,d;"time"in e?o=this.safeInteger(e,"time"):"workingTime"in e?(d=this.safeInteger(e,"transactTime"),o=this.safeInteger(e,"workingTime")):"transactTime"in e?(d=this.safeInteger(e,"transactTime"),o=this.safeInteger(e,"transactTime")):"updateTime"in e&&s==="open"&&(fe.stringGt(a,"0")?d=this.safeInteger(e,"updateTime"):o=this.safeInteger(e,"updateTime"));const c=this.safeString(e,"avgPrice"),u=this.safeString(e,"price"),h=this.safeString(e,"origQty");let f=this.safeString2(e,"cummulativeQuoteQty","cumQuote");f=this.safeString(e,"cumBase",f);const l=this.safeString(e,"orderId");let m=this.safeStringLower(e,"type");const g=this.safeStringLower(e,"side"),y=this.safeValue(e,"fills",[]),w=this.safeString(e,"clientOrderId");let b=this.safeString(e,"timeInForce");b==="GTX"&&(b="PO");const S=m==="limit_maker"||b==="PO";m==="limit_maker"&&(m="limit");const v=this.safeString(e,"stopPrice"),T=this.parseNumber(this.omitZero(v));return this.safeOrder({info:e,id:l,clientOrderId:w,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:d,symbol:r,type:m,timeInForce:b,postOnly:S,reduceOnly:this.safeValue(e,"reduceOnly"),side:g,price:u,triggerPrice:T,amount:h,cost:f,average:c,filled:a,remaining:void 0,status:s,fee:void 0,trades:y},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(r,"type",a.type),d=this.safeString2(r,"newClientOrderId","clientOrderId"),c=t.toUpperCase(),u=c==="MARKET",h=c==="LIMIT",f=this.isPostOnly(u,c==="LIMIT_MAKER",r),l=this.safeValue2(r,"triggerPrice","stopPrice"),m=this.safeValue(r,"stopLossPrice",l),g=this.safeValue(r,"takeProfitPrice"),y=m!==void 0,w=g!==void 0;r=this.omit(r,["type","newClientOrderId","clientOrderId","postOnly","stopLossPrice","takeProfitPrice","stopPrice","triggerPrice"]);const[b,S]=this.handleMarginModeAndParams("createOrder",r),v={symbol:a.id,side:s.toUpperCase()};let T="privatePostOrder";a.linear?T="fapiPrivatePostOrder":a.inverse?T="dapiPrivatePostOrder":(o==="margin"||b!==void 0)&&(T="sapiPostMarginOrder",this.safeValue(r,"reduceOnly")&&(v.sideEffectType="AUTO_REPAY",r=this.omit(r,"reduceOnly"))),(a.spot||o==="margin")&&(this.safeValue(S,"test",!1)&&(T+="Test"),f&&(t="LIMIT_MAKER"));let I=c,A;y?(A=m,u?I=a.contract?"STOP_MARKET":"STOP_LOSS":h&&(I=a.contract?"STOP":"STOP_LOSS_LIMIT")):w&&(A=g,u?I=a.contract?"TAKE_PROFIT_MARKET":"TAKE_PROFIT":h&&(I=a.contract?"TAKE_PROFIT":"TAKE_PROFIT_LIMIT"));const N=this.safeValue(a.info,"orderTypes");if(!this.inArray(I,N))throw c!==I?new Rt(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new Rt(this.id+" "+t+" is not a valid order type for the "+e+" market");if(b==="isolated"&&(v.isIsolated=!0),d===void 0){const L=this.safeValue(this.options,"broker");if(L!==void 0){const D=this.safeString(L,o);D!==void 0&&(v.newClientOrderId=D+this.uuid22())}}else v.newClientOrderId=d;o==="spot"||o==="margin"?v.newOrderRespType=this.safeValue(this.options.newOrderRespType,t,"RESULT"):v.newOrderRespType="RESULT",v.type=I;let B=!1,x=!1,k=!1,O=!1;if(I==="MARKET")if(a.spot)if(this.safeValue(this.options,"quoteOrderQty",!0)){const D=this.safeValue2(S,"quoteOrderQty","cost"),H=a.precision.price;if(D!==void 0)v.quoteOrderQty=this.decimalToPrecision(D,wa,H,this.precisionMode);else if(n!==void 0){const R=this.numberToString(i),_=this.numberToString(n),E=fe.stringMul(R,_);v.quoteOrderQty=this.decimalToPrecision(E,wa,H,this.precisionMode)}else O=!0}else O=!0;else O=!0;else if(I==="LIMIT")x=!0,B=!0,O=!0;else if(I==="STOP_LOSS"||I==="TAKE_PROFIT")k=!0,O=!0,(a.linear||a.inverse)&&(x=!0);else if(I==="STOP_LOSS_LIMIT"||I==="TAKE_PROFIT_LIMIT")O=!0,k=!0,x=!0,B=!0;else if(I==="LIMIT_MAKER")x=!0,O=!0;else if(I==="STOP")O=!0,k=!0,x=!0;else if(I==="STOP_MARKET"||I==="TAKE_PROFIT_MARKET")this.safeValue(S,"closePosition")===void 0&&(O=!0),k=!0;else if(I==="TRAILING_STOP_MARKET"&&(O=!0,this.safeNumber(S,"callbackRate")===void 0))throw new Rt(this.id+" createOrder() requires a callbackRate extra param for a "+t+" order");if(O&&(v.quantity=this.amountToPrecision(e,i)),x){if(n===void 0)throw new Rt(this.id+" createOrder() requires a price argument for a "+t+" order");v.price=this.priceToPrecision(e,n)}if(B&&(v.timeInForce=this.options.defaultTimeInForce),a.contract&&f&&(v.timeInForce="GTX"),k){if(A===void 0)throw new Rt(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");v.stopPrice=this.priceToPrecision(e,A)}const P=this.omit(r,["quoteOrderQty","cost","stopPrice","test","type","newClientOrderId","clientOrderId","postOnly"]),q=await this[T](this.extend(v,P));return this.parseOrder(q,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Zs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType","spot"),r=this.safeString(s,"type",n),[a,o]=this.handleMarginModeAndParams("fetchOrder",s),d={symbol:i.id};let c="privateGetOrder";i.linear?c="fapiPrivateGetOrder":i.inverse?c="dapiPrivateGetOrder":(r==="margin"||a!==void 0)&&(c="sapiGetMarginOrder",a==="isolated"&&(d.isIsolated=!0));const u=this.safeValue2(s,"origClientOrderId","clientOrderId");u!==void 0?d.origClientOrderId=u:d.orderId=e;const h=this.omit(o,["type","clientOrderId","origClientOrderId"]),f=await this[c](this.extend(d,h));return this.parseOrder(f,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Zs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeString2(this.options,"fetchOrders","defaultType","spot"),a=this.safeString(i,"type",r),[o,d]=this.handleMarginModeAndParams("fetchOrders",i),c={symbol:n.id};let u="privateGetAllOrders";n.linear?u="fapiPrivateGetAllOrders":n.inverse?u="dapiPrivateGetAllOrders":(a==="margin"||o!==void 0)&&(u="sapiGetMarginAllOrders",o==="isolated"&&(c.isIsolated=!0)),t!==void 0&&(c.startTime=t),s!==void 0&&(c.limit=s);const h=await this[u](this.extend(c,d));return this.parseOrders(h,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={};let o,d;if([o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i),e!==void 0){n=this.market(e),a.symbol=n.id;const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot"),m="type"in n?n.type:l;r=this.safeString(d,"type",m)}else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const m=this.symbols.length,g=parseInt(m/2);throw new He(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+g.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}else{const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot");r=this.safeString(d,"type",l)}let c;[c,d]=this.handleSubTypeAndParams("fetchOpenOrders",n,i);const u=this.omit(d,"type");let h="privateGetOpenOrders";if(this.isLinear(r,c))h="fapiPrivateGetOpenOrders";else if(this.isInverse(r,c))h="dapiPrivateGetOpenOrders";else if((r==="margin"||o!==void 0)&&(h="sapiGetMarginOpenOrders",o==="isolated"&&(a.isIsolated=!0,e===void 0)))throw new Zs(this.id+" fetchOpenOrders() requires a symbol argument for isolated markets");const f=await this[h](this.extend(a,u));return this.parseOrders(f,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Zs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"cancelOrder","defaultType","spot"),r=this.safeString(s,"type",n),a=this.safeValue2(s,"origClientOrderId","clientOrderId"),[o,d]=this.handleMarginModeAndParams("cancelOrder",s),c={symbol:i.id};a===void 0?c.orderId=e:c.origClientOrderId=a;let u="privateDeleteOrder";i.linear?u="fapiPrivateDeleteOrder":i.inverse?u="dapiPrivateDeleteOrder":(r==="margin"||o!==void 0)&&(u="sapiDeleteMarginOrder",o==="isolated"&&(c.isIsolated=!0));const h=this.omit(d,["type","origClientOrderId","clientOrderId"]),f=await this[u](this.extend(c,h));return this.parseOrder(f,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Zs(this.id+" cancelAllOrders () requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.safeString(t,"type",s.type);t=this.omit(t,["type"]);const[r,a]=this.handleMarginModeAndParams("cancelAllOrders",t);let o="privateDeleteOpenOrders";s.linear?o="fapiPrivateDeleteAllOpenOrders":s.inverse?o="dapiPrivateDeleteAllOpenOrders":(n==="margin"||r!==void 0)&&(o="sapiDeleteMarginOpenOrders",r==="isolated"&&(i.isIsolated=!0));const d=await this[o](this.extend(i,a));return Array.isArray(d)?this.parseOrders(d,s):d}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Zs(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a=this.safeString(n,"type",r.type);if(n=this.omit(n,"type"),a!=="spot")throw new Ps(this.id+" fetchOrderTrades() supports spot markets only");const o={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(o,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Zs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(i,"type",n.type);i=this.omit(i,"type");let o,d;[d,i]=this.handleMarginModeAndParams("fetchMyTrades",i),a==="spot"||a==="margin"?(o="privateGetMyTrades",(a==="margin"||d!==void 0)&&(o="sapiGetMarginMyTrades",d==="isolated"&&(r.isIsolated=!0))):n.linear?o="fapiPrivateGetUserTrades":n.inverse&&(o="dapiPrivateGetUserTrades");let c=this.safeInteger2(i,"until","endTime");if(t!==void 0){const h=parseInt(t);r.startTime=h;const f=this.milliseconds(),l=7*24*60*60*1e3;f-h>=l&&c===void 0&&n.linear&&(c=this.sum(h,l),c=Math.min(c,f))}c!==void 0&&(r.endTime=c,i=this.omit(i,["endTime","until"])),s!==void 0&&(n.contract&&(s=Math.min(s,1e3)),r.limit=s);const u=await this[o](this.extend(r,i));return this.parseTrades(u,n,t,s)}async fetchMyDustTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6));const r=await this.sapiGetAssetDribblet(this.extend(n,i)),a=this.safeValue(r,"userAssetDribblets",[]),o=this.safeInteger(r,"total",0),d=[];for(let u=0;u<o;u++){const h=this.safeValue(a[u],"userAssetDribbletDetails",[]);for(let f=0;f<h.length;f++)h[f].isDustTrade=!0,d.push(h[f])}const c=this.parseTrades(d,void 0,t,s);return this.filterBySinceLimit(c,t,s)}parseDustTrade(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeInteger(e,"operateTime"),n=this.safeString(e,"fromAsset"),r=this.safeCurrencyCode(n),o=this.currency("BNB").code,d=o+"/"+r;let c=!1;d in this.markets&&(c=!0);const u=this.safeString(e,"serviceChargeAmount"),h={currency:o,cost:this.parseNumber(u)};let f,l,m,g;c?(f=d,l=this.safeString(e,"transferedAmount"),m=this.safeString(e,"amount"),g="buy"):(f=r+"/"+o,l=this.safeString(e,"amount"),m=this.safeString(e,"transferedAmount"),g="sell");let y;m!==void 0&&l&&(y=fe.stringDiv(m,l));const w=void 0,b=this.parseNumber(l),S=this.parseNumber(y),v=this.parseNumber(m),T=void 0,I=void 0;return{id:w,timestamp:i,datetime:this.iso8601(i),symbol:f,order:s,type:T,takerOrMaker:I,side:g,amount:b,price:S,cost:v,fee:h,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={},o=this.safeValue(this.options,"legalMoney",{}),d=this.safeValue(i,"fiat",!1);i=this.omit(i,"fiatOnly");const c=this.safeInteger(i,"until");if(d||e in o){e!==void 0&&(n=this.currency(e)),a.transactionType=0,t!==void 0&&(a.beginTime=t),c!==void 0&&(a.endTime=c);const u=await this.sapiGetFiatOrders(this.extend(a,i));r=this.safeValue(u,"data")}else{if(e!==void 0&&(n=this.currency(e),a.coin=n.id),t!==void 0){a.startTime=t;let u=this.sum(t,7776e6);c!==void 0&&(u=Math.min(u,c)),a.endTime=u}s!==void 0&&(a.limit=s),r=await this.sapiGetCapitalDepositHisrec(this.extend(a,i))}return this.parseTransactions(r,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"legalMoney",{}),r=this.safeValue(i,"fiat",!1);i=this.omit(i,"fiatOnly");const a={};let o,d;if(r||e in n){e!==void 0&&(d=this.currency(e)),a.transactionType=1,t!==void 0&&(a.beginTime=t);const c=await this.sapiGetFiatOrders(this.extend(a,i));o=this.safeValue(c,"data")}else e!==void 0&&(d=this.currency(e),a.coin=d.id),t!==void 0&&(a.startTime=t,a.endTime=this.sum(t,7776e6)),s!==void 0&&(a.limit=s),o=await this.sapiGetCapitalWithdrawHistory(this.extend(a,i));return this.parseTransactions(o,d,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","orderNo"),i=this.safeString(e,"address");let n=this.safeString(e,"addressTag");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeString(e,"txId");r!==void 0&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency");let o=this.safeCurrencyCode(a,t),d;d=this.safeInteger2(e,"insertTime","createTime"),d===void 0&&(d=this.parse8601(this.safeString(e,"applyTime")));const c=this.safeInteger2(e,"successTime","updateTime");let u=this.safeString(e,"type");if(u===void 0){u=this.safeString(e,"transactionType")==="0"?"deposit":"withdrawal";const b=this.safeValue(this.options,"legalMoneyCurrenciesById");o=this.safeString(b,o,o)}const h=this.parseTransactionStatusByType(this.safeString(e,"status"),u),f=this.safeNumber(e,"amount"),l=this.safeNumber2(e,"transactionFee","totalFee");let m;l!==void 0&&(m={currency:o,cost:l});let g=this.safeInteger(e,"transferType");g!==void 0&&(g=!!g);const y=this.safeString(e,"network");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:y,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:u,amount:f,currency:o,status:h,updated:c,internal:g,fee:m}}parseTransferStatus(e){const t={CONFIRMED:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"tranId"),i=this.safeString(e,"asset"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=this.safeString(e,"type");let o,d;const c=this.safeValue(this.options,"accountsById",{});if(a!==void 0){const f=a.split("_");o=this.safeValue(f,0),d=this.safeValue(f,1),o=this.safeString(c,o,o),d=this.safeString(c,d,d)}const u=this.safeInteger(e,"timestamp"),h=this.parseTransferStatus(this.safeString(e,"status"));return{info:e,id:s,timestamp:u,datetime:this.iso8601(u),currency:n,amount:r,fromAccount:o,toAccount:d,status:h}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,void 0,"swap"),n=this.safeNumber(e,"income"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(e,"tranId"),d=this.safeInteger(e,"time");return{info:e,symbol:i,code:a,timestamp:d,datetime:this.iso8601(d),id:o,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t)};a.type=this.safeString(n,"type");let o="sapiPostAssetTransfer";if(a.type===void 0){const u=this.safeString(n,"symbol");u!==void 0&&(n=this.omit(n,"symbol"));let h=this.convertTypeToAccount(s).toUpperCase(),f=this.convertTypeToAccount(i).toUpperCase();if(h==="ISOLATED"){if(u===void 0)throw new Zs(this.id+' transfer () requires params["symbol"] when fromAccount is '+s);h=this.marketId(u)}if(f==="ISOLATED"){if(u===void 0)throw new Zs(this.id+' transfer () requires params["symbol"] when toAccount is '+i);f=this.marketId(u)}const l=this.safeValue(this.options,"accountsById",{}),m=!(h in l),g=!(f in l);if(m||g){const y=h==="UMFUTURE"||h==="CMFUTURE",w=f==="UMFUTURE"||f==="CMFUTURE",b=h==="MAIN",S=f==="MAIN";if((m||g)&&(y||w||(h==="MINING"||f==="MINING")||(h==="FUNDING"||f==="FUNDING")))throw new ie(this.id+" transfer () does not allow transfers between "+s+" and "+i);S&&m?(o="sapiPostMarginIsolatedTransfer",a.transFrom="ISOLATED_MARGIN",a.transTo="SPOT",a.symbol=h):b&&g?(o="sapiPostMarginIsolatedTransfer",a.transFrom="SPOT",a.transTo="ISOLATED_MARGIN",a.symbol=f):(m&&(a.fromSymbol=h,h="ISOLATEDMARGIN"),g&&(a.toSymbol=f,f="ISOLATEDMARGIN"),a.type=h+"_"+f)}else a.type=h+"_"+f}n=this.omit(n,"type");const d=await this[o](this.extend(a,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=this.safeString2(this.options,"fetchTransfers","defaultType","spot"),a=this.safeString(i,"fromAccount",r),o=a==="future"?"spot":"future",d=this.safeString(i,"toAccount",o);let c=this.safeString(i,"type");const u=this.safeValue(this.options,"accountsByType",{}),h=this.safeString(u,a),f=this.safeString(u,d);if(c===void 0){if(h===void 0){const y=Object.keys(u);throw new He(this.id+" fromAccount parameter must be one of "+y.join(", "))}if(f===void 0){const y=Object.keys(u);throw new He(this.id+" toAccount parameter must be one of "+y.join(", "))}c=h+"_"+f}const l={type:c};t!==void 0&&(l.startTime=t),s!==void 0&&(l.size=s);const m=await this.sapiGetAssetTransfer(this.extend(l,i)),g=this.safeValue(m,"rows",[]);return this.parseTransfers(g,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.sapiGetCapitalDepositAddress(this.extend(i,t)),o=this.safeString(a,"address"),d=this.safeString(a,"url");let c;if(d!==void 0){const h=this.safeValue(this.options,"reverseNetworks",{}),f=d.split("/");let l=this.safeString(f,2);if(l==="blockchair.com"||l==="viewblock.io"){const g=this.safeString(f,3);g!==void 0&&(l=l+"/"+g)}c=this.safeString(h,l);const m=this.safeValue(this.options,"impliedNetworks",{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}});if(e in m){const g=this.safeValue(m,e,{});c=this.safeString(g,c,c)}}let u=this.safeString(a,"tag","");return u.length===0&&(u=void 0),this.checkAddress(o),{currency:e,address:o,tag:u,network:c,info:a}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"network"),f=this.safeCurrencyCode(h),l=this.safeNumber(u,"withdrawFee");i[o][f]=l}}return{withdraw:i,deposit:{},info:s}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t);return this.parseDepositWithdrawFees(s,e,"coin")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i=this.depositWithdrawFee(e);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.networkIdToCode(a),d=this.safeNumber(r,"withdrawFee");this.safeValue(r,"isDefault")===!0&&(i.withdraw={fee:d,percentage:void 0}),i.networks[o]={withdraw:{fee:d,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return i}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,address:s,amount:t};i!==void 0&&(a.addressTag=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.network=d,n=this.omit(n,"network"));const c=await this.sapiPostCapitalWithdrawApply(this.extend(a,n));return this.parseTransaction(c,r)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,void 0,"spot");return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.sapiGetAssetTradeFee(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();let t;const s=this.safeString2(this.options,"fetchTradingFees","defaultType","linear"),i=this.safeString(e,"type",s);e=this.omit(e,"type");let n;[n,e]=this.handleSubTypeAndParams("fetchTradingFees",void 0,e);const r=i==="spot"||i==="margin",a=this.isLinear(i,n),o=this.isInverse(i,n);r?t="sapiGetAssetTradeFee":a?t="fapiPrivateGetAccount":o&&(t="dapiPrivateGetAccount");const d=await this[t](e);if(r){const c={};for(let u=0;u<d.length;u++){const h=this.parseTradingFee(d[u]),f=h.symbol;c[f]=h}return c}else if(a){const c=Object.keys(this.markets),u={},h=this.safeInteger(d,"feeTier"),f=this.fees[i].trading.tiers,l=f.maker[h][1],m=f.taker[h][1];for(let g=0;g<c.length;g++){const y=c[g];u[y]={info:{feeTier:h},symbol:y,maker:l,taker:m}}return u}else if(o){const c=Object.keys(this.markets),u={},h=this.safeInteger(d,"feeTier"),f=this.fees[i].trading.tiers,l=f.maker[h][1],m=f.taker[h][1];for(let g=0;g<c.length;g++){const y=c[g];u[y]={info:{feeTier:h},symbol:y,maker:l,taker:m}}return u}}async futuresTransfer(e,t,s,i={}){if(s<1||s>4)throw new Zs(this.id+" type must be between 1 and 4");await this.loadMarkets();const n=this.currency(e),r={asset:n.id,amount:t,type:s},a=await this.sapiPostFuturesTransfer(this.extend(r,i));return this.parseTransfer(a,n)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;if(s.linear)n="fapiPublicGetPremiumIndex";else if(s.inverse)n="dapiPublicGetPremiumIndex";else throw new Ps(this.id+" fetchFundingRate() supports linear and inverse contracts only");let r=await this[n](this.extend(i,t));return s.inverse&&(r=r[0]),this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeString2(this.options,"fetchFundingRateHistory","defaultType","future"),o=this.safeString(i,"type",a);let d;e!==void 0&&(d=this.market(e),e=d.symbol,n.symbol=d.id);let c;if([c,i]=this.handleSubTypeAndParams("fetchFundingRateHistory",d,i,"linear"),i=this.omit(i,"type"),this.isLinear(o,c)?r="fapiPublicGetFundingRate":this.isInverse(o,c)&&(r="dapiPublicGetFundingRate"),r===void 0)throw new Ps(this.id+" fetchFundingRateHistory() is not supported for "+o+" markets");t!==void 0&&(n.startTime=t);const u=this.safeInteger2(i,"until","till"),h=this.safeInteger(i,"endTime",u);i=this.omit(i,["endTime","till","until"]),h!==void 0&&(n.endTime=h),s!==void 0&&(n.limit=s);const f=await this[r](this.extend(n,i)),l=[];for(let g=0;g<f.length;g++){const y=f[g],w=this.safeInteger(y,"fundingTime");l.push({info:y,symbol:this.safeSymbol(this.safeString(y,"symbol"),void 0,void 0,"swap"),fundingRate:this.safeNumber(y,"fundingRate"),timestamp:w,datetime:this.iso8601(w)})}const m=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(m,e,t,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;const i=this.safeString2(this.options,"fetchFundingRates","defaultType","future"),n=this.safeString(t,"type",i);let r;[r,t]=this.handleSubTypeAndParams("fetchFundingRates",void 0,t,"linear");const a=this.omit(t,"type");if(this.isLinear(n,r))s="fapiPublicGetPremiumIndex";else if(this.isInverse(n,r))s="dapiPublicGetPremiumIndex";else throw new Ps(this.id+" fetchFundingRates() supports linear and inverse contracts only");const o=await this[s](a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.parseFundingRate(u);d.push(h)}return this.filterByArray(d,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,void 0,"contract"),r=this.safeNumber(e,"markPrice"),a=this.safeNumber(e,"indexPrice"),o=this.safeNumber(e,"interestRate"),d=this.safeNumber(e,"estimatedSettlePrice"),c=this.safeNumber(e,"lastFundingRate"),u=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:n,markPrice:r,indexPrice:a,interestRate:o,estimatedSettlePrice:d,timestamp:s,datetime:this.iso8601(s),fundingRate:c,fundingTimestamp:u,fundingDatetime:this.iso8601(u),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseAccountPositions(e){const t=this.safeValue(e,"positions"),s=this.safeValue(e,"assets",[]),i={};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"asset"),d=this.safeCurrencyCode(o),c=this.safeString(a,"crossWalletBalance"),u=this.safeString(a,"crossUnPnl");i[d]={crossMargin:fe.stringAdd(c,u),crossWalletBalance:c}}const n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"symbol"),d=this.safeMarket(o,void 0,void 0,"contract"),c=d.linear?d.quote:d.base;if(c in i){const u=this.parseAccountPosition(this.extend(a,{crossMargin:i[c].crossMargin,crossWalletBalance:i[c].crossWalletBalance}),d);n.push(u)}}return n}parseAccountPosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeString(t,"symbol"),n=this.safeString(e,"leverage"),r=parseInt(n),a=this.safeString(e,"initialMargin"),o=this.parseNumber(a);let d=fe.stringDiv("1",n,8);1e3%r===0||(d=fe.stringDiv(fe.stringAdd(d,"1e-8"),"1",8));const u="notional"in e,h=this.safeString(e,"maintMargin"),f=this.parseNumber(h),l=this.safeString(e,"entryPrice");let m=this.parseNumber(l);const g=this.safeString2(e,"notional","notionalValue"),y=fe.stringAbs(g),w=this.parseNumber(y);let b=this.safeString(e,"positionAmt"),S=fe.stringAbs(b);if(b===void 0){const me=fe.stringMul(fe.stringMul(n,a),l),ye=this.safeString(t,"contractSize");b=fe.stringDiv(me,ye),S=fe.stringDiv(fe.stringAdd(b,"0.5"),"1",0)}const v=this.parseNumber(S),T=this.safeValue(this.options,"leverageBrackets",{}),I=this.safeValue(T,i,[]);let A;for(let me=0;me<I.length;me++){const ye=I[me];if(fe.stringLt(y,ye[0]))break;A=ye[1]}const N=this.parseNumber(A),B=this.safeString(e,"unrealizedProfit"),x=this.parseNumber(B);let k=this.safeInteger(e,"updateTime");k===0&&(k=void 0);const O=this.safeValue(e,"isolated");let P,q,L;O?(P="isolated",L=this.safeString(e,"isolatedWallet"),q=fe.stringAdd(L,B)):(P="cross",L=this.safeString(e,"crossWalletBalance"),q=this.safeString(e,"crossMargin"));const D=this.parseNumber(q);let H,R,_,E,U;const G=this.safeValue(t,"contractSize"),$=this.numberToString(G);if(fe.stringEquals(g,"0"))m=void 0;else{if(R=fe.stringLt(g,"0")?"short":"long",H=this.parseNumber(fe.stringDiv(fe.stringAdd(fe.stringDiv(h,q),"5e-5"),"1",4)),_=this.parseNumber(fe.stringMul(fe.stringDiv(B,a,4),"100")),u){let K,z=l;R==="short"?K=fe.stringAdd("1",A):(K=fe.stringAdd("-1",A),z=fe.stringMul("-1",z));const V=fe.stringDiv(L,fe.stringMul(S,K)),C=fe.stringDiv(z,K);E=fe.stringAdd(V,C)}else{let K,z=l;R==="short"?K=fe.stringSub("1",A):(K=fe.stringSub("-1",A),z=fe.stringMul("-1",z));const V=fe.stringMul(S,$),C=fe.stringMul(V,K),M=fe.stringSub(fe.stringMul(fe.stringDiv("1",z),V),L);E=fe.stringDiv(C,M)}const me=t.precision.price,xe=(me+1).toString(),Mt=new fe("5e-"+xe).toString(),Me=fe.stringAdd(Mt,E);let ge=fe.stringDiv(Me,"1",me);ge[0]==="-"&&(ge=void 0),U=this.parseNumber(ge)}const he=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,timestamp:k,datetime:this.iso8601(k),initialMargin:o,initialMarginPercentage:this.parseNumber(d),maintenanceMargin:f,maintenanceMarginPercentage:N,entryPrice:m,notional:w,leverage:this.parseNumber(n),unrealizedPnl:x,contracts:v,contractSize:G,marginRatio:H,liquidationPrice:U,markPrice:void 0,collateral:D,marginMode:P,side:R,hedged:he,percentage:_}}parsePositionRisk(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeString(t,"symbol"),n=this.safeValue(this.options,"leverageBrackets",{}),r=this.safeValue(n,i,[]),a=this.safeString2(e,"notional","notionalValue"),o=fe.stringAbs(a);let d;for(let Z=0;Z<r.length;Z++){const he=r[Z];if(fe.stringLt(o,he[0]))break;d=he[1]}const c=this.parseNumber(o),u=fe.stringAbs(this.safeString(e,"positionAmt")),h=this.parseNumber(u),f=this.safeString(e,"unRealizedProfit"),l=this.parseNumber(f),m=this.safeString(e,"leverage"),g=parseInt(m),y=this.omitZero(this.safeString(e,"liquidationPrice")),w=this.parseNumber(y);let b;const S=this.safeString(e,"marginType");let v;fe.stringGt(a,"0")?v="long":fe.stringLt(a,"0")&&(v="short");const T=this.safeString(e,"entryPrice"),I=this.parseNumber(T),A=this.safeValue(t,"contractSize"),N=this.numberToString(A),B="notional"in e;if(S==="cross"){const Z=this.safeValue(t,"precision",{});if(B){let he,me=T;v==="short"?(he=fe.stringAdd("1",d),me=fe.stringMul("-1",me)):he=fe.stringAdd("-1",d);const ye=fe.stringMul(y,he),xe=fe.stringAdd(ye,me),Ae=this.safeInteger(Z,"price"),Mt=this.safeInteger(Z,"quote",Ae);Mt!==void 0&&(b=fe.stringDiv(fe.stringMul(xe,u),"1",Mt))}else{let he,me=T;v==="short"?he=fe.stringSub("1",d):(he=fe.stringSub("-1",d),me=fe.stringMul("-1",me));const ye=fe.stringMul(u,N),xe=fe.stringSub(fe.stringDiv("1",me),fe.stringDiv(he,y)),Ae=this.safeInteger(Z,"base");Ae!==void 0&&(b=fe.stringDiv(fe.stringMul(ye,xe),"1",Ae))}}else b=this.safeString(e,"isolatedMargin");b=b===void 0?"0":b;const x=this.parseNumber(b),k=this.parseNumber(this.omitZero(this.safeString(e,"markPrice")));let O=this.safeInteger(e,"updateTime");O===0&&(O=void 0);const P=this.parseNumber(d),q=fe.stringMul(d,o),L=this.parseNumber(q);let D=fe.stringDiv("1",m,8);1e3%g===0||(D=fe.stringAdd(D,"1e-8"));const R=fe.stringDiv(fe.stringMul(o,D),"1",8),_=this.parseNumber(R);let E,U;fe.stringEquals(b,"0")||(E=this.parseNumber(fe.stringDiv(fe.stringAdd(fe.stringDiv(q,b),"5e-5"),"1",4)),U=this.parseNumber(fe.stringMul(fe.stringDiv(f,R,4),"100")));const $=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,contracts:h,contractSize:A,unrealizedPnl:l,leverage:this.parseNumber(m),liquidationPrice:w,collateral:x,notional:c,markPrice:k,entryPrice:I,timestamp:O,initialMargin:_,initialMarginPercentage:this.parseNumber(D),maintenanceMargin:L,maintenanceMarginPercentage:P,marginRatio:E,datetime:this.iso8601(O),marginMode:S,marginType:S,side:v,hedged:$,percentage:U}}async loadLeverageBrackets(e=!1,t={}){if(await this.loadMarkets(),this.safeValue(this.options,"leverageBrackets")===void 0||e){let i;const n=this.safeString(this.options,"defaultType","future"),r=this.safeString(t,"type",n),a=this.omit(t,"type");let o;if([o,t]=this.handleSubTypeAndParams("loadLeverageBrackets",void 0,t,"linear"),this.isLinear(r,o))i="fapiPrivateGetLeverageBracket";else if(this.isInverse(r,o))i="dapiPrivateV2GetLeverageBracket";else throw new Ps(this.id+" loadLeverageBrackets() supports linear and inverse contracts only");const d=await this[i](a);this.options.leverageBrackets={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"symbol"),f=this.safeSymbol(h,void 0,void 0,"contract"),l=this.safeValue(u,"brackets",[]),m=[];for(let g=0;g<l.length;g++){const y=l[g],w=this.safeString2(y,"notionalFloor","qtyFloor"),b=this.safeString(y,"maintMarginRatio");m.push([w,b])}this.options.leverageBrackets[f]=m}}return this.options.leverageBrackets}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t);let n;[n,t]=this.handleSubTypeAndParams("fetchLeverageTiers",void 0,t,"linear");let r;if(this.isLinear(s,n))r="fapiPrivateGetLeverageBracket";else if(this.isInverse(s,n))r="dapiPrivateV2GetLeverageBracket";else throw new Ps(this.id+" fetchLeverageTiers() supports linear and inverse contracts only");const a=await this[r](i);return this.parseLeverageTiers(a,e,"symbol")}parseMarketLeverageTiers(e,t){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeValue(e,"brackets",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r];n.push({tier:this.safeNumber(a,"bracket"),currency:t.quote,minNotional:this.safeNumber2(a,"notionalFloor","qtyFloor"),maxNotional:this.safeNumber2(a,"notionalCap","qtyCap"),maintenanceMarginRate:this.safeNumber(a,"maintMarginRatio"),maxLeverage:this.safeNumber(a,"initialLeverage"),info:a})}return n}async fetchPositions(e=void 0,t={}){const s=this.safeString(this.options,"fetchPositions","positionRisk");if(s==="positionRisk")return await this.fetchPositionsRisk(e,t);if(s==="account")return await this.fetchAccountPositions(e,t);throw new Ps(this.id+'.options["fetchPositions"] = "'+s+'" is invalid, please choose between "account" and "positionRisk"')}async fetchAccountPositions(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new Zs(this.id+" fetchPositions() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);let s;const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(t,"type",i);let r=this.omit(t,"type"),a;if([a,r]=this.handleSubTypeAndParams("fetchAccountPositions",void 0,t,"linear"),this.isLinear(n,a))s="fapiPrivateGetAccount";else if(this.isInverse(n,a))s="dapiPrivateGetAccount";else throw new Ps(this.id+" fetchPositions() supports linear and inverse contracts only");const o=await this[s](r),d=this.parseAccountPositions(o);return e=this.marketSymbols(e),this.filterByArray(d,"symbol",e,!1)}async fetchPositionsRisk(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new Zs(this.id+" fetchPositionsRisk() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);const s={};let i,n="future";n=this.safeString(this.options,"defaultType",n);const r=this.safeString(t,"type",n);let a;if([a,t]=this.handleSubTypeAndParams("fetchPositionsRisk",void 0,t,"linear"),t=this.omit(t,"type"),this.isLinear(r,a))i="fapiPrivateGetPositionRisk";else if(this.isInverse(r,a))i="dapiPrivateGetPositionRisk";else throw new Ps(this.id+" fetchPositionsRisk() supports linear and inverse contracts only");const o=await this[i](this.extend(s,t)),d=[];for(let c=0;c<o.length;c++){const u=this.parsePositionRisk(o[c]);d.push(u)}return e=this.marketSymbols(e),this.filterByArray(d,"symbol",e,!1)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={incomeType:"FUNDING_FEE"};if(e!==void 0&&(n=this.market(e),a.symbol=n.id,!n.swap))throw new Ps(this.id+" fetchFundingHistory() supports swap contracts only");let o;[o,i]=this.handleSubTypeAndParams("fetchFundingHistory",n,i,"linear"),t!==void 0&&(a.startTime=t),s!==void 0&&(a.limit=s);const d=this.safeString2(this.options,"fetchFundingHistory","defaultType","future"),c=this.safeString(i,"type",d);if(i=this.omit(i,"type"),this.isLinear(c,o))r="fapiPrivateGetIncome";else if(this.isInverse(c,o))r="dapiPrivateGetIncome";else throw new Ps(this.id+" fetchFundingHistory() supports linear and inverse contracts only");const u=await this[r](this.extend(a,i));return this.parseIncomes(u,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Zs(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new ie(this.id+" leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostLeverage";else if(i.inverse)n="dapiPrivatePostLeverage";else throw new Ps(this.id+" setLeverage() supports linear and inverse contracts only");const r={symbol:i.id,leverage:e};return await this[n](this.extend(r,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Zs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toUpperCase(),e==="CROSS"&&(e="CROSSED"),e!=="ISOLATED"&&e!=="CROSSED")throw new ie(this.id+" marginMode must be either isolated or cross");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostMarginType";else if(i.inverse)n="dapiPrivatePostMarginType";else throw new Ps(this.id+" setMarginMode() supports linear and inverse contracts only");const r={symbol:i.id,marginType:e};let a;try{a=await this[n](this.extend(r,s))}catch(o){if(o instanceof Cy){if(this.safeValue(this.options,"throwMarginModeAlreadySet",!1))throw o;a={code:-4046,msg:"No need to change margin type."}}}return a}async setPositionMode(e,t=void 0,s={}){const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(s,"type",i);s=this.omit(s,["type"]);let r;e?r="true":r="false";const a={dualSidePosition:r};let o;return this.isInverse(n)?o="dapiPrivatePostPositionSideDual":o="fapiPrivatePostPositionSideDual",await this[o](this.extend(a,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new Ps(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="historicalTrades")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey};else throw new ds(this.id+" historicalTrades endpoint requires `apiKey` credential");if(e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new ds(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="eapiPrivate"||t==="sapi"&&e!=="system/status"||t==="sapiV2"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);let f;this.secret.indexOf("-----BEGIN RSA PRIVATE KEY-----")>-1?f=this.rsa(this.encode(d),this.encode(this.secret)):f=this.hmac(this.encode(d),this.encode(this.secret)),d+="&signature="+f,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new Bo(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Rt(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Rt(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Rt(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const f=this.safeString(a,"msg");let l;if(f!==void 0){try{l=JSON.parse(f)}catch{l=void 0}l!==void 0&&(a=l)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||fe.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new Bo(this.id+" "+r);const f=this.id+" "+r;throw u==="No need to change margin type."?new Cy(f):(this.throwExactlyMatchedException(this.exceptions.exact,h,f),new He(f))}if(!c)throw new He(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);return(t==="private"||t==="wapi")&&(this.options.hasAlreadyAuthenticatedSuccessfully=!0),d}async modifyMarginHelper(e,t,s,i={}){let n=this.safeString(this.options,"defaultType","future");n==="spot"&&(n="future");const r=this.safeString(i,"type",n);if(r==="margin"||r==="spot")throw new Ps(this.id+" add / reduce margin only supported with type future or delivery");await this.loadMarkets();const a=this.market(e);t=this.amountToPrecision(e,t);const o={type:s,symbol:a.id,amount:t};let d,c;a.linear?(d="fapiPrivatePostPositionMargin",c=a.quote):(d="dapiPrivatePostPositionMargin",c=a.base);const u=await this[d](this.extend(o,i));return this.extend(this.parseMarginModification(u,a),{code:c})}parseMarginModification(e,t=void 0){const i=this.safeInteger(e,"type")===1?"add":"reduce",n=this.safeNumber(e,"amount"),a=this.safeString(e,"code")==="200"?"ok":"failed";return{info:e,type:i,amount:n,code:void 0,symbol:t.symbol,status:a}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.sapiGetMarginInterestRateHistory(this.extend(i,t)),r=this.safeValue(n,0);return this.parseBorrowRate(r)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)s=93;else if(s>93)throw new ie(this.id+" fetchBorrowRateHistory() limit parameter cannot exceed 92");const r={asset:this.currency(e).id,limit:s};if(t!==void 0){r.startTime=t;const o=this.sum(t,s*864e5)-1,d=this.milliseconds();r.endTime=Math.min(o,d)}const a=await this.sapiGetMarginInterestRateHistory(this.extend(r,i));return this.parseBorrowRateHistory(a,e,t,s)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeNumber(e,"timestamp");return t=this.safeString(e,"asset"),{currency:this.safeCurrencyCode(t),rate:this.safeNumber(e,"dailyInterestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async createGiftCode(e,t,s={}){await this.loadMarkets();const n={token:this.currency(e).id,amount:t},r=await this.sapiPostGiftcardCreateCode(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeString(a,"code"),d=this.safeString(a,"referenceNo");return{info:r,id:d,code:o,currency:e,amount:t}}async redeemGiftCode(e,t={}){const s={code:e};return await this.sapiPostGiftcardRedeemCode(this.extend(s,t))}async verifyGiftCode(e,t={}){const s={referenceNo:e};return await this.sapiGetGiftcardVerify(this.extend(s,t))}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;if(e!==void 0){const u=this.currency(e);r.asset=u.id}s!==void 0&&(r.startTime=s),i!==void 0&&(r.size=i),t!==void 0&&(a=this.market(t),r.isolatedSymbol=a.id);const o=await this.sapiGetMarginInterestHistory(this.extend(r,n)),d=this.safeValue(o,"rows"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"isolatedSymbol"),i=this.safeNumber(e,"interestAccuredTime");return{account:s===void 0?"cross":s,symbol:s,marginMode:s===void 0?"cross":"isolated",currency:this.safeCurrencyCode(this.safeString(e,"asset")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"principal"),timestamp:i,datetime:this.iso8601(i),info:e}}async repayMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("repayMargin",i);this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginRepay(this.extend(o,r));return this.parseMarginLoan(d,a)}async borrowMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("borrowMargin",i);this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginLoan(this.extend(o,r));return this.parseMarginLoan(d,a)}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){if(t==="1m")throw new ie(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.linear?"symbol":"pair";a[o]=r.id,r.inverse&&(a.contractType=this.safeString(n,"contractType","CURRENT_QUARTER")),s!==void 0&&(a.startTime=s);const d=this.safeInteger2(n,"until","till"),c=this.safeInteger(n,"endTime",d);if(n=this.omit(n,["endTime","until","till"]),c)a.endTime=c;else if(s){i===void 0&&(i=30);const f=this.parseTimeframe(t);a.endTime=this.sum(s,f*i*1e3)}let u="fapiDataGetOpenInterestHist";r.inverse&&(u="dapiDataGetOpenInterestHist");const h=await this[u](this.extend(a,n));return this.parseOpenInterests(h,e,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeNumber(e,"sumOpenInterest"),r=this.safeNumber(e,"sumOpenInterestValue");return{symbol:this.safeSymbol(i,void 0,void 0,"contract"),baseVolume:n,quoteVolume:r,openInterestAmount:n,openInterestValue:r,timestamp:s,datetime:this.iso8601(s),info:e}}};const wV=tc;var bV=class extends wV{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/delivery/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{fetchMarkets:["inverse"],defaultSubType:"inverse",leverageBrackets:void 0}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,3,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,4,s)}};const kV=tc;var SV=class extends kV{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{web:"https://www.binance.us",sapi:"https://api.binance.us/sapi/v1",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v3",private:"https://api.binance.us/api/v3"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fetchMarkets:["spot"],defaultType:"spot",quoteOrderQty:!1},has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,fetchTickers:!1}})}};const vV=tc;var TV=class extends vV{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/futures/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{fetchMarkets:["linear"],defaultSubType:"linear",leverageBrackets:void 0,marginTypes:{},marginModes:{}}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,1,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,2,s)}};const OV=re,{ArgumentsRequired:IV,ExchangeError:My,InvalidNonce:xV,AuthenticationError:_V,PermissionDenied:CV,NotSupported:MV}=Q,{TICK_SIZE:PV}=ne,Py=ae;var AV=class extends OV{describe(){return this.deepExtend(super.describe(),{id:"bit2c",name:"Bit2C",countries:["IL"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg",api:{rest:"https://bit2c.co.il"},www:"https://www.bit2c.co.il",referral:"https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",doc:["https://www.bit2c.co.il/home/api","https://github.com/OferE/bit2c"]},api:{public:{get:["Exchanges/{pair}/Ticker","Exchanges/{pair}/orderbook","Exchanges/{pair}/trades","Exchanges/{pair}/lasttrades"]},private:{post:["Merchant/CreateCheckout","Funds/AddCoinFundsRequest","Order/AddFund","Order/AddOrder","Order/AddOrderMarketPriceBuy","Order/AddOrderMarketPriceSell","Order/CancelOrder","Order/AddCoinFundsRequest","Order/AddStopOrder","Payment/GetMyId","Payment/Send","Payment/Pay"],get:["Account/Balance","Account/Balance/v2","Order/MyOrders","Order/GetById","Order/AccountHistory","Order/OrderHistory"]}},markets:{"BTC/NIS":{id:"BtcNis",symbol:"BTC/NIS",base:"BTC",quote:"NIS",baseId:"Btc",quoteId:"Nis",type:"spot",spot:!0},"ETH/NIS":{id:"EthNis",symbol:"ETH/NIS",base:"ETH",quote:"NIS",baseId:"Eth",quoteId:"Nis",type:"spot",spot:!0},"LTC/NIS":{id:"LtcNis",symbol:"LTC/NIS",base:"LTC",quote:"NIS",baseId:"Ltc",quoteId:"Nis",type:"spot",spot:!0},"USDC/NIS":{id:"UsdcNis",symbol:"USDC/NIS",base:"USDC",quote:"NIS",baseId:"Usdc",quoteId:"Nis",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}},options:{fetchTradesMethod:"public_get_exchanges_pair_trades"},precisionMode:PV,exceptions:{exact:{"Please provide valid APIkey":_V},broad:{"Please provide valid nonce":xV,"please approve new terms of use on site":CV}}})}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],r=this.account(),o=this.currency(n).id.toUpperCase();o in e&&(r.free=this.safeString(e,"AVAILABLE_"+o),r.total=this.safeString(e,o)),t[n]=r}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalanceV2(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetExchangesPairOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"av"),r=this.safeString(e,"a"),a=this.safeString(e,"ll");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"h"),bidVolume:void 0,ask:this.safeString(e,"l"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:n,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetExchangesPairTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.options.fetchTradesMethod,a={pair:n.id};t!==void 0&&(a.date=parseInt(t)),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i));if(typeof o=="string")throw new My(o);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalance(e),s=this.safeValue(t,"Fees",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeSymbol(a),d=this.safeValue(s,a),c=this.safeString(d,"FeeMaker"),u=this.safeString(d,"FeeTaker"),h=this.parseNumber(Py.stringDiv(c,"100")),f=this.parseNumber(Py.stringDiv(u,"100"));n[o]={info:d,symbol:o,taker:f,maker:h,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePostOrderAddOrder";const o=this.market(e),d={Amount:i,Pair:o.id};t==="market"?a+="MarketPrice"+this.capitalize(s):(d.Price=n,d.Total=i*n,d.IsBid=s==="buy");const c=await this[a](this.extend(d,r));return{info:c,id:c.NewOrder.id}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostOrderCancelOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new IV(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrderMyOrders(this.extend(r,i)),o=this.safeValue(a,n.id,{}),d=this.safeValue(o,"ask",[]),c=this.safeValue(o,"bid",[]);return this.parseOrders(this.arrayConcat(d,c),n,t,s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"created"),i=this.safeString(e,"price"),n=this.safeString(e,"amount");t=this.safeMarket(void 0,t);let r=this.safeValue(e,"type");r===0?r="buy":r===1&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"status");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,triggerPrice:void 0,amount:n,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};s!==void 0&&(r.take=s),r.take=s,t!==void 0&&(r.toTime=this.yyyymmdd(this.milliseconds(),"."),r.fromTime=this.yyyymmdd(t,".")),e!==void 0&&(n=this.market(e),r.pair=n.id);const a=await this.privateGetOrderOrderHistory(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d;const c=this.safeString(e,"reference");if(c!==void 0){s=this.safeTimestamp(e,"ticks"),n=this.safeString(e,"price"),r=this.safeString(e,"firstAmount");const u=c.split("|"),h=this.safeString(e,"pair");t=this.safeMarket(h,t),t=this.safeMarket(u[0],t),a=u[1],i=u[2],d=this.safeInteger(e,"action"),d===0?d="buy":d===1&&(d="sell");const f=this.safeString(e,"feeAmount");f!==void 0&&(o={cost:f,currency:"NIS"})}else s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),d=this.safeValue(e,"isBid"),d!==void 0&&(d?d="buy":d="sell");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:a,type:void 0,side:d,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:o},t)}isFiat(e){return e==="NIS"}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new MV(this.id+" fetchDepositAddress() does not support fiat currencies");const i={Coin:s.id},n=await this.privatePostFundsAddCoinFundsRequest(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);if(t==="public")a+=".json";else{this.checkRequiredCredentials();const o=this.nonce(),d=this.extend({nonce:o},i),c=this.urlencode(d);s==="GET"?Object.keys(d).length&&(a+="?"+c):r=c;const u=this.hmac(this.encode(c),this.encode(this.secret),"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sign:u}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new My(u)}}};const BV=re,{ExchangeError:Uf,AuthenticationError:kc,InvalidNonce:NV,InsufficientFunds:VV,InvalidOrder:$f,OrderNotFound:Sc,PermissionDenied:EV}=Q,{TICK_SIZE:qV}=ne;var LV=class extends BV{describe(){return this.deepExtend(super.describe(),{id:"bitbank",name:"bitbank",countries:["JP"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},hostname:"bitbank.cc",urls:{logo:"https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg",api:{public:"https://public.{hostname}",private:"https://api.{hostname}",markets:"https://api.{hostname}"},www:"https://bitbank.cc/",doc:"https://docs.bitbank.cc/",fees:"https://bitbank.cc/docs/fees/"},api:{public:{get:["{pair}/ticker","{pair}/depth","{pair}/transactions","{pair}/transactions/{yyyymmdd}","{pair}/candlestick/{candletype}/{yyyymmdd}"]},private:{get:["user/assets","user/spot/order","user/spot/active_orders","user/spot/trade_history","user/withdrawal_account"],post:["user/spot/order","user/spot/cancel_order","user/spot/cancel_orders","user/spot/orders_info","user/request_withdrawal"]},markets:{get:["spot/pairs"]}},precisionMode:qV,exceptions:{20001:kc,20002:kc,20003:kc,20005:kc,20004:NV,40020:$f,40021:$f,40025:Uf,40013:Sc,40014:Sc,50008:EV,50009:Sc,50010:Sc,60001:VV,60005:$f}})}async fetchMarkets(e={}){const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"pairs",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"base_asset"),c=this.safeString(a,"quote_asset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"is_enabled"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(a,"taker_fee_rate_quote"),maker:this.safeNumber(a,"maker_fee_rate_quote"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_digits"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_digits")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"unit_amount"),max:this.safeNumber(a,"limit_max_amount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"executed_at");t=this.safeMarket(void 0,t);const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString2(e,"transaction_id","trade_id"),a=this.safeString(e,"maker_taker");let o;const d=this.safeString(e,"fee_amount_quote");d!==void 0&&(o={currency:t.quote,cost:d});const c=this.safeString(e,"order_id"),u=this.safeString(e,"type"),h=this.safeString(e,"side");return this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:r,order:c,type:u,side:h,takerOrMaker:a,price:i,amount:n,cost:void 0,fee:o,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTransactions(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"transactions",[]);return this.parseTrades(d,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"pairs",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),c=this.safeMarket(o).symbol;n[c]={info:a,symbol:c,maker:this.safeNumber(a,"maker_fee_rate_quote"),taker:this.safeNumber(a,"taker_fee_rate_quote"),percentage:!0,tierBased:!1}}return n}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(s===void 0){i===void 0&&(i=1e3);const f=this.parseTimeframe(t);s=this.milliseconds()-f*1e3*i}await this.loadMarkets();const r=this.market(e),a={pair:r.id,candletype:this.timeframes[t],yyyymmdd:this.yyyymmdd(s,"")},o=await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"candlestick",[]),u=this.safeValue(c,0,{}),h=this.safeValue(u,"ohlcv",[]);return this.parseOHLCVs(h,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"assets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free_amount"),d.used=this.safeString(r,"locked_amount"),d.total=this.safeString(r,"onhand_amount"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAssets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={UNFILLED:"open",PARTIALLY_FILLED:"open",FULLY_FILLED:"closed",CANCELED_UNFILLED:"canceled",CANCELED_PARTIALLY_FILLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"pair");t=this.safeMarket(i,t);const n=this.safeInteger(e,"ordered_at"),r=this.safeString(e,"price"),a=this.safeString(e,"start_amount"),o=this.safeString(e,"executed_amount"),d=this.safeString(e,"remaining_amount"),c=this.safeString(e,"average_price"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeStringLower(e,"type"),f=this.safeStringLower(e,"side");return this.safeOrder({id:s,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:u,symbol:t.symbol,type:h,timeInForce:void 0,postOnly:void 0,side:f,price:r,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:c,amount:a,filled:o,remaining:d,trades:void 0,fee:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,amount:this.amountToPrecision(e,i),side:s,type:t};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostUserSpotOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privatePostUserSpotCancelOrder(this.extend(n,s));return this.safeValue(r,"data")}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privateGetUserSpotOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=s),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privateGetUserSpotActiveOrders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.count=s),t!==void 0&&(n.since=parseInt(t/1e3));const a=await this.privateGetUserSpotTradeHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset:s.id},n=await this.privateGetUserWithdrawalAccount(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"accounts",[]),o=this.safeValue(a,0,{}),d=this.safeString(o,"address");return{currency:s,address:d,tag:void 0,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),!("uuid"in n))throw new Uf(this.id+" uuid is required for withdrawal");await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"txid");return t=this.safeCurrency(void 0,t),{id:s,txid:s,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.implodeHostname(this.urls.api[t])+"/";if(t==="public"||t==="markets")o+=this.implodeParams(e,i),Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d;o+=this.version+"/"+this.implodeParams(e,i),s==="POST"?(r=this.json(a),c+=r):(c+="/"+this.version+"/"+e,Object.keys(a).length&&(a=this.urlencode(a),o+="?"+a,c+="?"+a)),n={"Content-Type":"application/json","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(c),this.encode(this.secret))}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeInteger(a,"success"),u=this.safeValue(a,"data");if(!c||!u){const h={1e4:"URL does not exist",10001:"A system error occurred. Please contact support",10002:"Invalid JSON format. Please check the contents of transmission",10003:"A system error occurred. Please contact support",10005:"A timeout error occurred. Please wait for a while and try again",20001:"API authentication failed",20002:"Illegal API key",20003:"API key does not exist",20004:"API Nonce does not exist",20005:"API signature does not exist",20011:"Two-step verification failed",20014:"SMS authentication failed",30001:"Please specify the order quantity",30006:"Please specify the order ID",30007:"Please specify the order ID array",30009:"Please specify the stock",30012:"Please specify the order price",30013:"Trade Please specify either",30015:"Please specify the order type",30016:"Please specify asset name",30019:"Please specify uuid",30039:"Please specify the amount to be withdrawn",40001:"The order quantity is invalid",40006:"Count value is invalid",40007:"End time is invalid",40008:"end_id Value is invalid",40009:"The from_id value is invalid",40013:"The order ID is invalid",40014:"The order ID array is invalid",40015:"Too many specified orders",40017:"Incorrect issue name",40020:"The order price is invalid",40021:"The trading classification is invalid",40022:"Start date is invalid",40024:"The order type is invalid",40025:"Incorrect asset name",40028:"uuid is invalid",40048:"The amount of withdrawal is illegal",50003:"Currently, this account is in a state where you can not perform the operation you specified. Please contact support",50004:"Currently, this account is temporarily registered. Please try again after registering your account",50005:"Currently, this account is locked. Please contact support",50006:"Currently, this account is locked. Please contact support",50008:"User identification has not been completed",50009:"Your order does not exist",50010:"Can not cancel specified order",50011:"API not found",60001:"The number of possessions is insufficient",60002:"It exceeds the quantity upper limit of the tender buying order",60003:"The specified quantity exceeds the limit",60004:"The specified quantity is below the threshold",60005:"The specified price is above the limit",60006:"The specified price is below the lower limit",70001:"A system error occurred. Please contact support",70002:"A system error occurred. Please contact support",70003:"A system error occurred. Please contact support",70004:"We are unable to accept orders as the transaction is currently suspended",70005:"Order can not be accepted because purchase order is currently suspended",70006:"We can not accept orders because we are currently unsubscribed ",70009:"We are currently temporarily restricting orders to be carried out. Please use the limit order.",70010:"We are temporarily raising the minimum order quantity as the system load is now rising."},f=this.exceptions,l=this.safeString(u,"code"),m=this.safeString(h,l,"Error"),g=this.safeValue(f,l);throw g!==void 0?new g(m):new Uf(this.id+" "+this.json(a))}}};const RV=re,{InvalidNonce:Ay,InsufficientFunds:By,AuthenticationError:Wf,InvalidOrder:Dn,ExchangeError:on,OrderNotFound:FV,AccountSuspended:HV,BadSymbol:GV,OrderImmediatelyFillable:UV,RateLimitExceeded:$V,OnMaintenance:WV,PermissionDenied:zV}=Q,{TICK_SIZE:jV}=ne,Ny=ae;var oT=class extends RV{describe(){return this.deepExtend(super.describe(),{id:"zonda",name:"Zonda",countries:["EE"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchWithdrawal:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","3d":"259200","1w":"604800"},hostname:"zonda.exchange",urls:{referral:"https://auth.zondaglobal.com/ref/jHlbB4mIkdS1",logo:"https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg",www:"https://zondaglobal.com",api:{public:"https://{hostname}/API/Public",private:"https://{hostname}/API/Trading/tradingApi.php",v1_01Public:"https://api.{hostname}/rest",v1_01Private:"https://api.{hostname}/rest"},doc:["https://docs.zonda.exchange/","https://github.com/BitBayNet/API"],support:"https://zondaglobal.com/en/helpdesk/zonda-exchange",fees:"https://zondaglobal.com/legal/zonda-exchange/fees"},api:{public:{get:["{id}/all","{id}/market","{id}/orderbook","{id}/ticker","{id}/trades"]},private:{post:["info","trade","cancel","orderbook","orders","transfer","withdraw","history","transactions"]},v1_01Public:{get:["trading/ticker","trading/ticker/{symbol}","trading/stats","trading/stats/{symbol}","trading/orderbook/{symbol}","trading/transactions/{symbol}","trading/candle/history/{symbol}/{resolution}"]},v1_01Private:{get:["api_payments/deposits/crypto/addresses","payments/withdrawal/{detailId}","payments/deposit/{detailId}","trading/offer","trading/stop/offer","trading/config/{symbol}","trading/history/transactions","balances/BITBAY/history","balances/BITBAY/balance","fiat_cantor/rate/{baseId}/{quoteId}","fiat_cantor/history"],post:["trading/offer/{symbol}","trading/stop/offer/{symbol}","trading/config/{symbol}","balances/BITBAY/balance","balances/BITBAY/balance/transfer/{source}/{destination}","fiat_cantor/exchange"],delete:["trading/offer/{symbol}/{id}/{side}/{price}","trading/stop/offer/{symbol}/{id}/{side}/{price}"],put:["balances/BITBAY/balance/{id}"]}},fees:{trading:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.001"),percentage:!0,tierBased:!1},fiat:{maker:this.parseNumber("0.0030"),taker:this.parseNumber("0.0043"),percentage:!0,tierBased:!0,tiers:{taker:[[this.parseNumber("0.0043"),this.parseNumber("0")],[this.parseNumber("0.0042"),this.parseNumber("1250")],[this.parseNumber("0.0041"),this.parseNumber("3750")],[this.parseNumber("0.0040"),this.parseNumber("7500")],[this.parseNumber("0.0039"),this.parseNumber("10000")],[this.parseNumber("0.0038"),this.parseNumber("15000")],[this.parseNumber("0.0037"),this.parseNumber("20000")],[this.parseNumber("0.0036"),this.parseNumber("25000")],[this.parseNumber("0.0035"),this.parseNumber("37500")],[this.parseNumber("0.0034"),this.parseNumber("50000")],[this.parseNumber("0.0033"),this.parseNumber("75000")],[this.parseNumber("0.0032"),this.parseNumber("100000")],[this.parseNumber("0.0031"),this.parseNumber("150000")],[this.parseNumber("0.0030"),this.parseNumber("200000")],[this.parseNumber("0.0029"),this.parseNumber("250000")],[this.parseNumber("0.0028"),this.parseNumber("375000")],[this.parseNumber("0.0027"),this.parseNumber("500000")],[this.parseNumber("0.0026"),this.parseNumber("625000")],[this.parseNumber("0.0025"),this.parseNumber("875000")]],maker:[[this.parseNumber("0.0030"),this.parseNumber("0")],[this.parseNumber("0.0029"),this.parseNumber("1250")],[this.parseNumber("0.0028"),this.parseNumber("3750")],[this.parseNumber("0.0028"),this.parseNumber("7500")],[this.parseNumber("0.0027"),this.parseNumber("10000")],[this.parseNumber("0.0026"),this.parseNumber("15000")],[this.parseNumber("0.0025"),this.parseNumber("20000")],[this.parseNumber("0.0025"),this.parseNumber("25000")],[this.parseNumber("0.0024"),this.parseNumber("37500")],[this.parseNumber("0.0023"),this.parseNumber("50000")],[this.parseNumber("0.0023"),this.parseNumber("75000")],[this.parseNumber("0.0022"),this.parseNumber("100000")],[this.parseNumber("0.0021"),this.parseNumber("150000")],[this.parseNumber("0.0021"),this.parseNumber("200000")],[this.parseNumber("0.0020"),this.parseNumber("250000")],[this.parseNumber("0.0019"),this.parseNumber("375000")],[this.parseNumber("0.0018"),this.parseNumber("500000")],[this.parseNumber("0.0018"),this.parseNumber("625000")],[this.parseNumber("0.0017"),this.parseNumber("875000")]]}},funding:{withdraw:{}}},options:{fiatCurrencies:["EUR","USD","GBP","PLN"],transfer:{fillResponseFromRequest:!0}},precisionMode:jV,exceptions:{400:on,401:Dn,402:Dn,403:Dn,404:Dn,405:Dn,406:By,408:Dn,501:Wf,502:Wf,503:Ay,504:on,505:Wf,506:HV,509:on,510:GV,FUNDS_NOT_SUFFICIENT:By,OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS:Dn,OFFER_NOT_FOUND:FV,OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED:UV,ACTION_LIMIT_EXCEEDED:$V,UNDER_MAINTENANCE:WV,REQUEST_TIMESTAMP_TOO_OLD:Ay,PERMISSIONS_NOT_SUFFICIENT:zV,INVALID_STOP_RATE:Dn},commonCurrencies:{GGC:"Global Game Coin"}})}async fetchMarkets(e={}){const t=await this.v1_01PublicGetTradingTicker(e),s=this.safeValue(this.options,"fiatCurrencies",[]),i=[],n=this.safeValue(t,"items",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeValue(d,"market",{}),u=this.safeValue(c,"first",{}),h=this.safeValue(c,"second",{}),f=this.safeString(u,"currency"),l=this.safeString(h,"currency"),m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l);let y=this.safeValue(this.fees,"trading",{});(this.inArray(m,s)||this.inArray(g,s))&&(y=this.safeValue(this.fees,"fiat",{})),i.push({id:o,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:f,quoteId:l,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(y,"taker"),maker:this.safeNumber(y,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(h,"scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minOffer"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"minOffer"),max:void 0}},info:d})}return i}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.v1_01PrivateGetTradingOffer(this.extend(n,i)),a=this.safeValue(r,"items",[]);return this.parseOrders(a,void 0,t,s,{status:"open"})}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"time"),r=this.safeString(e,"startAmount"),a=this.safeString(e,"currentAmount"),o=this.safeValue(e,"postOnly");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,info:e,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:void 0,symbol:i,type:this.safeString(e,"mode"),timeInForce:void 0,postOnly:o,side:this.safeStringLower(e,"offerType"),price:this.safeString(e,"rate"),stopPrice:void 0,triggerPrice:void 0,amount:r,cost:void 0,filled:void 0,remaining:a,average:void 0,fee:void 0,trades:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e){const c=[this.marketId(e)];e=this.symbol(e),n.markets=c}const r={query:this.json(this.extend(n,i))},a=await this.v1_01PrivateGetTradingHistoryTransactions(r),o=this.safeValue(a,"items"),d=this.parseTrades(o,void 0,t,s);return e===void 0?d:this.filterBySymbol(d,e)}parseBalance(e){const t=this.safeValue(e,"balances");if(t===void 0)throw new on(this.id+" empty balance response "+this.json(e));const s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"lockedFunds"),o.free=this.safeString(n,"availableFunds"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1_01PrivateGetBalancesBITBAYBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1_01PublicGetTradingOrderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"buy",[]),o=this.safeValue(r,"sell",[]),d=this.safeInteger(r,"timestamp");return{symbol:i.symbol,bids:this.parseBidsAsks(a,"ra","ca"),asks:this.parseBidsAsks(o,"ra","ca"),timestamp:d,datetime:this.iso8601(d),nonce:this.safeInteger(r,"seqNo")}}parseTicker(e,t=void 0){const s=this.safeString(e,"r24h"),i=this.safeString(e,"h"),n=this.safeString(e,"l"),r=this.safeString(e,"v"),a=this.safeString(e,"m");t=this.safeMarket(a,t,"-");const o=t.symbol;return this.safeTicker({symbol:o,timestamp:void 0,datetime:void 0,high:i,low:n,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:s,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1_01PublicGetTradingStatsSymbol(this.extend(i,t)),r=this.safeValue(n,"stats");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PublicGetTradingStats(t),i=this.safeValue(s,"items");return this.parseTickers(i,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=[];if(e!==void 0){const d=this.currency(e);n.push(d.id)}let r={balanceCurrencies:n};t!==void 0&&(r.fromTime=t),s!==void 0&&(r.limit=s),r=this.extend(r,i);const o=(await this.v1_01PrivateGetBalancesBITBAYHistory({query:this.json(r)})).items;return this.parseLedger(o,void 0,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"balance",{}),n=this.safeString(i,"currency"),r=this.safeValue(e,"change",{});let a=this.safeString(r,"total"),o="in";Ny.stringLt(a,"0")&&(o="out",a=Ny.stringNeg(a));const d=this.safeValue(e,"fundsBefore",{}),c=this.safeValue(e,"fundsAfter",{});return{info:e,id:this.safeString(e,"historyId"),direction:o,account:void 0,referenceId:this.safeString(e,"detailId"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:this.safeCurrencyCode(n),amount:a,before:this.safeNumber(d,"total"),after:this.safeNumber(c,"total"),status:"ok",timestamp:s,datetime:this.iso8601(s),fee:void 0}}parseLedgerEntryType(e){const t={ADD_FUNDS:"transaction",BITCOIN_GOLD_FORK:"transaction",CREATE_BALANCE:"transaction",FUNDS_MIGRATION:"transaction",WITHDRAWAL_LOCK_FUNDS:"transaction",WITHDRAWAL_SUBTRACT_FUNDS:"transaction",WITHDRAWAL_UNLOCK_FUNDS:"transaction",TRANSACTION_COMMISSION_OUTCOME:"fee",TRANSACTION_COMMISSION_RETURN:"fee",TRANSACTION_OFFER_ABORTED_RETURN:"trade",TRANSACTION_OFFER_COMPLETED_RETURN:"trade",TRANSACTION_POST_INCOME:"trade",TRANSACTION_POST_OUTCOME:"trade",TRANSACTION_PRE_LOCKING:"trade"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,1,{});return[this.safeInteger(e,0),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.baseId+"-"+r.quoteId,resolution:this.timeframes[t]};i===void 0&&(i=100);const d=this.parseTimeframe(t),c=i*d*1e3;s===void 0?(o.to=this.milliseconds(),o.from=o.to-c):(o.from=parseInt(s),o.to=this.sum(o.from,c));const u=await this.v1_01PublicGetTradingCandleHistorySymbolResolution(this.extend(o,n)),h=this.safeValue(u,"items",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"time","t"),i=this.safeStringLower2(e,"userAction","ty"),n=this.safeValue(e,"wasTaker");let r;n!==void 0&&(r=n?"taker":"maker");const a=this.safeString2(e,"rate","r"),o=this.safeString2(e,"amount","a"),d=this.safeString(e,"commissionValue"),c=this.safeString(e,"market");t=this.safeMarket(c,t,"-");const u=t.symbol;let h;d!==void 0&&(h={currency:i==="buy"?t.base:t.quote,cost:d});const f=this.safeString(e,"offerId");let l;return f!==void 0&&(l=f?"limit":"market"),this.safeTrade({id:this.safeString(e,"id"),order:f,timestamp:s,datetime:this.iso8601(s),symbol:u,type:l,side:i,price:a,amount:o,cost:void 0,takerOrMaker:r,fee:h,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbol:n.baseId+"-"+n.quoteId};t!==void 0&&(a.fromTime=t-1),s!==void 0&&(a.limit=s);const o=await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(a,i)),d=this.safeValue(o,"items");return this.parseTrades(d,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.baseId+"-"+a.quoteId;i=parseFloat(this.amountToPrecision(e,i));const d={symbol:o,offerType:s.toUpperCase(),amount:i},c=this.safeValue2(r,"stopPrice","stopLossPrice"),u=c!==void 0,h=t==="limit",f=t==="market",l=t==="stop-limit"||h&&u,m=t==="stop-market"||f&&u,g=l||m,y=g?"v1_01PrivatePostTradingStopOfferSymbol":"v1_01PrivatePostTradingOfferSymbol";if(h||l)d.rate=this.priceToPrecision(e,n),d.mode=l?"stop-limit":"limit";else if(f||m)d.mode=m?"stop-market":"market";else throw new on(this.id+" createOrder() invalid type");if(g){if(!u)throw new on(this.id+" createOrder() zonda requires `triggerPrice` or `stopPrice` parameter for stop-limit or stop-market orders");d.stopRate=this.priceToPrecision(e,c)}r=this.omit(r,["stopPrice","stopLossPrice"]);const w=await this[y](this.extend(d,r)),b=this.safeString2(w,"offerId","stopOfferId"),v=this.safeValue(w,"completed",!1)?"closed":"open",T=this.safeValue(w,"transactions");return this.safeOrder({id:b,info:w,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:v,symbol:e,type:t,side:s,price:n,amount:i,cost:void 0,filled:void 0,remaining:void 0,average:void 0,fee:void 0,trades:T,clientOrderId:void 0})}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i===void 0)throw new on(this.id+' cancelOrder() requires a `side` parameter ("buy" or "sell")');const n=this.safeValue(s,"price");if(n===void 0)throw new on(this.id+" cancelOrder() requires a `price` parameter (float or string)");await this.loadMarkets();const r=this.market(t),o={symbol:r.baseId+"-"+r.quoteId,id:e,side:i,price:n};return await this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(o,s))}isFiat(e){const t={USD:!0,EUR:!0,PLN:!0};return this.safeValue(t,e,!1)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"address");return this.checkAddress(i),{currency:this.safeCurrencyCode(s,t),address:i,tag:this.safeString(e,"tag"),network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseDepositAddress(a,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(t),i=this.safeValue(s,"data");return this.parseDepositAddresses(i,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={source:s,destination:i,currency:e,funds:this.currencyToPrecision(e,t)},o=await this.v1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t),d}parseTransfer(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeValue(e,"from",{}),n=this.safeString(i,"id"),r=this.safeValue(e,"to",{}),a=this.safeString(r,"id"),o=this.safeString(i,"currency");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(o,t),amount:void 0,fromAccount:n,toAccount:a,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={Ok:"ok",Fail:"failed"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();let r;const a=this.currency(e),o={currency:a.id,quantity:t};this.isFiat(e)?r="privatePostWithdraw":(r="privatePostTransfer",i!==void 0&&(s+="?dt="+i.toString()),o.address=s);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,a)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t]);if(t==="public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i)+".json",Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Private"){this.checkRequiredCredentials();const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i);const d=this.milliseconds().toString();let c;s!=="POST"?(Object.keys(o).length&&(a+="?"+this.urlencode(o)),c=this.apiKey+d):r===void 0&&(r=this.json(o),c=this.apiKey+d+r),n={"Request-Timestamp":d,"Operation-Id":this.uuid(),"API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(c),this.encode(this.secret),"sha512"),"Content-Type":"application/json"}}else this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,moment:this.nonce()},i)),n={"Content-Type":"application/x-www-form-urlencoded","API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(r),this.encode(this.secret),"sha512")};return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("code"in a){const c=this.safeString(a,"code"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new on(u)}else if("status"in a&&this.safeString(a,"status")==="Fail"){const u=this.safeValue(a,"errors"),h=this.id+" "+r;for(let f=0;f<u.length;f++){const l=u[f];this.throwExactlyMatchedException(this.exceptions,l,h)}throw new on(h)}}}};const KV=oT;var XV=class extends KV{describe(){return this.deepExtend(super.describe(),{id:"bitbay",alias:!0})}};const YV=re,{ExchangeError:vc,ArgumentsRequired:Or,InsufficientFunds:ZV,OrderNotFound:QV,BadRequest:JV,BadSymbol:eE}=Q,{TICK_SIZE:tE}=ne,sE=ae;var iE=class extends YV{describe(){return this.deepExtend(super.describe(),{id:"bitbns",name:"Bitbns",countries:["IN"],rateLimit:1e3,certified:!1,pro:!1,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!1},timeframes:{},hostname:"bitbns.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/117201933-e7a6e780-adf5-11eb-9d80-98fc2a21c3d6.jpg",api:{www:"https://{hostname}",v1:"https://api.{hostname}/api/trade/v1",v2:"https://api.{hostname}/api/trade/v2"},www:"https://bitbns.com",referral:"https://ref.bitbns.com/1090961",doc:["https://bitbns.com/trade/#/api-trading/"],fees:"https://bitbns.com/fees"},api:{www:{get:["order/fetchMarkets","order/fetchTickers","order/fetchOrderbook","order/getTickerWithVolume","exchangeData/ohlc","exchangeData/orderBook","exchangeData/tradedetails"]},v1:{get:["platform/status","tickers","orderbook/sell/{symbol}","orderbook/buy/{symbol}"],post:["currentCoinBalance/EVERYTHING","getApiUsageStatus/USAGE","getOrderSocketToken/USAGE","currentCoinBalance/{symbol}","orderStatus/{symbol}","depositHistory/{symbol}","withdrawHistory/{symbol}","withdrawHistoryAll/{symbol}","depositHistoryAll/{symbol}","listOpenOrders/{symbol}","listOpenStopOrders/{symbol}","getCoinAddress/{symbol}","placeSellOrder/{symbol}","placeBuyOrder/{symbol}","buyStopLoss/{symbol}","sellStopLoss/{symbol}","placeSellOrder/{symbol}","cancelOrder/{symbol}","cancelStopLossOrder/{symbol}","listExecutedOrders/{symbol}","placeMarketOrder/{symbol}","placeMarketOrderQnty/{symbol}"]},v2:{post:["orders","cancel","getordersnew","marginOrders"]}},fees:{trading:{feeSide:"quote",tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")}},precisionMode:tE,exceptions:{exact:{400:JV,409:eE,416:ZV,417:QV},broad:{}}})}async fetchStatus(e={}){const t=await this.v1GetPlatformStatus(e),s=this.safeString(t,"status");return{status:this.safeString({1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.wwwGetOrderFetchMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"base"),o=this.safeString(n,"quote"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeValue(n,"precision",{}),h=this.safeValue(n,"limits",{}),f=this.safeValue(h,"amount",{}),l=this.safeValue(h,"price",{}),m=this.safeValue(h,"cost",{}),y=o==="USDT"?a+"_"+o:a;s.push({id:r,uppercaseId:y,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(u,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(f,"min"),max:this.safeNumber(f,"max")},price:{min:this.safeNumber(l,"min"),max:this.safeNumber(l,"max")},cost:{min:this.safeNumber(m,"min"),max:this.safeNumber(m,"max")}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.wwwGetOrderFetchOrderbook(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"last");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidVolume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askVolume"),vwap:this.safeString(e,"vwap"),open:this.safeString(e,"open"),close:r,last:r,previousClose:this.safeString(e,"previousClose"),change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.wwwGetOrderFetchTickers(t);return this.parseTickers(s,e)}parseBalance(e){const s={info:e,timestamp:void 0,datetime:this.iso8601(void 0)},i=this.safeValue(e,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("availableorder");if(o.length>1){let c=this.safeString(o,1);c==="Money"&&(c="INR");const u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(i,a),h.used=this.safeString(i,"inorder"+c),s[u]=h}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PostCurrentCoinBalanceEVERYTHING(e);return this.parseBalance(t)}parseOrderStatus(e){const t={0:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","entry_id"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"time")),a=this.safeString(e,"rate"),o=this.safeString2(e,"amount","btc"),d=this.safeString(e,"filled"),c=this.safeString(e,"remaining"),u=this.safeString(e,"avg_cost"),h=this.safeString(e,"cost");let f=this.safeStringLower(e,"type");f==="0"&&(f="limit");const l=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeStringLower(e,"side"),g=this.safeNumber(e,"fee");let y;return g!==void 0&&(y={cost:g,currency:void 0}),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:f,timeInForce:void 0,postOnly:void 0,side:m,price:a,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:h,average:u,filled:d,remaining:c,status:l,fee:y,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit"&&t!=="market")throw new vc(this.id+" allows limit and market orders only");await this.loadMarkets();const a=this.market(e),o={side:s.toUpperCase(),symbol:a.uppercaseId,quantity:this.amountToPrecision(e,i)};let d="v2PostOrders";if(t==="limit")o.rate=this.priceToPrecision(e,n);else if(t==="market")d="v1PostPlaceMarketOrderQntySymbol",o.market=a.quoteId;else throw new vc(this.id+" allows limit and market orders only");const c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Or(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.quoteId==="USDT"?"usdtcancelOrder":"cancelOrder",r={entry_id:e,symbol:i.uppercaseId,side:n},a=await this.v2PostCancel(this.extend(r,s));return this.parseOrder(a,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Or(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,entry_id:e},r=await this.v1PostOrderStatusSymbol(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Or(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.quoteId==="USDT"?"usdtListOpenOrders":"listOpenOrders",a={symbol:n.uppercaseId,side:r,page:0},o=await this.v2PostGetordersnew(this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString2(e,"id","tradeId");let i=this.parse8601(this.safeString(e,"date"));i=this.safeInteger(e,"timestamp",i);const n=this.safeString2(e,"rate","price");let r=this.safeString(e,"amount"),a=this.safeStringLower(e,"type");a!==void 0&&(a.indexOf("buy")>=0?a="buy":a.indexOf("sell")>=0&&(a="sell"));const o=this.safeString(e,"factor");let d;o!==void 0?r=sE.stringDiv(r,o):(r=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume"));const c=t.symbol;let u;const h=this.safeString(e,"fee");if(h!==void 0){const f=t.quote;u={cost:h,currency:f}}return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,id:s,order:s,type:void 0,side:a,takerOrMaker:void 0,price:n,amount:r,cost:d,fee:u},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Or(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id,page:0};t!==void 0&&(r.since=this.iso8601(t));const a=await this.v1PostListExecutedOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Or(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin:n.baseId,market:n.quoteId},a=await this.wwwGetExchangeDataTradedetails(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Or(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostDepositHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Or(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostWithdrawHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"unit"),i=this.safeCurrencyCode(s,t),n=this.parse8601(this.safeString2(e,"date","timestamp"));let r=this.safeString(e,"type");const a=this.safeString(e,"expTime","");let o;r!==void 0&&(r.indexOf("deposit")>=0?(r="deposit",o="ok"):(r.indexOf("withdraw")>=0||a.indexOf("withdraw")>=0)&&(r="withdrawal"));const d=this.safeNumber(e,"amount"),c=this.safeNumber(e,"fee");let u;return c!==void 0&&(u={currency:i,cost:c}),{info:e,id:void 0,txid:void 0,timestamp:n,datetime:this.iso8601(n),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:r,amount:d,currency:i,status:o,updated:void 0,internal:void 0,fee:u}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.v1PostGetCoinAddressSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"token"),o=this.safeString(r,"tag");return this.checkAddress(a),{currency:e,address:a,tag:o,network:void 0,info:n}}nonce(){return this.milliseconds()}sign(e,t="www",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new vc(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");t!=="www"&&(this.checkRequiredCredentials(),n={"X-BITBNS-APIKEY":this.apiKey});let o=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e)),c=this.nonce().toString();if(s==="GET")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(s==="POST"){Object.keys(d).length?r=this.json(d):r="{}";const u={timeStamp_nonce:c,body:r},h=this.stringToBase64(this.json(u)),f=this.hmac(h,this.encode(this.secret),"sha512");n["X-BITBNS-PAYLOAD"]=this.decode(h),n["X-BITBNS-SIGNATURE"]=f,n["Content-Type"]="application/x-www-form-urlencoded"}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"msg");if(c!==void 0&&c!=="200"&&c!=="204"||u!==void 0){const f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,f),this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwBroadlyMatchedException(this.exceptions.broad,u,f),new vc(f)}}};const nE=Ph;var dT=class extends nE{describe(){return this.deepExtend(super.describe(),{id:"fmfwio",name:"FMFW.io",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/159177712-b685b40c-5269-4cea-ac83-f7894c49525d.jpg",api:{public:"https://api.fmfw.io",private:"https://api.fmfw.io"},www:"https://fmfw.io",doc:"https://api.fmfw.io/api/2/explore/",fees:"https://fmfw.io/fees-and-limits",referral:"https://fmfw.io/referral/da948b21d6c92d69"},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}}})}};const rE=dT;var aE=class extends rE{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",alias:!0})}};const oE=re,{NotSupported:dE,RateLimitExceeded:Vy,AuthenticationError:Ey,PermissionDenied:cE,ArgumentsRequired:qy,ExchangeError:Ir,ExchangeNotAvailable:Ly,InsufficientFunds:zf,InvalidOrder:Vo,OrderNotFound:Ry,InvalidNonce:uE,BadSymbol:hE}=Q,{SIGNIFICANT_DIGITS:fE,DECIMAL_PLACES:Dy,TRUNCATE:Fy,ROUND:lE}=ne,Hy=ae;var cT=class extends oE{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:["VG"],version:"v1",rateLimit:666.666,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v2:"https://api-pub.bitfinex.com",public:"https://api.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",referral:"https://www.bitfinex.com/?refcode=P61eYxFL",doc:["https://docs.bitfinex.com/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:{"platform/status":3,tickers:1,"ticker/{symbol}":1,"tickers/hist":1,"trades/{symbol}/hist":1,"book/{symbol}/{precision}":.375,"book/{symbol}/P0":.375,"book/{symbol}/P1":.375,"book/{symbol}/P2":.375,"book/{symbol}/P3":.375,"book/{symbol}/R0":.375,"stats1/{key}:{size}:{symbol}:{side}/{section}":1,"stats1/{key}:{size}:{symbol}/{section}":1,"stats1/{key}:{size}:{symbol}:long/last":1,"stats1/{key}:{size}:{symbol}:long/hist":1,"stats1/{key}:{size}:{symbol}:short/last":1,"stats1/{key}:{size}:{symbol}:short/hist":1,"candles/trade:{timeframe}:{symbol}/{section}":1,"candles/trade:{timeframe}:{symbol}/last":1,"candles/trade:{timeframe}:{symbol}/hist":1}},public:{get:{"book/{symbol}":1,"lendbook/{currency}":6,"lends/{currency}":3,"pubticker/{symbol}":3,"stats/{symbol}":6,symbols:18,symbols_details:18,tickers:1,"trades/{symbol}":3}},private:{post:{account_fees:18,account_infos:6,balances:9.036,basket_manage:6,credits:6,"deposit/new":18,"funding/close":6,history:6,"history/movements":6,key_info:6,margin_infos:3,mytrades:3,mytrades_funding:6,"offer/cancel":6,"offer/new":6,"offer/status":6,offers:6,"offers/hist":90.03,"order/cancel":.2,"order/cancel/all":.2,"order/cancel/multi":.2,"order/cancel/replace":.2,"order/new":.2,"order/new/multi":.2,"order/status":.2,orders:.2,"orders/hist":90.03,"position/claim":18,"position/close":18,positions:18,summary:18,taken_funds:6,total_taken_funds:6,transfer:18,unused_taken_funds:6,withdraw:18}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,deposit:{},withdraw:{}}},commonCurrencies:{ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",UST:"USDT",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"},exceptions:{exact:{temporarily_unavailable:Ly,"Order could not be cancelled.":Ry,"No such order found.":Ry,"Order price must be positive.":Vo,"Could not find a key matching the given X-BFX-APIKEY.":Ey,'Key price should be a decimal number, e.g. "123.456"':Vo,'Key amount should be a decimal number, e.g. "123.456"':Vo,ERR_RATE_LIMIT:Vy,Ratelimit:Vy,"Nonce is too small.":uE,"No summary found.":Ir,"Cannot evaluate your available balance, please try again":Ly,"Unknown symbol":hE,"Cannot complete transfer. Exchange balance insufficient.":zf,"Momentary balance check. Please wait few seconds and try the transfer again.":Ir},broad:{"Invalid X-BFX-SIGNATURE":Ey,"This API key does not have permission":cE,"not enough exchange balance for ":zf,"minimum size for ":Vo,"Invalid order":Vo,"The available balance is only":zf}},precisionMode:fE,options:{currencyNames:{AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bab",BCI:"bci",BFT:"bft",BSV:"bsv",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",COMP:"comp",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LEO:"let",LINK:"link",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STORJ:"stj",TNB:"tnb",TRX:"trx",TUSD:"tsd",USD:"wire",USDC:"udc",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx",XTZ:"xtz"},orderTypes:{limit:"exchange limit",market:"exchange market"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CNH:"CNH"},accountsByType:{spot:"exchange",margin:"trading",funding:"deposit",swap:"trading"}}})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostAccountFees(t),n=this.safeValue(i,"withdraw"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o);e!==void 0&&!this.inArray(d,e)||(s[d]={withdraw:this.safeNumber(n,o),deposit:{},info:this.safeNumber(n,o)})}return s}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAccountFees(t),i=this.safeValue(s,"withdraw");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFee(e,t=void 0){return{withdraw:{fee:this.parseNumber(e),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{},info:e}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeNumber(t,"maker_fee"),r=this.safeNumber(t,"taker_fee"),a=this.safeNumber(t,"maker_fee_2fiat"),o=this.safeNumber(t,"taker_fee_2fiat"),d=this.safeNumber(t,"maker_fee_2deriv"),c=this.safeNumber(t,"taker_fee_2deriv");for(let u=0;u<this.symbols.length;u++){const h=this.symbols[u],f=this.market(h),l={info:t,symbol:h,percentage:!0,tierBased:!0};f.quote in i?(l.maker=a,l.taker=o):f.contract?(l.maker=d,l.taker=c):(l.maker=n,l.taker=r),s[h]=l}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(),s=await this.publicGetSymbolsDetails(),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"pair");if(!this.inArray(a,t))continue;a=a.toUpperCase();let o,d;if(a.indexOf(":")>=0){const l=a.split(":");o=l[0],d=l[1]}else o=a.slice(0,3),d=a.slice(3,6);const c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u;let f="spot";a.indexOf("F0")>-1&&(f="swap"),i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:f,spot:f==="spot",margin:this.safeValue(r,"margin"),swap:f==="swap",future:!1,option:!1,active:!0,contract:f==="swap",linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:this.safeInteger(r,"price_precision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_order_size"),max:this.safeNumber(r,"maximum_order_size")},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}amountToPrecision(e,t){return e=this.safeSymbol(e),this.decimalToPrecision(t,Fy,this.markets[e].precision.amount,Dy)}priceToPrecision(e,t){return e=this.safeSymbol(e),t=this.decimalToPrecision(t,lE,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,Fy,8,Dy)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"accountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new Ir(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=this.omit(e,"type"),r=await this.privatePostBalances(n),a={info:r},o=s==="derivatives";for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"type"),h=this.safeStringLower(c,"currency",""),f=h.length-2,l=h.slice(f)==="f0";if(i===u&&(!o||l)){const g=this.safeCurrencyCode(h);if(!(g in a)){const y=this.account();y.free=this.safeString(c,"available"),y.total=this.safeString(c,"amount"),a[g]=y}}}return this.safeBalance(a)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"accountsByType",{}),a=this.safeString(r,s,s),o=this.safeString(r,i,i),d=this.currency(e),c=this.convertDerivativesId(d.id,s),u=this.convertDerivativesId(d.id,i),h=this.currencyToPrecision(e,t),f={amount:h,currency:c,currency_to:u,walletfrom:a,walletto:o},l=await this.privatePostTransfer(this.extend(f,n)),m=this.safeValue(l,0);if(this.safeString(m,"message")===void 0)throw new Ir(this.id+" transfer failed");return this.extend(this.parseTransfer(m,d),{fromAccount:s,toAccount:i,amount:this.parseNumber(h)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{info:e,id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString(e,"status"))}}parseTransferStatus(e){const t={SUCCESS:"ok"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=e.length-2,i=e.slice(s)==="F0";return t!=="derivatives"&&t!=="trading"&&t!=="margin"&&i?e=e.slice(0,s):t==="derivatives"&&!i&&(e=e+"F0"),e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetBookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetPubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(t,"pair");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeString(e,"last_price");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"mid"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"tid"),i=this.safeTimestamp(e,"timestamp"),n=void 0,r=this.safeStringLower(e,"type"),a=this.safeString(e,"order_id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;if("fee_amount"in e){const u=Hy.stringNeg(this.safeString(e,"fee_amount")),h=this.safeString(e,"fee_currency"),f=this.safeCurrencyCode(h);c={cost:u,currency:f}}return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,order:a,side:r,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,limit_trades:s};t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qy(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostMytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(r,"postOnly",!1);t=t.toLowerCase(),r=this.omit(r,["postOnly"]),a.spot&&(t=this.safeStringLower(this.options.orderTypes,t,t));const d={symbol:a.id,side:s,amount:this.amountToPrecision(e,i),type:t,ocoorder:!1,buy_price_oco:0,sell_price_oco:0};t.indexOf("market")>-1?d.price=this.nonce().toString():d.price=this.priceToPrecision(e,n),o&&(d.is_postonly=!0);const c=await this.privatePostOrderNew(this.extend(d,r));return this.parseOrder(c,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={order_id:parseInt(e)};r!==void 0&&(o.price=this.priceToPrecision(t,r)),n!==void 0&&(o.amount=this.numberToString(n)),t!==void 0&&(o.symbol=this.marketId(t)),i!==void 0&&(o.side=i),s!==void 0&&(o.type=this.safeString(this.options.orderTypes,s,s));const d=await this.privatePostOrderCancelReplace(this.extend(o,a));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostOrderCancel(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.privatePostOrderCancelAll(t)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeValue(e,"is_live"),n=this.safeValue(e,"is_cancelled");let r;i?r="open":n?r="canceled":r="closed";const a=this.safeStringUpper(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString(e,"type","");d.indexOf("exchange ")>=0&&(d=e.type.split(" ")[1]);const u=this.safeTimestamp(e,"timestamp"),h=this.safeString(e,"id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:o,type:d,timeInForce:void 0,postOnly:void 0,side:s,price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,average:this.safeString(e,"avg_execution_price"),amount:this.safeString(e,"original_amount"),remaining:this.safeString(e,"remaining_amount"),filled:this.safeString(e,"executed_amount"),status:r,fee:void 0,cost:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e!==void 0&&!(e in this.markets))throw new Ir(this.id+" has no symbol "+e);const n=await this.privatePostOrders(i);let r=this.parseOrders(n,void 0,t,s);return e!==void 0&&(r=this.filterBy(r,"symbol",e)),r}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostOrdersHist(this.extend(n,i));let a=this.parseOrders(r,void 0,t,s);return e!==void 0&&(a=this.filterBy(a,"symbol",e)),a=this.filterByArray(a,"status",["closed","canceled"],!1),a}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrder(n)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=100);const r=this.market(e),o={symbol:"t"+r.id,timeframe:this.timeframes[t],sort:1,limit:i};s!==void 0&&(o.start=s);const d=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new dE(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){await this.loadMarkets();const s={renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},n=await this.privatePostDepositNew(this.extend(i,t));let r=this.safeValue(n,"address"),a;return"address_pool"in n&&(a=r,r=n.address_pool),this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n=this.safeString(i,"currency");const r=this.omit(i,"currency");let a;if(n===void 0){if(e===void 0)throw new qy(this.id+" fetchTransactions() requires a currency `code` argument or a `currency` parameter");a=this.currency(e),n=a.id}r.currency=n,t!==void 0&&(r.since=parseInt(t/1e3));const o=await this.privatePostHistoryMovements(this.extend(r,i));return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp_created"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t);let r=this.safeString(e,"fee");return r!==void 0&&(r=Hy.stringAbs(r)),{info:e,id:this.safeString2(e,"id","withdrawal_id"),txid:this.safeString(e,"txid"),type:this.safeStringLower(e,"type"),currency:n,network:void 0,amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:s,datetime:this.iso8601(s),address:this.safeString(e,"address"),addressFrom:void 0,addressTo:void 0,tag:this.safeString(e,"description"),tagFrom:void 0,tagTo:void 0,updated:this.safeTimestamp(e,"timestamp"),comment:void 0,fee:{currency:n,cost:this.parseNumber(r),rate:void 0}}}parseTransactionStatus(e){const t={SENDING:"pending",CANCELED:"canceled",ZEROCONFIRMED:"failed",COMPLETED:"ok"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.getCurrencyName(e),a=this.currency(e),o={withdraw_type:r,walletselected:"exchange",amount:this.numberToString(t),address:s};i!==void 0&&(o.payment_id=i);const d=await this.privatePostWithdraw(this.extend(o,n)),c=this.safeValue(d,0,{}),u=this.safeNumber(c,"withdrawal_id"),h=this.safeString(c,"message"),f=this.findBroadlyMatchedKey(this.exceptions.broad,h);if(u===0){if(f!==void 0){const l=this.exceptions.broad[f];throw new l(this.id+" "+h)}throw new Ir(this.id+" withdraw returned an id of zero: "+this.json(c))}return this.parseTransaction(c,a)}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);t==="v2"?a="/"+t+a:a="/"+this.version+a;let o=this.omit(i,this.extractParams(e)),d=this.urls.api[t]+a;if((t==="public"||e.indexOf("/hist")>=0)&&Object.keys(o).length){const c="?"+this.urlencode(o);d+=c,a+=c}if(t==="private"){this.checkRequiredCredentials();const c=this.nonce();o=this.extend({nonce:c.toString(),request:a},o),r=this.json(o);const u=this.stringToBase64(r),h=this.encode(this.secret),f=this.hmac(u,h,"sha384");n={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":this.decode(u),"X-BFX-SIGNATURE":f,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;let c=!1;if(e>=400)r[0]==="{"&&(c=!0);else{const u=this.safeValue(a,0,{});this.safeString(u,"status","")==="error"&&(c=!0)}if(c){const u=this.id+" "+r,h=this.safeString2(a,"message","error");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new Ir(u)}}};const pE=re,{ExchangeError:xr,InvalidAddress:mE,ArgumentsRequired:Eo,InsufficientFunds:Gy,AuthenticationError:gE,OrderNotFound:jf,InvalidOrder:Tc,BadRequest:yE,InvalidNonce:wE,BadSymbol:bE,OnMaintenance:kE,NotSupported:Uy,PermissionDenied:SE,ExchangeNotAvailable:vE}=Q,oi=ae,{SIGNIFICANT_DIGITS:TE,DECIMAL_PLACES:$y,TRUNCATE:Wy,ROUND:OE}=ne;var uT=class extends pE{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex",countries:["VG"],version:"v2",certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchClosedOrder:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTickers:!0,fetchTime:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:250,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v1:"https://api.bitfinex.com",public:"https://api-pub.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v2/docs/","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{public:{get:{"conf/{config}":2.66,"conf/pub:{action}:{object}":2.66,"conf/pub:{action}:{object}:{detail}":2.66,"conf/pub:map:{object}":2.66,"conf/pub:map:{object}:{detail}":2.66,"conf/pub:map:currency:{detail}":2.66,"conf/pub:map:currency:sym":2.66,"conf/pub:map:currency:label":2.66,"conf/pub:map:currency:unit":2.66,"conf/pub:map:currency:undl":2.66,"conf/pub:map:currency:pool":2.66,"conf/pub:map:currency:explorer":2.66,"conf/pub:map:currency:tx:fee":2.66,"conf/pub:map:tx:method":2.66,"conf/pub:list:{object}":2.66,"conf/pub:list:{object}:{detail}":2.66,"conf/pub:list:currency":2.66,"conf/pub:list:pair:exchange":2.66,"conf/pub:list:pair:margin":2.66,"conf/pub:list:pair:futures":2.66,"conf/pub:list:competitions":2.66,"conf/pub:info:{object}":2.66,"conf/pub:info:{object}:{detail}":2.66,"conf/pub:info:pair":2.66,"conf/pub:info:pair:futures":2.66,"conf/pub:info:tx:status":2.66,"conf/pub:fees":2.66,"platform/status":8,tickers:2.66,"ticker/{symbol}":2.66,"tickers/hist":2.66,"trades/{symbol}/hist":2.66,"book/{symbol}/{precision}":1,"book/{symbol}/P0":1,"book/{symbol}/P1":1,"book/{symbol}/P2":1,"book/{symbol}/P3":1,"book/{symbol}/R0":1,"stats1/{key}:{size}:{symbol}:{side}/{section}":2.66,"stats1/{key}:{size}:{symbol}:{side}/last":2.66,"stats1/{key}:{size}:{symbol}:{side}/hist":2.66,"stats1/{key}:{size}:{symbol}/{section}":2.66,"stats1/{key}:{size}:{symbol}/last":2.66,"stats1/{key}:{size}:{symbol}/hist":2.66,"stats1/{key}:{size}:{symbol}:long/last":2.66,"stats1/{key}:{size}:{symbol}:long/hist":2.66,"stats1/{key}:{size}:{symbol}:short/last":2.66,"stats1/{key}:{size}:{symbol}:short/hist":2.66,"candles/trade:{timeframe}:{symbol}:{period}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/last":2.66,"candles/trade:{timeframe}:{symbol}/hist":2.66,"status/{type}":2.66,"status/deriv":2.66,"liquidations/hist":80,"rankings/{key}:{timeframe}:{symbol}/{section}":2.66,"rankings/{key}:{timeframe}:{symbol}/hist":2.66,"pulse/hist":2.66,"pulse/profile/{nickname}":2.66,"funding/stats/{symbol}/hist":10},post:{"calc/trade/avg":2.66,"calc/fx":2.66}},private:{post:{"auth/r/wallets":2.66,"auth/r/wallets/hist":2.66,"auth/r/orders":2.66,"auth/r/orders/{symbol}":2.66,"auth/w/order/submit":2.66,"auth/w/order/update":2.66,"auth/w/order/cancel":2.66,"auth/w/order/multi":2.66,"auth/w/order/cancel/multi":2.66,"auth/r/orders/{symbol}/hist":2.66,"auth/r/orders/hist":2.66,"auth/r/order/{symbol}:{id}/trades":2.66,"auth/r/trades/{symbol}/hist":2.66,"auth/r/trades/hist":2.66,"auth/r/ledgers/{currency}/hist":2.66,"auth/r/ledgers/hist":2.66,"auth/r/info/margin/{key}":2.66,"auth/r/info/margin/base":2.66,"auth/r/info/margin/sym_all":2.66,"auth/r/positions":2.66,"auth/w/position/claim":2.66,"auth/w/position/increase:":2.66,"auth/r/position/increase/info":2.66,"auth/r/positions/hist":2.66,"auth/r/positions/audit":2.66,"auth/r/positions/snap":2.66,"auth/w/deriv/collateral/set":2.66,"auth/w/deriv/collateral/limits":2.66,"auth/r/funding/offers":2.66,"auth/r/funding/offers/{symbol}":2.66,"auth/w/funding/offer/submit":2.66,"auth/w/funding/offer/cancel":2.66,"auth/w/funding/offer/cancel/all":2.66,"auth/w/funding/close":2.66,"auth/w/funding/auto":2.66,"auth/w/funding/keep":2.66,"auth/r/funding/offers/{symbol}/hist":2.66,"auth/r/funding/offers/hist":2.66,"auth/r/funding/loans":2.66,"auth/r/funding/loans/hist":2.66,"auth/r/funding/loans/{symbol}":2.66,"auth/r/funding/loans/{symbol}/hist":2.66,"auth/r/funding/credits":2.66,"auth/r/funding/credits/hist":2.66,"auth/r/funding/credits/{symbol}":2.66,"auth/r/funding/credits/{symbol}/hist":2.66,"auth/r/funding/trades/{symbol}/hist":2.66,"auth/r/funding/trades/hist":2.66,"auth/r/info/funding/{key}":2.66,"auth/r/info/user":2.66,"auth/r/summary":2.66,"auth/r/logins/hist":2.66,"auth/r/permissions":2.66,"auth/w/token":2.66,"auth/r/audit/hist":2.66,"auth/w/transfer":2.66,"auth/w/deposit/address":24,"auth/w/deposit/invoice":24,"auth/w/withdraw":24,"auth/r/movements/{currency}/hist":2.66,"auth/r/movements/hist":2.66,"auth/r/alerts":5.33,"auth/w/alert/set":2.66,"auth/w/alert/price:{symbol}:{price}/del":2.66,"auth/w/alert/{type}:{symbol}:{price}/del":2.66,"auth/calc/order/avail":2.66,"auth/w/settings/set":2.66,"auth/r/settings":2.66,"auth/w/settings/del":2.66,"auth/r/pulse/hist":2.66,"auth/w/pulse/add":16,"auth/w/pulse/del":2.66}}},fees:{trading:{feeSide:"get",percentage:!0,tierBased:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{withdraw:{}}},precisionMode:TE,options:{precision:"R0",exchangeTypes:{"EXCHANGE MARKET":"market","EXCHANGE LIMIT":"limit","EXCHANGE STOP":"market","EXCHANGE FOK":"limit","EXCHANGE STOP LIMIT":"limit","EXCHANGE IOC":"limit"},orderTypes:{market:"EXCHANGE MARKET",limit:"EXCHANGE LIMIT"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CHN:"CHN"},v2AccountsByType:{spot:"exchange",exchange:"exchange",funding:"funding",margin:"margin",derivatives:"margin",future:"margin"}},exceptions:{exact:{10001:SE,10020:yE,10100:gE,10114:wE,20060:kE,temporarily_unavailable:vE},broad:{address:mE,"available balance is only":Gy,"not enough exchange balance":Gy,"Order not found":jf,"symbol: invalid":bE,"Invalid order":Tc}},commonCurrencies:{UST:"USDT",EUTF0:"EURT",USTF0:"USDT",ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"}})}isFiat(e){return e in this.options.fiat}getCurrencyId(e){return"f"+e}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new Uy(this.id+" "+e+" not supported for withdrawal")}amountToPrecision(e,t){return e=this.safeSymbol(e),this.decimalToPrecision(t,Wy,this.markets[e].precision.amount,$y)}priceToPrecision(e,t){return e=this.safeSymbol(e),t=this.decimalToPrecision(t,OE,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,Wy,8,$y)}async fetchStatus(e={}){const t=await this.publicGetPlatformStatus(e),s=this.safeString(t,0);return{status:this.safeString({0:"maintenance",1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){let t=await this.publicGetConfPubInfoPair(e),s=await this.publicGetConfPubInfoPairFutures(e);t=this.safeValue(t,0,[]),s=this.safeValue(s,0,[]);const i=this.arrayConcat(t,s);let n=await this.publicGetConfPubListPairMargin(e);n=this.safeValue(n,0,[]);const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeStringUpper(o,0),c=this.safeValue(o,1,{});let u=!0;d.indexOf("F0")>=0&&(u=!1);const h=!u;let f,l;if(d.indexOf(":")>=0){const A=d.split(":");f=A[0],l=A[1]}else f=d.slice(0,3),l=d.slice(3,6);let m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l);const y=m.split("F0"),w=g.split("F0");m=this.safeString(y,0),g=this.safeString(w,0);let b=m+"/"+g;f=this.getCurrencyId(f),l=this.getCurrencyId(l);let S;h&&(S=g,b=b+":"+S);const v=this.safeString(c,3),T=this.safeString(c,4);let I=!1;this.inArray(d,n)&&(I=!0),r.push({id:"t"+d,symbol:b,base:m,quote:g,settle:S,baseId:f,quoteId:l,settleId:l,type:u?"spot":"swap",spot:u,margin:I,swap:h,future:!1,option:!1,active:!0,contract:h,linear:h?!0:void 0,inverse:h?!1:void 0,contractSize:h?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:parseInt("5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(v),max:this.parseNumber(T)},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:c})}return r}async fetchCurrencies(e={}){const i={config:["pub:list:currency","pub:map:currency:sym","pub:map:currency:label","pub:map:currency:unit","pub:map:currency:undl","pub:map:currency:pool","pub:map:currency:explorer","pub:map:currency:tx:fee","pub:map:tx:method"].join(",")},n=await this.publicGetConfConfig(this.extend(i,e)),r={sym:this.indexBy(this.safeValue(n,1,[]),0),label:this.indexBy(this.safeValue(n,2,[]),0),unit:this.indexBy(this.safeValue(n,3,[]),0),undl:this.indexBy(this.safeValue(n,4,[]),0),pool:this.indexBy(this.safeValue(n,5,[]),0),explorer:this.indexBy(this.safeValue(n,6,[]),0),fees:this.indexBy(this.safeValue(n,7,[]),0)},a=this.safeValue(n,0,[]),o={};for(let d=0;d<a.length;d++){const c=a[d];if(c.indexOf("F0")>=0)continue;const u=this.safeCurrencyCode(c),h=this.safeValue(r.label,c,[]),f=this.safeString(h,1),l=this.safeValue(r.pool,c,[]),m=this.safeString(l,1),g=this.safeValue(r.fees,c,[]),y=this.safeValue(g,1,[]),w=this.safeNumber(y,1),b=this.safeValue(r.undl,c,[]),S="8",v="f"+c;o[u]={id:v,uppercaseId:c,code:u,info:[c,h,l,g,b],type:m,name:f,active:!0,deposit:void 0,withdraw:void 0,fee:w,precision:parseInt(S),limits:{amount:{min:this.parseNumber(this.parsePrecision(S)),max:void 0},withdraw:{min:w,max:void 0}}};const T={},I=this.safeValue(n,8,[]),A=c.replace("F0","");for(let x=0;x<I.length;x++){const k=I[x],O=this.safeString(k,0);if(this.safeString(this.safeValue(k,1,[]),0)===A){const q=this.safeNetwork(O);T[q]={info:O,id:O.toLowerCase(),network:O,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}}Object.keys(T).length>0&&(o[u].networks=T)}return o}safeNetwork(e){const t={BITCOIN:"BTC",LITECOIN:"LTC",ETHEREUM:"ERC20",TETHERUSE:"ERC20",TETHERUSO:"OMNI",TETHERUSL:"LIQUID",TETHERUSX:"TRC20",TETHERUSS:"EOS",TETHERUSDTAVAX:"AVAX",TETHERUSDTSOL:"SOL",TETHERUSDTALG:"ALGO",TETHERUSDTBCH:"BCH",TETHERUSDTKSM:"KSM",TETHERUSDTDVF:"DVF",TETHERUSDTOMG:"OMG"};return this.safeString(t,e,e)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"v2AccountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new xr(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=s==="derivatives",r=this.omit(e,"type"),a=await this.privatePostAuthRWallets(r),o={info:a};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,0),h=this.safeStringLower(c,1,""),f=h.length-2,l=h.slice(f)==="f0";if(i===u&&(!n||l)){const g=this.safeCurrencyCode(h),y=this.account();y.total=this.safeString(c,2),y.free=this.safeString(c,4),o[g]=y}}return this.safeBalance(o)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"v2AccountsByType",{}),a=this.safeString(r,s);if(a===void 0){const g=Object.keys(r);throw new Eo(this.id+" transfer() fromAccount must be one of "+g.join(", "))}const o=this.safeString(r,i);if(o===void 0){const g=Object.keys(r);throw new Eo(this.id+" transfer() toAccount must be one of "+g.join(", "))}const d=this.currency(e),c=this.convertDerivativesId(d,s),u=this.convertDerivativesId(d,i),f={amount:this.currencyToPrecision(e,t),currency:c,currency_to:u,from:a,to:o},l=await this.privatePostAuthWTransfer(this.extend(f,n));if(this.safeString(l,0)==="error"){const g=this.safeString(l,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,g,this.id+" "+g),new xr(this.id+" "+g)}return this.parseTransfer(l,d)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,0),i=this.safeValue(e,4),n=this.safeString(i,1),r=this.safeString(i,2),a=this.safeString(i,5),o=this.safeString(e,6);return{id:void 0,timestamp:s,datetime:this.iso8601(s),status:this.parseTransferStatus(o),amount:this.safeNumber(i,7),currency:this.safeCurrencyCode(a,t),fromAccount:n,toAccount:r,info:e}}parseTransferStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=this.safeValue(e,"info"),i=this.safeString(s,0),n=this.safeValue(s,4,[]);let r;if(t==="derivatives"){r=this.safeString(n,0,i);const a=r.length-2;r.slice(a)==="F0"||(r=r+"F0")}else t!=="margin"?r=this.safeString(n,1,i):r=i;return r}async fetchOrder(e,t=void 0,s={}){throw new Uy(this.id+" fetchOrder() is not supported yet. Consider using fetchOpenOrder() or fetchClosedOrder() instead.")}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"precision","R0"),n=this.market(e),r={symbol:n.id,precision:i};t!==void 0&&(r.len=t);const a=this.extend(r,s),o=await this.publicGetBookSymbolPrecision(a),d=this.milliseconds(),c={symbol:n.symbol,bids:[],asks:[],timestamp:d,datetime:this.iso8601(d),nonce:void 0},u=a.precision==="R0"?1:0;for(let h=0;h<o.length;h++){const f=o[h],l=this.safeNumber(f,u),m=this.safeString(f,2),g=oi.stringAbs(m),y=oi.stringGt(m,"0")?"bids":"asks";c[y].push([l,this.parseNumber(g)])}return c.bids=this.sortBy(c.bids,0,!0),c.asks=this.sortBy(c.asks,0),c}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=e.length,r=this.safeString(e,n-4),a=this.safeString(e,n-5);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,n-2),low:this.safeString(e,n-1),bid:this.safeString(e,n-10),bidVolume:void 0,ask:this.safeString(e,n-8),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeString(e,n-6),percentage:oi.stringMul(a,"100"),average:void 0,baseVolume:this.safeString(e,n-3),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const r=this.marketIds(e);s.symbols=r.join(",")}else s.symbols="ALL";const i=await this.publicGetTickers(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,0),d=this.safeMarket(o),c=d.symbol;n[c]=this.parseTicker(a,d)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseSymbol(e){if(e===void 0)return e;e=e.replace("t","");let t,s;if(e.indexOf(":")>=0){const r=e.split(":");t=r[0],s=r[1]}else t=e.slice(0,3),s=e.slice(3,6);const i=this.safeCurrencyCode(t),n=this.safeCurrencyCode(s);return i+"/"+n}parseTrade(e,t=void 0){const i=e.length>5,n=this.safeString(e,0),r=i?4:2;let a,o=this.safeString(e,r);const d=i?5:3,c=this.safeString(e,d);o[0]==="-"?(a="sell",o=oi.stringAbs(o)):a="buy";let u,h,f,l,m;const g=i?2:1,y=this.safeInteger(e,g);if(i){const w=e[1];m=this.parseSymbol(w),u=this.safeString(e,3),h=this.safeInteger(e,8)===1?"maker":"taker";let S=this.safeString(e,9);S=oi.stringNeg(S);const v=this.safeString(e,10),T=this.safeCurrencyCode(v);l={cost:S,currency:T};const I=e[6];f=this.safeString(this.options.exchangeTypes,I)}return this.safeTrade({id:n,timestamp:y,datetime:this.iso8601(y),symbol:m,order:u,side:a,type:f,takerOrMaker:h,price:c,amount:o,cost:void 0,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="-1";const a={symbol:n.id};t!==void 0&&(a.start=t,r="1"),s!==void 0&&(a.limit=s),a.sort=r;const o=await this.publicGetTradesSymbolHist(this.extend(a,i)),d=this.sortBy(o,1);return this.parseTrades(d,n,void 0,s)}async fetchOHLCV(e,t="1m",s=void 0,i=100,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*i*1e3}const a={symbol:r.id,timeframe:this.timeframes[t],sort:1,start:s,limit:i},o=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}parseOrderStatus(e){if(e===void 0)return e;const t=e.split(" "),s=this.safeString(t,0),i={ACTIVE:"open",PARTIALLY:"open",EXECUTED:"closed",CANCELED:"canceled",INSUFFICIENT:"canceled","POSTONLY CANCELED":"canceled",RSN_DUST:"rejected",RSN_PAUSE:"rejected","IOC CANCELED":"canceled","FILLORKILL CANCELED":"canceled"};return this.safeString(i,s,e)}parseOrderFlags(e){const t={1024:["reduceOnly"],4096:["postOnly"],5120:["reduceOnly","postOnly"]};return this.safeValue(t,e,void 0)}parseTimeInForce(e){const t={"EXCHANGE IOC":"IOC","EXCHANGE FOK":"FOK",IOC:"IOC",FOK:"FOK"};return this.safeString(t,e,"GTC")}parseOrder(e,t=void 0){const s=this.safeString(e,0),i=this.safeString(e,3),n=this.parseSymbol(i),r=this.safeInteger(e,5),a=oi.stringAbs(this.safeString(e,6)),o=this.safeString(e,7),d=oi.stringAbs(o),c=oi.stringLt(o,"0")?"sell":"buy",u=this.safeString(e,8),h=this.safeString(this.safeValue(this.options,"exchangeTypes"),u),f=this.parseTimeInForce(u),l=this.safeString(e,12),m=this.parseOrderFlags(l);let g=!1;if(m!==void 0)for(let I=0;I<m.length;I++)m[I]==="postOnly"&&(g=!0);let y=this.safeString(e,16),w;(u==="EXCHANGE STOP"||u==="EXCHANGE STOP LIMIT")&&(y=void 0,w=this.safeNumber(e,16),u==="EXCHANGE STOP LIMIT"&&(y=this.safeString(e,19)));let b;const S=this.safeString(e,13);if(S!==void 0){const I=S.split(" @ ");b=this.parseOrderStatus(this.safeString(I,0))}const v=this.safeString(e,17),T=this.safeString(e,2);return this.safeOrder({info:e,id:s,clientOrderId:T,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:h,timeInForce:f,postOnly:g,side:c,price:y,stopPrice:w,triggerPrice:w,amount:d,cost:void 0,average:v,filled:void 0,remaining:a,status:b,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"orderTypes",{});let d=t.toUpperCase();a.spot&&(d=this.safeStringUpper(o,t,t));const c=this.safeString2(r,"stopPrice","triggerPrice"),u=this.safeString(r,"timeInForce"),h=this.safeValue(r,"postOnly",!1),f=this.safeValue(r,"reduceOnly",!1),l=this.safeValue2(r,"cid","clientOrderId");r=this.omit(r,["triggerPrice","stopPrice","timeInForce","postOnly","reduceOnly","price_aux_limit"]);let m=this.amountToPrecision(e,i);m=s==="buy"?m:oi.stringNeg(m);const g={type:d,symbol:a.id,amount:m},y=d==="EXCHANGE STOP LIMIT"||d==="EXCHANGE LIMIT"&&c!==void 0,w=d==="EXCHANGE STOP",b=d==="EXCHANGE MARKET",S=w||b&&c!==void 0,v=d==="EXCHANGE IOC"||u==="IOC",T=d==="EXCHANGE FOK"||u==="FOK",I=h||u==="PO";if((v||T)&&n===void 0)throw new Tc(this.id+" createOrder() requires a price argument with IOC and FOK orders");if((v||T)&&b)throw new Tc(this.id+" createOrder() does not allow market IOC and FOK orders");d!=="MARKET"&&!b&&!w&&(g.price=this.priceToPrecision(e,n)),(y||S)&&(g.price=this.priceToPrecision(e,c),S?g.type="EXCHANGE STOP":y&&(g.type="EXCHANGE STOP LIMIT",g.price_aux_limit=this.priceToPrecision(e,n))),v?g.type="EXCHANGE IOC":T&&(g.type="EXCHANGE FOK");let A=0;I&&(A=this.sum(A,4096)),f&&(A=this.sum(A,1024)),A!==0&&(g.flags=A),l!==void 0&&(g.cid=l,r=this.omit(r,["cid","clientOrderId"]));const N=await this.privatePostAuthWOrderSubmit(this.extend(g,r));if(this.safeString(N,6)!=="SUCCESS"){const O=N[5],P=N[7];throw new xr(this.id+" "+N[6]+": "+P+" (#"+O+")")}const x=this.safeValue(N,4,[]),k=this.safeValue(x,0);return this.parseOrder(k,a)}async cancelAllOrders(e=void 0,t={}){const s={all:1},i=await this.privatePostAuthWOrderCancelMulti(this.extend(s,t)),n=this.safeValue(i,4,[]);return this.parseOrders(n)}async cancelOrder(e,t=void 0,s={}){const i=this.safeValue2(s,"cid","clientOrderId");let n;if(i!==void 0){const o=this.safeValue(s,"cidDate");if(o===void 0)throw new Tc(this.id+" canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')");n={cid:i,cid_date:o},s=this.omit(s,["cid","clientOrderId"])}else n={id:parseInt(e)};const r=await this.privatePostAuthWOrderCancel(this.extend(n,s)),a=this.safeValue(r,4);return this.parseOrder(a)}async fetchOpenOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchOpenOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new jf(this.id+" order "+e+" not found");return r}async fetchClosedOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchClosedOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new jf(this.id+" order "+e+" not found");return r}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;return e===void 0?a=await this.privatePostAuthROrders(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbol(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);let r,a;return e===void 0?a=await this.privatePostAuthROrdersHist(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbolHist(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Eo(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),o={id:parseInt(e),symbol:r.id},d=await this.privatePostAuthROrderSymbolIdTrades(this.extend(o,n));return this.parseTrades(d,r,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={end:this.milliseconds()};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);let a="privatePostAuthRTradesHist";e!==void 0&&(n=this.market(e),r.symbol=n.id,a="privatePostAuthRTradesSymbolHist");const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s={op_renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"network",e),n=this.safeValue(s,"networks",{}),r=this.safeValue(n,i),a=this.safeString(r,"id");if(a===void 0)throw new Eo(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const o=this.safeString(t,"wallet","exchange");t=this.omit(t,"network","wallet");const d={method:a,wallet:o,op_renew:0},c=await this.privatePostAuthWDepositAddress(this.extend(d,t)),u=this.safeValue(c,4,[]),h=this.safeString(u,5),f=h===void 0?this.safeString(u,4):h,l=h===void 0?void 0:this.safeString(u,4);return this.checkAddress(f),{currency:e,address:f,tag:l,network:void 0,info:c}}parseTransactionStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed",CANCELED:"canceled",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=e.length;let i,n,r,a,o,d,c,u,h,f,l,m,g;if(s===8){const y=this.safeValue(e,4,[]);i=this.safeInteger(e,0),t!==void 0&&(r=t.code),h=this.safeString(y,8),h!==void 0&&(h=oi.stringAbs(h)),a=this.safeNumber(y,5),o=this.safeValue(y,0),d="ok",o===0&&(o=void 0,d="failed"),c=this.safeString(y,3),u="withdrawal"}else if(s===22){o=this.safeString(e,0);const y=this.safeString(e,1);r=this.safeCurrencyCode(y,t);const w=this.safeString(e,2);m=this.safeNetwork(w),i=this.safeInteger(e,5),n=this.safeInteger(e,6),d=this.parseTransactionStatus(this.safeString(e,9));const b=this.safeString(e,12);a=oi.stringAbs(b),b!==void 0&&(oi.stringLt(b,"0")?u="withdrawal":u="deposit"),h=this.safeString(e,13),h!==void 0&&(h=oi.stringAbs(h)),l=this.safeString(e,16),f=this.safeString(e,20),g=this.safeString(e,21)}return{info:e,id:o,txid:f,type:u,currency:r,network:m,amount:this.parseNumber(a),status:d,timestamp:i,datetime:this.iso8601(i),address:l,addressFrom:void 0,addressTo:l,tag:c,tagFrom:void 0,tagTo:c,updated:n,comment:g,fee:{currency:r,cost:this.parseNumber(h),rate:void 0}}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostAuthRSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeValue(t,4,[]),r=this.safeValue(n,0,[]),a=this.safeValue(n,1,[]),o=this.safeNumber(r,0),d=this.safeNumber(r,2),c=this.safeNumber(r,5),u=this.safeNumber(a,0),h=this.safeNumber(a,2),f=this.safeNumber(a,5);for(let l=0;l<this.symbols.length;l++){const m=this.symbols[l],g=this.market(m),y={info:t,symbol:m,percentage:!0,tierBased:!0};g.quote in i?(y.maker=d,y.taker=h):g.contract?(y.maker=c,y.taker=f):(y.maker=o,y.taker=u),s[m]=y}return s}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};let a="privatePostAuthRMovementsHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRMovementsCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeString(n,"network",e);n=this.omit(n,"network");const o=this.safeValue(r,"networks",{}),d=this.safeValue(o,a),c=this.safeString(d,"id");if(c===void 0)throw new Eo(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const u=this.safeString(n,"wallet","exchange");n=this.omit(n,"network","wallet");const h={method:c,wallet:u,amount:this.numberToString(t),address:s};i!==void 0&&(h.payment_id=i);const f=await this.privatePostAuthWWithdraw(this.extend(h,n));if(this.safeString(f,0)==="error"){const y=this.id+" "+f,w=this.safeString(f,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,w,y),this.throwBroadlyMatchedException(this.exceptions.broad,w,y),new xr(y)}const m=this.safeString(f,7);m!=="success"&&this.throwBroadlyMatchedException(this.exceptions.broad,m,m);const g=this.parseTransaction(f,r);return this.extend(g,{address:s})}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostAuthRPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));t==="v1"?a=t+a:a=this.version+a;let d=this.urls.api[t]+"/"+a;if(t==="public"&&Object.keys(o).length&&(d+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();r=this.json(o);const u="/api/"+a+c+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha384");n={"bfx-nonce":c,"bfx-apikey":this.apiKey,"bfx-signature":h,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(!Array.isArray(a)){const c=this.safeString2(a,"message","error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new xr(this.id+" "+r)}}else if(a==="")throw new xr(this.id+" returned empty response");if(e===500){const c=this.numberToString(a[1]),u=a[2],h=this.id+" "+u;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new xr(this.id+" "+u+" (#"+c+")")}return a}parseLedgerEntryType(e){if(e!==void 0)return e.indexOf("fee")>=0||e.indexOf("charged")>=0?"fee":e.indexOf("exchange")>=0||e.indexOf("position")>=0?"trade":e.indexOf("rebate")>=0?"rebate":e.indexOf("deposit")>=0||e.indexOf("withdrawal")>=0?"transaction":e.indexOf("transfer")>=0?"transfer":e.indexOf("payment")>=0?"payout":e}parseLedgerEntry(e,t=void 0){let s;const i=this.safeString(e,0),n=this.safeString(e,1),r=this.safeCurrencyCode(n,t),a=this.safeInteger(e,3),o=this.safeNumber(e,5),d=this.safeNumber(e,6),c=this.safeString(e,8);if(c!==void 0){const u=c.split(" @ "),h=this.safeStringLower(u,0);s=this.parseLedgerEntryType(h)}return{id:i,direction:void 0,account:void 0,referenceId:i,referenceAccount:void 0,type:s,currency:r,amount:o,timestamp:a,datetime:this.iso8601(a),before:void 0,after:d,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadMarkets();let n;const r={};let a="privatePostAuthRLedgersHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRLedgersCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseLedger(o,n,t,s)}};const IE=re,{ExchangeError:xE,ArgumentsRequired:qo,OrderNotFound:_E}=Q,{TICK_SIZE:CE}=ne;var ME=class extends IE{describe(){return this.deepExtend(super.describe(),{id:"bitflyer",name:"bitFlyer",countries:["JP"],version:"v1",rateLimit:1e3,hostname:"bitflyer.com",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:"emulated",fetchOrder:"emulated",fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!0,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg",api:{rest:"https://api.{hostname}"},www:"https://bitflyer.com",doc:"https://lightning.bitflyer.com/docs?lang=en"},api:{public:{get:["getmarkets/usa","getmarkets/eu","getmarkets","getboard","getticker","getexecutions","gethealth","getboardstate","getchats"]},private:{get:["getpermissions","getbalance","getbalancehistory","getcollateral","getcollateralhistory","getcollateralaccounts","getaddresses","getcoinins","getcoinouts","getbankaccounts","getdeposits","getwithdrawals","getchildorders","getparentorders","getparentorder","getexecutions","getpositions","gettradingcommission"],post:["sendcoin","withdraw","sendchildorder","cancelchildorder","sendparentorder","cancelparentorder","cancelallchildorders"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:CE})}parseExpiryDate(e){const t=e.slice(0,2),s=e.slice(2,5),i=e.slice(5,9),n={JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},r=this.safeString(n,s);return this.parse8601(i+"-"+r+"-"+t+"T00:00:00Z")}async fetchMarkets(e={}){const t=await this.publicGetGetmarkets(e),s=await this.publicGetGetmarketsUsa(e),i=await this.publicGetGetmarketsEu(e);let n=this.arrayConcat(t,s);n=this.arrayConcat(n,i);const r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"product_code"),c=d.split("_"),u=this.safeString(o,"market_type"),h=u==="FX",f=u==="Futures",l=!h&&!f;let m="spot",g,y,w,b;if(l)y=this.safeString(c,0),w=this.safeString(c,1);else if(h)m="swap",y=this.safeString(c,1),w=this.safeString(c,2);else if(f){const B=this.safeString(o,"alias");if(B===void 0){y=d.slice(0,3),w=d.slice(3,6);const x=d.slice(-9);b=this.parseExpiryDate(x)}else{const x=B.split("_"),k=this.safeString(x,0);y=k.slice(0,-3),w=k.slice(-3);const O=d.split(k),P=this.safeString(O,1);b=this.parseExpiryDate(P)}m="future"}const S=this.safeCurrencyCode(y),v=this.safeCurrencyCode(w);let T=S+"/"+v,I=this.fees.trading.taker,A=this.fees.trading.maker;const N=h||f;N&&(A=0,I=0,g="JPY",T=T+":"+g,f&&(T=T+"-"+this.yymmdd(b))),r.push({id:d,symbol:T,base:S,quote:v,settle:g,baseId:y,quoteId:w,settleId:void 0,type:m,spot:l,margin:!1,swap:h,future:f,option:!1,active:!0,contract:N,linear:l?void 0:!0,inverse:l?void 0:!1,taker:I,maker:A,contractSize:void 0,expiry:b,expiryDatetime:this.iso8601(b),strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency_code"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"amount"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetbalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={product_code:i.id},r=await this.publicGetGetboard(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","size")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"ltp");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_by_product"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.publicGetGetticker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeStringLower(e,"side");s!==void 0&&s.length<1&&(s=void 0);let i;if(s!==void 0){const d=s+"_child_order_acceptance_id";d in e&&(i=e[d])}i===void 0&&(i=this.safeString(e,"child_order_acceptance_id"));const n=this.parse8601(this.safeString(e,"exec_date")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:i,type:void 0,side:s,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.privateGetGettradingcommission(this.extend(i,t)),r=this.safeNumber(n,"commission_rate");return{info:n,symbol:s.symbol,maker:r,taker:r}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a={product_code:this.marketId(e),child_order_type:t.toUpperCase(),side:s.toUpperCase(),price:n,size:i},o=await this.privatePostSendchildorder(this.extend(a,r)),d=this.safeString(o,"child_order_acceptance_id");return{info:o,id:d}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new qo(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const i={product_code:this.marketId(t),child_order_acceptance_id:e};return await this.privatePostCancelchildorder(this.extend(i,s))}parseOrderStatus(e){const t={ACTIVE:"open",COMPLETED:"closed",CANCELED:"canceled",EXPIRED:"canceled",REJECTED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"child_order_date")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=this.safeString(e,"executed_size"),a=this.safeString(e,"outstanding_size"),o=this.parseOrderStatus(this.safeString(e,"child_order_state")),d=this.safeStringLower(e,"child_order_type"),c=this.safeStringLower(e,"side"),u=this.safeString(e,"product_code"),h=this.safeSymbol(u,t);let f;const l=this.safeNumber(e,"total_commission");l!==void 0&&(f={cost:l,currency:void 0,rate:void 0});const m=this.safeString(e,"child_order_acceptance_id");return this.safeOrder({id:m,clientOrderId:void 0,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:h,type:d,timeInForce:void 0,postOnly:void 0,side:c,price:i,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:n,filled:r,remaining:a,fee:f,average:void 0,trades:void 0},t)}async fetchOrders(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new qo(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id,count:s},a=await this.privateGetGetchildorders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return e!==void 0&&(o=this.filterBy(o,"symbol",e)),o}async fetchOpenOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"ACTIVE"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"COMPLETED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new qo(this.id+" fetchOrder() requires a `symbol` argument");const i=await this.fetchOrders(t),n=this.indexBy(i,"id");if(e in n)return n[e];throw new _E(this.id+" No order found with id "+e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qo(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchPositions(e=void 0,t={}){if(e===void 0)throw new qo(this.id+" fetchPositions() requires a `symbols` argument, exactly one symbol in an array");await this.loadMarkets();const s={product_code:this.marketIds(e)};return await this.privateGetpositions(this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){if(this.checkAddress(s),await this.loadMarkets(),e!=="JPY"&&e!=="USD"&&e!=="EUR")throw new xE(this.id+" allows withdrawing JPY, USD, EUR only, "+e+" is not supported");const r=this.currency(e),a={currency_code:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinins(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinouts(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseDepositStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","message_id"),i=this.safeString(e,"address"),n=this.safeString(e,"currency_code"),r=this.safeCurrencyCode(n,t),a=this.parse8601(this.safeString(e,"event_date")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"tx_hash"),c=this.safeString(e,"status");let u,h,f;if("fee"in e){u="withdrawal",h=this.parseWithdrawalStatus(c);const l=this.safeNumber(e,"fee"),m=this.safeNumber(e,"additional_fee");f={currency:r,cost:l+m}}else u="deposit",h=this.parseDepositStatus(c);return{info:e,id:s,txid:d,timestamp:a,datetime:this.iso8601(a),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:o,currency:r,status:h,updated:void 0,internal:void 0,fee:f}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/";t==="private"&&(a+="me/"),a+=e,s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.implodeHostname(this.urls.api.rest)+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");Object.keys(i).length&&s!=="GET"&&(r=this.json(i),u+=r),n={"ACCESS-KEY":this.apiKey,"ACCESS-TIMESTAMP":c,"ACCESS-SIGN":this.hmac(this.encode(u),this.encode(this.secret)),"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}};const PE=re,{ExchangeError:AE,ArgumentsRequired:zy,AuthenticationError:jy,OrderNotFound:Ky,InsufficientFunds:BE,DDoSProtection:NE,PermissionDenied:VE,BadSymbol:Xy,InvalidOrder:Yy}=Q,{TICK_SIZE:EE}=ne;var qE=class extends PE{describe(){return this.deepExtend(super.describe(),{id:"bitforex",name:"Bitforex",countries:["CN"],rateLimit:500,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!1,option:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295553-1160ec00-c50e-11ea-8ea0-df79276a9646.jpg",api:{rest:"https://api.bitforex.com"},www:"https://www.bitforex.com",doc:"https://github.com/githubdev2020/API_Doc_en/wiki",fees:"https://help.bitforex.com/en_us/?cat=13",referral:"https://www.bitforex.com/en/invitationRegister?inviterId=1867438"},api:{public:{get:{"api/v1/market/symbols":20,"api/v1/market/ticker":4,"api/v1/market/ticker-all":4,"api/v1/market/depth":4,"api/v1/market/depth-all":4,"api/v1/market/trades":20,"api/v1/market/kline":20}},private:{post:{"api/v1/fund/mainAccount":1,"api/v1/fund/allAccount":30,"api/v1/trade/placeOrder":1,"api/v1/trade/placeMultiOrder":10,"api/v1/trade/cancelOrder":1,"api/v1/trade/cancelMultiOrder":20,"api/v1/trade/cancelAllOrder":20,"api/v1/trade/orderInfo":1,"api/v1/trade/multiOrderInfo":10,"api/v1/trade/orderInfos":20}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!0,deposit:{},withdraw:{}}},commonCurrencies:{BKC:"Bank Coin",CAPP:"Crypto Application Token",CREDIT:"TerraCredit",CTC:"Culture Ticket Chain",EWT:"EcoWatt Token",IQ:"IQ.Cash",MIR:"MIR COIN",NOIA:"METANOIA",TON:"To The Moon"},precisionMode:EE,exceptions:{1e3:Ky,1003:Xy,1013:jy,1016:jy,1017:VE,1019:Xy,3002:BE,4002:Yy,4003:Yy,4004:Ky,10204:NE}})}async fetchMarkets(e={}){const s=(await this.publicGetApiV1MarketSymbols(e)).data,i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("-"),d=o[2],c=o[1],u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);i.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"time"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeInteger(e,"direction"),d=this.parseSide(o);return this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:d,price:r,amount:a,cost:void 0,order:n,fee:void 0,takerOrMaker:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={symbol:this.marketId(e)};s!==void 0&&(n.size=s);const r=this.market(e),a=await this.publicGetApiV1MarketTrades(this.extend(n,i));return this.parseTrades(a.data,r,t,s)}parseBalance(e){const t=e.data,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"frozen"),o.free=this.safeString(n,"active"),o.total=this.safeString(n,"fix"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostApiV1FundAllAccount(e);return this.parseBalance(t)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"date");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"last"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.markets[e],i={symbol:s.id},n=await this.publicGetApiV1MarketTickerAll(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"vol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,ktype:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.publicGetApiV1MarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetApiV1MarketDepthAll(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(r,"time");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return e in t?t[e]:e}parseSide(e){return e===1?"buy":e===2?"sell":void 0}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeNumber(e,"createTime"),n=this.safeNumber(e,"lastTime"),r=t.symbol,a=this.safeInteger(e,"tradeType"),o=this.parseSide(a),d=void 0,c=this.safeString(e,"orderPrice"),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"orderAmount"),f=this.safeString(e,"dealAmount"),l=this.parseOrderStatus(this.safeString(e,"orderState")),g=t[o==="buy"?"base":"quote"],y={cost:this.safeNumber(e,"tradeFee"),currency:g};return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:r,type:d,timeInForce:void 0,postOnly:void 0,side:o,price:c,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:u,amount:h,filled:f,remaining:void 0,status:l,fee:y,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:this.marketId(t),orderId:e},r=await this.privatePostApiV1TradeOrderInfo(this.extend(n,s));return this.parseOrder(r.data,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zy(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:0},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zy(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:1},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a;s==="buy"?a=1:s==="sell"&&(a=2);const d={symbol:this.market(e).id,price:n,amount:i,tradeType:a},c=await this.privatePostApiV1TradePlaceOrder(this.extend(d,r)),u=c.data;return{info:c,id:this.safeString(u,"orderId")}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};t!==void 0&&(i.symbol=this.marketId(t));const n=await this.privatePostApiV1TradeCancelOrder(this.extend(i,s)),r=n.success;return{info:n,success:r}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();let d=this.urlencode({accessKey:this.apiKey});o.nonce=this.milliseconds(),Object.keys(o).length&&(d+="&"+this.urlencode(this.keysort(o)));const c="/"+e+"?"+d,u=this.hmac(this.encode(c),this.encode(this.secret));r=d+"&signData="+u,n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(typeof r=="string"&&(r[0]==="{"||r[0]==="[")){const c=this.id+" "+r,u=this.safeValue(a,"success");if(u!==void 0&&!u){const h=this.safeString(a,"code");throw this.throwExactlyMatchedException(this.exceptions,h,c),new AE(c)}}}};const LE=re,{ExchangeError:W,ExchangeNotAvailable:Lo,NotSupported:RE,OnMaintenance:Kf,ArgumentsRequired:Dt,BadRequest:Se,AccountSuspended:Fn,InvalidAddress:Zy,PermissionDenied:Qe,DDoSProtection:Xf,InsufficientFunds:Qs,InvalidNonce:Ro,CancelPending:DE,InvalidOrder:te,OrderNotFound:Oc,AuthenticationError:Ke,RequestTimeout:Qy,BadSymbol:Tn,RateLimitExceeded:Yf}=Q,{TICK_SIZE:FE}=ne,it=ae;var hT=class extends LE{describe(){return this.deepExtend(super.describe(),{id:"bitget",name:"Bitget",countries:["SG"],version:"v1",rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:void 0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},hostname:"bitget.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg",api:{spot:"https://api.{hostname}",mix:"https://api.{hostname}"},www:"https://www.bitget.com",doc:["https://bitgetlimited.github.io/apidoc/en/mix","https://bitgetlimited.github.io/apidoc/en/spot","https://bitgetlimited.github.io/apidoc/en/broker"],fees:"https://www.bitget.cc/zh-CN/rate?tab=1",referral:"https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j"},api:{public:{spot:{get:{"public/time":1,"public/currencies":1,"public/products":1,"public/product":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/depth":1}},mix:{get:{"market/contracts":1,"market/depth":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/index":1,"market/funding-time":1,"market/history-fundRate":1,"market/current-fundRate":1,"market/open-interest":1,"market/mark-price":1,"market/symbol-leverage":1}}},private:{spot:{get:{"account/getInfo":20,"account/assets":2,"account/transferRecords":4,"wallet/deposit-address":4,"wallet/withdrawal-inner":4,"wallet/withdrawal-list":1,"wallet/deposit-list":1},post:{"account/bills":2,"account/sub-account-spot-assets":200,"trade/orders":2,"trade/batch-orders":4,"trade/cancel-order":2,"trade/cancel-batch-orders":4,"trade/orderInfo":1,"trade/open-orders":1,"trade/history":1,"trade/fills":1,"wallet/transfer":4,"wallet/withdrawal":4,"wallet/subTransfer":10}},mix:{get:{"account/account":2,"account/accounts":2,"account/open-count":1,"order/current":2,"order/history":2,"order/detail":2,"order/fills":2,"order/historyProductType":8,"order/allFills":2,"plan/currentPlan":2,"plan/historyPlan":2,"position/singlePosition":2,"position/allPosition":2,"trace/currentTrack":2,"trace/followerOrder":2,"trace/historyTrack":2,"trace/summary":2,"trace/profitSettleTokenIdGroup":2,"trace/profitDateGroupList":2,"trade/profitDateList":2,"trace/waitProfitDateList":2,"trace/traderSymbols":2,"order/marginCoinCurrent":2},post:{"account/setLeverage":8,"account/setMargin":8,"account/setMarginMode":8,"account/setPositionMode":8,"order/placeOrder":2,"order/batch-orders":2,"order/cancel-order":2,"order/cancel-all-orders":2,"order/cancel-batch-orders":2,"plan/placePlan":2,"plan/modifyPlan":2,"plan/modifyPlanPreset":2,"plan/placeTPSL":2,"plan/placePositionsTPSL":2,"plan/modifyTPSLPlan":2,"plan/cancelPlan":2,"plan/cancelAllPlan":2,"trace/closeTrackOrder":2,"trace/setUpCopySymbols":2}}}},fees:{spot:{taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")},swap:{taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0004")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:W,"failure to get a peer from the ring-balancer":Lo,4010:Qe,4001:W,4002:W,30001:Ke,30002:Ke,30003:Ke,30004:Ke,30005:Ro,30006:Ke,30007:Se,30008:Qy,30009:W,30010:Ke,30011:Qe,30012:Ke,30013:Ke,30014:Xf,30015:Ke,30016:W,30017:W,30018:W,30019:Lo,30020:Se,30021:Se,30022:Qe,30023:Se,30024:Tn,30025:Se,30026:Xf,30027:Ke,30028:Qe,30029:Fn,30030:W,30031:Se,30032:Tn,30033:Se,30034:W,30035:W,30036:W,30037:Lo,30038:Kf,32001:Fn,32002:Qe,32003:DE,32004:W,32005:te,32006:te,32007:te,32008:te,32009:te,32010:W,32011:W,32012:W,32013:W,32014:W,32015:W,32016:W,32017:W,32018:W,32019:W,32020:W,32021:W,32022:W,32023:W,32024:W,32025:W,32026:W,32027:W,32028:Fn,32029:W,32030:te,32031:Dt,32038:Ke,32040:W,32044:W,32045:W,32046:W,32047:W,32048:te,32049:W,32050:te,32051:te,32052:W,32053:W,32057:W,32054:W,32055:te,32056:W,32058:W,32059:te,32060:te,32061:te,32062:te,32063:te,32064:W,32065:W,32066:W,32067:W,32068:W,32069:W,32070:W,32071:W,32072:W,32073:W,32074:W,32075:W,32076:W,32077:W,32078:W,32079:W,32080:W,32083:W,33001:Qe,33002:Fn,33003:Qs,33004:W,33005:W,33006:W,33007:W,33008:Qs,33009:W,33010:W,33011:W,33012:W,33013:te,33014:Oc,33015:te,33016:W,33017:Qs,33018:W,33020:W,33021:Se,33022:te,33023:W,33024:te,33025:te,33026:W,33027:te,33028:te,33029:te,33034:W,33035:W,33036:W,33037:W,33038:W,33039:W,33040:W,33041:W,33042:W,33043:W,33044:W,33045:W,33046:W,33047:W,33048:W,33049:W,33050:W,33051:W,33059:Se,33060:Se,33061:W,33062:W,33063:W,33064:W,33065:W,21009:W,34001:Qe,34002:Zy,34003:W,34004:W,34005:W,34006:W,34007:W,34008:Qs,34009:W,34010:W,34011:W,34012:W,34013:W,34014:W,34015:W,34016:Qe,34017:Fn,34018:Ke,34019:Qe,34020:Qe,34021:Zy,34022:W,34023:Qe,34026:W,34036:W,34037:W,34038:W,34039:W,35001:W,35002:W,35003:W,35004:W,35005:Ke,35008:te,35010:te,35012:te,35014:te,35015:te,35017:W,35019:te,35020:te,35021:te,35022:W,35024:W,35025:Qs,35026:W,35029:Oc,35030:te,35031:te,35032:W,35037:W,35039:W,35040:te,35044:W,35046:Qs,35047:Qs,35048:W,35049:te,35050:te,35052:Qs,35053:W,35055:Qs,35057:W,35058:W,35059:Se,35060:Se,35061:Se,35062:te,35063:te,35064:te,35066:te,35067:te,35068:te,35069:te,35070:te,35071:te,35072:te,35073:te,35074:te,35075:te,35076:te,35077:te,35078:te,35079:te,35080:te,35081:te,35082:te,35083:te,35084:te,35085:te,35086:te,35087:te,35088:te,35089:te,35090:W,35091:W,35092:W,35093:W,35094:W,35095:Se,35096:W,35097:W,35098:W,35099:W,36001:Se,36002:Se,36005:W,36101:Ke,36102:Qe,36103:Fn,36104:Qe,36105:Qe,36106:Fn,36107:Qe,36108:Qs,36109:Qe,36201:Qe,36202:Qe,36203:te,36204:W,36205:Se,36206:Se,36207:te,36208:te,36209:te,36210:te,36211:te,36212:te,36213:te,36214:W,36216:Oc,36217:te,36218:te,36219:te,36220:te,36221:te,36222:te,36223:te,36224:te,36225:te,36226:te,36227:te,36228:te,36229:te,36230:te,400:Se,401:Ke,403:Qe,404:Se,405:Se,415:Se,429:Xf,500:Lo,1001:Yf,1002:W,1003:W,40001:Ke,40002:Ke,40003:Ke,40004:Ro,40005:Ro,40006:Ke,40007:Se,40008:Ro,40009:Ke,40010:Ke,40011:Ke,40012:Ke,40013:W,40014:Qe,40015:W,40016:Qe,40017:W,40018:Qe,40102:Se,40103:Se,40104:W,40105:W,40106:W,40107:W,40108:te,40109:Oc,40200:Kf,40201:te,40202:W,40203:Se,40204:Se,40205:Se,40206:Se,40207:Se,40208:Se,40209:Se,40300:W,40301:Qe,40302:Se,40303:Se,40304:Se,40305:Se,40306:W,40308:Kf,40309:Tn,40400:W,40401:W,40402:Se,40403:Se,40404:Se,40405:Se,40406:Se,40407:W,40408:W,40409:W,40500:te,40501:W,40502:W,40503:W,40504:W,40505:W,40506:Ke,40507:Ke,40508:W,40509:W,40600:W,40601:W,40602:W,40603:W,40604:Lo,40605:W,40606:W,40607:W,40608:W,40609:W,40700:Se,40701:W,40702:W,40703:W,40704:W,40705:Se,40706:te,40707:Se,40708:Se,40709:W,40710:W,40711:Qs,40712:Qs,40713:W,40714:W,45110:te,"invalid sign":Ke,"invalid currency":Tn,"invalid symbol":Tn,"invalid period":Se,"invalid user":W,"invalid amount":te,"invalid type":te,"invalid orderId":te,"invalid record":W,"invalid accountId":Se,"invalid address":Se,"accesskey not null":Ke,"illegal accesskey":Ke,"sign not null":Ke,"req_time is too much difference from server time":Ro,"permissions not right":Qe,"illegal sign invalid":Ke,"user locked":Fn,"Request Frequency Is Too High":Yf,"more than a daily rate of cash":Se,"more than the maximum daily withdrawal amount":Se,"need to bind email or mobile":W,"user forbid":Qe,"User Prohibited Cash Withdrawal":Qe,"Cash Withdrawal Is Less Than The Minimum Value":Se,"Cash Withdrawal Is More Than The Maximum Value":Se,"the account with in 24 hours ban coin":Qe,"order cancel fail":Se,"base symbol error":Tn,"base date error":W,"api signature not valid":Ke,"gateway internal error":W,"audit failed":W,"order queryorder invalid":Se,"market no need price":te,"limit need price":te,"userid not equal to account_id":W,"your balance is low":Qs,"address invalid cointype":W,"system exception":W,50003:W,50004:Tn,50006:Qe,50007:Qe,50008:Qy,50009:Yf,50010:W,50014:te,50015:te,50016:te,50017:te,50018:te,50019:te,50020:Qs,50021:te,50026:te,"invalid order query time":W,"invalid start time":Se,"invalid end time":Se,20003:W,"01001":W,43111:Qe},broad:{"invalid size, valid range":W}},precisionMode:FE,commonCurrencies:{JADE:"Jade Protocol"},options:{timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6Hutc","12h":"12Hutc","1d":"1Dutc","3d":"3Dutc","1w":"1Wutc","1M":"1Mutc"},swap:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6Hutc","12h":"12Hutc","1d":"1Dutc","3d":"3Dutc","1w":"1Wutc","1M":"1Mutc"}},fetchMarkets:["spot","swap"],defaultType:"spot",defaultSubType:"linear",createMarketBuyOrderRequiresPrice:!0,broker:"p4sve",withdraw:{fillResponseFromRequest:!0},sandboxMode:!1}})}setSandboxMode(e){this.options.sandboxMode=e}async fetchTime(e={}){const t=await this.publicSpotGetPublicTime(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=this.safeValue(this.options,"sandboxMode",!1);let s=this.safeValue(this.options,"fetchMarkets",["spot","swap"]);t&&(s=["swap"]);let i=[];for(let r=0;r<s.length;r++){const a=s[r];if(a==="swap"){let o;t?o=["sumcbl","sdmcbl","scmcbl"]:o=["umcbl","dmcbl","cmcbl"];for(let d=0;d<o.length;d++)i.push(this.fetchMarketsByType(a,this.extend(e,{productType:o[d]})))}else i.push(this.fetchMarketsByType(s[r],e))}i=await Promise.all(i);let n=i[0];for(let r=1;r<i.length;r++)n=this.arrayConcat(n,i[r]);return n}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quoteCoin"),i=this.safeString(e,"baseCoin"),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i),a=this.safeValue(e,"supportMarginCoins",[]),o=this.safeString(a,0),d=this.safeCurrencyCode(o);let c=r+"/"+n;const u=t.split("_"),h=this.safeString(u,1);let f,l=!1,m=!1,g=!1,y=!1,w,b,S,v,T,I;if(h==="SPBL")f="spot",m=!0,w=this.parseNumber(this.parsePrecision(this.safeString(e,"priceScale"))),b=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityScale")));else{const x=this.safeString(u,2);if(x!==void 0){const _="20"+x.slice(0,2),E=x.slice(2,4),U=x.slice(4,6);I=_+"-"+E+"-"+U+"T00:00:00Z",T=this.parse8601(I),f="future",g=!0,c=c+":"+d+"-"+x}else f="swap",l=!0,c=c+":"+d;y=!0,S=h==="UMCBL"||h==="CMCBL"||h==="SUMCBL"||h==="SCMCBL",v=!S;const k=this.safeInteger(e,"pricePlace"),O=this.safeInteger(e,"volumePlace"),P=this.safeString(e,"priceEndStep"),q=this.safeString(e,"minTradeNum"),L=new it(P);L.decimals=Math.max(L.decimals,k),L.reduce();const D=L.toString();w=this.parseNumber(D);const H=new it(q);H.decimals=Math.max(H.decimals,O),H.reduce();const R=H.toString();b=this.parseNumber(R)}const A=this.safeString(e,"status");let N;A!==void 0&&(N=A==="online");let B;return n==="USDT"&&(B=this.safeNumber(e,"minTradeUSDT")),{id:t,symbol:c,base:r,quote:n,settle:d,baseId:i,quoteId:s,settleId:o,type:f,spot:m,margin:!1,swap:l,future:g,option:!1,active:N,contract:y,linear:S,inverse:v,taker:this.safeNumber(e,"takerFeeRate"),maker:this.safeNumber(e,"makerFeeRate"),contractSize:this.safeNumber(e,"sizeMultiplier"),expiry:T,expiryDatetime:I,strike:void 0,optionType:void 0,precision:{amount:b,price:w},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(e,"minTradeNum","minTradeAmount"),max:this.safeNumber(e,"maxTradeAmount")},price:{min:void 0,max:void 0},cost:{min:B,max:void 0}},info:e}}async fetchMarketsByType(e,t={}){const s=this.getSupportedMapping(e,{spot:"publicSpotGetPublicProducts",swap:"publicMixGetMarketContracts"}),i=await this[s](t),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}async fetchCurrencies(e={}){const t=await this.publicSpotGetPublicCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coinId"),o=this.safeCurrencyCode(this.safeString(r,"coinName")),d=this.safeValue(r,"chains",[]),c={};for(let u=0;u<d.length;u++){const h=d[u],f=this.safeString(h,"chain"),l=this.safeCurrencyCode(f),m=this.safeString(h,"withdrawable"),g=this.safeString(h,"rechargeable");c[l]={info:h,id:f,network:l,limits:{withdraw:{min:this.safeNumber(h,"minWithdrawAmount"),max:void 0},deposit:{min:this.safeNumber(h,"minDepositAmount"),max:void 0}},active:void 0,withdraw:m==="true",deposit:g==="true",fee:this.safeNumber(h,"withdrawFee"),precision:void 0}}s[o]={info:r,id:a,code:o,networks:c,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Dt(this.id+" fetchDeposits() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletDepositList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s);const r=this.safeString(n,"chain");if(r===void 0)throw new Dt(this.id+" withdraw() requires a chain parameter");await this.loadMarkets();const o={coin:this.currency(e).code,address:s,chain:r,amount:t};i!==void 0&&(o.tag=i);const d=await this.privateSpotPostWalletWithdrawal(this.extend(o,n)),c={id:this.safeString(d,"data"),info:d,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:"withdrawal",currency:void 0,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0},u=this.safeValue(this.options,"withdraw",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.currency=e,c.timestamp=this.milliseconds(),c.datetime=this.iso8601(this.milliseconds()),c.amount=t,c.tag=i,c.address=s,c.addressTo=s,c.network=r),c}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Dt(this.id+" fetchWithdrawals() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletWithdrawalList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"cTime"),i=this.safeString(e,"chain"),n=this.safeString(e,"coin"),r=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,txid:this.safeString(e,"txId"),timestamp:s,datetime:this.iso8601(s),network:i,addressFrom:void 0,address:this.safeString(e,"toAddress"),addressTo:this.safeString(e,"toAddress"),amount:this.safeNumber(e,"amount"),type:this.safeString(e,"type"),currency:this.safeCurrencyCode(n),status:this.parseTransactionStatus(r),updated:this.safeNumber(e,"uTime"),tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0}}parseTransactionStatus(e){const t={success:"ok",Pending:"pending",pending_review:"pending",pending_review_fail:"failed",reject:"failed"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.code},n=await this.privateSpotGetWalletDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeString(e,"chain");return{currency:this.safeCurrencyCode(s,t),address:this.safeString(e,"address"),tag:this.safeString(e,"tag"),network:i,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketDepth",swap:"publicMixGetMarketDepth"}),o={symbol:i.id};t!==void 0&&(o.limit=t);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeInteger(c,"timestamp");return this.parseOrderBook(c,e,u)}parseTicker(e,t=void 0){let s=this.safeString(e,"symbol");t===void 0&&s!==void 0&&s.indexOf("_")===-1&&(s=s+"_SPBL");const i=this.safeSymbol(s,t),n=this.safeString(e,"high24h"),r=this.safeString(e,"low24h"),a=this.safeString2(e,"close","last"),o=this.safeString2(e,"quoteVol","quoteVolume"),d=this.safeString2(e,"baseVol","baseVolume"),c=this.safeInteger2(e,"ts","timestamp"),u=this.iso8601(c),h=this.safeString2(e,"buyOne","bestBid"),f=this.safeString2(e,"sellOne","bestAsk"),l=it.stringMul(this.safeString(e,"priceChangePercent"),"100");return this.safeTicker({symbol:i,timestamp:c,datetime:u,high:n,low:r,bid:h,bidVolume:void 0,ask:f,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:void 0,previousClose:void 0,change:void 0,percentage:l,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketTicker",swap:"publicMixGetMarketTicker"}),o=await this[a](this.extend(i,r)),d=this.safeValue(o,"data");return this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();let s,i;if(e!==void 0){const d=this.safeValue(e,0);i=this.market(d)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicSpotGetMarketTickers",swap:"publicMixGetMarketTickers"}),r={};if(n==="publicMixGetMarketTickers"){const d=this.safeString(this.options,"defaultSubType");r.productType=d==="linear"?"UMCBL":"DMCBL"}const a=await this[n](this.extend(r,t)),o=this.safeValue(a,"data");return this.parseTickers(o,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString2(e,"tradeId","fillId"),r=this.safeString(e,"orderId"),a=this.safeString(e,"side"),o=this.safeString2(e,"fillPrice","price");let d=this.safeString2(e,"fillQuantity","size");d=this.safeString(e,"sizeQty",d);let c=this.safeInteger2(e,"fillTime","timestamp");c=this.safeInteger(e,"cTime",c);let u;const h=this.safeString(e,"fees"),f=this.safeString(e,"orderType");if(h!==void 0){const m=this.safeCurrencyCode(this.safeString(e,"feeCcy"));u={code:m,currency:m,cost:h}}const l=this.iso8601(c);return this.safeTrade({info:e,id:n,order:r,symbol:i,side:a,type:f,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:u,timestamp:c,datetime:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.limit=t);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"publicSpotGetMarketFills",swap:"publicMixGetMarketFills"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"data",[]);return this.parseTrades(u,n,s,t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicSpotGetPublicProduct(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicSpotGetPublicProducts(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTradingFee(r),o=a.symbol;i[o]=a}return i}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate")}}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger2(e,0,"ts"),this.safeNumber2(e,1,"open"),this.safeNumber2(e,2,"high"),this.safeNumber2(e,3,"low"),this.safeNumber2(e,4,"close"),this.safeNumber2(e,5,"baseVol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"publicSpotGetMarketCandles",swap:"publicMixGetMarketCandles"}),u=this.safeInteger2(n,"until","till");if(n=this.omit(n,["until","till"]),i===void 0&&(i=100),r.type==="spot"){if(a.period=this.options.timeframes.spot[t],a.limit=i,s!==void 0&&(a.after=s,u===void 0)){const l=this.options.timeframes.swap[t]*1e3;a.before=this.sum(s,l*i)}u!==void 0&&(a.before=u)}else if(r.type==="swap"){a.granularity=this.options.timeframes.swap[t];const l=this.parseTimeframe(t),m=this.milliseconds();s===void 0?(a.startTime=m-(i-1)*(l*1e3),a.endTime=m):(a.startTime=this.sum(s,l*1e3),u!==void 0?a.endTime=u:a.endTime=this.sum(s,i*l*1e3))}const h=await this[c](this.extend(a,d)),f=this.safeValue(h,"data",h);return this.parseOHLCVs(f,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"privateSpotGetAccountAssets",swap:"privateMixGetAccountAccounts"}),n={};if(t==="swap"){const o=this.safeString(this.options,"defaultSubType");n.productType=o==="linear"?"UMCBL":"DMCBL"}const r=await this[i](this.extend(n,s)),a=this.safeValue(r,"data");return this.parseBalance(a)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString2(i,"coinId","marginCoin"),r=this.safeCurrencyCode(n),a=this.account(),o=this.safeString(i,"frozen"),d=this.safeString2(i,"lock","locked");a.used=it.stringAdd(o,d),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseOrderStatus(e){const t={new:"open",init:"open",full_fill:"closed",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s);const i=t.symbol,n=this.safeString(e,"orderId"),r=this.safeString2(e,"price","executePrice"),a=this.safeString2(e,"quantity","size"),o=this.safeString2(e,"fillQuantity","filledQty"),d=this.safeString2(e,"fillTotalAmount","filledAmount"),c=this.safeString2(e,"fillPrice","priceAvg"),u=this.safeString(e,"orderType"),h=this.safeInteger(e,"cTime");let f=this.safeString2(e,"side","posSide");f==="open_long"||f==="close_short"?f="buy":(f==="close_long"||f==="open_short")&&(f="sell");const l=this.safeString2(e,"clientOrderId","clientOid"),m=void 0,g=this.safeString2(e,"status","state"),y=this.parseOrderStatus(g),w=this.safeInteger(e,"uTime");return this.safeOrder({info:e,id:n,clientOrderId:l,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:w,symbol:i,type:u,timeInForce:void 0,postOnly:void 0,side:f,price:r,stopPrice:this.safeNumber(e,"triggerPrice"),triggerPrice:this.safeNumber(e,"triggerPrice"),average:c,cost:d,amount:a,filled:o,remaining:void 0,status:y,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c={symbol:a.id,orderType:t},u=t==="market",h=this.safeValue2(r,"stopPrice","triggerPrice"),f=h!==void 0,l=this.safeValue(r,"stopLossPrice"),m=l!==void 0,g=this.safeValue(r,"takeProfitPrice"),y=g!==void 0,w=m||y;if(this.sum(f,m,y)>1)throw new W(this.id+" createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice");t==="limit"&&h===void 0&&(c.price=this.priceToPrecision(e,n));const b=this.safeString2(r,"clientOid","clientOrderId");let S=this.getSupportedMapping(o,{spot:"privateSpotPostTradeOrders",swap:"privateMixPostOrderPlaceOrder"});const v=this.safeString2(r,"force","timeInForceValue"),T=this.isPostOnly(u,v==="post_only",r);if(o==="spot"){if(w)throw new te(this.id+" createOrder() does not support stop orders on spot markets, only swap markets");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)&&u&&s==="buy"){if(n===void 0)throw new te(this.id+" createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const x=this.numberToString(i),k=this.numberToString(n),O=this.parseNumber(it.stringMul(x,k));c.quantity=this.priceToPrecision(e,O)}}else c.quantity=this.amountToPrecision(e,i);b!==void 0&&(c.clientOrderId=b),c.side=s,T?c.force="post_only":c.force="gtc"}else{b!==void 0&&(c.clientOid=b),c.size=this.amountToPrecision(e,i),T&&(c.timeInForceValue="post_only");const B=this.safeValue(r,"reduceOnly",!1);if(h!==void 0){const x=this.safeString(r,"triggerType","market_price");c.triggerType=x,c.triggerPrice=this.priceToPrecision(e,h),c.executePrice=this.priceToPrecision(e,n),S="privateMixPostPlanPlacePlan"}if(w){if(!u)throw new W(this.id+" createOrder() bitget stopLoss or takeProfit orders must be market orders");m?(c.triggerPrice=this.priceToPrecision(e,l),c.planType="loss_plan"):y&&(c.triggerPrice=this.priceToPrecision(e,g),c.planType="profit_plan"),c.holdSide=s==="buy"?"long":"short",S="privateMixPostPlanPlaceTPSL"}else B?c.side=s==="buy"?"close_short":"close_long":c.side=s==="buy"?"open_long":"open_short";c.marginCoin=a.settleId}const I=this.omit(d,["stopPrice","triggerType","stopLossPrice","takeProfitPrice","postOnly"]),A=await this[S](this.extend(c,I)),N=this.safeValue(A,"data");return this.parseOrder(N,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Dt(this.id+" cancelOrder() requires a symbol argument for spot orders");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeCancelOrder",swap:"privateMixPostOrderCancelOrder"});const o={symbol:i.id,orderId:e};if(this.safeValue(s,"stop")){const u=this.safeString(s,"planType");if(u===void 0)throw new Dt(this.id+" cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan or loss_plan");o.planType=u,a="privateMixPostPlanCancelPlan",s=this.omit(s,["stop","planType"])}n==="swap"&&(o.marginCoin=i.settleId);const c=await this[a](this.extend(o,r));return this.parseOrder(c,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Dt(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString(s,"type",i.type);if(n===void 0)throw new Dt(this.id+" cancelOrders() requires a type parameter (one of 'spot', 'swap').");s=this.omit(s,"type");const r={};let a;if(n==="spot"){a="apiPostOrderOrdersBatchcancel",r.method="batchcancel";const c=this.json(e).split('"');r.order_ids=c.join("")}else n==="swap"&&(a="privateMixPostOrderCancelBatchOrders",r.symbol=i.id,r.marginCoin=i.quote,r.orderIds=e);return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s,i=this.safeString(this.options,"defaultSubType");e!==void 0&&(s=this.market(e),i=s.linear?"linear":"inverse");const n=i==="linear"?"UMCBL":"DMCBL",[r,a]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);if(r==="spot")throw new RE(this.id+" cancelAllOrders () does not support spot markets");const o={productType:n};let d;const c=this.safeValue(t,"stop"),u=this.safeString(t,"planType");if(c!==void 0||u!==void 0){if(u===void 0)throw new Dt(this.id+" cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan, loss_plan, pos_profit, pos_loss, moving_plan or track_plan");d="privateMixPostPlanCancelAllPlan",t=this.omit(t,["stop"])}else{const f=this.safeString2(t,"code","marginCoin");if(f===void 0)throw new Dt(this.id+" cancelAllOrders () requires a code argument [marginCoin] in the params");const l=this.currency(f);o.marginCoin=this.safeCurrencyCode(f,l),d="privateMixPostOrderCancelAllOrders"}return t=this.omit(a,["code","marginCoin"]),await this[d](this.extend(o,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Dt(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeOrderInfo",swap:"privateMixGetOrderDetail"}),o={symbol:i.id,orderId:e},d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeValue(c,0,c);return this.parseOrder(u,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Dt(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),o={symbol:n.id};let d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeOpenOrders",swap:"privateMixGetOrderCurrent"});this.safeValue(i,"stop")&&(d="privateMixGetPlanCurrentPlan",i=this.omit(i,"stop"));const u=await this[d](this.extend(o,a)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Dt(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),o={symbol:n.id},d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeHistory",swap:"privateMixGetOrderHistory"});r==="swap"&&(s===void 0&&(s=100),o.pageSize=s,t===void 0&&(t=0),o.startTime=t,o.endTime=this.milliseconds());const c=await this[d](this.extend(o,a)),u=this.safeValue(c,"data"),h=this.safeValue(u,"orderList",u);return this.parseOrders(h,n,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.coinId=n.id);const a=await this.privateSpotPostAccountBills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseLedger(o,n,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=this.safeString(e,"coinId"),n=this.safeCurrencyCode(i),r=this.parseNumber(it.stringAbs(this.safeString(e,"quantity"))),a=this.safeInteger(e,"cTime"),o=this.safeString(e,"bizType");let d;o!==void 0&&o.indexOf("-")>=0&&(d=o.split("-")[1]);const c=this.safeString(e,"groupType"),u=this.safeNumber(e,"fees"),h=this.safeNumber(e,"balance");return{info:e,id:s,timestamp:a,datetime:this.iso8601(a),direction:d,account:void 0,referenceId:void 0,referenceAccount:void 0,type:c,currency:n,amount:r,before:void 0,after:h,status:void 0,fee:u}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Dt(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(n.swap)throw new Tn(this.id+" fetchMyTrades() only supports spot markets");const r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateSpotPostTradeFills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Dt(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),[a,o]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n),d=this.getSupportedMapping(a,{spot:"privateSpotPostTradeFills",swap:"privateMixGetOrderFills"}),c={symbol:r.id,orderId:e},u=await this[d](this.extend(c,o)),h=this.safeValue(u,"data");return await this.parseTrades(h,r,s,i)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id,marginCoin:s.settleId},n=await this.privateMixGetPositionSinglePosition(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePositions(r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const i={productType:this.safeString(this.options,"defaultSubType")==="linear"?"UMCBL":"DMCBL"},n=await this.privateMixGetPositionAllPosition(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o]));return e=this.marketSymbols(e),this.filterByArray(a,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"cTime");let r=this.safeString(e,"marginMode"),a,o;const d=this.safeString(e,"unrealizedPL"),c=this.safeString(e,"margin");r==="fixed"?(r="isolated",a=it.stringAdd(c,d)):r==="crossed"&&(r="cross",o=c);const u=this.safeString(e,"holdMode");let h;u==="double_hold"?h=!0:u==="single_hold"&&(h=!1);const f=this.safeString(e,"holdSide"),l=this.safeString(e,"leverage"),m=this.safeValue(t,"contractSize"),g=this.numberToString(m),y=this.safeString(e,"total"),w=this.safeString(e,"averageOpenPrice"),b=this.safeString(e,"keepMarginRate"),S=it.stringMul(w,y);o===void 0&&(o=it.stringDiv(S,l));const v=this.parseNumber(it.stringDiv(y,g)),T=this.safeString(e,"marketPrice"),I=it.stringMul(y,T),A=it.stringDiv(o,I);let N=this.parseNumber(this.omitZero(this.safeString(e,"liquidationPrice")));const B="0.0006",x="0.9994";if(N===void 0&&r==="isolated"&&it.stringGt(y,"0")){let L=it.stringDiv(c,y),D=b;f==="short"&&(L=it.stringNeg(L),D=it.stringNeg(D));let H=it.stringSub("1",D),R=it.stringSub(w,L);f==="long"?H=it.stringMul(H,x):R=it.stringMul(R,x),N=it.stringDiv(R,H)}const k=it.stringMul(I,B),O=it.stringAdd(it.stringMul(b,I),k),P=it.stringDiv(O,a),q=it.stringMul(it.stringDiv(d,o,4),"100");return{info:e,id:void 0,symbol:i,notional:this.parseNumber(I),marginMode:r,liquidationPrice:this.parseNumber(N),entryPrice:this.parseNumber(w),unrealizedPnl:this.parseNumber(d),percentage:this.parseNumber(q),contracts:v,contractSize:m,markPrice:this.parseNumber(T),side:f,hedged:h,timestamp:n,datetime:this.iso8601(n),maintenanceMargin:this.parseNumber(O),maintenanceMarginPercentage:this.parseNumber(b),collateral:this.parseNumber(a),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(A),leverage:this.parseNumber(l),marginRatio:this.parseNumber(P)}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Dt(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.pageSize=s);const a=await this.publicMixGetMarketHistoryFundRate(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],f=this.safeString(h,"symbol"),l=this.safeSymbol(f,n),m=this.safeInteger(h,"settleTime");d.push({info:h,symbol:l,fundingRate:this.safeString(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Tn(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},n=await this.publicMixGetMarketCurrentFundRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t);return{info:e,symbol:i,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.safeString(i,"holdSide"),r=this.market(e),a=r.linear?r.quote:r.base,o={symbol:r.id,marginCoin:a,amount:this.amountToPrecision(e,t),holdSide:n};i=this.omit(i,"holdSide");const d=await this.privateMixPostAccountSetMargin(this.extend(o,i));return this.extend(this.parseMarginModification(d,r),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="00000"?"ok":"failed",n=t.linear?t.quote:t.base;return{info:e,type:void 0,amount:void 0,code:n,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){if(t>0)throw new Se(this.id+" reduceMargin() amount parameter must be a negative value");if(this.safeString(s,"holdSide")===void 0)throw new Dt(this.id+" reduceMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){if(this.safeString(s,"holdSide")===void 0)throw new Dt(this.id+" addMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id};return await this.publicMixGetMarketSymbolLeverage(this.extend(i,t))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Dt(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,leverage:e};return await this.privateMixPostAccountSetLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Dt(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="fixed"&&e!=="crossed")throw new Dt(this.id+' setMarginMode() marginMode must be "fixed" or "crossed"');await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,marginMode:e};return await this.privateMixPostAccountSetMarginMode(this.extend(n,s))}async setPositionMode(e,t=void 0,s={}){if(this.safeString(s,"productType")===void 0&&t===void 0)throw new Dt(this.id+" setPositionMode() requires a symbol or the productType parameter");await this.loadMarkets();const r={holdMode:e?"double_hold":"single_hold"};if(t!==void 0){const o=this.market(t);r.productType=o.linear?"umcbl":"dmcbl"}return await this.privateMixPostAccountSetPositionMode(this.extend(r,s))}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Se(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},n=await this.publicMixGetMarketOpenInterest(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseOpenInterest(r,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=s==="swap",o=i==="swap",d=r.code==="USDT";a?s=d?"mix_usdt":"mix_usd":o&&(i=d?"mix_usdt":"mix_usd");const c={fromType:s,toType:i,amount:t,coin:r.info.coinName},u=await this.privateSpotPostWalletTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"requestTime"),i=this.safeString(e,"msg");return{info:e,id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeString(t,"code"),amount:this.safeNumber(e,"size"),fromAccount:void 0,toAccount:void 0,status:i==="success"?"ok":i}}parseTransferStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"amount");return{symbol:n,openInterestAmount:r,openInterestValue:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"err_msg"),u=this.safeString2(a,"code","err_code"),h=this.id+" "+r,f=c!==void 0&&c!=="";f&&(this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h));const l=u!==void 0&&u!=="00000";if(l&&this.throwExactlyMatchedException(this.exceptions.exact,u,h),l||f)throw new W(h)}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",o=t[1],d=o==="spot"?"/api/spot/v1":"/api/mix/v1",c="/"+this.implodeParams(e,i),u=d+c;let h=this.implodeHostname(this.urls.api[o])+u;const f=this.omit(i,this.extractParams(e));if(!a&&s==="GET"&&Object.keys(f).length>0&&(h=h+"?"+this.urlencode(f)),a){this.checkRequiredCredentials();const l=this.milliseconds().toString();let m=l+s+u;if(s==="POST")r=this.json(i),m+=r;else if(Object.keys(i).length){const w="?"+this.urlencode(this.keysort(i));h+=w,m+=w}const g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","base64"),y=this.safeString(this.options,"broker");n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":g,"ACCESS-TIMESTAMP":l,"ACCESS-PASSPHRASE":this.password,"X-CHANNEL-API-CODE":y},s==="POST"&&(n["Content-Type"]="application/json")}return{url:h,method:s,body:r,headers:n}}};const HE=re,{ExchangeError:Ic,ExchangeNotAvailable:GE,AuthenticationError:Zf,BadRequest:Qf,PermissionDenied:Jy,InvalidAddress:UE,ArgumentsRequired:Do,InvalidOrder:$E}=Q,{DECIMAL_PLACES:WE,SIGNIFICANT_DIGITS:zE,TRUNCATE:jE}=ne,KE=ae;var XE=class extends HE{describe(){return this.deepExtend(super.describe(),{id:"bithumb",name:"Bithumb",countries:["KR"],rateLimit:500,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},hostname:"bithumb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg",api:{public:"https://api.{hostname}/public",private:"https://api.{hostname}"},www:"https://www.bithumb.com",doc:"https://apidocs.bithumb.com",fees:"https://en.bithumb.com/customer_support/info_fee"},api:{public:{get:["ticker/{currency}","ticker/all","ticker/ALL_BTC","ticker/ALL_KRW","orderbook/{currency}","orderbook/all","transaction_history/{currency}","transaction_history/all","candlestick/{currency}/{interval}"]},private:{post:["info/account","info/balance","info/wallet_address","info/ticker","info/orders","info/user_transactions","info/order_detail","trade/place","trade/cancel","trade/btc_withdrawal","trade/krw_deposit","trade/krw_withdrawal","trade/market_buy","trade/market_sell"]}},fees:{trading:{maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")}},precisionMode:zE,exceptions:{"Bad Request(SSL)":Qf,"Bad Request(Bad Method)":Qf,"Bad Request.(Auth Data)":Zf,"Not Member":Zf,"Invalid Apikey":Zf,"Method Not Allowed.(Access IP)":Jy,"Method Not Allowed.(BTC Adress)":UE,"Method Not Allowed.(Access)":Jy,"Database Fail":GE,"Invalid Parameter":Qf,5600:Ic,"Unknown Error":Ic,"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions":Ic},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","30m":"30m","1h":"1h","6h":"6h","12h":"12h","1d":"24h"},options:{quoteCurrencies:{BTC:{limits:{cost:{min:2e-4,max:100}}},KRW:{limits:{cost:{min:500,max:5e9}}}}},commonCurrencies:{FTC:"FTC2",SOC:"Soda Coin"}})}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return super.safeMarket(e,t,s,"spot")}amountToPrecision(e,t){return this.decimalToPrecision(t,jE,this.markets[e].precision.amount,WE)}async fetchMarkets(e={}){const t=[],s=this.safeValue(this.options,"quoteCurrencies",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=r,o=this.safeValue(s,r,{}),d="publicGetTickerALL"+r,c=await this[d](e),u=this.safeValue(c,"data"),h=Object.keys(u);for(let f=0;f<h.length;f++){const l=h[f];if(l==="date")continue;const m=u[l],g=this.safeCurrencyCode(l);let y=!0;Array.isArray(m)&&m.length===0&&(y=!1);const w=this.deepExtend({id:l,symbol:g+"/"+r,base:g,quote:r,settle:void 0,baseId:l,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("4"),price:parseInt("4")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{}},info:m},o);t.push(w)}}return t}parseBalance(e){const t={info:e},s=this.safeValue(e,"data"),i=Object.keys(this.currencies);for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.currency(r),d=this.safeStringLower(o,"id");a.total=this.safeString(s,"total_"+d),a.used=this.safeString(s,"in_use_"+d),a.free=this.safeString(s,"available_"+d),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"ALL"},s=await this.privatePostInfoBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.base+"_"+i.quote};t!==void 0&&(n.count=t);const r=await this.publicGetOrderbookCurrency(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"bids","asks","price","quantity")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t),n=this.safeString(e,"opening_price"),r=this.safeString(e,"closing_price"),a=this.safeString(e,"units_traded_24H"),o=this.safeString(e,"acc_trade_value_24H");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"max_price"),low:this.safeString(e,"min_price"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:n,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickerAll(t),i={},n=this.safeValue(s,"data",{}),r=this.safeInteger(n,"date"),a=this.omit(n,"date"),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeMarket(c),h=u.symbol,f=a[c];Array.isArray(f)||(f.date=r,i[h]=this.parseTicker(f,u))}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.base},n=await this.publicGetTickerCurrency(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currency:r.base,interval:this.timeframes[t]},o=await this.publicGetCandlestickCurrencyInterval(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseTrade(e,t=void 0){let s;const i=this.safeString(e,"transaction_date");if(i!==void 0){const f=i.split(" ");if(f.length>1){const m=f[0];let g=f[1];g.length<8&&(g="0"+g),s=this.parse8601(m+" "+g)}else s=this.safeIntegerProduct(e,"transaction_date",.001)}s!==void 0&&(s-=9*36e5);const n=void 0;let r=this.safeString(e,"type");r=r==="ask"?"sell":"buy";const a=this.safeString(e,"cont_no");t=this.safeMarket(void 0,t);const o=this.safeString(e,"price"),d=this.fixCommaNumber(this.safeString2(e,"units_traded","units")),c=this.safeString(e,"total");let u;const h=this.safeString(e,"fee");if(h!==void 0){const f=this.safeString(e,"fee_currency"),l=this.commonCurrencyCode(f);u={cost:h,currency:l}}return this.safeTrade({id:a,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.base};s!==void 0&&(r.count=s);const a=await this.publicGetTransactionHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={order_currency:a.id,payment_currency:a.quote,units:i};let d="privatePostTradePlace";t==="limit"?(o.price=n,o.type=s==="buy"?"bid":"ask"):d="privatePostTradeMarket"+this.capitalize(s);const c=await this[d](this.extend(o,r)),u=this.safeString(c,"order_id");if(u===void 0)throw new $E(this.id+" createOrder() did not return an order id");return{info:c,symbol:e,type:t,side:s,id:u}}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Do(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,count:1,order_currency:i.base,payment_currency:i.quote},r=await this.privatePostInfoOrderDetail(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(this.extend(a,{order_id:e}),i)}parseOrderStatus(e){const t={Pending:"open",Completed:"closed",Cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeIntegerProduct(e,"order_date",.001),n=this.safeValue2(e,"type","side")==="bid"?"buy":"sell",r=this.parseOrderStatus(this.safeString(e,"order_status")),a=this.safeString2(e,"order_price","price");let o="limit";KE.stringEquals(a,"0")&&(o="market");const d=this.fixCommaNumber(this.safeString2(e,"order_qty","units"));let c=this.fixCommaNumber(this.safeString(e,"units_remaining"));c===void 0&&(r==="closed"?c="0":r!=="canceled"&&(c=d));let u;const h=this.safeString(e,"order_currency"),f=this.safeString(e,"payment_currency"),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f);l!==void 0&&m!==void 0&&(u=l+"/"+m),u===void 0&&(t=this.safeMarket(void 0,t),u=t.symbol);const g=this.safeString(e,"order_id"),y=this.safeValue(e,"contract",[]);return this.safeOrder({info:e,id:g,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:o,timeInForce:void 0,postOnly:void 0,side:n,price:a,stopPrice:void 0,triggerPrice:void 0,amount:d,cost:void 0,average:void 0,filled:void 0,remaining:c,status:r,fee:void 0,trades:y},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Do(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={count:s,order_currency:n.base,payment_currency:n.quote};t!==void 0&&(r.after=t);const a=await this.privatePostInfoOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(!("side"in s))throw new Do(this.id+" cancelOrder() requires a `side` parameter (sell or buy)");if(t===void 0)throw new Do(this.id+" cancelOrder() requires a `symbol` argument");const n=this.market(t),r=s.side==="buy"?"bid":"ask";s=this.omit(s,["side","currency"]);const a={order_id:e,type:r,order_currency:n.base,payment_currency:n.quote};return await this.privatePostTradeCancel(this.extend(a,s))}cancelUnifiedOrder(e,t={}){const s={side:e.side};return this.cancelOrder(e.id,e.symbol,this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={units:t,address:s,currency:r.id};if(r==="XRP"||r==="XMR"||r==="EOS"||r==="STEEM"){const d=this.safeString(n,"destination");if(i===void 0&&d===void 0)throw new Do(this.id+" "+e+" withdraw() requires a tag argument or an extra destination param");i!==void 0&&(a.destination=i)}const o=await this.privatePostTradeBtcWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}fixCommaNumber(e){if(e===void 0)return;let t=e;for(;t.indexOf(",")>-1;)t=t.replace(",","");return t}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.implodeHostname(this.urls.api[t])+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),r=this.urlencode(this.extend({endpoint:a},d));const c=this.nonce().toString(),u=a+"\0"+r+"\0"+c,h=this.hmac(this.encode(u),this.encode(this.secret),"sha512"),f=this.decode(this.stringToBase64(h));n={Accept:"application/json","Content-Type":"application/x-www-form-urlencoded","Api-Key":this.apiKey,"Api-Sign":f,"Api-Nonce":c}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a){const c=this.safeString(a,"status"),u=this.safeString(a,"message");if(c!==void 0){if(c==="0000")return;if(u==="\uAC70\uB798 \uC9C4\uD589\uC911\uC778 \uB0B4\uC5ED\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4")return;const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new Ic(h)}}}};const YE=re,{AuthenticationError:On,ExchangeNotAvailable:ew,AccountSuspended:Jf,PermissionDenied:_r,RateLimitExceeded:ZE,InvalidNonce:QE,InvalidAddress:tw,ArgumentsRequired:Di,ExchangeError:nt,InvalidOrder:dt,InsufficientFunds:Fo,BadRequest:vt,OrderNotFound:sw,BadSymbol:Ho,NotSupported:Fi}=Q,{TICK_SIZE:JE,TRUNCATE:eq}=ne,xc=ae;var fT=class extends YE{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:33.34,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:void 0,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:void 0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawAddressesByNetwork:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},hostname:"bitmart.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg",api:{rest:"https://api-cloud.{hostname}"},www:"https://www.bitmart.com/",doc:"https://developer-pro.bitmart.com/",referral:{url:"http://www.bitmart.com/?r=rQCFLh",discount:.3},fees:"https://www.bitmart.com/fee/en"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:{"system/time":3,"system/service":3,"spot/v1/currencies":7.5,"spot/v1/symbols":7.5,"spot/v1/symbols/details":5,"spot/v1/ticker":5,"spot/v2/ticker":5,"spot/v1/steps":30,"spot/v1/symbols/kline":5,"spot/v1/symbols/book":5,"spot/v1/symbols/trades":5,"contract/v1/tickers":15,"contract/public/details":5,"contract/public/depth":5,"contract/public/open-interest":30,"contract/public/funding-rate":30,"contract/public/kline":5}},private:{get:{"account/sub-account/v1/transfer-list":7.5,"account/sub-account/v1/transfer-history":7.5,"account/sub-account/main/v1/wallet":5,"account/sub-account/main/v1/subaccount-list":7.5,"account/v1/wallet":5,"account/v1/currencies":30,"spot/v1/wallet":5,"account/v1/deposit/address":30,"account/v1/withdraw/charge":32,"account/v2/deposit-withdraw/history":7.5,"account/v1/deposit-withdraw/detail":7.5,"spot/v1/order_detail":1,"spot/v2/orders":5,"spot/v1/trades":5,"spot/v2/trades":5,"spot/v3/orders":5,"spot/v2/order_detail":1,"spot/v1/margin/isolated/borrow_record":1,"spot/v1/margin/isolated/repay_record":1,"spot/v1/margin/isolated/pairs":1,"spot/v1/margin/isolated/account":6,"spot/v1/trade_fee":6,"spot/v1/user_fee":6,"contract/private/assets-detail":5,"contract/private/order":2,"contract/private/order-history":10,"contract/private/position":10},post:{"account/sub-account/main/v1/sub-to-main":30,"account/sub-account/sub/v1/sub-to-main":30,"account/sub-account/main/v1/main-to-sub":30,"account/sub-account/sub/v1/sub-to-sub":30,"account/sub-account/main/v1/sub-to-sub":30,"account/v1/withdraw/apply":7.5,"spot/v1/submit_order":1,"spot/v1/batch_orders":1,"spot/v2/cancel_order":1,"spot/v1/cancel_orders":15,"spot/v3/cancel_order":1,"spot/v2/batch_orders":1,"spot/v2/submit_order":1,"spot/v1/margin/submit_order":1,"spot/v1/margin/isolated/borrow":6,"spot/v1/margin/isolated/repay":6,"spot/v1/margin/isolated/transfer":6,"contract/private/trades":10}}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0020")],[this.parseNumber("10"),this.parseNumber("0.18")],[this.parseNumber("50"),this.parseNumber("0.0016")],[this.parseNumber("250"),this.parseNumber("0.0014")],[this.parseNumber("1000"),this.parseNumber("0.0012")],[this.parseNumber("5000"),this.parseNumber("0.0010")],[this.parseNumber("25000"),this.parseNumber("0.0008")],[this.parseNumber("50000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("10"),this.parseNumber("0.0009")],[this.parseNumber("50"),this.parseNumber("0.0008")],[this.parseNumber("250"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0005")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")]]}}},precisionMode:JE,exceptions:{exact:{3e4:nt,30001:On,30002:On,30003:Jf,30004:On,30005:On,30006:On,30007:On,30008:On,30010:_r,30011:On,30012:On,30013:ZE,30014:ew,6e4:vt,60001:vt,60002:vt,60003:nt,60004:nt,60005:nt,60006:nt,60007:tw,60008:Fo,60009:nt,60010:nt,60011:tw,60012:nt,60020:_r,60021:_r,60022:_r,60030:vt,60031:vt,60050:nt,60051:nt,61001:Fo,61003:vt,5e4:vt,50001:Ho,50002:vt,50003:vt,50004:vt,50005:sw,50006:dt,50007:dt,50008:dt,50009:dt,50010:dt,50011:dt,50012:dt,50013:dt,50014:vt,50015:vt,50016:vt,50017:vt,50018:vt,50019:vt,51004:Fo,50020:Fo,50021:vt,50022:ew,50023:Ho,50029:dt,50030:dt,50032:sw,50035:dt,50034:dt,51011:dt,53e3:Jf,53001:Jf,57001:vt,58001:vt,59001:nt,59002:nt,40001:nt,40002:nt,40003:nt,40004:nt,40005:nt,40006:_r,40007:vt,40008:QE,40009:vt,40010:vt,40011:vt,40012:nt,40013:nt,40014:Ho,40015:Ho,40016:dt,40017:dt,40018:dt,40019:nt,40020:dt,40021:nt,40022:nt,40023:nt,40024:nt,40025:nt,40026:nt,40027:Fo,40028:_r,40029:dt,40030:dt,40031:dt,40032:dt,40033:dt,40034:Ho,53002:_r},broad:{}},commonCurrencies:{$GM:"GOLDMINER",$HERO:"Step Hero",$PAC:"PAC",BP:"BEYOND",GDT:"Gorilla Diamond",GLD:"Goldario",MVP:"MVP Coin",TRU:"Truebit"},options:{networks:{TRX:"TRC20",ETH:"ERC20"},defaultNetworks:{USDT:"ERC20"},defaultType:"spot",fetchBalance:{type:"spot"},accountsByType:{spot:"spot"},createMarketBuyOrderRequiresPrice:!0}})}async fetchTime(e={}){const t=await this.publicGetSystemTime(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"server_time")}async fetchStatus(e={}){const t=this.safeValue(this.options,"fetchStatus",{}),s=this.safeString(this.options,"defaultType");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i),e=this.omit(e,"type");const n=await this.publicGetSystemService(e),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"service",[]),o=this.indexBy(a,"service_type");i==="swap"&&(i="contract");const d=this.safeValue(o,i);let c,u;return d!==void 0&&(this.safeInteger(d,"status")===2?c="ok":(c="maintenance",u=this.safeInteger(d,"end_time"))),{status:c,updated:void 0,eta:u,url:void 0,info:n}}async fetchSpotMarkets(e={}){const t=await this.publicGetSpotV1SymbolsDetails(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeInteger(a,"symbol_id"),c=this.safeString(a,"base_currency"),u=this.safeString(a,"quote_currency"),h=this.safeCurrencyCode(c),f=this.safeCurrencyCode(u),l=h+"/"+f,m=this.safeString(a,"min_buy_amount"),g=this.safeString(a,"min_sell_amount"),y=xc.stringMax(m,g),w=this.safeNumber(a,"base_min_size");n.push({id:o,numericId:d,symbol:l,base:h,quote:f,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:w,price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_max_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:w,max:this.safeNumber(a,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.parseNumber(y),max:void 0}},info:a})}return n}async fetchContractMarkets(e={}){const t=await this.publicGetContractV1Tickers(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"tickers",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"contract_symbol"),d=o.slice(0,-4),c=o.slice(-4),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f="USDT",l=u+"/"+h+":"+f;n.push({id:o,numericId:void 0,symbol:l,base:u,quote:h,settle:f,baseId:d,quoteId:c,settleId:void 0,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:!0,contract:!0,linear:!0,inverse:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchContractMarkets(e);return this.arrayConcat(t,s)}async fetchCurrencies(e={}){const t=await this.publicGetSpotV1Currencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"id"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"withdraw_enabled"),h=this.safeValue(a,"deposit_enabled"),f=u&&h;n[d]={id:o,code:d,name:c,info:a,active:f,deposit:h,withdraw:u,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetAccountV1WithdrawCharge(this.extend(i,t)),r=n.data,a={};return a[e]=this.safeNumber(r,"withdraw_fee"),{info:n,withdraw:a,deposit:{}}}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},r=(await this.privateGetAccountV1WithdrawCharge(this.extend(i,t))).data;return this.parseDepositWithdrawFee(r)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp",this.milliseconds()),i=this.safeString2(e,"symbol","contract_symbol");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeString2(e,"close_24h","last_price");let a=this.safeString(e,"price_change_percent_24h");if(a===void 0){const f=this.safeString(e,"fluctuation");if(f!==void 0&&f!=="0"){const l=f[0];a=l+xc.stringMul(f.replace(l,""),"100")}else f==="0"&&(a="0")}const o=this.safeString(e,"base_volume_24h");let d=this.safeString(e,"quote_volume_24h");d=this.safeString(e,"volume_24h",d);const c=this.safeString2(e,"avg_price","index_price"),u=this.safeString2(e,"high_24h","high_price"),h=this.safeString2(e,"low_24h","low_price");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:a,average:c,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;s.swap?(n="publicGetContractV1Tickers",i.contract_symbol=s.id):s.spot&&(n="publicGetSpotV1Ticker",i.symbol=s.id);const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]);let d;s.spot?d=this.indexBy(o,"symbol"):s.swap&&(d=this.indexBy(o,"contract_symbol"));const c=this.safeValue(d,s.id);return this.parseTicker(c,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s,i;if(e!==void 0){const c=this.safeValue(e,0);i=this.market(c)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicGetSpotV2Ticker",swap:"publicGetContractV1Tickers"}),r=await this[n](t),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]),d={};for(let c=0;c<o.length;c++){const u=this.parseTicker(o[c]),h=u.symbol;d[h]=u}return this.filterByArray(d,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new Fi(this.id+" fetchOrderBook() does not support "+i.type+" markets, only spot markets are accepted");const n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetSpotV1SymbolsBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"buys","sells","price","amount")}parseTrade(e,t=void 0){const s=this.safeString(e,"detail_id"),i=this.safeInteger2(e,"order_time","create_time"),n=void 0,r=this.safeStringLower2(e,"type","side");let a;const o=this.safeString(e,"exec_type");o!==void 0&&(a=o==="M"?"maker":"taker");let d=this.safeString(e,"price");d=this.safeString(e,"price_avg",d);let c=this.safeString(e,"count");c=this.safeString(e,"size",c);const u=this.safeString2(e,"amount","notional"),h=this.safeString(e,"order_id"),f=this.safeString(e,"symbol");t=this.safeMarket(f,t,"_");const l=this.safeString(e,"fees");let m;if(l!==void 0){const g=this.safeString(e,"fee_coin_name");let y=this.safeCurrencyCode(g);y===void 0&&(y=r==="buy"?t.base:t.quote),m={cost:l,currency:y}}return this.safeTrade({info:e,id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,side:r,price:d,amount:c,cost:u,takerOrMaker:a,fee:m},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new Fi(this.id+" fetchTrades() does not support "+n.type+" orders, only spot orders are accepted");const r={symbol:n.id},a=await this.publicGetSpotV1SymbolsTrades(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,"timestamp"),this.safeNumber2(e,"open","open_price"),this.safeNumber2(e,"high","high_price"),this.safeNumber2(e,"low","low_price"),this.safeNumber2(e,"close","close_price"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.type,o=this.parseTimeframe(t),d={symbol:r.id,step:this.timeframes[t]},c=500;i===void 0&&(i=c),i=Math.min(c,i);const u=parseInt(this.milliseconds()/1e3),h=a==="spot"?"from":"start_time",f=a==="spot"?"to":"end_time";if(s===void 0){const b=u-i*o;d[h]=b,d[f]=u}else{const b=parseInt(s/1e3)-1,S=this.sum(b,i*o);d[h]=b,d[f]=Math.min(S,u)}let l="publicGetSpotV1SymbolsKline";a==="swap"&&(l="publicGetContractPublicKline");const m=await this[l](this.extend(d,n)),g=this.safeValue(m,"data",{}),y=this.safeValue(g,"klines",[]),w=a==="spot"?y:g;return this.parseOHLCVs(w,r,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Di(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new Fi(this.id+" fetchMyTrades() does not support "+n.type+" orders, only spot orders are accepted");const r=this.safeValue(this.options,"fetchMyTrades",{}),a=this.safeInteger(r,"limit",200);s===void 0&&(s=a);const o={symbol:n.id,N:s},d=await this.privateGetSpotV2Trades(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"trades",[]);return this.parseTrades(u,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Di(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new Fi(this.id+" fetchOrderTrades() does not support "+r.type+" orders, only spot orders are accepted");const a=this.safeValue(this.options,"fetchOrderTrades",{}),o=this.safeInteger(a,"limit",200);i===void 0&&(i=o);const d={symbol:r.id,order_id:e,N:i},c=await this.privateGetSpotV2Trades(this.extend(d,n)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,r,s,i)}parseBalance(e,t){const s=this.safeValue(e,"data",{});let i;t==="swap"?i=this.safeValue(e,"data",[]):t==="margin"?i=this.safeValue(s,"symbols",[]):i=this.safeValue(s,"wallet",[]);const n={info:e};if(t==="margin"){for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeSymbol(o,void 0,"_"),c=this.safeValue(a,"base",{}),u=this.safeValue(a,"quote",{}),h=this.safeCurrencyCode(this.safeString(c,"currency")),f=this.safeCurrencyCode(this.safeString(u,"currency")),l={};l[h]=this.parseBalanceHelper(c),l[f]=this.parseBalanceHelper(u),n[d]=this.safeBalance(l)}return n}else{for(let r=0;r<i.length;r++){const a=i[r];let o=this.safeString2(a,"id","currency");o=this.safeString(a,"coin_code",o);const d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString2(a,"available","available_balance"),c.used=this.safeString2(a,"frozen","frozen_balance"),n[d]=c}return this.safeBalance(n)}}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"frozen"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total_asset");const s=this.safeString(e,"borrow_unpaid"),i=this.safeString(e,"interest_unpaid");return t.debt=xc.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let s=this.getSupportedMapping(t,{spot:"privateGetSpotV1Wallet",swap:"privateGetContractPrivateAssetsDetail",account:"privateGetAccountV1Wallet",margin:"privateGetSpotV1MarginIsolatedAccount"});const i=this.safeString(e,"marginMode"),n=this.safeValue(e,"margin",!1);e=this.omit(e,["margin","marginMode"]),(i!==void 0||n)&&(s="privateGetSpotV1MarginIsolatedAccount",t="margin");const r=await this[s](e);return this.parseBalance(r,t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new Fi(this.id+" fetchTradingFee() does not support "+s.type+" orders, only spot orders are accepted");const i={symbol:s.id},n=await this.privateGetSpotV1TradeFee(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTradingFee(r)}parseOrder(e,t=void 0){let s;typeof e=="string"&&(s=e,e={}),s=this.safeString(e,"order_id",s);const i=this.safeInteger(e,"create_time"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t,"_");let a;t!==void 0&&(a=this.parseOrderStatusByType(t.type,this.safeString(e,"status")));const o=this.safeString(e,"size"),d=this.safeString(e,"filled_size"),c=this.safeString(e,"price_avg"),u=this.safeString(e,"price"),h=this.safeString(e,"side");let f=this.safeString(e,"type"),l,m;return f==="limit_maker"&&(f="limit",m=!0,l="PO"),f==="ioc"&&(f="limit",l="IOC"),this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:f,timeInForce:l,postOnly:m,side:h,price:u,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:void 0,average:c,filled:d,remaining:void 0,status:a,fee:void 0,trades:void 0},t)}parseOrderStatusByType(e,t){const s={spot:{1:"failed",2:"open",3:"failed",4:"open",5:"open",6:"closed",7:"canceling",8:"canceled"},swap:{1:"open",2:"open",4:"closed"}},i=this.safeValue(s,e,{});return this.safeString(i,t,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={},d=this.safeString(r,"timeInForce");if(d==="FOK")throw new dt(this.id+" createOrder() only accepts timeInForce parameter values of IOC or PO");const c=t==="market",u=this.isPostOnly(c,t==="limit_maker",r);r=this.omit(r,["timeInForce","postOnly"]);const h=d==="IOC"||t==="ioc",f=t==="limit"||u||h;let l;if(a.spot){if(o.symbol=a.id,o.side=s,o.type=t,l="privatePostSpotV2SubmitOrder",f)o.size=this.amountToPrecision(e,i),o.price=this.priceToPrecision(e,n);else if(c)if(s==="buy"){let S=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(S===void 0){const T=this.numberToString(i),I=this.numberToString(n);S=this.parseNumber(xc.stringMul(T,I))}}else if(S===void 0)throw new dt(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else S=S===void 0?i:S;o.notional=this.decimalToPrecision(S,eq,a.precision.price,this.precisionMode)}else s==="sell"&&(o.size=this.amountToPrecision(e,i))}else if(a.swap)throw new Fi(this.id+" createOrder() does not accept swap orders, only spot orders are allowed");u&&(o.type="limit_maker"),h&&(o.type="ioc");const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(l="privatePostSpotV1MarginSubmitOrder");const y=await this[l](this.extend(o,g)),w=this.safeValue(y,"data",{}),b=this.parseOrder(w,a);return this.extend(b,{type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Di(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new Fi(this.id+" cancelOrder() does not support "+i.type+" orders, only spot orders are accepted");const n={order_id:e.toString(),symbol:i.id},r=await this.privatePostSpotV3CancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");if(a===!0)return this.parseOrder(e,i);const o=this.safeValue(a,"succeed");if(o!==void 0){if(e=this.safeString(o,0),e===void 0)throw new dt(this.id+" cancelOrder() failed to cancel "+t+" order id "+e)}else if(!this.safeValue(a,"result"))throw new dt(this.id+" cancelOrder() "+t+" order id "+e+" is filled or canceled");const d=this.parseOrder(e,i);return this.extend(d,{id:e})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Di(this.id+" cancelAllOrders() requires a symbol argument");const s=this.safeString(t,"side");if(s===void 0)throw new Di(this.id+" cancelAllOrders() requires a `side` parameter ('buy' or 'sell')");await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new Fi(this.id+" cancelAllOrders() does not support "+i.type+" orders, only spot orders are accepted");const n={symbol:i.id,side:s};return await this.privatePostSpotV1CancelOrders(this.extend(n,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Di(this.id+" fetchOrdersByStatus() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new Fi(this.id+" fetchOrdersByStatus() does not support "+r.type+" orders, only spot orders are accepted");const a={symbol:r.id,offset:1,N:100};e==="open"?a.status=9:e==="closed"?a.status=6:e==="canceled"?a.status=8:a.status=e;const o=await this.privateGetSpotV3Orders(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("canceled",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Di(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new Fi(this.id+" fetchOrder() does not support "+i.type+" orders, only spot orders are accepted");typeof e!="string"&&(e=e.toString());const n={symbol:i.id,order_id:e},r=await this.privateGetSpotV2OrderDetail(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id};if(e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),f=this.safeValue(this.options,"networks",{});let l=this.safeStringUpper(t,"network",h);l=this.safeString(f,l,l),l!==void 0&&(i.currency+="-"+l,t=this.omit(t,"network"))}const n=await this.privateGetAccountV1DepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"address"),o=this.safeString(r,"address_memo"),d=this.safeString(r,"chain");let c;if(d!==void 0){const u=d.split("-"),h=this.safeString(u,1);c=this.safeNetwork(h)}return this.checkAddress(a),{currency:e,address:a,tag:o,network:c,info:n}}safeNetwork(e){return e}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,destination:"To Digital Address",address:s};if(i!==void 0&&(a.address_memo=i),e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),f=this.safeValue(this.options,"networks",{});let l=this.safeStringUpper(n,"network",h);l=this.safeString(f,l,l),l!==void 0&&(a.currency+="-"+l,n=this.omit(n,"network"))}const o=await this.privatePostAccountV1WithdrawApply(this.extend(a,n)),d=this.safeValue(o,"data"),c=this.parseTransaction(d,r);return this.extend(c,{code:e,address:s,tag:i})}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=50);const r={operation_type:e,offset:1,N:i};let a;if(t!==void 0&&(a=this.currency(t),r.currency=a.id),t==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,t),f=this.safeValue(this.options,"networks",{});let l=this.safeStringUpper(n,"network",h);l=this.safeString(f,l,l),l!==void 0&&(r.currency+="-"+l,a.code=r.currency,n=this.omit(n,"network"))}const o=await this.privateGetAccountV2DepositWithdrawHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]);return this.parseTransactions(c,a,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAccountV1DepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateAccountGetDepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdraw",e,t,s,i)}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"pending",3:"ok",4:"canceled",5:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"withdraw_id"),n=this.safeString(e,"deposit_id");let r;i!==void 0&&i!==""?(r="withdraw",s=i):n!==void 0&&n!==""&&(r="deposit",s=n);const a=this.safeNumber(e,"arrival_amount"),o=this.safeInteger(e,"apply_time"),d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d,t),u=this.parseTransactionStatus(this.safeString(e,"status")),h=this.safeNumber(e,"fee");let f;h!==void 0&&(f={cost:h,currency:c});const l=this.safeString(e,"tx_id"),m=this.safeString(e,"address"),g=this.safeString(e,"address_memo");return{info:e,id:s,currency:c,amount:a,network:void 0,address:m,addressFrom:void 0,addressTo:void 0,tag:g,tagFrom:void 0,tagTo:void 0,status:u,type:r,updated:void 0,txid:l,timestamp:o!==0?o:void 0,datetime:o!==0?this.iso8601(o):void 0,fee:f}}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new Di(this.id+" repayMargin() requires a symbol argument");const n=this.market(s),r=this.currency(e),a={symbol:n.id,currency:r.id,amount:this.currencyToPrecision(e,t)};i=this.omit(i,"marginMode");const o=await this.privatePostSpotV1MarginIsolatedRepay(this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new Di(this.id+" borrowMargin() requires a symbol argument");const n=this.market(s),r=this.currency(e),a={symbol:n.id,currency:r.id,amount:this.currencyToPrecision(e,t)};i=this.omit(i,"marginMode");const o=await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.milliseconds();return{id:this.safeString2(e,"borrow_id","repay_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const d=this.safeString(this.options,"defaultSettle","USDT");e==="USDT"?s=this.market("BTC/"+d):s=this.market(e+"/"+d)}const i={symbol:s.id},n=await this.privateGetSpotV1MarginIsolatedPairs(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"symbols",[]),o=e==="USDT"?s.quote:s.base;return this.parseBorrowRate(a,o)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=t==="USDT"?this.safeValue(e[0],"quote",{}):this.safeValue(e[0],"base",{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetSpotV1MarginIsolatedPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]);return this.parseBorrowRates(i,void 0)}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"base",{});i.push({currency:this.safeCurrencyCode(this.safeString(a,"currency")),rate:this.safeNumber(a,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={amount:a,currency:r.id},d=this.convertTypeToAccount(s),c=this.convertTypeToAccount(i);if(s==="spot")o.side="in",o.symbol=c;else if(i==="spot")o.side="out",o.symbol=d;else throw new Di(this.id+" transfer() requires either fromAccount or toAccount to be spot");const u=await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(o,n));return this.extend(this.parseTransfer(u,r),{amount:this.parseNumber(a),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={1e3:"ok",OK:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"data",{});return{id:this.safeString(s,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString2(e,"code","message"))}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Di(this.id+" fetchBorrowInterest() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id};i!==void 0&&(a.N=i),s!==void 0&&(a.start_time=s);const o=await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]),u=this.parseBorrowInterests(c,r);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"create_time");return{symbol:this.safeString(t,"symbol"),marginMode:"isolated",currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest_amount"),interestRate:this.safeNumber(e,"hourly_interest"),amountBorrowed:this.safeNumber(e,"borrow_amount"),timestamp:i,datetime:this.iso8601(i),info:e}}handleMarginModeAndParams(e,t={},s=void 0){let i;if([i,t]=super.handleMarginModeAndParams(e,t,s),i!==void 0&&i!=="isolated")throw new Fi(this.id+" only isolated margin is supported");return[i,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let o=this.implodeHostname(this.urls.api.rest)+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));let c="";const u=s==="GET"||s==="DELETE";if(u&&Object.keys(d).length&&(c=this.urlencode(d),o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=this.milliseconds().toString();n={"X-BM-KEY":this.apiKey,"X-BM-TIMESTAMP":h,"Content-Type":"application/json"},u||(r=this.json(d),c=r);const f=h+"#"+this.uid+"#"+c,l=this.hmac(this.encode(f),this.encode(this.secret));n["X-BM-SIGN"]=l}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeStringLower(a,"message"),u=this.safeString(a,"code");if(u!==void 0&&u!=="1000"||c!==void 0&&c!=="ok"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h),new nt(h)}}};const tq=re,{TICK_SIZE:sq}=ne,{AuthenticationError:iw,BadRequest:el,DDoSProtection:iq,ExchangeError:tl,ExchangeNotAvailable:nw,InsufficientFunds:nq,InvalidOrder:ba,OrderNotFound:rw,PermissionDenied:sl,ArgumentsRequired:_c,BadSymbol:il}=Q,cs=ae;var lT=class extends tq{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:["SC"],version:"v1",userAgent:void 0,rateLimit:100,pro:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,reduceMargin:void 0,setLeverage:!0,setMargin:void 0,setMarginMode:!0,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:{public:"https://testnet.bitmex.com",private:"https://testnet.bitmex.com"},logo:"https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",api:{public:"https://www.bitmex.com",private:"https://www.bitmex.com"},www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees",referral:"https://www.bitmex.com/register/upZpOX"},api:{public:{get:{announcement:5,"announcement/urgent":5,funding:5,instrument:5,"instrument/active":5,"instrument/activeAndIndices":5,"instrument/activeIntervals":5,"instrument/compositeIndex":5,"instrument/indices":5,insurance:5,leaderboard:5,liquidation:5,orderBook:5,"orderBook/L2":5,quote:5,"quote/bucketed":5,schema:5,"schema/websocketHelp":5,settlement:5,stats:5,"stats/history":5,trade:5,"trade/bucketed":5,"wallet/assets":5,"wallet/networks":5}},private:{get:{apiKey:5,chat:5,"chat/channels":5,"chat/connected":5,execution:5,"execution/tradeHistory":5,notification:5,order:5,position:5,user:5,"user/affiliateStatus":5,"user/checkReferralCode":5,"user/commission":5,"user/depositAddress":5,"user/executionHistory":5,"user/margin":5,"user/minWithdrawalFee":5,"user/wallet":5,"user/walletHistory":5,"user/walletSummary":5,"wallet/assets":5,"wallet/networks":5,userEvent:5},post:{apiKey:5,"apiKey/disable":5,"apiKey/enable":5,chat:5,order:1,"order/bulk":5,"order/cancelAllAfter":5,"order/closePosition":5,"position/isolate":1,"position/leverage":1,"position/riskLimit":5,"position/transferMargin":1,"user/cancelWithdrawal":5,"user/confirmEmail":5,"user/confirmEnableTFA":5,"user/confirmWithdrawal":5,"user/disableTFA":5,"user/logout":5,"user/logoutAll":5,"user/preferences":5,"user/requestEnableTFA":5,"user/requestWithdrawal":5},put:{order:1,"order/bulk":5,user:5},delete:{apiKey:5,order:1,"order/all":1}}},exceptions:{exact:{"Invalid API Key.":iw,"This key is disabled.":sl,"Access Denied":sl,"Duplicate clOrdID":ba,"orderQty is invalid":ba,"Invalid price":ba,"Invalid stopPx for ordType":ba},broad:{"Signature not valid":iw,overloaded:nw,"Account has insufficient Available Balance":nq,"Service unavailable":nw,"Server Error":tl,"Unable to cancel order due to existing state":ba,"We require all new traders to verify":sl}},precisionMode:sq,options:{"api-expires":5,fetchOHLCVOpenTimestamp:!0,networks:{BTC:"btc",ETH:"eth",BSC:"bsc",BNB:"bsc",TRON:"tron",ERC20:"eth",BEP20:"bsc",TRC20:"tron",TRX:"tron",AVAX:"avax",NEAR:"near",XTZ:"xtz",DOT:"dot",SOL:"sol"},networksById:{btc:"BTC",eth:"ERC20",bsc:"BSC",tron:"TRX",avax:"AVAX",near:"NEAR",xtz:"XTZ",dot:"DOT",sol:"SOL"}},commonCurrencies:{USDt:"USDT",XBt:"BTC",XBT:"BTC",Gwei:"ETH",GWEI:"ETH",LAMP:"SOL",LAMp:"SOL"}})}async fetchMarkets(e={}){const t=await this.publicGetInstrumentActiveAndIndices(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeString(n,"underlying"),o=this.safeString(n,"quoteCurrency"),d=this.safeString(n,"settlCurrency",""),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),f=a+o,l=r===f;let m,g=!1,y=!1,w=!1,b=c+"/"+u+":"+h;const S=this.safeString(n,"expiry"),v=this.parse8601(S),T=this.safeValue(n,"isInverse");let A=this.safeString(n,"state")!=="Unlisted";l?m="swap":r.indexOf("B_")>=0?(y=!0,m="prediction",b=r):v!==void 0?(g=!0,m="future",b=b+"-"+this.yymmdd(v)):(w=!0,m="index",b=r,A=!1);const N=this.safeString2(n,"positionCurrency","underlying"),x=this.safeCurrencyCode(N)===u,k=this.safeNumber(n,"maxOrderQty"),O=!w,P=this.safeString(n,"initMargin","1"),q=this.parseNumber(cs.stringDiv("1",P)),L=cs.stringAbs(this.safeString(n,"multiplier"));s.push({id:r,symbol:b,base:c,quote:u,settle:h,baseId:a,quoteId:o,settleId:d,type:m,spot:!1,margin:!1,swap:l,future:g,option:!1,prediction:y,index:w,active:A,contract:O,linear:O?!T:void 0,inverse:O?T:void 0,taker:this.safeNumber(n,"takerFee"),maker:this.safeNumber(n,"makerFee"),contractSize:this.parseNumber(L),expiry:v,expiryDatetime:S,strike:this.safeNumber(n,"optionStrikePrice"),optionType:void 0,precision:{amount:this.safeNumber(n,"lotSize"),price:this.safeNumber(n,"tickSize"),quote:this.safeNumber(n,"tickSize"),base:this.safeNumber(n,"tickSize")},limits:{leverage:{min:O?this.parseNumber("1"):void 0,max:O?q:void 0},amount:{min:void 0,max:x?void 0:k},price:{min:void 0,max:this.safeNumber(n,"maxPrice")},cost:{min:void 0,max:x?k:void 0}},info:n})}return s}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();let o=this.safeString(i,"availableMargin"),d=this.safeString(i,"marginBalance");if(r!=="USDT"){const c=r+"_USDT",u=this.safeMarket(c),h=this.safeValue(u,"info",{}),f=this.safeString(h,"underlyingToPositionMultiplier");f!==void 0?(o=cs.stringDiv(o,f),d=cs.stringDiv(d,f)):(o=cs.stringDiv(o,"1e8"),d=cs.stringDiv(d,"1e8"))}else o=cs.stringDiv(o,"1e6"),d=cs.stringDiv(d,"1e6");a.free=o,a.total=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"all"},s=await this.privateGetUserMargin(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookL2(this.extend(n,s)),a={symbol:e,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let o=0;o<r.length;o++){const d=r[o],c=d.side==="Sell"?"asks":"bids",u=this.safeNumber(d,"size"),h=this.safeNumber(d,"price");h!==void 0&&a[c].push([h,u])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t=void 0,s={}){const i={filter:{orderID:e}},n=await this.fetchOrders(t,void 0,void 0,this.deepExtend(i,s));if(n.length===1)return n[0];throw new rw(this.id+": The order "+e+" not found.")}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetOrder(r);return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={filter:{open:!0}};return await this.fetchOrders(e,t,s,this.deepExtend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetExecutionTradeHistory(r);return this.parseTrades(a,n,t,s)}parseLedgerEntryType(e){const t={Withdrawal:"transaction",RealisedPNL:"margin",UnrealisedPNL:"margin",Deposit:"transaction",Transfer:"transfer",AffiliatePayout:"referral"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"account"),n=this.safeString(e,"tx"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"transactType")),o=this.safeString(e,"currency"),d=this.safeCurrencyCode(o,t);let c=this.safeNumber(e,"amount");c!==void 0&&(c=c/1e8);let u=this.parse8601(this.safeString(e,"transactTime"));u===void 0&&(u=0);let h=this.safeNumber(e,"fee",0);h!==void 0&&(h=h/1e8);const f={cost:h,currency:d};let l=this.safeNumber(e,"walletBalance");l!==void 0&&(l=l/1e8);const m=this.sum(l,-c);let g;c<0?(g="out",c=Math.abs(c)):g="in";const y=this.parseTransactionStatus(this.safeString(e,"transactStatus"));return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),direction:g,account:i,referenceId:n,referenceAccount:r,type:a,currency:d,amount:c,before:m,after:l,status:y,fee:f}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.count=s);const a=await this.privateGetUserWalletHistory(this.extend(r,i));return this.parseLedger(a,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={currency:"all"};s!==void 0&&(n.count=s);const r=await this.privateGetUserWalletHistory(this.extend(n,i)),a=this.filterByArray(r,"transactType",["Withdrawal","Deposit"],!1);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}parseTransactionStatus(e){const t={Canceled:"canceled",Completed:"ok",Pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency");t=this.safeCurrency(s,t);const i=this.parse8601(this.safeString(e,"transactTime")),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeStringLower(e,"transactType");let a,o,d;r==="withdrawal"&&(a=this.safeString(e,"address"),o=this.safeString(e,"tx"),d=a);let c=this.safeString(e,"amount");const u=t.code==="BTC"?"1e8":"1e6";c=cs.stringDiv(cs.stringAbs(c),u);let h=this.safeString(e,"fee");h=cs.stringDiv(h,u);let f=this.safeString(e,"transactStatus");return f!==void 0&&(f=this.parseTransactionStatus(f)),{info:e,id:this.safeString(e,"transactID"),txid:this.safeString(e,"tx"),type:r,currency:t.code,network:this.safeString(e,"status"),amount:this.parseNumber(c),status:f,timestamp:i,datetime:this.iso8601(i),address:a,addressFrom:o,addressTo:d,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:n,comment:void 0,fee:{currency:t.code,cost:this.parseNumber(h),rate:void 0}}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.fetchTickers([s.symbol],t),n=this.safeValue(i,s.symbol);if(n===void 0)throw new il(this.id+" fetchTicker() symbol "+e+" not found");return n}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetInstrumentActiveAndIndices(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=this.safeString(r,"symbol");a!==void 0&&(i[a]=r)}return this.filterByArray(i,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"prevPrice24h"),a=this.safeString(e,"lastPrice");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:void 0,ask:this.safeString(e,"askPrice"),askVolume:void 0,vwap:this.safeString(e,"vwap"),open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"homeNotional24h"),quoteVolume:this.safeString(e,"foreignNotional24h"),info:e},t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,binSize:this.timeframes[t],partial:!0};i!==void 0&&(a.count=i);const o=this.parseTimeframe(t)*1e3,d=this.safeValue(this.options,"fetchOHLCVOpenTimestamp",!0);if(s!==void 0){let h=s;d&&(h=this.sum(h,o));const f=this.ymdhms(h);a.startTime=f}else a.reverse=!0;const c=await this.publicGetTradeBucketed(this.extend(a,n)),u=this.parseOHLCVs(c,r,t,s,i);if(d)for(let h=0;h<u.length;h++)u[h][0]=u[h][0]-o;return u}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString2(e,"avgPx","price"),n=this.safeString2(e,"size","lastQty"),r=this.safeString(e,"execCost"),a=cs.stringDiv(cs.stringAbs(r),"1e8"),o=this.safeString(e,"trdMatchID"),d=this.safeString(e,"orderID"),c=this.safeStringLower(e,"side");let u;const h=cs.stringDiv(this.safeString(e,"execComm"),"1e8");if(h!==void 0){const w=this.safeString(e,"settlCurrency"),b=this.safeCurrencyCode(w),S=this.safeString(e,"commission");u={cost:h,currency:b,rate:S}}const f=this.safeString(e,"execType");let l;h!==void 0&&f==="Trade"&&(l=cs.stringLt(h,"0")?"maker":"taker");const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t),y=this.safeStringLower(e,"ordType");return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:g,id:o,order:d,type:y,takerOrMaker:l,side:c,price:i,cost:a,amount:n,fee:u},t)}parseOrderStatus(e){const t={New:"open",PartiallyFilled:"open",Filled:"closed",DoneForDay:"open",Canceled:"canceled",PendingCancel:"open",PendingNew:"open",Rejected:"rejected",Expired:"expired",Stopped:"open",Untriggered:"open",Triggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={Day:"Day",GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"ordStatus")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"timestamp")),a=this.parse8601(this.safeString(e,"transactTime")),o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"cumQty"),u=this.safeString(e,"avgPx"),h=this.safeString(e,"orderID"),f=this.safeStringLower(e,"ordType"),l=this.safeStringLower(e,"side"),m=this.safeString(e,"clOrdID"),g=this.parseTimeInForce(this.safeString(e,"timeInForce")),y=this.safeNumber(e,"stopPx"),w=this.safeString(e,"execInst");let b;return w!==void 0&&(b=w==="ParticipateDoNotInitiate"),this.safeOrder({info:e,id:h,clientOrderId:m,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:f,timeInForce:g,postOnly:b,side:l,price:o,stopPrice:y,triggerPrice:y,amount:d,cost:void 0,average:u,filled:c,remaining:void 0,status:s,fee:void 0,trades:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0?r.startTime=this.iso8601(t):r.reverse=!0,s!==void 0&&(r.count=s);const a=await this.publicGetTrade(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="future")throw new ba(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap and future markets only");const c={symbol:a.id,side:this.capitalize(s),orderQty:parseFloat(this.amountToPrecision(e,i)),ordType:o};if(d&&(c.execInst="ReduceOnly"),o==="Stop"||o==="StopLimit"||o==="MarketIfTouched"||o==="LimitIfTouched"){const f=this.safeNumber2(r,"stopPx","stopPrice");if(f===void 0)throw new _c(this.id+" createOrder() requires a stopPx or stopPrice parameter for the "+o+" order type");c.stopPx=parseFloat(this.priceToPrecision(e,f)),r=this.omit(r,["stopPx","stopPrice"])}(o==="Limit"||o==="StopLimit"||o==="LimitIfTouched")&&(c.price=parseFloat(this.priceToPrecision(e,n)));const u=this.safeString2(r,"clOrdID","clientOrderId");u!==void 0&&(c.clOrdID=u,r=this.omit(r,["clOrdID","clientOrderId"]));const h=await this.privatePostOrder(this.extend(c,r));return this.parseOrder(h,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={},d=this.safeString2(a,"origClOrdID","clientOrderId");if(d!==void 0){o.origClOrdID=d;const u=this.safeString(a,"clOrdID","clientOrderId");u!==void 0&&(o.clOrdID=u),a=this.omit(a,["origClOrdID","clOrdID","clientOrderId"])}else o.orderID=e;n!==void 0&&(o.orderQty=n),r!==void 0&&(o.price=r);const c=await this.privatePutOrder(this.extend(o,a));return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s)),a=this.safeValue(r,0,{}),o=this.safeString(a,"error");if(o!==void 0&&o.indexOf("Unable to cancel order due to existing state")>=0)throw new rw(this.id+" cancelOrder() failed: "+o);return this.parseOrder(a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrders(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPosition(t);return this.parsePositions(s,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"timestamp"),r=this.safeValue(e,"crossMargin")===!0?"cross":"isolated";let a;t.quote==="USDT"||t.quote==="USD"||t.quote==="EUR"?a=cs.stringMul(this.safeString(e,"foreignNotional"),"-1"):a=this.safeString(e,"homeNotional");const o=this.safeNumber(e,"maintMargin"),d=this.safeNumber(e,"unrealisedPnl"),c=this.omitZero(this.safeNumber(e,"currentQty"));return{info:e,id:this.safeString(e,"account"),symbol:s,timestamp:this.parse8601(i),datetime:i,hedged:void 0,side:void 0,contracts:this.convertValue(c,t),contractSize:void 0,entryPrice:this.safeNumber(e,"avgEntryPrice"),markPrice:this.safeNumber(e,"markPrice"),notional:a,leverage:this.safeNumber(e,"leverage"),collateral:void 0,initialMargin:this.safeNumber(e,"initMargin"),initialMarginPercentage:this.safeNumber(e,"initMarginReq"),maintenanceMargin:this.convertValue(o,t),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),unrealizedPnl:this.convertValue(d,t),liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:r,marginRatio:void 0,percentage:this.safeNumber(e,"unrealisedPnlPcnt")}}convertValue(e,t=void 0){if(e===void 0||t===void 0)return e;let s;if(e=this.numberToString(e),t.quote==="USD"||t.quote==="EUR")s=cs.stringMul(e,"0.00000001");else if(t.quote==="USDT")s=cs.stringMul(e,"0.000001");else{let i;t.quote!==void 0&&(i=this.currency(t.quote)),i!==void 0&&(s=cs.stringMul(e,this.numberToString(i.precision)))}return s=s!==void 0?parseFloat(s):void 0,s}isFiat(e){return e==="EUR"||e==="PLN"}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets(),e!=="BTC")throw new tl(this.id+" supoprts BTC withdrawals only, other currencies coming soon...");const r=this.currency(e),a={currency:"XBt",amount:t,address:s},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetInstrumentActiveAndIndices(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a);this.safeValue(o,"swap",!1)&&i.push(r)}return this.parseFundingRates(i,e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeString(e,"fundingTimestamp");return{info:e,symbol:this.safeSymbol(i,t),markPrice:this.safeNumber(e,"markPrice"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:this.safeNumber(e,"indicativeSettlePrice"),timestamp:this.parse8601(s),datetime:s,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:this.iso8601(n),fundingDatetime:n,nextFundingRate:this.safeNumber(e,"indicativeFundingRate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e in this.currencies){const d=this.currency(e);n.symbol=d.id}else if(e!==void 0){const d=e.split(":"),c=d.length,u=["nearest","daily","weekly","monthly","quarterly","biquarterly","perpetual"];c>1&&this.inArray(d[1],u)?(e=this.currency(d[0]).id+":"+d[1],n.symbol=e):(r=this.market(e),n.symbol=r.id)}t!==void 0&&(n.startTime=this.iso8601(t)),s!==void 0&&(n.count=s);const a=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),a!==void 0&&(n.endTime=this.iso8601(a));const o=await this.publicGetFunding(this.extend(n,i));return this.parseFundingRateHistories(o,r,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t),fundingRate:this.safeNumber(e,"fundingRate"),timestamp:this.parse8601(i),datetime:i}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new _c(this.id+" setLeverage() requires a symbol argument");if(e<.01||e>100)throw new el(this.id+" leverage should be between 0.01 and 100");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new il(this.id+" setLeverage() supports future and swap contracts only");const n={symbol:i.id,leverage:e};return await this.privatePostPositionLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new _c(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new el(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new il(this.id+" setMarginMode() supports swap and future contracts only");const n=e!=="cross",r={symbol:i.id,enabled:n};return await this.privatePostPositionIsolate(this.extend(r,s))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeStringUpper(t,"network");if(s===void 0)throw new _c(this.id+' fetchDepositAddress requires params["network"]');const i=this.currency(e);let n=i.id;const r=this.networkCodeToId(s,i.code),a=n.length;n=n.slice(0,a-1)+n.slice(a-1,a).toLowerCase(),t=this.omit(t,"network");const o={currency:n,network:r},d=await this.privateGetUserDepositAddress(this.extend(o,t));return{currency:e,address:d.replace('"',"").replace('"',""),tag:void 0,network:this.networkIdToCode(r).toUpperCase(),info:d}}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.checkRequiredCredentials(!1),o=this.safeValue(n,"cost",1);return o!==1?a?o:20:o}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(e===429)throw new iq(this.id+" "+r);if(e>=400){const c=this.safeValue(a,"error",{}),u=this.safeString(c,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),e===400?new el(h):new tl(h)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+e;if(s==="GET")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{const c=this.safeString(i,"_format");c!==void 0&&(a+="?"+this.urlencode({_format:c}),i=this.omit(i,"_format"))}const o=this.urls.api[t]+a,d=this.checkRequiredCredentials(!1);if(t==="private"||t==="public"&&d){this.checkRequiredCredentials();let c=s+a,u=this.safeInteger(this.options,"api-expires");n={"Content-Type":"application/json","api-key":this.apiKey},u=this.sum(this.seconds(),u),u=u.toString(),c+=u,n["api-expires"]=u,(s==="POST"||s==="PUT"||s==="DELETE")&&Object.keys(i).length&&(r=this.json(i),c+=r),n["api-signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}};const rq=re,{ExchangeError:aw,ArgumentsRequired:Hn,AuthenticationError:aq,InvalidOrder:nl,InsufficientFunds:oq,BadRequest:ka}=Q,{TICK_SIZE:dq}=ne,cq=ae;var pT=class extends rq{describe(){return this.deepExtend(super.describe(),{id:"bitopro",name:"BitoPro",countries:["TW"],version:"v3",rateLimit:100,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg",api:{rest:"https://api.bitopro.com/v3"},www:"https://www.bitopro.com",doc:["https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md"],fees:"https://www.bitopro.com/fees"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["order-book/{pair}","tickers","tickers/{pair}","trades/{pair}","provisioning/currencies","provisioning/trading-pairs","provisioning/limitations-and-fees","trading-history/{pair}"]},private:{get:["accounts/balance","orders/history","orders/all/{pair}","orders/trades/{pair}","orders/{pair}/{orderId}","wallet/withdraw/{currency}/{serial}","wallet/withdraw/{currency}/id/{id}","wallet/depositHistory/{currency}","wallet/withdrawHistory/{currency}"],post:["orders/{pair}","orders/batch","wallet/withdraw/{currency}"],put:["orders"],delete:["orders/{pair}/{id}","orders/all","orders/{pair}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("3000000"),this.parseNumber("0.00194")],[this.parseNumber("5000000"),this.parseNumber("0.0015")],[this.parseNumber("30000000"),this.parseNumber("0.0014")],[this.parseNumber("300000000"),this.parseNumber("0.0013")],[this.parseNumber("550000000"),this.parseNumber("0.0012")],[this.parseNumber("1300000000"),this.parseNumber("0.0011")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("3000000"),this.parseNumber("0.00097")],[this.parseNumber("5000000"),this.parseNumber("0.0007")],[this.parseNumber("30000000"),this.parseNumber("0.0006")],[this.parseNumber("300000000"),this.parseNumber("0.0005")],[this.parseNumber("550000000"),this.parseNumber("0.0004")],[this.parseNumber("1300000000"),this.parseNumber("0.0003")]]}}},options:{networks:{ERC20:"ERC20",ETH:"ERC20",TRX:"TRX",TRC20:"TRX",BEP20:"BSC",BSC:"BSC"}},precisionMode:dq,exceptions:{exact:{"Unsupported currency.":ka,"Unsupported order type":ka,"Invalid body":ka,"Invalid Signature":aq,"Address not in whitelist.":ka},broad:{"Invalid amount":nl,"Balance for ":oq,"Invalid ":ka,"Wrong parameter":ka}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetProvisioningCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"deposit"),c=this.safeValue(r,"withdraw"),u=this.safeNumber(r,"withdrawFee"),h=this.safeNumber(r,"minWithdraw"),f=this.safeNumber(r,"maxWithdraw"),l={withdraw:{min:h,max:f},amount:{min:void 0,max:void 0}};i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:d&&c,deposit:d,withdraw:c,fee:u,precision:void 0,limits:l}}return i}async fetchMarkets(e={}){const t=await this.publicGetProvisioningTradingPairs(),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=!this.safeValue(r,"maintain"),o=this.safeString(r,"pair"),d=o.toUpperCase(),c=this.safeString(r,"base"),u=this.safeString(r,"quote"),h=this.safeCurrencyCode(c),f=this.safeCurrencyCode(u),l=h+"/"+f,m={amount:{min:this.safeNumber(r,"minLimitBaseAmount"),max:this.safeNumber(r,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}};i.push({id:o,uppercaseId:d,symbol:l,base:h,quote:f,baseId:h,quoteId:f,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,derivative:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:m,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"basePrecision")))},active:a,info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"lastPrice"),last:this.safeString(e,"lastPrice"),previousClose:void 0,change:void 0,percentage:this.safeString(e,"priceChange24hr"),average:void 0,baseVolume:this.safeString(e,"volume24hr"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTrade(e,t){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"orderId");let n;s===void 0?n=this.safeTimestamp(e,"timestamp"):n=this.safeInteger(e,"timestamp");const r=this.safeString(e,"pair");t=this.safeMarket(r,t);const a=this.safeString(t,"symbol"),o=this.safeString(e,"price"),d=this.safeStringLower(e,"type");let c=this.safeStringLower(e,"action");c===void 0&&(this.safeValue(e,"isBuyer")?c="buy":c="sell");let u=this.safeString(e,"amount");u===void 0&&(u=this.safeString(e,"baseAmount"));let h;const f=this.safeString(e,"fee"),l=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));f!==void 0&&(h={cost:f,currency:l,rate:void 0});const m=this.safeValue(e,"isTaker");let g;return m!==void 0&&(m?g="taker":g="maker"),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:a,takerOrMaker:g,type:d,side:c,price:o,amount:u,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProvisioningLimitationsAndFees(e),s=this.safeValue(t,"tradingFeeRate",{}),i=this.safeValue(s,0),n={},r=this.safeNumber(i,"makerFee"),a=this.safeNumber(i,"takerFee");for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];n[d]={info:i,symbol:d,maker:r,taker:a,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={pair:r.id,resolution:a};i===void 0&&(i=500);const d=this.parseTimeframe(t);let c;if(s===void 0)o.to=this.seconds(),o.from=o.to-i*d;else{const l=d*1e3;c=Math.floor(s/l)*l,o.from=Math.floor(s/1e3),o.to=this.sum(o.from,i*d)}const u=await this.publicGetTradingHistoryPair(this.extend(o,n)),h=this.safeValue(u,"data",[]),f=this.parseOHLCVs(h,r,t,s,i);return this.insertMissingCandles(f,d,c,i)}insertMissingCandles(e,t,s,i){if(e.length===0)return e;const r=[];let a=e[0],o;s===void 0?o=a[0]:o=s;let d=0;const c=e.length;let u=0;for(;u<i&&d<c;){const h=e[d];if(h[0]===o)r.push(h),d=this.sum(d,1);else{const f=this.arrayConcat([],a);f[0]=o,f[1]=f[4],f[2]=f[4],f[3]=f[4],f[5]=this.parseNumber("0"),r.push(f)}o=this.sum(o,t*1e3),u=r.length,a=r[u-1]}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.safeString(i,"amount"),d={free:this.safeString(i,"available"),total:a};t[r]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),s=this.safeValue(t,"data",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={"-1":"open",0:"open",1:"open",2:"closed",3:"closed",4:"canceled"};return this.safeString(t,e,void 0)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","orderId"),i=this.safeInteger2(e,"timestamp","createdTimestamp");let n=this.safeString(e,"action");n=n.toLowerCase();const r=this.safeString2(e,"amount","originalAmount"),a=this.safeString(e,"price"),o=this.safeString(e,"pair");t=this.safeMarket(o,t,"_");const d=this.safeString(t,"symbol"),c=this.safeString(e,"status"),u=this.parseOrderStatus(c),h=this.safeStringLower(e,"type"),f=this.safeString(e,"avgExecutionPrice"),l=this.safeString(e,"executedAmount"),m=this.safeString(e,"remainingAmount"),g=this.safeString(e,"timeInForce");let y;const w=this.safeString(e,"fee"),b=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));return cq.stringGt(w,"0")&&(y={currency:b,cost:w}),this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updatedTimestamp"),symbol:d,type:h,timeInForce:g,postOnly:void 0,side:n,price:a,stopPrice:void 0,triggerPrice:void 0,amount:r,cost:void 0,average:f,filled:l,remaining:m,status:u,fee:y,trades:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,pair:a.id,action:s,amount:this.amountToPrecision(e,i),timestamp:this.milliseconds()},d=t.toUpperCase();if(d==="LIMIT"&&(o.price=this.priceToPrecision(e,n)),d==="STOP_LIMIT"){o.price=this.priceToPrecision(e,n);const u=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["triggerPrice","stopPrice"]),u===void 0)throw new nl(this.id+" createOrder() requires a stopPrice parameter for "+d+" orders");o.stopPrice=this.priceToPrecision(e,u);const h=this.safeString(r,"condition");if(h===void 0)throw new nl(this.id+" createOrder() requires a condition parameter for "+d+" orders");o.condition=h}const c=await this.privatePostOrdersPair(this.extend(o,r),r);return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Hn(this.id+" cancelOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,pair:i.id},r=await this.privateDeleteOrdersPairId(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Hn(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(t).uppercaseId,r={};return r[n]=e,await this.privatePutOrders(this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i=this.safeString(this.options,"privateDeleteOrdersPair","privateDeleteOrdersAll");if(e!==void 0){const a=this.market(e);s.pair=a.id,i="privateDeleteOrdersPair"}const n=await this[i](this.extend(s,t));return this.safeValue(n,"data",{})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Hn(this.id+" fetchOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,pair:i.id},r=await this.privateGetOrdersPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hn(this.id+" fetchOrders() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrdersAllPair(this.extend(r,i),i);let o=this.safeValue(a,"data");return o===void 0&&(o=[]),this.parseOrders(o,n,t,s)}fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"OPEN"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"DONE"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hn(this.id+" fetchMyTrades() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrdersTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",INVALID:"failed",PROCESSING:"pending",WAIT_PROCESS:"pending",FAILED:"failed",EXPIRED:"failed",CANCELLED:"failed",EMAIL_VERIFICATION:"pending",WAIT_CONFIRMATION:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"address"),a=this.safeString(e,"message"),o=this.safeString(e,"status");let d=this.safeString(e,"protocol");return d==="MAIN"&&(d=i),{info:e,id:this.safeString(e,"serial"),txid:this.safeString(e,"txid"),type:void 0,currency:i,network:this.networkIdToCode(d),amount:this.safeNumber(e,"total"),status:this.parseTransactionStatus(o),timestamp:n,datetime:this.iso8601(n),address:r,addressFrom:void 0,addressTo:r,tag:a,tagFrom:void 0,tagTo:a,updated:void 0,comment:void 0,fee:{currency:i,cost:this.safeNumber(e,"fee"),rate:void 0}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hn(this.id+" fetchDeposits() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletDepositHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hn(this.id+" fetchWithdrawals() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletWithdrawHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new Hn(this.id+" fetchWithdrawal() requires the code argument");await this.loadMarkets();const i=this.safeCurrency(t),n={serial:e,currency:i.id},r=await this.privateGetWalletWithdrawCurrencySerial(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseTransaction(a,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:this.numberToString(t),address:s};if("network"in n){const c=this.safeValue(this.options,"networks",{}),u=this.safeStringUpper(n,"network");n=this.omit(n,["network"]);const h=this.safeString(c,u);if(h===void 0)throw new aw(this.id+" invalid network "+u);a.protocol=h}i!==void 0&&(a.message=i);const o=await this.privatePostWalletWithdrawCurrency(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n===void 0&&(n={}),n["X-BITOPRO-API"]="ccxt",t==="private"){if(this.checkRequiredCredentials(),s==="POST"||s==="PUT"){r=this.json(i);const d=this.stringToBase64(r),c=this.hmac(d,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=d,n["X-BITOPRO-SIGNATURE"]=c}else if(s==="GET"||s==="DELETE"){Object.keys(o).length&&(a+="?"+this.urlencode(o));let c={nonce:this.milliseconds()};c=this.json(c);const u=this.stringToBase64(c),h=this.hmac(u,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=u,n["X-BITOPRO-SIGNATURE"]=h}}else t==="public"&&s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=200&&e<300)return;const c=this.id+" "+r,u=this.safeString(a,"error");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new aw(c)}};const uq=re,{AuthenticationError:Js,ExchangeError:ow,PermissionDenied:dw,BadRequest:Je,ArgumentsRequired:yi,OrderNotFound:rl,InsufficientFunds:cw,ExchangeNotAvailable:al,DDoSProtection:uw,InvalidAddress:hw,InvalidOrder:wi}=Q,{TICK_SIZE:hq}=ne,Cc=ae;var fq=class extends uq{describe(){return this.deepExtend(super.describe(),{id:"bitpanda",name:"Bitpanda Pro",countries:["AT"],rateLimit:300,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1/MINUTES","5m":"5/MINUTES","15m":"15/MINUTES","30m":"30/MINUTES","1h":"1/HOURS","4h":"4/HOURS","1d":"1/DAYS","1w":"1/WEEKS","1M":"1/MONTHS"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87591171-9a377d80-c6f0-11ea-94ac-97a126eac3bc.jpg",api:{public:"https://api.exchange.bitpanda.com/public",private:"https://api.exchange.bitpanda.com/public"},www:"https://www.bitpanda.com/en/pro",doc:["https://developers.bitpanda.com/exchange/"],fees:"https://www.bitpanda.com/en/pro/fees"},api:{public:{get:["currencies","candlesticks/{instrument_code}","fees","instruments","order-book/{instrument_code}","market-ticker","market-ticker/{instrument_code}","price-ticks/{instrument_code}","time"]},private:{get:["account/balances","account/deposit/crypto/{currency_code}","account/deposit/fiat/EUR","account/deposits","account/deposits/bitpanda","account/withdrawals","account/withdrawals/bitpanda","account/fees","account/orders","account/orders/{order_id}","account/orders/{order_id}/trades","account/trades","account/trades/{trade_id}","account/trading-volume"],post:["account/deposit/crypto","account/withdraw/crypto","account/withdraw/fiat","account/fees","account/orders"],delete:["account/orders","account/orders/{order_id}","account/orders/client/{client_id}"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.001"),tiers:[{taker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100"),this.parseNumber("0.0013")],[this.parseNumber("250"),this.parseNumber("0.0013")],[this.parseNumber("1000"),this.parseNumber("0.001")],[this.parseNumber("5000"),this.parseNumber("0.0009")],[this.parseNumber("10000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("100"),this.parseNumber("0.001")],[this.parseNumber("250"),this.parseNumber("0.0009")],[this.parseNumber("1000"),this.parseNumber("0.00075")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0005")]]}]}},requiredCredentials:{apiKey:!0,secret:!1},precisionMode:hq,exceptions:{exact:{INVALID_CLIENT_UUID:wi,ORDER_NOT_FOUND:rl,ONLY_ONE_ERC20_ADDRESS_ALLOWED:hw,DEPOSIT_ADDRESS_NOT_USED:hw,INVALID_CREDENTIALS:Js,MISSING_CREDENTIALS:Js,INVALID_APIKEY:Js,INVALID_SCOPES:Js,INVALID_SUBJECT:Js,INVALID_ISSUER:Js,INVALID_AUDIENCE:Js,INVALID_DEVICE_ID:Js,INVALID_IP_RESTRICTION:Js,APIKEY_REVOKED:Js,APIKEY_EXPIRED:Js,SYNCHRONIZER_TOKEN_MISMATCH:Js,SESSION_EXPIRED:Js,INTERNAL_ERROR:Js,CLIENT_IP_BLOCKED:dw,MISSING_PERMISSION:dw,ILLEGAL_CHARS:Je,UNSUPPORTED_MEDIA_TYPE:Je,ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG:Je,CANDLESTICKS_TIME_RANGE_TOO_BIG:Je,INVALID_INSTRUMENT_CODE:Je,INVALID_ORDER_TYPE:Je,INVALID_UNIT:Je,INVALID_PERIOD:Je,INVALID_TIME:Je,INVALID_DATE:Je,INVALID_CURRENCY:Je,INVALID_AMOUNT:Je,INVALID_PRICE:Je,INVALID_LIMIT:Je,INVALID_QUERY:Je,INVALID_CURSOR:Je,INVALID_ACCOUNT_ID:Je,INVALID_SIDE:wi,INVALID_ACCOUNT_HISTORY_FROM_TIME:Je,INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE:Je,INVALID_ACCOUNT_HISTORY_TIME_PERIOD:Je,INVALID_ACCOUNT_HISTORY_TO_TIME:Je,INVALID_CANDLESTICKS_GRANULARITY:Je,INVALID_CANDLESTICKS_UNIT:Je,INVALID_ORDER_BOOK_DEPTH:Je,INVALID_ORDER_BOOK_LEVEL:Je,INVALID_PAGE_CURSOR:Je,INVALID_TIME_RANGE:Je,INVALID_TRADE_ID:Je,INVALID_UI_ACCOUNT_SETTINGS:Je,NEGATIVE_AMOUNT:wi,NEGATIVE_PRICE:wi,MIN_SIZE_NOT_SATISFIED:wi,BAD_AMOUNT_PRECISION:wi,BAD_PRICE_PRECISION:wi,BAD_TRIGGER_PRICE_PRECISION:wi,MAX_OPEN_ORDERS_EXCEEDED:Je,MISSING_PRICE:wi,MISSING_ORDER_TYPE:wi,MISSING_SIDE:wi,MISSING_CANDLESTICKS_PERIOD_PARAM:yi,MISSING_CANDLESTICKS_UNIT_PARAM:yi,MISSING_FROM_PARAM:yi,MISSING_INSTRUMENT_CODE:yi,MISSING_ORDER_ID:wi,MISSING_TO_PARAM:yi,MISSING_TRADE_ID:yi,INVALID_ORDER_ID:rl,NOT_FOUND:rl,INSUFFICIENT_LIQUIDITY:cw,INSUFFICIENT_FUNDS:cw,NO_TRADING:al,SERVICE_UNAVAILABLE:al,GATEWAY_TIMEOUT:al,RATELIMIT:uw,CF_RATELIMIT:uw,INTERNAL_SERVER_ERROR:ow},broad:{}},commonCurrencies:{MIOTA:"IOTA"},options:{fetchTradingFees:{method:"fetchPrivateTradingFees"},fiat:["EUR","CHF"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"epoch_millis")}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"code"),a=this.safeCurrencyCode(r);s[a]={id:r,code:a,name:void 0,info:n,active:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),withdraw:void 0,deposit:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeValue(n,"base",{}),a=this.safeValue(n,"quote",{}),o=this.safeString(r,"code"),d=this.safeString(a,"code"),c=o+"_"+d,u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),f=this.safeString(n,"state");s.push({id:c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_size"),max:void 0}},info:n})}return s}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFees(e),s=this.safeValue(t,0,{}),i=this.safeValue(s,"fee_tiers"),n=this.parseFeeTiers(i),r=this.safeValue(i,0,{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:s,symbol:d,maker:this.safeNumber(r,"maker_fee"),taker:this.safeNumber(r,"taker_fee"),percentage:!0,tierBased:!0,tiers:n}}return a}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFees(e),s=this.safeValue(t,"active_fee_tier",{});let i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee");i=Cc.stringDiv(i,"100"),n=Cc.stringDiv(n,"100");const r=this.safeValue(t,"fee_tiers"),a={},o=this.parseFeeTiers(r);for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];a[c]={info:t,symbol:c,maker:this.parseNumber(i),taker:this.parseNumber(n),percentage:!0,tierBased:!0,tiers:o}}return a}parseFeeTiers(e,t=void 0){const s=[],i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"volume");let o=this.safeString(r,"taker_fee"),d=this.safeString(r,"maker_fee");d=Cc.stringDiv(d,"100"),o=Cc.stringDiv(o,"100"),i.push([a,this.parseNumber(d)]),s.push([a,this.parseNumber(o)])}return{maker:i,taker:s}}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"instrument_code"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last_price"),a=this.safeString(e,"price_change_percentage"),o=this.safeString(e,"price_change"),d=this.safeString(e,"base_volume"),c=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_code:s.id},n=await this.publicGetMarketTickerInstrumentCode(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTicker(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_code:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookInstrumentCode(this.extend(n,s)),a=this.parse8601(this.safeString(r,"time"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"granularity"),i=this.safeString(s,"unit"),n=this.safeString(s,"period"),r={MINUTES:"m",HOURS:"h",DAYS:"d",WEEKS:"w",MONTHS:"M"},a=this.safeString(r,i),o=n+a,c=this.parseTimeframe(o)*1e3,u=this.parse8601(this.safeString(e,"time")),h=c*parseInt(u/c),f=this.safeValue(this.options,"fetchOHLCV",{}),l=this.safeString(f,"volume","total_amount");return[h,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,l)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(this.timeframes,t),[o,d]=a.split("/"),u=this.parseTimeframe(t)*1e3;i===void 0&&(i=1500);const h={instrument_code:r.id,period:o,unit:d};if(s===void 0){const l=this.milliseconds();h.to=this.iso8601(l),h.from=this.iso8601(l-i*u)}else h.from=this.iso8601(s),h.to=this.iso8601(this.sum(s,i*u));const f=await this.publicGetCandlesticksInstrumentCode(this.extend(h,n));return this.parseOHLCVs(f,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeValue(e,"fee",{});e=this.safeValue(e,"trade",e);let i=this.safeInteger(e,"trade_timestamp");i===void 0&&(i=this.parse8601(this.safeString(e,"time")));const n=this.safeStringLower2(e,"side","taker_side"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"volume"),d=this.safeString(e,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"fee_amount");let h,f;if(u!==void 0){const l=this.safeString(s,"fee_currency"),m=this.safeCurrencyCode(l),g=this.safeString(s,"fee_percentage");f={cost:u,currency:m,rate:g},h=this.safeStringLower(s,"fee_type")}return this.safeTrade({id:this.safeString2(e,"trade_id","sequence"),order:this.safeString(e,"order_id"),timestamp:i,datetime:this.iso8601(i),symbol:c,type:void 0,side:n,price:r,amount:a,cost:o,takerOrMaker:h,fee:f,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_code:n.id};t!==void 0&&(r.from=this.iso8601(t),r.to=this.iso8601(this.sum(t,144e5)));const a=await this.publicGetPriceTicksInstrumentCode(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalances(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){let s;t!==void 0&&(s=t.code);const i=this.safeString(e,"address"),n=this.safeString(e,"destination_tag");return this.checkAddress(i),{currency:s,address:i,tag:n,network:void 0,info:e}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountDepositCrypto(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_code:s.id},n=await this.privateGetAccountDepositCryptoCurrencyCode(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new yi(this.id+' fetchDeposits() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"deposit_history",[]);return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new yi(this.id+' fetchWithdrawals() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"withdrawal_history",[]);return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:e,amount:this.currencyToPrecision(e,t)},o=this.safeValue(this.options,"fiat",[]),d=this.inArray(e,o),c=d?"privatePostAccountWithdrawFiat":"privatePostAccountWithdrawCrypto";if(d){if(this.safeString(n,"payout_account_id")===void 0)throw new yi(this.id+" withdraw() requires a payout_account_id param for fiat "+e+" withdrawals")}else{const h={address:s};i!==void 0&&(h.destination_tag=i),a.recipient=h}const u=await this[c](this.extend(a,n));return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transaction_id"),i=this.safeNumber(e,"amount"),n=this.parse8601(this.safeString(e,"time")),r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a="ok",o=this.safeNumber2(e,"fee_amount","fee");let d;const c=this.safeString(e,"recipient"),u=this.safeString(e,"destination_tag");if(o!==void 0){const h=this.safeString(e,"fee_currency",r),f=this.safeCurrencyCode(h);d={cost:o,currency:f}}return{info:e,id:s,currency:t.code,amount:i,network:void 0,address:c,addressFrom:void 0,addressTo:c,tag:u,tagFrom:void 0,tagTo:u,status:a,type:void 0,updated:void 0,txid:this.safeString(e,"blockchain_transaction_id"),timestamp:n,datetime:this.iso8601(n),fee:d}}parseOrderStatus(e){const t={FILLED:"open",FILLED_FULLY:"closed",FILLED_CLOSED:"canceled",FILLED_REJECTED:"rejected",OPEN:"open",REJECTED:"rejected",CLOSED:"canceled",FAILED:"failed",STOP_TRIGGERED:"triggered"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"order",e),i=this.safeString(s,"order_id"),n=this.safeString(s,"client_id"),r=this.parse8601(this.safeString(s,"time")),a=this.parseOrderStatus(this.safeString(s,"status")),o=this.parseOrderStatus(a),d=this.safeString(s,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"price"),h=this.safeString(s,"amount"),f=this.safeString(s,"filled_amount"),l=this.safeStringLower(s,"side"),m=this.safeStringLower(s,"type"),g=this.parseTimeInForce(this.safeString(s,"time_in_force")),y=this.safeNumber(s,"trigger_price"),w=this.safeValue(s,"is_post_only"),b=this.safeValue(e,"trades",[]);return this.safeOrder({id:i,clientOrderId:n,info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:c,type:m,timeInForce:g,postOnly:w,side:l,price:u,stopPrice:y,triggerPrice:y,amount:h,cost:void 0,average:void 0,filled:f,remaining:void 0,status:o,trades:b},t)}parseTimeInForce(e){const t={GOOD_TILL_CANCELLED:"GTC",GOOD_TILL_TIME:"GTT",IMMEDIATE_OR_CANCELLED:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_code:a.id,type:o,side:s.toUpperCase(),amount:this.amountToPrecision(e,i)};let c=!1;if((o==="LIMIT"||o==="STOP")&&(c=!0),o==="STOP"){const f=this.safeNumber(r,"trigger_price");if(f===void 0)throw new yi(this.id+" createOrder() requires a trigger_price param for "+t+" orders");d.trigger_price=this.priceToPrecision(e,f),r=this.omit(r,"trigger_price")}c&&(d.price=this.priceToPrecision(e,n));const u=this.safeString2(r,"clientOrderId","client_id");u!==void 0&&(d.client_id=u,r=this.omit(r,["clientOrderId","client_id"]));const h=await this.privatePostAccountOrders(this.extend(d,r));return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(s,"clientOrderId","client_id");s=this.omit(s,["clientOrderId","client_id"]);let n="privateDeleteAccountOrdersOrderId";const r={};return i!==void 0?(n="privateDeleteAccountOrdersClientClientId",r.client_id=i):r.order_id=e,await this[n](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.market(e);s.instrument_code=n.id}return await this.privateDeleteAccountOrders(this.extend(s,t))}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={ids:e.join(",")};return await this.privateDeleteAccountOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetAccountOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new yi(this.id+' fetchOpenOrders() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountOrders(this.extend(n,i)),o=this.safeValue(a,"order_history",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={with_cancelled_and_rejected:!0};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.max_page_size=i);const a=await this.privateGetAccountOrdersOrderIdTrades(this.extend(r,n)),o=this.safeValue(a,"trade_history",[]);let d;return t!==void 0&&(d=this.market(t)),this.parseTrades(o,d,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new yi(this.id+' fetchMyTrades() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountTrades(this.extend(n,i)),o=this.safeValue(a,"trade_history",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&(this.checkRequiredCredentials(),n={Accept:"application/json",Authorization:"Bearer "+this.apiKey},s==="POST"?(r=this.json(o),n["Content-Type"]="application/json"):Object.keys(o).length&&(a+="?"+this.urlencode(o))),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new ow(u)}}};const lq=re,{ExchangeError:Cr,ArgumentsRequired:Gn,ExchangeNotAvailable:Go,InsufficientFunds:dn,OrderNotFound:fw,InvalidOrder:Un,DDoSProtection:ol,InvalidNonce:pq,AuthenticationError:Mr,RateLimitExceeded:lw,PermissionDenied:dl,BadRequest:$t,BadSymbol:mq,AccountSuspended:gq,OrderImmediatelyFillable:cl,OnMaintenance:yq}=Q,{TRUNCATE:pw,TICK_SIZE:wq}=ne,mw=ae;var mT=class extends lq{describe(){return this.deepExtend(super.describe(),{id:"bitrue",name:"Bitrue",countries:["SG"],rateLimit:1e3,certified:!1,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/139516488-243a830d-05dd-446b-91c6-c1f18fe30c63.jpg",api:{v1:"https://www.bitrue.com/api/v1",v2:"https://www.bitrue.com/api/v2",kline:"https://www.bitrue.com/kline-api"},www:"https://www.bitrue.com",referral:"https://www.bitrue.com/activity/task/task-landing?inviteCode=EZWETQE&cn=900000",doc:["https://github.com/Bitrue-exchange/bitrue-official-api-docs"],fees:"https://bitrue.zendesk.com/hc/en-001/articles/4405479952537"},api:{kline:{public:{get:{"public.json":1,"public{currency}.json":1}}},v1:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10]]},trades:1,historicalTrades:5,aggTrades:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},"market/kline":1}},private:{get:{order:1,openOrders:1,allOrders:5,account:5,myTrades:{cost:5,noSymbol:40},"etf/net-value/{symbol}":1,"withdraw/history":1,"deposit/history":1},post:{order:4,"withdraw/commit":1},delete:{order:1}}},v2:{private:{get:{myTrades:5}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.00098"),maker:this.parseNumber("0.00098")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}}},options:{fetchMyTradesMethod:"v2PrivateGetMyTrades",hasAlreadyAuthenticatedSuccessfully:!1,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"FULL"},networks:{ERC20:"ETH",TRC20:"TRX",TRON:"TRX"}},commonCurrencies:{MIM:"MIM Swarm"},precisionMode:wq,exceptions:{exact:{"System is under maintenance.":yq,"System abnormality":Cr,"You are not authorized to execute this request.":dl,"API key does not exist":Mr,"Order would trigger immediately.":cl,"Stop price would trigger immediately.":cl,"Order would immediately match and take.":cl,"Account has insufficient balance for requested action.":dn,"Rest API trading is not enabled.":Go,"You don't have permission.":dl,"Market is closed.":Go,"Too many requests. Please try again later.":ol,"-1000":Go,"-1001":Go,"-1002":Mr,"-1003":lw,"-1013":Un,"-1015":lw,"-1016":Go,"-1020":$t,"-1021":pq,"-1022":Mr,"-1100":$t,"-1101":$t,"-1102":$t,"-1103":$t,"-1104":$t,"-1105":$t,"-1106":$t,"-1111":$t,"-1112":Un,"-1114":$t,"-1115":$t,"-1116":$t,"-1117":$t,"-1118":$t,"-1119":$t,"-1120":$t,"-1121":mq,"-1125":Mr,"-1127":$t,"-1128":$t,"-1130":$t,"-1131":$t,"-2008":Mr,"-2010":Cr,"-2011":fw,"-2013":fw,"-2014":Mr,"-2015":Mr,"-2019":dn,"-3005":dn,"-3006":dn,"-3008":dn,"-3010":Cr,"-3015":Cr,"-3022":gq,"-4028":$t,"-3020":dn,"-3041":dn,"-5013":dn,"-11008":dn,"-4051":dn},broad:{"has no operation privilege":dl,MAX_POSITION:Un}}})}costToPrecision(e,t){return this.decimalToPrecision(t,pw,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,pw,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchStatus(e={}){const t=await this.v1PublicGetPing(e);return{status:Object.keys(t).length?"maintenance":"ok",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v1PublicGetTime(e);return this.safeInteger(t,"serverTime")}safeNetwork(e){const t=e.toUpperCase(),s={Aeternity:"Aeternity",AION:"AION",Algorand:"Algorand",ASK:"ASK",ATOM:"ATOM","AVAX C-Chain":"AVAX C-Chain",bch:"bch",BCH:"BCH",BEP2:"BEP2",BEP20:"BEP20",Bitcoin:"Bitcoin",BRP20:"BRP20",Cardano:"ADA",CasinoCoin:"CasinoCoin","CasinoCoin XRPL":"CasinoCoin XRPL",Contentos:"Contentos",Dash:"Dash",Decoin:"Decoin",DeFiChain:"DeFiChain",DGB:"DGB",Divi:"Divi",dogecoin:"DOGE",EOS:"EOS",ERC20:"ERC20",ETC:"ETC",Filecoin:"Filecoin",FREETON:"FREETON",HBAR:"HBAR","Hedera Hashgraph":"Hedera Hashgraph",HRC20:"HRC20",ICON:"ICON",ICP:"ICP",Ignis:"Ignis","Internet Computer":"Internet Computer",IOTA:"IOTA",KAVA:"KAVA",KSM:"KSM",LiteCoin:"LiteCoin",Luna:"Luna",MATIC:"MATIC","Mobile Coin":"Mobile Coin",MonaCoin:"MonaCoin",Monero:"Monero",NEM:"NEM",NEP5:"NEP5",OMNI:"OMNI",PAC:"PAC",Polkadot:"Polkadot",Ravencoin:"Ravencoin",Safex:"Safex",SOLANA:"SOL",Songbird:"Songbird","Stellar Lumens":"Stellar Lumens",Symbol:"Symbol",Tezos:"XTZ",theta:"theta",THETA:"THETA",TRC20:"TRC20",VeChain:"VeChain",VECHAIN:"VECHAIN",Wanchain:"Wanchain","XinFin Network":"XinFin Network",XRP:"XRP",XRPL:"XRPL",ZIL:"ZIL"};return this.safeString2(s,e,t,e)}async fetchCurrencies(e={}){const t=await this.v1PublicGetExchangeInfo(e),s={},i=this.safeValue(t,"coins",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coin"),o=this.safeString(r,"coinFulName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"enableDeposit"),u=this.safeValue(r,"enableWithdraw"),h=this.safeValue(r,"chains",[]),f={};for(let m=0;m<h.length;m++){const g=h[m],y=this.safeNetwork(g);f[y]={info:g,id:g,network:y,active:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}const l=u&&c;s[d]={id:a,name:o,code:d,precision:void 0,info:r,active:l,deposit:c,withdraw:u,networks:f,fee:this.safeNumber(r,"withdrawFee"),limits:{withdraw:{min:this.safeNumber(r,"minWithdraw"),max:this.safeNumber(r,"maxWithdraw")}}}}return s}async fetchMarkets(e={}){const t=await this.v1PublicGetExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeStringLower(r,"symbol"),d=this.safeString(r,"baseAsset"),c=this.safeString(r,"quoteAsset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeValue(r,"filters",[]),l=this.indexBy(f,"filterType"),m=this.safeString(r,"status"),g=this.safeValue(l,"PRICE_FILTER",{}),y=this.safeValue(l,"LOT_SIZE",{}),w=this.safeString(r,"pricePrecision"),b=this.safeString(r,"quantityPrecision"),S=this.safeString(g,"priceScale",w),v=this.safeString(y,"volumeScale",b),T={id:a,lowercaseId:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(v)),price:this.parseNumber(this.parsePrecision(S)),base:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(y,"minQty"),max:this.safeNumber(y,"maxQty")},price:{min:this.safeNumber(g,"minPrice"),max:this.safeNumber(g,"maxPrice")},cost:{min:this.safeNumber(y,"minVal"),max:void 0}},info:r};i.push(T)}return i}parseBalance(e){const t={info:e},s=this.safeInteger(e,"updateTime"),i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),t[o]=d}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PrivateGetAccount(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:this.safeString(e,"highestBid"),bidVolume:void 0,ask:this.safeString(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeStringUpper(s,"baseId"),n=this.safeStringUpper(s,"quoteId"),r={currency:n,command:"returnTicker"},a=await this.klinePublicGetPublicCurrencyJson(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=i+"_"+n,c=this.safeValue(o,d);if(c===void 0)throw new Cr(this.id+" fetchTicker() could not find the ticker for "+s.symbol);return this.parseTicker(c,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,scale:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=await this.v1PublicGetMarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"i"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchBidsAsks","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTickerBookTicker":i==="delivery"?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](n);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={command:"returnTicker"},i=await this.klinePublicGetPublicJson(this.extend(s,t)),n=this.safeValue(i,"data",{}),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o].replace("_","");r[d]=n[a[o]]}return this.parseTickers(r,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t);let o=this.safeString2(e,"t","a");o=this.safeString2(e,"id","tradeId",o);let d;const c=this.safeString(e,"orderId");"m"in e?d=e.m?"sell":"buy":"isBuyerMaker"in e?d=e.isBuyerMaker?"sell":"buy":"side"in e?d=this.safeStringLower(e,"side"):"isBuyer"in e&&(d=e.isBuyer?"buy":"sell");let u;"commission"in e&&(u={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAssert"))});let h;return"isMaker"in e&&(h=e.isMaker?"maker":"taker"),"maker"in e&&(h=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:a,id:o,order:c,type:void 0,side:d,takerOrMaker:h,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(this.options,"fetchTradesMethod","v1PublicGetAggTrades");s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty");let a,o;"time"in e?a=this.safeInteger(e,"time"):"transactTime"in e?a=this.safeInteger(e,"transactTime"):"updateTime"in e&&s==="open"&&(mw.stringGt(r,"0")?o=this.safeInteger(e,"updateTime"):a=this.safeInteger(e,"updateTime"));const d=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),u=this.safeString(e,"origQty"),h=this.safeString2(e,"cummulativeQuoteQty","cumQuote"),f=this.safeString(e,"orderId");let l=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),y=this.safeString(e,"clientOrderId"),w=this.safeString(e,"timeInForce"),b=l==="limit_maker"||w==="GTX";l==="limit_maker"&&(l="limit");const S=this.safeString(e,"stopPrice"),v=this.parseNumber(this.omitZero(S));return this.safeOrder({info:e,id:f,clientOrderId:y,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:n,type:l,timeInForce:w,postOnly:b,side:m,price:c,stopPrice:v,triggerPrice:v,amount:u,cost:h,average:d,filled:r,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=this.safeValue(a.info,"orderTypes");if(!this.inArray(o,d))throw new Un(this.id+" "+t+" is not a valid order type in market "+e);const c={symbol:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)},u=this.safeString2(r,"newClientOrderId","clientOrderId");if(u!==void 0&&(r=this.omit(r,["newClientOrderId","clientOrderId"]),c.newClientOrderId=u),o==="LIMIT"){if(n===void 0)throw new Un(this.id+" createOrder() requires a price argument");c.price=this.priceToPrecision(e,n)}const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),c.stopPrice=this.priceToPrecision(e,h));const f=await this.v1PrivatePostOrder(this.extend(c,r));return this.parseOrder(f,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Gn(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeValue2(s,"origClientOrderId","clientOrderId");r!==void 0?n.origClientOrderId=r:n.orderId=e;const a=this.omit(s,["type","clientOrderId","origClientOrderId"]),o=await this.v1PrivateGetOrder(this.extend(n,a));return this.parseOrder(o,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gn(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetAllOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gn(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1PrivateGetOpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Gn(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue2(s,"origClientOrderId","clientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=this.omit(s,["type","origClientOrderId","clientOrderId"]),o=await this.v1PrivateDeleteOrder(this.extend(r,a));return this.parseOrder(o,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchMyTradesMethod","v2PrivateGetMyTrades");if(e===void 0&&n==="v2PrivateGetMyTrades")throw new Gn(this.id+" v2PrivateGetMyTrades() requires a symbol argument");await this.loadMarkets();const r={};let a;e!==void 0&&(a=this.market(e),r.symbol=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this[n](this.extend(r,i));return this.parseTrades(o,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gn(this.id+" fetchDeposits() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:1};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gn(this.id+" fetchWithdrawals() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:5};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetWithdrawHistory(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseTransactions(o,n)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",5:"ok",6:"canceled"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdrawId"),i=this.safeString(e,"tagType");let n=this.safeString(e,"addressTo"),r=this.safeString(e,"addressFrom"),a,o;if(i!==void 0){if(n!==void 0){const T=n.split("_");n=this.safeString(T,0),a=this.safeString(T,1)}if(r!==void 0){const T=r.split("_");r=this.safeString(T,0),o=this.safeString(T,1)}}const d=this.safeString(e,"txid"),c=this.safeInteger(e,"createdAt"),u=this.safeInteger(e,"updatedAt"),h="payAmount"in e,f="ctime"in e,l=h||f?"withdrawal":"deposit",m=this.parseTransactionStatusByType(this.safeString(e,"status"),l),g=this.safeNumber(e,"amount");let y,w=this.safeString2(e,"symbol","coin");if(w!==void 0){const T=w.split("_");w=this.safeString(T,0);const I=this.safeString(T,1);I!==void 0&&(y=I.toUpperCase())}const b=this.safeCurrencyCode(w,t),S=this.safeNumber(e,"fee");let v;return S!==void 0&&(v={currency:b,cost:S}),{info:e,id:s,txid:d,timestamp:c,datetime:this.iso8601(c),network:y,address:n,addressTo:n,addressFrom:r,tag:a,tagTo:a,tagFrom:o,type:l,amount:g,currency:b,status:m,updated:u,internal:!1,fee:v}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"chainName");if(a===void 0){const u=this.safeValue(r,"networks",{}),h=this.safeValue(this.options,"networks",{});let f=this.safeStringUpper(n,"network");f=this.safeString(h,f,f);const l=this.safeValue(u,f,{});if(a=this.safeString(l,"id"),a===void 0)throw new Gn(this.id+" withdraw() requires a network parameter or a chainName parameter");n=this.omit(n,"network")}const o={coin:r.id.toUpperCase(),amount:t,addressTo:s,chainName:a};i!==void 0&&(o.tag=i);const d=await this.v1PrivatePostWithdrawCommit(this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="private"){this.checkRequiredCredentials();const c=this.safeInteger(this.options,"recvWindow",5e3);let u=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:c},i));const h=this.hmac(this.encode(u),this.encode(this.secret));u+="&signature="+h,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?d+="?"+u:(r=u,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(d+="?"+this.urlencode(i));return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new ol(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Un(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Un(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Un(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const f=this.safeString(a,"msg");let l;if(f!==void 0){try{l=JSON.parse(f)}catch{l=void 0}l!==void 0&&(a=l)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||mw.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new ol(this.id+" temporary banned: "+r);const f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,h,f),new Cr(f)}if(!c)throw new Cr(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}};const bq=re,{ExchangeError:Uo,InvalidNonce:kq,AuthenticationError:Sq,OrderNotFound:vq,NotSupported:Tq,BadRequest:Oq,ArgumentsRequired:Iq}=Q,{TICK_SIZE:xq}=ne,Sa=ae;var _q=class extends bq{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:["MX"],rateLimit:2e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg",api:{rest:"https://api.bitso.com"},www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees",referral:"https://bitso.com/?ref=itej"},precisionMode:xq,options:{precision:{XRP:1e-6,MXN:.01,TUSD:.01},defaultPrecision:1e-8},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"},api:{public:{get:["available_books","ticker","order_book","trades","ohlc"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders","orders/{oid}","orders/all"]}},exceptions:{"0201":Sq,104:kq,"0304":Oq}})}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n={};s!==void 0&&(n.limit=s);const r=await this.privateGetLedger(this.extend(n,i)),a=this.safeValue(r,"payload",[]);return this.parseLedger(a,e,t,s)}parseLedgerEntryType(e){const t={funding:"transaction",withdrawal:"transaction",trade:"trade",fee:"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"operation"),i=this.parseLedgerEntryType(s),n=this.safeValue(e,"balance_updates",[]),r=this.safeValue(n,0,{});let a,o;const d=this.safeString(r,"amount"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeValue(e,"details",{});let f=this.safeString2(h,"fid","wid");f===void 0&&(f=this.safeString(h,"tid")),s==="funding"?a="in":s==="withdrawal"?a="out":s==="trade"?a=void 0:s==="fee"&&(a="out",o={cost:Sa.stringAbs(d),currency:t});const l=this.parse8601(this.safeString(e,"created_at"));return this.safeLedgerEntry({id:this.safeString(e,"eid"),direction:a,account:void 0,referenceId:f,referenceAccount:void 0,type:i,currency:u,amount:d,timestamp:l,datetime:this.iso8601(l),before:void 0,after:void 0,status:"ok",fee:o,info:e},t)}async fetchMarkets(e={}){const t=await this.publicGetAvailableBooks(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"book"),[o,d]=a.split("_");let c=o.toUpperCase(),u=d.toUpperCase();c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=this.safeValue(r,"fees",{}),f=this.safeValue(h,"flat_rate",{}),l=this.safeString(f,"taker"),m=this.safeString(f,"maker"),g=this.parseNumber(Sa.stringDiv(l,"100")),y=this.parseNumber(Sa.stringDiv(m,"100")),w=this.safeValue(h,"structure",[]),b={taker:g,maker:y,percentage:!0,tierBased:!0},S=[],v=[];for(let A=0;A<w.length;A++){const N=w[A],B=this.safeNumber(N,"volume"),x=this.safeNumber(N,"taker"),k=this.safeNumber(N,"maker");S.push([B,x]),v.push([B,k]),A===0&&(b.taker=x,b.maker=k)}const T={taker:S,maker:v};b.tiers=T;const I=this.safeNumber(this.options.precision,u,this.options.defaultPrecision);i.push(this.extend({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:g,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(this.options.precision,c,this.options.defaultPrecision),price:this.safeNumber(r,"tick_size",I)},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_amount"),max:this.safeNumber(r,"maximum_amount")},price:{min:this.safeNumber(r,"minimum_price"),max:this.safeNumber(r,"maximum_price")},cost:{min:this.safeNumber(r,"minimum_value"),max:this.safeNumber(r,"maximum_value")}},info:r},b))}return i}parseBalance(e){const t=this.safeValue(e,"payload",{}),s=this.safeValue(t,"balances",[]),i={info:e,timestamp:void 0,datetime:void 0};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.used=this.safeString(r,"locked"),d.total=this.safeString(r,"total"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={book:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"payload"),o=this.parse8601(this.safeString(a,"updated_at"));return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Sa.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={book:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"payload");return this.parseTicker(r,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={book:r.id,time_bucket:this.timeframes[t]};if(s!==void 0){if(a.start=s,i!==void 0){const c=this.parseTimeframe(t);a.end=this.sum(s,c*i*1e3)}}else if(i!==void 0){const c=this.milliseconds();a.end=c,a.start=c-this.parseTimeframe(t)*1e3*i}const o=await this.publicGetOhlc(this.extend(a,n)),d=this.safeValue(o,"payload",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger(e,"bucket_start_time"),this.safeNumber(e,"first_rate"),this.safeNumber(e,"max_rate"),this.safeNumber(e,"min_rate"),this.safeNumber(e,"last_rate"),this.safeNumber(e,"volume")]}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"book"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"side","maker_side"),a=this.safeString(e,"maker_side");let o;r===a?o="maker":o="taker";let d=this.safeString2(e,"amount","major");d!==void 0&&(d=Sa.stringAbs(d));let c;const u=this.safeString(e,"fees_amount");if(u!==void 0){const g=this.safeString(e,"fees_currency"),y=this.safeCurrencyCode(g);c={cost:u,currency:y}}let h=this.safeString(e,"minor");h!==void 0&&(h=Sa.stringAbs(h));const f=this.safeString(e,"price"),l=this.safeString(e,"oid"),m=this.safeString(e,"tid");return this.safeTrade({id:m,info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,order:l,type:void 0,side:r,takerOrMaker:o,price:f,amount:d,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={book:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a.payload,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"fees",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"book"),d=this.safeSymbol(o,void 0,"_");n[d]={info:a,symbol:d,maker:this.safeNumber(a,"maker_fee_decimal"),taker:this.safeNumber(a,"taker_fee_decimal"),percentage:!0,tierBased:!0}}return n}async fetchMyTrades(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new Uo(this.id+" fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetUserTrades(this.extend(a,i));return this.parseTrades(o.payload,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={book:a.id,side:s,type:t,major:this.amountToPrecision(a.symbol,i)};t==="limit"&&(o.price=this.priceToPrecision(a.symbol,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeString(d.payload,"oid");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={oid:e};return await this.privateDeleteOrdersOid(this.extend(i,s))}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new Iq(this.id+" cancelOrders() ids argument should be an array");let i;t!==void 0&&(i=this.market(t));const r={oids:e.join(",")},a=await this.privateDeleteOrders(this.extend(r,s)),o=this.safeValue(a,"payload",[]),d=[];for(let c=0;c<o.length;c++){const u=o[c];d.push(this.parseOrder(u,i))}return d}async cancelAllOrders(e=void 0,t={}){if(e!==void 0)throw new Tq(this.id+" cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.");const s=await this.privateDeleteOrdersAll(t),i=this.safeValue(s,"payload",[]),n=[];for(let r=0;r<i.length;r++){const a=this.parseOrder(i[r]);n.push(a)}return n}parseOrderStatus(e){const t={"partial-fill":"open",completed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString(e,"oid");const i=this.safeString(e,"side"),n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeString(e,"book"),a=this.safeSymbol(r,t,"_"),o=this.safeString(e,"type"),d=this.parse8601(this.safeString(e,"created_at")),c=this.safeString(e,"price"),u=this.safeString(e,"original_amount"),h=this.safeString(e,"unfilled_amount"),f=this.safeString(e,"client_id");return this.safeOrder({info:e,id:s,clientOrderId:f,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:i,price:c,stopPrice:void 0,triggerPrice:void 0,amount:u,cost:void 0,remaining:h,filled:void 0,status:n,fee:void 0,average:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new Uo(this.id+" fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetOpenOrders(this.extend(a,i));return this.parseOrders(o.payload,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privateGetOrdersOid({oid:e}),n=this.safeValue(i,"payload");if(Array.isArray(n)&&i.payload.length===1)return this.parseOrder(n[0]);throw new vq(this.id+": The order "+e+" not found.")}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(t),a={oid:e},o=await this.privateGetOrderTradesOid(this.extend(a,n));return this.parseTrades(o.payload,r)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={fid:e},n=await this.privateGetFundingsFid(this.extend(i,s)),r=this.safeValue(n,"payload",[]),a=this.safeValue(r,0,{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetFundings(i),a=this.safeValue(r,"payload",[]);return this.parseTransactions(a,n,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={fund_currency:this.currency(e).id},n=await this.privateGetFundingDestination(this.extend(i,t));let r=this.safeString(n.payload,"account_identifier"),a;if(r.indexOf("?dt=")>=0){const o=r.split("?dt=");r=this.safeString(o,0),a=this.safeString(o,1)}return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i={},n=this.safeValue(s,"payload",{}),r=this.safeValue(n,"deposit_fees",[]);for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u);e!==void 0&&!this.inArray(h,e)||(i[h]={deposit:this.safeNumber(c,"fee"),withdraw:void 0,info:{deposit:c,withdraw:void 0}})}const a=this.safeValue(n,"withdrawal_fees",[]),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeCurrencyCode(c);e!==void 0&&!this.inArray(u,e)||(i[u]={deposit:this.safeValue(i[u],"deposit"),withdraw:this.safeNumber(a,c),info:{deposit:this.safeValue(i[u].info,"deposit"),withdraw:this.safeNumber(a,c)}})}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i=this.safeValue(s,"payload",{});return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={},n=this.safeValue(e,"deposit_fees",[]),r=this.safeValue(e,"withdrawal_fees",[]);for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c);(t===void 0||u in t)&&(i[u]={deposit:{fee:this.safeNumber(d,"fee"),percentage:!this.safeValue(d,"is_fixed")},withdraw:{fee:void 0,percentage:void 0},networks:{},info:d})}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d);if(t===void 0||c in t){const u=this.parseNumber(r[d]);this.safeValue(i,c)===void 0&&(i[c]=this.depositWithdrawFee({})),i[c].withdraw.fee=u,i[c].info[c]=u}}return i}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},a=this.currency(e),o=e in r?r[e]:void 0;if(o===void 0)throw new Uo(this.id+" not valid withdraw coin: "+e);const d={amount:t,address:s,destination_tag:i},c="privatePost"+o+"Withdrawal",u=await this[c](this.extend(d,n)),h=this.safeValue(u,"payload",[]),f=this.safeValue(h,0);return this.parseTransaction(f,a)}safeNetwork(e){if(e===void 0)return;e=e.toUpperCase();const t={trx:"TRC20",erc20:"ERC20",bsc:"BEP20",bep2:"BEP2"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"currency","asset");t=this.safeCurrency(s,t);const i=this.safeValue(e,"details",{}),n=this.safeString(e,"created_at"),r=this.safeString(i,"withdrawal_address"),a=this.safeString(i,"receiving_address"),o=this.safeString2(e,"network","method"),d=this.safeString(e,"status"),c=this.safeString(e,"wid");return{id:this.safeString2(e,"wid","fid"),txid:this.safeString(i,"tx_hash"),timestamp:this.parse8601(n),datetime:n,network:this.safeNetwork(o),addressFrom:a,address:r!==void 0?r:a,addressTo:r,amount:this.safeString(e,"amount"),type:c===void 0?"deposit":"withdrawal",currency:this.safeCurrencyCode(s,t),status:this.parseTransactionStatus(d),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseTransactionStatus(e){const t={pending:"pending",in_progress:"pending",complete:"ok",failed:"failed"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));(s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");s!=="GET"&&s!=="DELETE"&&Object.keys(o).length&&(r=this.json(o),u+=r);const h=this.hmac(this.encode(u),this.encode(this.secret)),f=this.apiKey+":"+c+":"+h;n={Authorization:"Bitso "+f,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.id+" "+this.json(a),h=this.safeValue(a,"error");if(h===void 0)throw new Uo(u);const f=this.safeString(h,"code");throw this.throwExactlyMatchedException(this.exceptions,f,u),new Uo(u)}}}};const Cq=re,{AuthenticationError:va,BadRequest:Mq,ExchangeError:gw,NotSupported:Pq,PermissionDenied:Mc,InvalidNonce:Aq,OrderNotFound:Bq,InsufficientFunds:Nq,InvalidAddress:Vq,InvalidOrder:ul,OnMaintenance:Eq,ExchangeNotAvailable:qq}=Q,{TICK_SIZE:Lq}=ne,$n=ae;var gT=class extends Cq{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:["GB"],rateLimit:75,version:"v2",userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{public:"https://www.bitstamp.net/api",private:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"259200"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{"ohlc/{pair}/":1,"order_book/{pair}/":1,"ticker_hour/{pair}/":1,"ticker/{pair}/":1,"transactions/{pair}/":1,"trading-pairs-info/":1}},private:{post:{"balance/":1,"balance/{pair}/":1,"bch_withdrawal/":1,"bch_address/":1,"user_transactions/":1,"user_transactions/{pair}/":1,"open_orders/all/":1,"open_orders/{pair}/":1,"order_status/":1,"cancel_order/":1,"cancel_all_orders/":1,"cancel_all_orders/{pair}/":1,"buy/{pair}/":1,"buy/market/{pair}/":1,"buy/instant/{pair}/":1,"sell/{pair}/":1,"sell/market/{pair}/":1,"sell/instant/{pair}/":1,"transfer-to-main/":1,"transfer-from-main/":1,"withdrawal-requests/":1,"withdrawal/open/":1,"withdrawal/status/":1,"withdrawal/cancel/":1,"liquidation_address/new/":1,"liquidation_address/info/":1,"btc_unconfirmed/":1,"websockets_token/":1,"btc_withdrawal/":1,"btc_address/":1,"ripple_withdrawal/":1,"ripple_address/":1,"ltc_withdrawal/":1,"ltc_address/":1,"eth_withdrawal/":1,"eth_address/":1,"xrp_withdrawal/":1,"xrp_address/":1,"xlm_withdrawal/":1,"xlm_address/":1,"pax_withdrawal/":1,"pax_address/":1,"link_withdrawal/":1,"link_address/":1,"usdc_withdrawal/":1,"usdc_address/":1,"omg_withdrawal/":1,"omg_address/":1,"dai_withdrawal/":1,"dai_address/":1,"knc_withdrawal/":1,"knc_address/":1,"mkr_withdrawal/":1,"mkr_address/":1,"zrx_withdrawal/":1,"zrx_address/":1,"gusd_withdrawal/":1,"gusd_address/":1,"aave_withdrawal/":1,"aave_address/":1,"bat_withdrawal/":1,"bat_address/":1,"uma_withdrawal/":1,"uma_address/":1,"snx_withdrawal/":1,"snx_address/":1,"uni_withdrawal/":1,"uni_address/":1,"yfi_withdrawal/":1,yfi_address:1,"audio_withdrawal/":1,"audio_address/":1,"crv_withdrawal/":1,"crv_address/":1,"algo_withdrawal/":1,"algo_address/":1,"comp_withdrawal/":1,"comp_address/":1,grt_withdrawal:1,"grt_address/":1,"usdt_withdrawal/":1,"usdt_address/":1,"eurt_withdrawal/":1,"eurt_address/":1,"matic_withdrawal/":1,"matic_address/":1,"sushi_withdrawal/":1,"sushi_address/":1,"chz_withdrawal/":1,"chz_address/":1,"enj_withdrawal/":1,"enj_address/":1,"alpha_withdrawal/":1,"alpha_address/":1,"ftt_withdrawal/":1,"ftt_address/":1,"storj_withdrawal/":1,"storj_address/":1,"axs_withdrawal/":1,"axs_address/":1,"sand_withdrawal/":1,"sand_address/":1,"hbar_withdrawal/":1,"hbar_address/":1,"rgt_withdrawal/":1,"rgt_address/":1,"fet_withdrawal/":1,"fet_address/":1,"skl_withdrawal/":1,"skl_address/":1,"cel_withdrawal/":1,"cel_address/":1,"sxp_withdrawal/":1,"sxp_address/":1,"ada_withdrawal/":1,"ada_address/":1,"slp_withdrawal/":1,"slp_address/":1,"ftm_withdrawal/":1,"ftm_address/":1,"perp_withdrawal/":1,"perp_address/":1,"dydx_withdrawal/":1,"dydx_address/":1,"gala_withdrawal/":1,"gala_address/":1,"shib_withdrawal/":1,"shib_address/":1,"amp_withdrawal/":1,"amp_address/":1,"sgb_withdrawal/":1,"sgb_address/":1,"avax_withdrawal/":1,"avax_address/":1,"wbtc_withdrawal/":1,"wbtc_address/":1,"ctsi_withdrawal/":1,"ctsi_address/":1,"cvx_withdrawal/":1,"cvx_address/":1,"imx_withdrawal/":1,"imx_address/":1,"nexo_withdrawal/":1,"nexo_address/":1,"ust_withdrawal/":1,"ust_address/":1,"ant_withdrawal/":1,"ant_address/":1,"gods_withdrawal/":1,"gods_address/":1,"rad_withdrawal/":1,"rad_address/":1,"band_withdrawal/":1,"band_address/":1,"inj_withdrawal/":1,"inj_address/":1,"rly_withdrawal/":1,"rly_address/":1,"rndr_withdrawal/":1,"rndr_address/":1,"vega_withdrawal/":1,"vega_address/":1,"1inch_withdrawal/":1,"1inch_address/":1,"ens_withdrawal/":1,"ens_address/":1,"mana_withdrawal/":1,"mana_address/":1,"lrc_withdrawal/":1,"lrc_address/":1,"ape_withdrawal/":1,"ape_address/":1,"mpl_withdrawal/":1,"mpl_address/":1,"euroc_withdrawal/":1,"euroc_address/":1,"sol_withdrawal/":1,"sol_address/":1,"dot_withdrawal/":1,"dot_address/":1,"near_withdrawal/":1,"near_address/":1,"doge_withdrawal/":1,"doge_address/":1,"flr_withdrawal/":1,"flr_address/":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]],maker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,XLM:0,PAX:0,USD:7.5,EUR:0}}},precisionMode:Lq,commonCurrencies:{UST:"USTC"},exceptions:{exact:{"No permission found":Mc,"API key not found":va,"IP address not allowed":Mc,"Invalid nonce":Aq,"Invalid signature":va,"Authentication failed":va,"Missing key, signature and nonce parameters":va,"Wrong API key format":va,"Your account is frozen":Mc,"Please update your profile with your FATCA information, before using API.":Mc,"Order not found.":Bq,"Price is more than 20% below market price.":ul,"Bitstamp.net is under scheduled maintenance. We'll be back soon.":Eq,"Order could not be placed.":qq,"Invalid offset.":Mq},broad:{"Minimum order size is":ul,"Check your account balance for details.":Nq,"Ensure this value has at least":Vq,"Ensure that there are no more than":ul}}})}async fetchMarkets(e={}){const t=await this.fetchMarketsFromCache(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const h=this.safeString(n,"minimum_order").split(" "),f=this.safeString(n,"trading");s.push({id:this.safeString(n,"url_symbol"),marketId:d+"_"+c,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:f==="Enabled",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"base_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"counter_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,0),max:void 0}},info:n})}return s}constructCurrencyObject(e,t,s,i,n,r){let a="crypto";const o=this.describe();this.isFiat(t)&&(a="fiat");const d=this.parseNumber(this.parsePrecision(this.numberToString(i)));return{id:e,code:t,info:r,type:a,name:s,active:!0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(o.fees.funding.withdraw,t),precision:d,limits:{amount:{min:d,max:void 0},price:{min:d,max:void 0},cost:{min:n,max:void 0},withdraw:{min:void 0,max:void 0}}}}async fetchMarketsFromCache(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetTradingPairsInfo(e);this.options.fetchMarkets=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchMarkets,"response")}async fetchCurrencies(e={}){const t=await this.fetchMarketsFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const u=this.safeString(n,"description"),[h,f]=u.split(" / "),g=this.safeString(n,"minimum_order").split(" ")[0];if(!(a in s)){const y=this.safeInteger(n,"base_decimals");s[a]=this.constructCurrencyObject(d,a,h,y,void 0,n)}if(!(o in s)){const y=this.safeInteger(n,"counter_decimals");s[o]=this.constructCurrencyObject(c,o,f,y,this.parseNumber(g),n)}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeInteger(r,"microtimestamp"),o=parseInt(a/1e3),d=this.parseOrderBook(r,i.symbol,o);return d.nonce=a,d}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=$n.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}getCurrencyIdFromTransaction(e){const t=this.safeStringLower(e,"currency");if(t!==void 0)return t;e=this.omit(e,["fee","price","datetime","type","status","id"]);const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(n.indexOf("_")<0){const r=this.safeNumber(e,n);if(r!==void 0&&r!==0)return n}}}getMarketFromTrade(e){e=this.omit(e,["fee","price","datetime","tid","type","order_id","side"]);const t=Object.keys(e),s=t.length;if(s>2)throw new gw(this.id+" getMarketFromTrade() too many keys: "+this.json(t)+" in the trade: "+this.json(e));if(s===2){let i=t[0]+t[1];if(i in this.markets_by_id)return this.safeMarket(i);if(i=t[1]+t[0],i in this.markets_by_id)return this.safeMarket(i)}}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tid");let i,n,r=this.safeString(e,"price"),a=this.safeString(e,"amount");const o=this.safeString(e,"order_id"),d=void 0;let c=this.safeString(e,"cost"),u;if(t===void 0){const y=Object.keys(e);for(let w=0;w<y.length;w++){const b=y[w];b!=="order_id"&&b.indexOf("_")>=0&&(u=b,t=this.safeMarket(u,t,"_"))}}t===void 0&&(t=this.getMarketFromTrade(e));const h=this.safeString(e,"fee"),f=t.quote;r=this.safeString(e,u,r),a=this.safeString(e,t.baseId,a),c=this.safeString(e,t.quoteId,c),i=t.symbol;const l=this.safeString2(e,"date","datetime");let m;l!==void 0&&(l.indexOf(" ")>=0?m=this.parse8601(l):(m=parseInt(l),m=m*1e3)),"id"in e?a!==void 0&&($n.stringLt(a,"0")?(n="sell",a=$n.stringNeg(a)):n="buy"):(n=this.safeString(e,"type"),n==="1"?n="sell":n==="0"?n="buy":n=void 0),c!==void 0&&(c=$n.stringAbs(c));let g;return h!==void 0&&(g={cost:h,currency:f}),this.safeTrade({id:s,info:e,timestamp:m,datetime:this.iso8601(m),symbol:i,order:o,type:d,side:n,takerOrMaker:void 0,price:r,amount:a,cost:c,fee:g},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id,time:"hour"},a=await this.publicGetTransactionsPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,step:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0)if(s===void 0)a.limit=1e3;else{i=1e3;const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o),a.limit=i}else{if(s!==void 0){const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o)}a.limit=Math.min(i,1e3)}const d=await this.publicGetOhlcPair(this.extend(a,n)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"ohlc",[]);return this.parseOHLCVs(u,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.privatePostBalancePair(this.extend(i,t));return this.parseTradingFee(n,s)}parseTradingFee(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,t.id+"_fee"),i=$n.stringDiv(s,"100"),n=this.parseNumber(i);return{info:e,symbol:t.symbol,maker:n,taker:n}}parseTradingFees(e){const t={info:e},s=this.symbols;for(let i=0;i<s.length;i++){const n=s[i],r=this.market(n),a=this.parseTradingFee(e,r);t[n]=a}return t}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseTradingFees(t)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostBalance(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){t===void 0&&(t=Object.keys(this.currencies));const s={};let i;const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_")[0],d=this.safeCurrencyCode(o);t!==void 0&&!this.inArray(d,t)||(a.indexOf("_available")>=0&&(i=o,s[d]={deposit:void 0,withdraw:void 0,info:{}}),o===i&&(s[d].info[a]=this.safeNumber(e,a)),a.indexOf("_withdrawal_fee")>=0&&(s[d].withdraw=this.safeNumber(e,a)))}return s}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostBalance(t);return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_")[0],d=this.safeCurrencyCode(o),c=this.safeNumber(e,a);if(t!==void 0&&!this.inArray(d,t))continue;a.indexOf("_available")>=0&&(i[d]=this.depositWithdrawFee({})),a.indexOf("_withdrawal_fee")>=0&&(i[d].withdraw.fee=c),this.safeValue(i,d)!==void 0&&(i[d].info[a]=c)}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o="privatePost"+this.capitalize(s);const d={pair:a.id,amount:this.amountToPrecision(e,i)};t==="market"?o+="Market":t==="instant"?o+="Instant":d.price=this.priceToPrecision(e,n),o+="Pair";const c=this.safeString2(r,"client_order_id","clientOrderId");c!==void 0&&(d.client_order_id=c,r=this.omit(r,["client_order_id","clientOrderId"]));const u=await this[o](this.extend(d,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};let n="privatePostCancelAllOrders";return e!==void 0&&(s=this.market(e),i.pair=s.id,n="privatePostCancelAllOrdersPair"),await this[n](this.extend(i,t))}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"client_order_id","clientOrderId"),n={};i!==void 0?(n.client_order_id=i,s=this.omit(s,["client_order_id","clientOrderId"])):n.id=e;const r=await this.privatePostOrderStatus(this.extend(n,s));return this.parseOrderStatus(this.safeString(r,"status"))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.safeValue2(s,"client_order_id","clientOrderId"),r={};n!==void 0?(r.client_order_id=n,s=this.omit(s,["client_order_id","clientOrderId"])):r.id=e;const a=await this.privatePostOrderStatus(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostUserTransactions",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i)),d=this.filterBy(o,"type","2");return this.parseTrades(d,a,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.filterByArray(r,"type",["0","1"],!1);return this.parseTransactions(o,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0?n.timedelta=this.milliseconds()-t:n.timedelta=5e7;const r=await this.privatePostWithdrawalRequests(this.extend(n,i));return this.parseTransactions(r,void 0,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"datetime")),i=this.getCurrencyIdFromTransaction(e),n=this.safeCurrencyCode(i,t),r=this.safeString(e,"fee");let a,o;"amount"in e?o=this.safeString(e,"amount"):t!==void 0?(o=this.safeString(e,t.id,o),a=t.code):n!==void 0&&i!==void 0&&(o=this.safeString(e,i,o),a=n),o!==void 0&&(o=$n.stringAbs(o));let d="ok";"status"in e&&(d=this.parseTransactionStatus(this.safeString(e,"status")));let c;if("type"in e){const l=this.safeString(e,"type");l==="0"?c="deposit":l==="1"&&(c="withdrawal")}else c="withdrawal";let u,h=this.safeString(e,"address");if(h!==void 0){const l=h.split("?dt=");l.length>1&&(h=l[0],u=l[1])}let f={currency:void 0,cost:void 0,rate:void 0};return r!==void 0&&(f={currency:a,cost:r,rate:void 0}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),type:c,currency:n,network:void 0,amount:this.parseNumber(o),status:d,timestamp:s,datetime:this.iso8601(s),address:h,addressFrom:void 0,addressTo:h,tag:u,tagFrom:void 0,tagTo:u,updated:void 0,comment:void 0,fee:f}}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"ok",3:"canceled",4:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id");let n=this.safeString(e,"type");n!==void 0&&(n=n==="1"?"sell":"buy");const r=this.parse8601(this.safeString(e,"datetime")),a=this.safeStringLower(e,"currency_pair"),o=this.safeSymbol(a,t,"/"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"amount"),u=this.safeValue(e,"transactions",[]),h=this.safeString(e,"price");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:d,symbol:o,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:c,filled:void 0,remaining:void 0,trades:u,fee:void 0,info:e,average:void 0},t)}parseLedgerEntryType(e){const t={0:"transaction",1:"transaction",2:"trade",14:"transfer"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString(e,"type"));if(s==="trade"){const i=this.parseTrade(e);let n;const r=Object.keys(e);for(let o=0;o<r.length;o++)if(r[o].indexOf("_")>=0){const d=r[o].replace("_","");n=this.safeMarket(d,n)}n===void 0&&(n=this.getMarketFromTrade(e));const a=i.side==="buy"?"in":"out";return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:a,account:void 0,referenceId:i.order,referenceAccount:void 0,type:s,currency:n.base,amount:i.amount,before:void 0,after:void 0,status:"ok",fee:i.fee}}else{const i=this.parseTransaction(e,t);let n;if("amount"in e){const r=this.safeString(e,"amount");n=$n.stringGt(r,"0")?"in":"out"}else if("currency"in i&&i.currency!==void 0){const r=this.safeString(i,"currency");t=this.currency(r);const a=this.safeString(e,t.id);n=$n.stringGt(a,"0")?"in":"out"}return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:n,account:void 0,referenceId:i.txid,referenceAccount:void 0,type:s,currency:i.currency,amount:i.amount,before:void 0,after:void 0,status:i.status,fee:i.fee}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;return e!==void 0&&(a=this.currency(e)),this.parseLedger(r,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let n;await this.loadMarkets(),e!==void 0&&(n=this.market(e));const r=await this.privatePostOpenOrdersAll(i);return this.parseOrders(r,n,t,s,{status:"open",type:"limit"})}getCurrencyName(e){return e.toLowerCase()}isFiat(e){return e==="USD"||e==="EUR"||e==="GBP"}async fetchDepositAddress(e,t={}){if(this.isFiat(e))throw new Pq(this.id+" fiat fetchDepositAddress() for "+e+" is not supported!");const s=this.getCurrencyName(e),i="privatePost"+this.capitalize(s)+"Address",n=await this[i](t),r=this.safeString(n,"address"),a=this.safeString2(n,"memo_id","destination_tag");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r={amount:t};let a,o;if(this.isFiat(e))o="privatePostWithdrawalOpen",a=this.currency(e),r.iban=s,r.account_currency=a.id;else{const c=this.getCurrencyName(e);o="privatePost"+this.capitalize(c)+"Withdrawal",e==="XRP"?i!==void 0&&(r.destination_tag=i):(e==="XLM"||e==="HBAR")&&i!==void 0&&(r.memo_id=i),r.address=s}const d=await this[o](this.extend(r,n));return this.parseTransaction(d,a)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";a+=this.version+"/",a+=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d="BITSTAMP "+this.apiKey,c=this.uuid(),u=this.milliseconds().toString(),h="v2";let f="";n={"X-Auth":d,"X-Auth-Nonce":c,"X-Auth-Timestamp":u,"X-Auth-Version":h},s==="POST"&&(Object.keys(o).length?(r=this.urlencode(o),f="application/x-www-form-urlencoded",n["Content-Type"]=f):(r=this.urlencode({foo:"bar"}),f="application/x-www-form-urlencoded",n["Content-Type"]=f));const l=r||"",m=d+s+a.replace("https://","")+f+c+u+h+l,g=this.hmac(this.encode(m),this.encode(this.secret));n["X-Auth-Signature"]=g}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"status"),u=this.safeValue(a,"error");if(c==="error"||u!==void 0){let h=[];if(typeof u=="string")h.push(u);else if(u!==void 0){const g=Object.keys(u);for(let y=0;y<g.length;y++){const w=g[y],b=this.safeValue(u,w);Array.isArray(b)?h=this.arrayConcat(h,b):h.push(b)}}const f=this.safeValue(a,"reason",{});if(typeof f=="string")h.push(f);else{const g=this.safeValue(f,"__all__",[]);for(let y=0;y<g.length;y++)h.push(g[y])}if(this.safeString(a,"code")==="API0005")throw new va(this.id+" invalid signature, use the uid for the main account if you have subaccounts");const m=this.id+" "+r;for(let g=0;g<h.length;g++){const y=h[g];this.throwExactlyMatchedException(this.exceptions.exact,y,m),this.throwBroadlyMatchedException(this.exceptions.broad,y,m)}throw new gw(m)}}};const Rq=re,{BadSymbol:Dq,ExchangeError:$o}=Q,{TICK_SIZE:Fq}=ne,Hq=ae;var Gq=class extends Rq{describe(){return this.deepExtend(super.describe(),{id:"bitstamp1",name:"Bitstamp",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOrder:void 0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{rest:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["ticker","ticker_hour","order_book","transactions","eur_usd"]},private:{post:["balance","user_transactions","open_orders","order_status","cancel_order","cancel_all_orders","buy","sell","bitcoin_deposit_address","unconfirmed_btc","ripple_withdrawal","ripple_address","withdrawal_requests","bitcoin_withdrawal"]}},precisionMode:Fq,markets:{"BTC/USD":{id:"btcusd",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"btc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"BTC/EUR":{id:"btceur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"EUR/USD":{id:"eurusd",symbol:"EUR/USD",base:"EUR",quote:"USD",baseId:"eur",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/USD":{id:"xrpusd",symbol:"XRP/USD",base:"XRP",quote:"USD",baseId:"xrp",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/EUR":{id:"xrpeur",symbol:"XRP/EUR",base:"XRP",quote:"EUR",baseId:"xrp",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/BTC":{id:"xrpbtc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/USD":{id:"ltcusd",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"ltc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/EUR":{id:"ltceur",symbol:"LTC/EUR",base:"LTC",quote:"EUR",baseId:"ltc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/USD":{id:"ethusd",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"eth",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/EUR":{id:"etheur",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"eth",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/BTC":{id:"ethbtc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0}}})}async fetchOrderBook(e,t=void 0,s={}){if(e!=="BTC/USD")throw new $o(this.id+" "+this.version+" fetchOrderBook doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const i=await this.publicGetOrderBook(s),n=this.safeTimestamp(i,"timestamp");return this.parseOrderBook(i,e,n)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Hq.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/USD")throw new $o(this.id+" "+this.version+" fetchTicker doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const s=this.market(e),i=await this.publicGetTicker(t);return this.parseTicker(i,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","datetime"),i=e.type===0?"buy":"sell",n=this.safeString(e,"order_id"),r=this.safeString(e,"tid"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"currency_pair");return t=this.safeMarket(d,t),this.safeTrade({id:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:n,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e!=="BTC/USD")throw new Dq(this.id+" "+this.version+" fetchTrades doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const n=this.market(e),r={time:"minute"},a=await this.publicGetTransactions(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new $o(this.id+" "+this.version+" accepts limit orders only");if(e!=="BTC/USD")throw new $o(this.id+" v1 supports BTC/USD orders only");await this.loadMarkets();const a="privatePost"+this.capitalize(s),o={amount:i,price:n},d=await this[a](this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){return await this.privatePostCancelOrder({id:e})}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrderStatus(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const a={id:n?n.id:"all"},o=await this.privatePostOpenOrdersId(this.extend(a,i));return this.parseTrades(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.encode(this.hmac(this.encode(c),this.encode(this.secret)));o=this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o),r=this.urlencode(o),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"status")==="error")throw new $o(this.id+" "+this.json(a))}};const Uq=re,{ArgumentsRequired:$q,BadSymbol:yw,ExchangeError:ww,ExchangeNotAvailable:Wq,AuthenticationError:Wo,InvalidOrder:Wn,InsufficientFunds:zq,OrderNotFound:Ta,DDoSProtection:bw,PermissionDenied:jq,AddressPending:kw,OnMaintenance:Kq,BadRequest:hl,InvalidAddress:Xq}=Q,{TRUNCATE:Yq,TICK_SIZE:Zq}=ne;var yT=class extends Uq{describe(){return this.deepExtend(super.describe(),{id:"bittrex",name:"Bittrex",countries:["US"],version:"v3",rateLimit:1500,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","1h":"HOUR_1","1d":"DAY_1"},hostname:"bittrex.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87153921-edf53180-c2c0-11ea-96b9-f2a9a95a455b.jpg",api:{public:"https://api.bittrex.com",private:"https://api.bittrex.com"},www:"https://bittrex.com",doc:["https://bittrex.github.io/api/v3"],fees:["https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS","https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-"],referral:"https://bittrex.com/Account/Register?referralCode=1ZE-G0G-M3B"},api:{public:{get:["ping","currencies","currencies/{symbol}","markets","markets/tickers","markets/summaries","markets/{marketSymbol}","markets/{marketSymbol}/summary","markets/{marketSymbol}/orderbook","markets/{marketSymbol}/trades","markets/{marketSymbol}/ticker","markets/{marketSymbol}/candles/{candleInterval}/recent","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}/{day}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}"]},private:{get:["account","account/fees/fiat","account/fees/fiat/{currencySymbol}","account/fees/trading","account/fees/trading/{marketSymbol}","account/volume","account/permissions/markets","account/permissions/markets/{marketSymbol}","account/permissions/currencies","account/permissions/currencies/{currencySymbol}","addresses","addresses/{currencySymbol}","balances","balances/{currencySymbol}","deposits/open","deposits/closed","deposits/ByTxId/{txId}","deposits/{depositId}","executions","executions/last-id","executions/{executionId}","orders/closed","orders/open","orders/{orderId}","orders/{orderId}/executions","ping","subaccounts/{subaccountId}","subaccounts","subaccounts/withdrawals/open","subaccounts/withdrawals/closed","subaccounts/deposits/open","subaccounts/deposits/closed","withdrawals/open","withdrawals/closed","withdrawals/ByTxId/{txId}","withdrawals/{withdrawalId}","withdrawals/allowed-addresses","conditional-orders/{conditionalOrderId}","conditional-orders/closed","conditional-orders/open","transfers/sent","transfers/received","transfers/{transferId}","funds-transfer-methods/{fundsTransferMethodId}"],post:["addresses","orders","subaccounts","withdrawals","conditional-orders","transfers","batch"],delete:["orders/open","orders/{orderId}","withdrawals/{withdrawalId}","conditional-orders/{conditionalOrderId}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0075"),taker:this.parseNumber("0.0075")},funding:{tierBased:!1,percentage:!1}},precisionMode:Zq,exceptions:{exact:{BAD_REQUEST:hl,STARTDATE_OUT_OF_RANGE:hl,APISIGN_NOT_PROVIDED:Wo,APIKEY_INVALID:Wo,INVALID_SIGNATURE:Wo,INVALID_CURRENCY:ww,INVALID_PERMISSION:Wo,INSUFFICIENT_FUNDS:zq,INVALID_CEILING_MARKET_BUY:Wn,INVALID_FIAT_ACCOUNT:Wn,INVALID_ORDER_TYPE:Wn,QUANTITY_NOT_PROVIDED:Wn,MIN_TRADE_REQUIREMENT_NOT_MET:Wn,NOT_FOUND:Ta,ORDER_NOT_OPEN:Ta,INVALID_ORDER:Wn,UUID_INVALID:Ta,RATE_NOT_PROVIDED:Wn,INVALID_MARKET:yw,WHITELIST_VIOLATION_IP:jq,DUST_TRADE_DISALLOWED_MIN_VALUE:Wn,RESTRICTED_MARKET:yw,"We are down for scheduled maintenance, but we\u2019ll be back up shortly.":Kq},broad:{throttled:bw,problem:Wq}},options:{fetchTicker:{method:"publicGetMarketsMarketSymbolTicker"},fetchTickers:{method:"publicGetMarketsTickers"},fetchDeposits:{status:"ok"},fetchWithdrawals:{status:"ok"},parseOrderStatus:!1,hasAlreadyAuthenticatedSuccessfully:!1,tag:{NXT:!0,CRYPTO_NOTE_PAYMENTID:!0,BITSHAREX:!0,RIPPLE:!0,NEM:!0,STELLAR:!0,STEEM:!0},subaccountId:void 0,fetchClosedOrdersFilterBySince:!0},commonCurrencies:{BIFI:"Bifrost Finance",BTR:"BTRIPS",GMT:"GMT Token",MEME:"Memetic",MER:"Mercury",PROS:"Pros.Finance",REPV2:"REP",TON:"Tokamak Network"}})}feeToPrecision(e,t){return this.decimalToPrecision(t,Yq,this.markets[e].precision.price,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseCurrencySymbol"),a=this.safeString(n,"quoteCurrencySymbol"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),c=this.safeString(n,"status");s.push({id:this.safeString(n,"symbol"),symbol:o+"/"+d,base:o,quote:d,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:c==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"minTradeSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e},s=this.indexBy(e,"currencySymbol"),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account(),d=s[r];o.free=this.safeString(d,"available"),o.total=this.safeString(d,"total"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={marketSymbol:i.id};if(t!==void 0){if(t!==1&&t!==25&&t!==500)throw new hl(this.id+" fetchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");n.depth=t}const r=await this.publicGetMarketsMarketSymbolOrderbook(this.extend(n,s)),a=this.safeInteger(this.last_response_headers,"Sequence"),o=this.parseOrderBook(r,i.symbol,void 0,"bid","ask","rate","quantity");return o.nonce=a,o}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),o=this.parseNumber("1e-8"),d=this.safeNumber(n,"txFee"),c=this.safeString(n,"status");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),info:n,type:this.safeString(n,"coinType"),name:this.safeString(n,"name"),active:c==="ONLINE",deposit:void 0,withdraw:void 0,fee:d,precision:o,limits:{amount:{min:o,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"updatedAt")),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"percentChange"),a=this.safeString(e,"lastTradeRate");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bidRate"),bidVolume:void 0,ask:this.safeString(e,"askRate"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:r,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchTickers",{}),i=this.safeString(s,"method","publicGetMarketsTickers"),n=this.safeString(t,"method",i);t=this.omit(t,"method");const r=await this[n](t),a=[];for(let o=0;o<r.length;o++){const d=this.parseTicker(r[o]);a.push(d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=this.safeValue(this.options,"fetchTicker",{}),r=this.safeString(n,"method","publicGetMarketsMarketSymbolTicker"),a=this.safeString(t,"method",r);t=this.omit(t,"method");const o=await this[a](this.extend(i,t));return this.parseTicker(o,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetMarketsTickers(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"executedAt")),i=this.safeString(e,"id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"marketSymbol");t=this.safeMarket(r,t,"-");const a=this.safeString(e,"rate"),o=this.safeString(e,"quantity");let d,c=this.safeStringLower2(e,"takerSide","direction");const u=this.safeValue(e,"isTaker");u!==void 0&&(d=u?"taker":"maker",u||(c==="buy"?c="sell":c==="sell"&&(c="buy")));let h;const f=this.safeString(e,"commission");return f!==void 0&&(h={cost:f,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:i,order:n,takerOrMaker:d,type:void 0,side:c,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetPing(e);return this.safeInteger(t,"serverTime")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketSymbol:n.id},a=await this.publicGetMarketsMarketSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=await this.privateGetAccountFeesTradingMarketSymbol(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFeesTrading(e);return this.parseTradingFees(t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"marketSymbol"),i=this.safeNumber(e,"makerRate"),n=this.safeNumber(e,"takerRate");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:n}}parseTradingFees(e){const t={info:e};for(let s=0;s<e.length;s++){const i=this.parseTradingFee(e[s]),n=i.symbol;t[n]=i}return t}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"startsAt")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.baseId+"-"+r.quoteId,o={candleInterval:this.timeframes[t],marketSymbol:a};let d="publicGetMarketsMarketSymbolCandlesCandleIntervalRecent";if(s!==void 0){const u=this.milliseconds(),h=Math.abs(u-s),l=this.yyyymmdd(s).split("-"),m=this.safeInteger(l,0),g=this.safeInteger(l,1),y=this.safeInteger(l,2);t==="1d"?h>316224e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYear",o.year=m):t==="1h"?h>26784e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonth",o.year=m,o.month=g):h>864e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonthDay",o.year=m,o.month=g,o.day=y)}const c=await this[d](this.extend(o,n));return this.parseOHLCVs(c,r,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeValue(i,"stop");e!==void 0&&(r=this.market(e),n.marketSymbol=r.id);let o="privateGetOrdersOpen";a&&(o="privateGetConditionalOrdersOpen");const d=this.omit(i,"stop"),c=await this[o](this.extend(n,d));return this.parseOrders(c,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:e},a=await this.privateGetOrdersOrderIdExecutions(this.extend(r,n));let o;return t!==void 0&&(o=this.market(t)),this.parseTrades(a,o,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;t!==void 0&&(o=t.toUpperCase());const d=a.baseId+"-"+a.quoteId,c=this.safeValue(r,"stop"),u=this.safeNumber2(r,"triggerPrice","stopPrice"),h={marketSymbol:d};let f="privatePostOrders";if(c||u){f="privatePostConditionalOrders";const g=this.safeString(r,"operand");if(g===void 0)throw new $q(this.id+" createOrder() requires an operand parameter");const y=this.safeNumber(r,"trailingStopPercent"),w=this.safeValue(r,"orderToCreate"),b=this.safeValue(r,"orderToCancel");if(u===void 0&&(h.trailingStopPercent=this.priceToPrecision(e,y)),w){const S=o==="CEILING_LIMIT",v=o==="CEILING_MARKET",T=S||v;let I,A,N;if(T){let B;S?(A=this.priceToPrecision(e,n),B=this.safeNumber2(r,"ceiling","cost",i)):v&&(B=this.safeNumber2(r,"ceiling","cost"),B===void 0&&(n===void 0?B=i:B=i*n)),I=this.costToPrecision(e,B),N="IMMEDIATE_OR_CANCEL"}else o==="LIMIT"?(A=this.priceToPrecision(e,n),N="GOOD_TIL_CANCELLED"):N="IMMEDIATE_OR_CANCEL";h.orderToCreate={marketSymbol:d,direction:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i),ceiling:I,limit:A,timeInForce:N,clientOrderId:this.safeString(r,"clientOrderId"),useAwards:this.safeValue(r,"useAwards")}}b&&(h.orderToCancel=b),h.triggerPrice=this.priceToPrecision(e,u),h.operand=g}else{s!==void 0&&(h.direction=s.toUpperCase()),h.type=o;const g=o==="CEILING_LIMIT",y=o==="CEILING_MARKET";if(g||y){let b;g?(h.limit=this.priceToPrecision(e,n),b=this.safeNumber2(r,"ceiling","cost",i)):y&&(b=this.safeNumber2(r,"ceiling","cost"),b===void 0&&(n===void 0?b=i:b=i*n)),h.ceiling=this.costToPrecision(e,b),h.timeInForce="IMMEDIATE_OR_CANCEL"}else h.quantity=this.amountToPrecision(e,i),o==="LIMIT"?(h.limit=this.priceToPrecision(e,n),h.timeInForce="GOOD_TIL_CANCELLED"):h.timeInForce="IMMEDIATE_OR_CANCEL"}const l=this.omit(r,["stop","stopPrice","ceiling","cost","operand","trailingStopPercent","orderToCreate","orderToCancel"]),m=await this[f](this.extend(h,l));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n={},r,a;t!==void 0&&(a=this.market(t)),i?(r="privateDeleteConditionalOrdersConditionalOrderId",n={conditionalOrderId:e}):(r="privateDeleteOrdersOrderId",n={orderId:e});const o=this.omit(s,"stop"),d=await this[r](this.extend(n,o));return this.extend(this.parseOrder(d,a),{id:e,info:d,status:"canceled"})}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.marketSymbol=i.id);const n=await this.privateDeleteOrdersOpen(this.extend(s,t)),r=[];for(let a=0;a<n.length;a++){const o=this.safeValue(n[a],"result",{});r.push(o)}return this.parseOrders(r,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetDepositsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchDeposits",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetDepositsOpen":a="privateGetDepositsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,void 0,s)}async fetchPendingDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchDeposits(e,t,s,this.extend(i,{status:"pending"}))}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetWithdrawalsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchWithdrawals",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetWithdrawalsOpen":a="privateGetWithdrawalsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,t,s)}async fetchPendingWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchWithdrawals(e,t,s,this.extend(i,{status:"pending"}))}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","clientWithdrawalId"),i=this.safeNumber(e,"quantity"),n=this.safeString(e,"cryptoAddress");let r,a;this.safeString(e,"source")==="BLOCKCHAIN"?a=n:r=n;const d=this.safeString(e,"txId"),c=this.parse8601(this.safeString(e,"updatedAt")),u=this.parse8601(this.safeString(e,"createdAt")),h=u||c,f=u===void 0?"deposit":"withdrawal",l=this.safeString(e,"currencySymbol"),m=this.safeCurrencyCode(l,t);let g="pending";if(f==="deposit")g="ok";else{const w=this.safeString(e,"status");w==="ERROR_INVALID_ADDRESS"?g="failed":w==="CANCELLED"?g="canceled":w==="PENDING"?g="pending":(w==="COMPLETED"||w==="AUTHORIZED"&&d!==void 0)&&(g="ok")}let y=this.safeNumber(e,"txCost");return y===void 0&&f==="deposit"&&(y=0),{info:e,id:s,currency:m,amount:i,network:void 0,address:n,addressTo:r,addressFrom:a,tag:void 0,tagTo:void 0,tagFrom:void 0,status:g,type:f,updated:c,txid:d,timestamp:h,datetime:this.iso8601(h),fee:{currency:m,cost:y}}}parseTimeInForce(e){const t={GOOD_TIL_CANCELLED:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK",POST_ONLY_GOOD_TIL_CANCELLED:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"marketSymbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=t.quote,r=this.safeString(e,"createdAt"),a=this.safeString(e,"updatedAt"),o=this.safeString(e,"closedAt"),d=this.safeString(e,"clientOrderId");let c;o!==void 0?c=this.parse8601(o):a&&(c=this.parse8601(a));const u=this.parse8601(r);let h=this.safeStringLower(e,"direction");if(h===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),h=this.safeStringLower(T,"direction")}let f=this.safeStringLower(e,"type");if(f===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),f=this.safeStringLower(T,"type")}let l=this.safeString(e,"quantity");if(l===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),l=this.safeString(T,"quantity")}let m=this.safeString(e,"limit");if(m===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),m=this.safeString(T,"limit")}let g=this.parseTimeInForce(this.safeString(e,"timeInForce"));if(g===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),g=this.parseTimeInForce(this.safeString(T,"timeInForce"))}const y=this.safeString(e,"fillQuantity"),w=this.safeNumber(e,"commission"),b=this.safeString(e,"proceeds"),S=this.safeStringLower(e,"status"),v=g==="PO";return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:d,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:c,symbol:i,type:f,timeInForce:g,postOnly:v,side:h,price:m,stopPrice:this.safeString(e,"triggerPrice"),triggerPrice:this.safeString(e,"triggerPrice"),cost:b,average:void 0,amount:l,filled:y,remaining:void 0,status:S,fee:{cost:w,currency:n},info:e,trades:void 0},t)}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){return this.options.fetchClosedOrdersFilterBySince?super.parseOrders(e,t,s,i,n):super.parseOrders(e,t,void 0,i,n)}parseOrderStatus(e){const t={CLOSED:"closed",OPEN:"open",CANCELLED:"canceled",CANCELED:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n;t!==void 0&&(n=this.market(t));let r,a;try{const o={};i?(a="privateGetConditionalOrdersConditionalOrderId",o.conditionalOrderId=e):(a="privateGetOrdersOrderId",o.orderId=e);const d=this.omit(s,"stop");r=await this[a](this.extend(o,d))}catch(o){throw this.last_json_response&&this.safeString(this.last_json_response,"message")==="UUID_INVALID"?new Ta(this.id+" fetchOrder() error: "+this.last_http_response):o}return this.parseOrder(r,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.ymdhms(t,"T")+"Z");let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.marketSymbol=r.id);const a=await this.privateGetExecutions(this.extend(n,i)),o=this.parseTrades(a,r);return this.filterBySymbolSinceLimit(o,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(i,"stop"),r={};s!==void 0&&(r.pageSize=s),t!==void 0&&(r.startDate=this.ymdhms(t,"T")+"Z");let a;e!==void 0&&(a=this.market(e),r.marketSymbol=a.base+"-"+a.quote);let o="privateGetOrdersClosed";n&&(o="privateGetConditionalOrdersClosed");const d=this.omit(i,"stop"),c=await this[o](this.extend(r,d));return this.parseOrders(c,a,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privatePostAddresses(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new kw(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privateGetAddressesCurrencySymbol(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new kw(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currencySymbol:r.id,quantity:t,cryptoAddress:s};i!==void 0&&(a.cryptoAddressTag=i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="v3",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+"/";if(t==="private"){a+=this.version+"/",this.checkRequiredCredentials(),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e));let o="";s==="POST"?(r=this.json(i),o=r):Object.keys(i).length&&(a+="?"+this.rawencode(i));const d=this.hash(this.encode(o),"sha512","hex"),c=this.milliseconds().toString();let u=c+a+s+d;const h=this.safeValue(this.options,"subaccountId");h!==void 0&&(u+=h);const f=this.hmac(this.encode(u),this.encode(this.secret),"sha512");n={"Api-Key":this.apiKey,"Api-Timestamp":c,"Api-Content-Hash":d,"Api-Signature":f},h!==void 0&&(n["Api-Subaccount-Id"]=h),s==="POST"&&(n["Content-Type"]="application/json")}else t==="public"&&(a+=this.version+"/"),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;let u=this.safeValue(a,"success");if(u===void 0){const h=this.safeString(a,"code");if(h==="NOT_FOUND"&&s.indexOf("addresses")>=0)throw new Xq(c);h!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c));return}if(typeof u=="string"&&(u=u==="true"),!u){const h=this.safeString(a,"message");if(h==="APIKEY_INVALID")throw this.options.hasAlreadyAuthenticatedSuccessfully?new bw(c):new Wo(c);if(h==="INVALID_ORDER"){const f="cancel";if(s.indexOf(f)>=0){const m=s.split("?");if(m.length>1){const w=m[1].split("&"),b=w.length;let S;for(let v=0;v<b;v++){const I=w[v].split("=");if(I[0]==="uuid"){S=I[1];break}}throw S!==void 0?new Ta(this.id+" cancelOrder "+S+" "+this.json(a)):new Ta(this.id+" cancelOrder "+this.json(a))}}}throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new ww(c)}}}};const Qq=re,{ExchangeError:Hi,BadSymbol:Sw,AuthenticationError:In,InsufficientFunds:vw,InvalidOrder:Gi,ArgumentsRequired:zo,OrderNotFound:Jq,InvalidAddress:fl,BadRequest:ei,RateLimitExceeded:Tw,PermissionDenied:Pr,ExchangeNotAvailable:ll,AccountSuspended:eL,OnMaintenance:tL}=Q,{SIGNIFICANT_DIGITS:sL,DECIMAL_PLACES:pl,TRUNCATE:ml,ROUND:iL}=ne,Ow=ae;var wT=class extends Qq{describe(){return this.deepExtend(super.describe(),{id:"bitvavo",name:"Bitvavo",countries:["NL"],rateLimit:60,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/169202626-bd130fc5-fcf9-41bb-8d97-6093225c73cd.jpg",api:{public:"https://api.bitvavo.com",private:"https://api.bitvavo.com"},www:"https://bitvavo.com/",doc:"https://docs.bitvavo.com/",fees:"https://bitvavo.com/en/fees",referral:"https://bitvavo.com/?a=24F34952F7"},api:{public:{get:{time:1,markets:1,assets:1,"{market}/book":1,"{market}/trades":5,"{market}/candles":1,"ticker/price":1,"ticker/book":1,"ticker/24h":{cost:1,noMarket:25}}},private:{get:{account:1,order:1,orders:5,ordersOpen:{cost:1,noMarket:25},trades:5,balance:5,deposit:1,depositHistory:5,withdrawalHistory:5},post:{order:1,withdrawal:1},put:{order:1},delete:{order:1,orders:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0020")],[this.parseNumber("250000"),this.parseNumber("0.0016")],[this.parseNumber("500000"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.0010")],[this.parseNumber("2500000"),this.parseNumber("0.0008")],[this.parseNumber("5000000"),this.parseNumber("0.0006")],[this.parseNumber("10000000"),this.parseNumber("0.0005")],[this.parseNumber("25000000"),this.parseNumber("0.0004")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0006")],[this.parseNumber("1000000"),this.parseNumber("0.0005")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("10000000"),this.parseNumber("0.0003")],[this.parseNumber("25000000"),this.parseNumber("0.0003")]]}}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{101:Hi,102:ei,103:Tw,104:Tw,105:Pr,107:ll,108:ll,109:ll,110:ei,200:ei,201:ei,202:ei,203:Sw,204:ei,205:ei,206:ei,210:Gi,211:Gi,212:Gi,213:Gi,214:Gi,215:Gi,216:vw,217:Gi,230:Hi,231:Hi,232:ei,233:Gi,234:Gi,235:Hi,236:ei,240:Jq,300:In,301:In,302:In,303:In,304:In,305:In,306:In,307:Pr,308:In,309:In,310:Pr,311:Pr,312:Pr,315:ei,317:eL,400:Hi,401:Hi,402:Pr,403:Pr,404:tL,405:Hi,406:ei,407:Hi,408:vw,409:fl,410:Hi,411:ei,412:fl,413:fl,414:Hi},broad:{"start parameter is invalid":ei,"symbol parameter is invalid":Sw,"amount parameter is invalid":Gi,"orderId parameter is invalid":Gi}},options:{"BITVAVO-ACCESS-WINDOW":1e4,fetchCurrencies:{expires:1e3}},precisionMode:sL,commonCurrencies:{MIOTA:"IOTA"}})}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,pl)}amountToPrecision(e,t){return this.decimalToPrecision(t,ml,this.markets[e].precision.amount,pl)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,iL,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,ml,8,pl)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"time")}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.fetchCurrenciesFromCache(e),i=this.indexBy(s,"symbol"),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"market"),d=this.safeString(a,"base"),c=this.safeString(a,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeString(a,"status"),l=this.safeValue(i,d);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f==="trading",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(l,"decimals",8),price:this.safeInteger(a,"pricePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderInBaseAsset"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderInQuoteAsset"),max:void 0}},info:a})}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetAssets(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),d=this.safeValue(n,"depositStatus")==="OK",u=this.safeValue(n,"withdrawalStatus")==="OK",h=d&&u,f=this.safeString(n,"name");s[a]={id:r,info:n,code:a,name:f,active:h,deposit:d,withdraw:u,fee:this.safeNumber(n,"withdrawalFee"),precision:this.safeInteger(n,"decimals",8),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawalMinAmount"),max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last"),a=this.safeString(e,"volume"),o=this.safeString(e,"volumeQuote"),d=this.safeString(e,"open");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker24h(t);return this.parseTickers(s,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.start=t);const a=await this.publicGetMarketTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"amount"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"side"),a=this.safeString2(e,"id","fillId"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),c=this.safeValue(e,"taker");let u;c!==void 0&&(u=c?"taker":"maker");const h=this.safeString(e,"fee");let f;if(h!==void 0){const m=this.safeString(e,"feeCurrency"),g=this.safeCurrencyCode(m);f={cost:h,currency:g}}const l=this.safeString(e,"orderId");return this.safeTrade({info:e,id:a,symbol:d,timestamp:n,datetime:this.iso8601(n),order:l,type:void 0,side:r,takerOrMaker:u,price:s,amount:i,cost:void 0,fee:f},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e),s=this.safeValue(t,"fees"),i=this.safeNumber(s,"maker"),n=this.safeNumber(s,"taker"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:i,taker:n,percentage:!0,tierBased:!0}}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetMarketBook(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol);return a.nonce=this.safeInteger(r,"nonce"),a}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){const d=this.parseTimeframe(t);a.start=s,i===void 0&&(i=1440),a.end=this.sum(s,i*d*1e3)}i!==void 0&&(a.limit=i);const o=await this.publicGetMarketCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"inOrder"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.privateGetDeposit(this.extend(i,t)),r=this.safeString(n,"address"),a=this.safeString(n,"paymentId");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,orderType:t},d=t==="market"||t==="stopLoss"||t==="takeProfit",c=t==="limit"||t==="stopLossLimit"||t==="takeProfitLimit",u=this.safeString(r,"timeInForce");let h=this.safeStringN(r,["triggerPrice","stopPrice","triggerAmount"]);const f=this.isPostOnly(d,!1,r),l=this.safeValue(r,"stopLossPrice"),m=this.safeValue(r,"takeProfitPrice");if(r=this.omit(r,["timeInForce","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),d){let b;if(n!==void 0){const S=this.numberToString(n),v=this.numberToString(i),T=Ow.stringMul(v,S);b=this.parseNumber(T)}else b=this.safeNumber(r,"cost");if(b!==void 0){const S=this.currency(a.quote).precision;o.amountQuote=this.decimalToPrecision(b,ml,S,this.precisionMode)}else o.amount=this.amountToPrecision(e,i);r=this.omit(r,["cost"])}else c&&(o.price=this.priceToPrecision(e,n),o.amount=this.amountToPrecision(e,i));const g=m!==void 0||t==="takeProfit"||t==="takeProfitLimit";l!==void 0||h!==void 0&&!g||t==="stopLoss"||t==="stopLossLimit"?(l!==void 0&&(h=l),o.orderType=d?"stopLoss":"stopLossLimit"):g&&(m!==void 0&&(h=m),o.orderType=d?"takeProfit":"takeProfitLimit"),h!==void 0&&(o.triggerAmount=this.priceToPrecision(e,h),o.triggerType="price",o.triggerReference="lastTrade"),u!==void 0&&u!=="PO"&&(o.timeInForce=u),f&&(o.postOnly=!0);const w=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(w,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);let d={};const c=this.safeNumber(a,"amountRemaining");if(a=this.omit(a,"amountRemaining"),r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.amount=this.amountToPrecision(t,n)),c!==void 0&&(d.amountRemaining=this.amountToPrecision(t,c)),d=this.extend(d,a),Object.keys(d).length){d.orderId=e,d.market=o.id;const u=await this.privatePutOrder(this.extend(d,a));return this.parseOrder(u,o)}else throw new zo(this.id+" editOrder() requires an amount argument, or a price argument, or non-empty params")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new zo(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.market=i.id);const n=await this.privateDeleteOrders(this.extend(s,t));return this.parseOrders(n,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new zo(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateGetOrder(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zo(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id);const a=await this.privateGetOrdersOpen(this.extend(n,i));return this.parseOrders(a,r,t,s)}parseOrderStatus(e){const t={new:"open",canceled:"canceled",canceledAuction:"canceled",canceledSelfTradePrevention:"canceled",canceledIOC:"canceled",canceledFOK:"canceled",canceledMarketProtection:"canceled",canceledPostOnly:"canceled",filled:"closed",partiallyFilled:"open",expired:"canceled",rejected:"canceled",awaitingTrigger:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeInteger(e,"created"),n=this.safeString(e,"market");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"status")),o=this.safeString(e,"side"),d=this.safeString(e,"orderType"),c=this.safeString(e,"price"),u=this.safeString(e,"amount"),h=this.safeString(e,"amountRemaining"),f=this.safeString(e,"filledAmount");let l=this.safeString(e,"filledAmountQuote");if(l===void 0){const v=this.safeString(e,"amountQuote"),T=this.safeString(e,"amountQuoteRemaining");l=Ow.stringSub(v,T)}let m;const g=this.safeNumber(e,"feePaid");if(g!==void 0){const v=this.safeString(e,"feeCurrency"),T=this.safeCurrencyCode(v);m={cost:g,currency:T}}const y=this.safeValue(e,"fills",[]),w=this.safeString(e,"timeInForce"),b=this.safeValue(e,"postOnly"),S=this.safeNumber(e,"triggerPrice");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:d,timeInForce:w,postOnly:b,side:o,price:c,stopPrice:S,triggerPrice:S,amount:u,cost:l,average:void 0,filled:f,remaining:h,status:a,fee:m,trades:y},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zo(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(a.paymentId=i);const o=await this.privatePostWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawalHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"withdrawal"})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetDepositHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"deposit"})}parseTransactionStatus(e){const t={awaiting_processing:"pending",awaiting_email_confirmation:"pending",awaiting_bitvavo_inspection:"pending",approved:"pending",sending:"pending",in_mempool:"pending",processed:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"symbol"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"address"),c=this.safeString(e,"txId");let u;const h=this.safeNumber(e,"fee");h!==void 0&&(u={cost:h,currency:r});let f;"success"in e||"address"in e?f="withdrawal":f="deposit";const l=this.safeString(e,"paymentId");return{info:e,id:void 0,txid:c,timestamp:i,datetime:this.iso8601(i),addressFrom:void 0,address:d,addressTo:d,tagFrom:void 0,tag:l,tagTo:l,type:f,amount:o,currency:r,status:a,updated:void 0,fee:u}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o="/"+this.version+"/"+this.implodeParams(e,i);const d=s==="GET"||s==="DELETE";if(d&&Object.keys(a).length&&(o+="?"+this.urlencode(a)),t==="private"){this.checkRequiredCredentials();let c="";d||Object.keys(a).length&&(r=this.json(a),c=r);const u=this.milliseconds().toString(),h=u+s+o+c,f=this.hmac(this.encode(h),this.encode(this.secret)),l=this.safeString(this.options,"BITVAVO-ACCESS-WINDOW","10000");n={"BITVAVO-ACCESS-KEY":this.apiKey,"BITVAVO-ACCESS-SIGNATURE":f,"BITVAVO-ACCESS-TIMESTAMP":u,"BITVAVO-ACCESS-WINDOW":l},d||(n["Content-Type"]="application/json")}return o=this.urls.api[t]+o,{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"errorCode"),u=this.safeString(a,"error");if(c!==void 0){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),new Hi(h)}}calculateRateLimiterCost(e,t,s,i,n={},r={}){return"noMarket"in n&&!("market"in i)?n.noMarket:this.safeValue(n,"cost",1)}};const nL=re,{ExchangeError:rL,BadRequest:Pc,ArgumentsRequired:Oa,InsufficientFunds:Iw,InvalidOrder:aL}=Q,{TICK_SIZE:oL}=ne;var dL=class extends nL{describe(){return this.deepExtend(super.describe(),{id:"bkex",name:"BKEX",countries:["BVI"],rateLimit:100,version:"v2",certified:!1,has:{CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,editOrder:void 0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:!0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158043180-bb079a65-69e8-45a2-b393-f094d334e610.jpg",api:{spot:"https://api.bkex.com",swap:"https://fapi.bkex.com"},www:"https://www.bkex.com/",doc:["https://bkexapi.github.io/docs/api_en.htm"],fees:["https://www.bkex.com/help/instruction/33"]},api:{public:{spot:{get:{"/common/symbols":1,"/common/currencys":1,"/common/timestamp":1,"/q/kline":1,"/q/tickers":1,"/q/ticker/price":1,"/q/depth":1,"/q/deals":1}},swap:{get:{"/market/candle":1,"/market/deals":1,"/market/depth":1,"/market/fundingRate":1,"/market/index":1,"/market/riskLimit":1,"/market/symbols":1,"/market/ticker/price":1,"/market/tickers":1,"/server/ping":1}}},private:{spot:{get:{"/u/api/info":1,"/u/account/balance":1,"/u/wallet/address":1,"/u/wallet/depositRecord":1,"/u/wallet/withdrawRecord":1,"/u/order/openOrders":1,"/u/order/openOrder/detail":1,"/u/order/historyOrders":1},post:{"/u/account/transfer":1,"/u/wallet/withdraw":1,"/u/order/create":1,"/u/order/cancel":1,"/u/order/batchCreate":1,"/u/order/batchCancel":1}},swap:{get:{"/account/balance":1,"/account/balanceRecord":1,"/account/order":1,"/account/orderForced":1,"/account/position":1,"/entrust/finished":1,"/entrust/unFinish":1,"/order/finished":1,"/order/finishedInfo":1,"/order/unFinish":1,"/position/info":1},post:{"/account/setLeverage":1,"/entrust/add":1,"/entrust/cancel":1,"/order/batchCancel":1,"/order/batchOpen":1,"/order/cancel":1,"/order/close":1,"/order/closeAll":1,"/order/open":1,"/position/setSpSl":1,"/position/update":1}}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0015"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},swap:{"1m":"M1","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","6h":"H6","1d":"D1"}},defaultType:"spot",networks:{TRX:"TRC-20",TRC20:"TRC-20",ETH:"ERC-20",ERC20:"ERC-20",BEP20:"BEP-20(BSC)"}},commonCurrencies:{SHINJA:"SHINJA(1M)"},precisionMode:oL,exceptions:{exact:{1005:Iw},broad:{"Not Enough balance":Iw,"Order does not exist":aL,"System busy, please try again later":Pc}}})}async fetchMarkets(e={}){let t=[this.publicSpotGetCommonSymbols(e),this.publicSwapGetMarketSymbols(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(s,"data",[]),r=this.safeValue(i,"data",[]),a=this.arrayConcat(n,r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"symbol"),h=this.safeStringUpper(c,"symbol"),[f,l]=h.split("_"),m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l),w=this.safeString(c,"minimumOrderSize")!==void 0?"spot":"swap",b=w==="swap";let S=m+"/"+g,v,T;b&&(v=l,T=g,S=m+"/"+g+":"+T);const I=b?!0:void 0;o.push({id:u,symbol:S,base:m,quote:g,settle:T,baseId:f,quoteId:l,settleId:v,type:w,spot:w==="spot",margin:!1,future:!1,swap:b,option:!1,active:this.safeValue(c,"supportTrade"),contract:b,linear:I,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(c,"volumePrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(c,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumberN(c,["minimumOrderSize","marketMiniAmount","limitMiniAmount"]),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(c,"minimumTradeVolume"),max:void 0}},info:c})}return o}async fetchCurrencies(e={}){const t=await this.publicSpotGetCommonCurrencys(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"supportWithdraw"),u=this.safeValue(r,"supportDeposit"),h=this.safeValue(r,"supportTrade"),f=c&&u&&h;i[o]={id:a,code:o,name:d,deposit:u,withdraw:c,active:f,fee:this.safeNumber(r,"withdrawFee"),precision:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"minWithdrawSingle"),max:this.safeNumber(r,"maxWithdrawSingle")}},info:r}}return i}async fetchTime(e={}){const t=await this.publicSpotGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicSpotGetCommonTimestamp(e),s=this.safeInteger(t,"status"),i=this.safeInteger(t,"code"),n=this.safeInteger(t,"data");return{status:s===0&&i===0?"ok":s,updated:n,eta:void 0,url:void 0,info:t}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.swap,o={symbol:r.id};let d="publicSpotGetQKline";const c=this.safeValue(this.options,"timeframes");if(a){const f=this.safeValue(c,"swap");d="publicSwapGetMarketCandle",o.period=f[t],i!==void 0&&(o.count=i)}else{const f=this.safeValue(c,"spot");o.symbol=r.id,o.period=f[t]}if(i!==void 0){const f=a?"count":"size";o[f]=i}if(s!==void 0){const f=a?"start":"from";o[f]=s,i===void 0&&(i=500);const l=this.parseTimeframe(t),m=i*l*1e3,g=a?"end":"to";o[g]=this.sum(o[f],m)}const u=await this[d](o),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseOHLCV(e,t=void 0){const s=t.swap?"amount":"volume";return[this.safeInteger(e,"ts"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,s)]}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t),o=await this[n==="swap"?"publicSwapGetMarketTickers":"publicSpotGetQTickers"](this.extend(i,r)),d=this.safeValue(o,"data",[]),c=this.safeValue(d,0);return this.parseTicker(c,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0&&!Array.isArray(e))throw new Pc(this.id+" fetchTickers() symbols argument should be an array");let i;if(e!==void 0){const c=this.marketIds(e),u=this.safeString(e,0);if(i=this.market(u),i.swap){if(Array.isArray(e)&&e.length>1)throw new Pc(this.id+" fetchTickers() symbols argument cannot contain more than 1 symbol for swap markets");s.symbol=i.id}else s.symbol=c.join(",")}const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),o=await this[n==="swap"?"publicSwapGetMarketTickers":"publicSpotGetQTickers"](this.extend(s,r)),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e,r)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeSymbol(s,t),n=this.safeInteger2(e,"ts","lastTime"),r=t.swap?"amount":"volume",a=t.swap?"volume":"quoteVolume",o=t.swap?"lastPrice":"close";return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,o),previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString(e,r),quoteVolume:this.safeString(e,a),info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=i.swap,r={symbol:i.id};let a="publicSpotGetQDepth";n?a="publicSwapGetMarketDepth":t!==void 0&&(r.depth=Math.min(t,50));const o=await this[a](this.extend(r,s)),d=this.safeValue(o,"data"),c=this.safeInteger(d,"timestamp");return this.parseOrderBook(d,i.symbol,c,"bid","ask")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.swap,a={symbol:n.id};let o="publicSpotGetQDeals";r?o="publicSwapGetMarketDeals":s!==void 0&&(a.size=Math.min(s,50));const d=await this[o](this.extend(a,i)),c=this.safeValue(d,"data");return this.parseTrades(c,n,t,s)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"ts","time"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.parseTradeSide(this.safeString2(e,"direction","side")),r=this.safeNumber2(e,"volume","amount"),a=this.safeNumber(e,"price"),o=void 0;let d=this.safeString(e,"tid");return d===void 0&&(d=this.syntheticTradeId(t,s,n,r,a,o)),this.safeTrade({id:d,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:o,side:n,takerOrMaker:void 0,price:a,amount:r,cost:void 0,fee:void 0,info:e},t)}parseTradeSide(e){const t={B:"buy",S:"sell",buy:"buy",sell:"sell"};return this.safeString(t,e,e)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),r!==void 0&&(o+="-"+r),a!==void 0&&(o+="-"+a),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n))),o}async fetchBalance(e={}){await this.loadMarkets();const t=this.omit(e,"type"),s=await this.privateSpotGetUAccountBalance(t),i=this.safeValue(s,"data"),n=this.safeValue(i,"WALLET",[]),r={info:n};for(let a=0;a<n.length;a++){const o=n[a],d=o.currency,c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeNumber(o,"available"),u.used=this.safeNumber(o,"frozen"),u.total=this.safeNumber(o,"total"),r[c]=u}return this.safeBalance(r)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privateSpotGetUWalletAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeValue(e,0),i=this.safeString(s,"address"),n=this.safeString(s,"memo"),r=this.safeString(s,"currency");return t=this.safeCurrency(r,t),{currency:t.code,address:i,tag:n,network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oa(this.id+" fetchDeposits() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateSpotGetUWalletDepositRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="deposit";return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oa(this.id+" fetchWithdrawals() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateSpotGetUWalletWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="withdrawal";return this.parseTransactions(d,n,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"volume"),n=this.safeValue(e,"toAddress",{}),r=this.safeString(e,"fromAddress"),a=this.safeString(e,"hash"),o=this.safeString(e,"transactType"),d=this.safeInteger(e,"createTime"),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.parseTransactionStatus(this.safeString(e,"status"));return{id:s,currency:u,amount:i,network:void 0,address:n,addressTo:n,addressFrom:r,tag:void 0,tagTo:void 0,tagFrom:void 0,status:h,type:o,updated:void 0,txid:a,timestamp:d,datetime:this.iso8601(d),fee:{currency:u,cost:void 0},info:e}}parseTransactionStatus(e){const t={"-1":"failed",0:"ok",3:"pending",5:"pending"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s==="buy"?"BID":"ASK",d={symbol:a.id,type:t.toUpperCase(),volume:this.amountToPrecision(e,i),direction:o};t!=="market"&&n!==void 0&&(d.price=this.priceToPrecision(e,n));const c=await this.privateSpotPostUOrderCreate(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={orderId:e},r=await this.privateSpotPostUOrderCancel(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new Oa(this.id+" cancelOrders() ids argument should be an array");await this.loadMarkets();const i={orders:this.json(e)},n=await this.privateSpotPostUOrderBatchCancel(this.extend(i,s)),r=this.safeValue(n,"data"),a=this.safeValue(r,"results"),o=t!==void 0?this.market(t):void 0;return this.parseOrders(a,o,void 0,void 0,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oa(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.privateSpotGetUOrderOpenOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}async fetchOpenOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateSpotGetUOrderOpenOrderDetail(this.extend(i,s)),r=this.safeValue(n,"data"),a=t!==void 0?this.market(t):void 0;return this.parseOrder(r,a)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oa(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.startTime=t);const a=await this.privateSpotGetUOrderHistoryOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updateTime"),n=this.safeString(e,"dealVolume"),r=this.parseOrderSide(this.safeString(e,"direction")),a=this.safeString2(e,"id","data"),o=this.safeString(e,"price"),d=this.safeString(e,"status"),c=this.safeString(e,"type"),u=this.parseOrderType(c);let h=!1;c==="LIMIT_MAKER"&&(h=!0);let f;s!==void 0&&(f=this.parseOrderStatus(d));const l=this.safeString(e,"symbol");t=this.safeMarket(l,t);const m=this.safeString(e,"totalVolume"),g=this.safeNumber(e,"stopPrice"),y=this.safeString(e,"dealAvgPrice");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:f,symbol:t.symbol,type:u,timeInForce:void 0,postOnly:h,side:r,price:o,stopPrice:g,triggerPrice:g,average:y,amount:m,filled:n,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e},t)}parseOrderSide(e){const t={BID:"buy",ASK:"sell"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit",STOP_LIMIT:"limit"};return this.safeString(t,e,e)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSpotGetCommonCurrencys(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s=this.safeValue(e,"data"),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrency(a),d=this.safeString(o,"code");(t===void 0||this.inArray(d,t))&&(i[d]={withdraw:this.parseTransactionFee(r),deposit:void 0,info:r})}return i}parseTransactionFee(e,t=void 0){return this.safeNumber(e,"withdrawFee")}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSpotGetCommonCurrencys(t),i=this.safeValue(s,"data");return this.parseDepositWithdrawFees(i,e,"currency")}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e);return s.withdraw.fee=this.safeNumber(e,"withdrawFee"),s}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oa(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicSwapGetMarketFundingRate(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],f=this.safeString(h,"symbol"),l=this.safeSymbol(f),m=this.safeInteger(h,"time");d.push({info:h,symbol:l,fundingRate:this.safeNumber(h,"rate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Pc(this.id+" fetchMarketLeverageTiers() supports swap markets only");const i={symbol:s.id},n=await this.publicSwapGetMarketRiskLimit(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parseMarketLeverageTiers(r,s)}parseMarketLeverageTiers(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(e,"symbol");t=this.safeMarket(r,t),s.push({tier:this.sum(i,1),currency:t.settle,minNotional:this.safeNumber(n,"minValue"),maxNotional:this.safeNumber(n,"maxValue"),maintenanceMarginRate:this.safeNumber(n,"maintenanceMarginRate"),maxLeverage:this.safeNumber(n,"maxLeverage"),info:n})}return s}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",o=t[1],d=o==="spot"?this.version:"fapi/"+this.version;let c=this.urls.api[o]+"/"+d+this.implodeParams(e,i);i=this.omit(i,this.extractParams(e));let u="";if(Object.keys(i).length&&(u=this.rawencode(this.keysort(i)),s==="GET"&&(c+="?"+u)),a){this.checkRequiredCredentials();const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n={"Cache-Control":"no-cache","Content-type":"application/x-www-form-urlencoded",X_ACCESS_KEY:this.apiKey,X_SIGNATURE:h},s!=="GET"&&(r=u)}return{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"msg")==="success")return;const u=this.safeString(a,"code");if(u!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new rL(h)}}};const cL=re,{TICK_SIZE:uL}=ne,Ar=ae;var hL=class extends cL{describe(){return this.deepExtend(super.describe(),{id:"bl3p",name:"BL3P",countries:["NL"],rateLimit:1e3,version:"1",comment:"An exchange market by BitonicNL",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg",api:{rest:"https://api.bl3p.eu"},www:"https://bl3p.eu",doc:["https://github.com/BitonicNL/bl3p-api/tree/master/docs","https://bl3p.eu/api","https://bitonic.nl/en/api"]},api:{public:{get:["{market}/ticker","{market}/orderbook","{market}/trades"]},private:{post:["{market}/money/depth/full","{market}/money/order/add","{market}/money/order/cancel","{market}/money/order/result","{market}/money/orders","{market}/money/orders/history","{market}/money/trades/fetch","GENMKT/money/info","GENMKT/money/deposit_address","GENMKT/money/new_deposit_address","GENMKT/money/wallet/history","GENMKT/money/withdraw"]}},markets:{"BTC/EUR":{id:"BTCEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR",maker:.0025,taker:.0025,type:"spot",spot:!0}},precisionMode:uL})}parseBalance(e){const t=this.safeValue(e,"data",{}),s=this.safeValue(t,"wallets",{}),i={info:t},n=Object.keys(this.currencies);for(let r=0;r<n.length;r++){const a=n[r],d=this.currency(a).id,c=this.safeValue(s,d,{}),u=this.safeValue(c,"available",{}),h=this.safeValue(c,"balance",{}),f=this.account();f.free=this.safeString(u,"value"),f.total=this.safeString(h,"value"),i[a]=f}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e);return this.parseBalance(t)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=this.safeString(e,s);return[this.parseNumber(Ar.stringDiv(i,"100000.0")),this.parseNumber(Ar.stringDiv(n,"100000000.0"))]}async fetchOrderBook(e,t=void 0,s={}){const i=this.market(e),n={market:i.id},r=await this.publicGetMarketOrderbook(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price_int","amount_int")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last"),r=this.safeValue(e,"volume",{});return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(r,"24h"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){const s=this.market(e),i={market:s.id},n=await this.publicGetMarketTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeInteger(e,"date"),n=this.safeString(e,"price_int"),r=this.safeString(e,"amount_int");return t=this.safeMarket(void 0,t),this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:Ar.stringDiv(n,"100000"),amount:Ar.stringDiv(r,"100000000"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.market(e),r=await this.publicGetMarketTrades(this.extend({market:n.id},i));return this.parseTrades(r.data.trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"trade_fee"),n=this.parseNumber(Ar.stringDiv(i,"100")),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:s,symbol:o,maker:n,taker:n,percentage:!0,tierBased:!1}}return r}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.market(e),o=this.numberToString(i),d=this.numberToString(n),c={market:a.id,amount_int:parseInt(Ar.stringMul(o,"100000000")),fee_currency:a.quote,type:s==="buy"?"bid":"ask"};t==="limit"&&(c.price_int=parseInt(Ar.stringMul(d,"100000.0")));const u=await this.privatePostMarketMoneyOrderAdd(this.extend(c,r)),h=this.safeString(u.data,"order_id");return{info:u,id:h}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostMarketMoneyOrderCancel(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i);let o=this.urls.api.rest+"/"+this.version+"/"+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce();r=this.urlencode(this.extend({nonce:c},d));const u=this.base64ToBinary(this.secret),h=a+"\0"+r,f=this.hmac(this.encode(h),u,"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded","Rest-Key":this.apiKey,"Rest-Sign":f}}return{url:o,method:s,body:r,headers:n}}};const fL=re,{ExchangeError:lL,AuthenticationError:pL,OrderNotFound:mL,InsufficientFunds:gL,ArgumentsRequired:yL}=Q,{TICK_SIZE:wL}=ne,Ac=ae;var bL=class extends fL{describe(){return this.deepExtend(super.describe(),{id:"blockchaincom",secret:void 0,name:"Blockchain.com",countries:["LX"],rateLimit:500,version:"v3",has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchL3OrderBook:!0,fetchLedger:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!0,transfer:!1,withdraw:!0},timeframes:void 0,urls:{logo:"https://user-images.githubusercontent.com/1294454/147515585-1296e91b-7398-45e5-9d32-f6121538533f.jpeg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.blockchain.com/v3/exchange",private:"https://api.blockchain.com/v3/exchange"},www:"https://blockchain.com",doc:["https://api.blockchain.com/v3"],fees:"https://exchange.blockchain.com/fees"},api:{public:{get:{tickers:1,"tickers/{symbol}":1,symbols:1,"symbols/{symbol}":1,"l2/{symbol}":1,"l3/{symbol}":1}},private:{get:{fees:1,orders:1,"orders/{orderId}":1,trades:1,fills:1,deposits:1,"deposits/{depositId}":1,accounts:1,"accounts/{account}/{currency}":1,whitelist:1,"whitelist/{currency}":1,withdrawals:1,"withdrawals/{withdrawalId}":1},post:{orders:1,"deposits/{currency}":1,withdrawals:1},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0022")],[this.parseNumber("50000"),this.parseNumber("0.002")],[this.parseNumber("100000"),this.parseNumber("0.0018")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("2500000"),this.parseNumber("0.0018")],[this.parseNumber("5000000"),this.parseNumber("0.0016")],[this.parseNumber("25000000"),this.parseNumber("0.0014")],[this.parseNumber("100000000"),this.parseNumber("0.0011")],[this.parseNumber("500000000"),this.parseNumber("0.0008")],[this.parseNumber("1000000000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("10000"),this.parseNumber("0.0012")],[this.parseNumber("50000"),this.parseNumber("0.001")],[this.parseNumber("100000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0007000000000000001")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("25000000"),this.parseNumber("0.0003")],[this.parseNumber("100000000"),this.parseNumber("0.0002")],[this.parseNumber("500000000"),this.parseNumber("0.0001")],[this.parseNumber("1000000000"),this.parseNumber("0")]]}}},requiredCredentials:{apiKey:!1,secret:!0},precisionMode:wL,exceptions:{exact:{401:pL,404:mL},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(t,r),o=this.safeString(a,"base_currency"),d=this.safeString(a,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeNumber(a,"id");let f;this.safeString(a,"status")==="open"?f=!0:f=!1;const m=this.safeString(a,"min_price_increment"),g=this.safeString(a,"min_price_increment_scale"),y=this.parsePrecision(g),w=Ac.stringMul(m,y),b=this.safeString(a,"lot_size"),S=this.safeString(a,"lot_size_scale"),v=this.parsePrecision(S),T=Ac.stringMul(b,v),I=this.safeString(a,"min_order_size"),A=this.safeString(a,"min_order_size_scale"),N=this.parsePrecision(A),B=Ac.stringMul(I,N),x=this.parseNumber(B);let k;if(k=this.safeString(a,"max_order_size"),k!=="0"){const O=this.safeString(a,"max_order_size_scale"),P=this.parsePrecision(O),q=Ac.stringMul(k,P);k=this.parseNumber(q)}else k=void 0;i.push({info:a,id:r,numericId:h,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(T),price:this.parseNumber(w)},limits:{leverage:{min:void 0,max:void 0},amount:{min:x,max:k},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchOrderBook(e,t=void 0,s={}){return await this.fetchL3OrderBook(e,t,s)}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL3Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}async fetchL2OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"last_trade_price"),r=this.safeString(e,"volume_24h"),a=this.safeString(e,"price_24h");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:void 0,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseOrderState(e){const t={OPEN:"open",REJECTED:"rejected",FILLED:"closed",CANCELED:"canceled",PART_FILLED:"open",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"clOrdId"),i=this.safeStringLower(e,"ordType"),n=this.safeString(e,"ordStatus"),r=this.parseOrderState(n),a=this.safeStringLower(e,"side"),o=this.safeString(e,"symbol"),d=this.safeSymbol(o,t,"-"),c=this.safeString(e,"exOrdId"),u=i!=="market"?this.safeString(e,"price"):void 0,h=this.safeNumber(e,"avgPx"),f=this.safeInteger(e,"timestamp"),l=this.iso8601(f),m=this.safeString(e,"cumQty"),g=this.safeString(e,"leavesQty");return this.safeOrder({id:c,clientOrderId:s,datetime:l,timestamp:f,lastTradeTimestamp:void 0,status:r,symbol:d,type:i,timeInForce:void 0,side:a,price:u,average:h,amount:void 0,filled:m,remaining:g,cost:void 0,trades:[],fees:{},info:e})}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=this.safeString(r,"ordType",t).toUpperCase(),c=this.safeString2(r,"clientOrderId","clOrdId",this.uuid16());r=this.omit(r,["ordType","clientOrderId","clOrdId"]);const u={ordType:d,symbol:a.id,side:s.toUpperCase(),orderQty:this.amountToPrecision(e,i),clOrdId:c},h=this.safeValue2(r,"stopPx","stopPrice");if(r=this.omit(r,["stopPx","stopPrice"]),(d==="STOP"||d==="STOPLIMIT")&&h===void 0)throw new yL(this.id+" createOrder() requires a stopPx or stopPrice param for a "+d+" order");h!==void 0&&(d==="MARKET"?u.ordType="STOP":d==="LIMIT"&&(u.ordType="STOPLIMIT"));let f=!1,l=!1;(u.ordType==="LIMIT"||u.ordType==="STOPLIMIT")&&(f=!0),(u.ordType==="STOP"||u.ordType==="STOPLIMIT")&&(l=!0),f&&(u.price=this.priceToPrecision(e,n)),l&&(u.stopPx=this.priceToPrecision(e,h));const m=await this.privatePostOrders(this.extend(u,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return{id:e,info:n}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.marketId(e);s.symbol=n}const i=await this.privateDeleteOrders(this.extend(s,t));return{symbol:e,info:i}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"makerRate"),i=this.safeNumber(t,"takerRate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i}}return n}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){const n="CANCELED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n="FILLED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n="OPEN";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={status:e,limit:100};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"exOrdId"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"side").toLowerCase(),r=this.safeString(e,"symbol"),a=this.safeString(e,"price"),o=this.safeString(e,"qty"),d=this.safeInteger(e,"timestamp"),c=this.iso8601(d);t=this.safeMarket(r,t,"-");const u=t.symbol;let h;const f=this.safeString(e,"fee");if(f!==void 0){const l=t.quote;h={cost:f,currency:l}}return this.safeTrade({id:i,timestamp:d,datetime:c,symbol:u,order:s,type:void 0,side:n,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:h,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);let r;e!==void 0&&(n.symbol=this.marketId(e),r=this.market(e));const a=await this.privateGetFills(this.extend(n,i));return this.parseTrades(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostDepositsCurrency(this.extend(i,t)),r=this.safeString(n,"address");let a,o;r!==void 0&&([o,a]=r.split(":"));const d={info:n};return d.currency=s.code,d.address=o,a!==void 0&&(d.tag=a),d}parseTransactionState(e){const t={COMPLETED:"ok",REJECTED:"failed",PENDING:"pending",FAILED:"failed",REFUNDED:"refunded"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"state");"depositId"in e?(s="deposit",i=this.safeString(e,"depositId")):"withdrawalId"in e&&(s="withdrawal",i=this.safeString(e,"withdrawalId"));const c=s==="withdrawal"?this.safeNumber(e,"fee"):void 0;let u;c!==void 0&&(u={currency:o,cost:c});const h=this.safeString(e,"address"),f=this.safeString(e,"txhash");return{info:e,id:i,txid:f,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:h,addressTo:h,tagFrom:void 0,tag:void 0,tagTo:void 0,type:s,amount:n,currency:o,status:this.parseTransactionState(d),updated:void 0,comment:void 0,fee:u}}async fetchWithdrawalWhitelist(e={}){await this.loadMarkets();const t=await this.privateGetWhitelist(),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push({beneficiaryId:this.safeString(n,"whitelistId"),name:this.safeString(n,"name"),currency:this.safeString(n,"currency"),info:n})}return s}async fetchWithdrawalWhitelistByCurrency(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetWhitelistCurrency(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a];r.push({beneficiaryId:this.safeString(o,"whitelistId"),name:this.safeString(o,"name"),currency:this.safeString(o,"currency"),info:o})}return r}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,beneficiary:s,sendMax:!1},o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdrawalId:e},n=await this.privateGetWithdrawalsWithdrawalId(this.extend(i,s));return this.parseTransaction(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={depositId:this.safeString(s,"depositId",e)},r=await this.privateGetDepositsDepositId(this.extend(n,s));return this.parseTransaction(r)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"account","primary");e=this.omit(e,"account");const s={account:t},i=await this.privateGetAccounts(this.extend(s,e)),n=this.safeValue(i,t);if(n===void 0)throw new lL(this.id+' fetchBalance() could not find the "'+t+'" account');const r={info:i};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"available"),u.total=this.safeString(o,"balance"),r[c]=u}return this.safeBalance(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),n={"X-API-Token":this.secret},s==="GET"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):(r=this.json(d),n["Content-Type"]="application/json")),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"text");if(c!==void 0&&c==="Insufficient Balance")throw new gL(this.id+" "+r);const u=this.safeString(a,"status"),h=this.safeString(a,"error");if(e!==void 0){const f=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f)}}};const kL=re,{ExchangeError:SL,AuthenticationError:vL,DDoSProtection:TL,InvalidOrder:OL,InsufficientFunds:IL}=Q,{TICK_SIZE:xL}=ne,gl=ae;var _L=class extends kL{describe(){return this.deepExtend(super.describe(),{id:"btcalpha",name:"BTC-Alpha",countries:["US"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"D"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg",api:{rest:"https://btc-alpha.com/api"},www:"https://btc-alpha.com",doc:"https://btc-alpha.github.io/api-docs",fees:"https://btc-alpha.com/fees/",referral:"https://btc-alpha.com/?r=123788"},api:{public:{get:["currencies/","pairs/","orderbook/{pair_name}","exchanges/","charts/{pair}/{type}/chart/"]},private:{get:["wallets/","orders/own/","order/{id}/","exchanges/own/","deposits/","withdraws/"],post:["order/","order-cancel/"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{withdraw:{}}},commonCurrencies:{CBC:"Cashbery"},precisionMode:xL,exceptions:{exact:{},broad:{"Out of balance":IL}}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"currency1"),o=this.safeString(n,"currency2"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"price_precision"),h=this.parsePrecision(u),f=this.safeString(n,"minimum_order_size");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(u))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(f),max:this.safeNumber(n,"maximum_order_size")},price:{min:this.parseNumber(h),max:void 0},cost:{min:this.parseNumber(gl.stringMul(h,f)),max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair_name:i.id};t&&(n.limit_sell=t,n.limit_buy=t);const r=await this.publicGetOrderbookPairName(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount")}parseBidsAsks(e,t=0,s=1){const i=[];for(let n=0;n<e.length;n++){const r=e[n];r&&i.push(this.parseBidAsk(r,t,s))}return i}parseTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"timestamp"),n=this.parseNumber(gl.stringMul(i,"1000000")),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"id"),d=this.safeString2(e,"my_side","type");return this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:o,type:"limit",side:d,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.limit=s);const a=await this.publicGetExchanges(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetDeposits(i);return this.parseTransactions(r,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency_id=n.id);const a=await this.privateGetWithdraws(this.extend(r,i));return this.parseTransactions(a,n,t,s,{type:"withdrawal"})}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),txid:void 0,type:void 0,status:this.parseTransactionStatus(n),comment:void 0,fee:void 0,updated:void 0}}parseTransactionStatus(e){const t={10:"pending",20:"pending",30:"ok",40:"failed",50:"canceled"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.since=parseInt(s/1e3));const o=await this.publicGetChartsPairTypeChart(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"reserve"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={1:"open",2:"canceled",3:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeValue(e,"success",!1);let r;n?r=this.safeTimestamp(e,"date"):r=this.safeInteger(e,"date");const a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"amount_filled"),c=this.safeString(e,"amount_original"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeString2(e,"oid","id"),f=this.safeValue(e,"trades"),l=this.safeString2(e,"my_side","type");return this.safeOrder({id:h,clientOrderId:void 0,datetime:this.iso8601(r),timestamp:r,status:u,symbol:i,type:"limit",timeInForce:void 0,postOnly:void 0,side:l,price:a,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:c,filled:d,remaining:o,trades:f,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i,price:this.priceToPrecision(e,n)},d=await this.privatePostOrder(this.extend(o,r));if(!d.success)throw new OL(this.id+" "+this.json(d));const c=this.parseOrder(d,a),u=c.amount.toString();return i=gl.stringGt(u,"0")?c.amount:i,this.extend(c,{amount:this.parseNumber(i)})}async cancelOrder(e,t=void 0,s={}){const i={order:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrdersOwn(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"1"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"3"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const a=this.market(e);n.pair=a.id}s!==void 0&&(n.limit=s);const r=await this.privateGetExchangesOwn(this.extend(n,i));return this.parseTrades(r,void 0,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urlencode(this.keysort(this.omit(i,this.extractParams(e))));let o=this.urls.api.rest+"/";if(e!=="charts/{pair}/{type}/chart/"&&(o+="v1/"),o+=this.implodeParams(e,i),n={Accept:"application/json"},t==="public")a.length&&(o+="?"+a);else{this.checkRequiredCredentials();let d=this.apiKey;s==="POST"?(n["Content-Type"]="application/x-www-form-urlencoded",r=a,d+=r):a.length&&(o+="?"+a),n["X-KEY"]=this.apiKey,n["X-SIGN"]=this.hmac(this.encode(d),this.encode(this.secret)),n["X-NONCE"]=this.nonce().toString()}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error"),u=this.id+" "+r;if(c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u)),e===401||e===403)throw new vL(u);if(e===429)throw new TL(u);if(!(e<400))throw new SL(u)}};const CL=re,{ExchangeError:xw,InsufficientFunds:ML,InvalidOrder:yl,AuthenticationError:PL,PermissionDenied:AL,InvalidNonce:BL,OrderNotFound:_w,DDoSProtection:NL}=Q,{TICK_SIZE:VL}=ne,EL=ae;var qL=class extends CL{describe(){return this.deepExtend(super.describe(),{id:"btcbox",name:"BtcBox",countries:["JP"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg",api:{rest:"https://www.btcbox.co.jp/api"},www:"https://www.btcbox.co.jp/",doc:"https://blog.btcbox.jp/en/archives/8762",fees:"https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction"},api:{public:{get:["depth","orders","ticker"]},private:{post:["balance","trade_add","trade_cancel","trade_list","trade_view","wallet"]}},markets:{"BTC/JPY":{id:"btc",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0005"),type:"spot",spot:!0},"ETH/JPY":{id:"eth",symbol:"ETH/JPY",base:"ETH",quote:"JPY",baseId:"eth",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"LTC/JPY":{id:"ltc",symbol:"LTC/JPY",base:"LTC",quote:"JPY",baseId:"ltc",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"BCH/JPY":{id:"bch",symbol:"BCH/JPY",base:"BCH",quote:"JPY",baseId:"bch",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0}},precisionMode:VL,exceptions:{104:PL,105:AL,106:BL,107:yl,200:ML,201:yl,202:yl,203:_w,401:_w,402:NL}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=a+"_balance";if(o in e){const d=this.account(),c=a+"_lock";d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={};this.symbols.length>1&&(n.coin=i.baseId);const a=await this.publicGetDepth(this.extend(n,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};this.symbols.length>1&&(i.coin=s.baseId);const r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");t=this.safeMarket(void 0,t);const i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=void 0,o=this.safeString(e,"type");return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:a,side:o,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};this.symbols.length>1&&(r.coin=n.baseId);const o=await this.publicGetOrders(this.extend(r,i));return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={amount:i,price:n,type:s,coin:a.baseId},d=await this.privatePostTradeAdd(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n={id:e,coin:i.baseId},r=await this.privatePostTradeCancel(this.extend(n,s));return this.parseOrder(r,i)}parseOrderStatus(e){const t={part:"open",all:"closed",cancelled:"canceled",closed:"closed",no:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"datetime");let n;i!==void 0&&(n=this.parse8601(e.datetime+"+09:00"));const r=this.safeString(e,"amount_original"),a=this.safeString(e,"amount_outstanding"),o=this.safeString(e,"price");let d=this.parseOrderStatus(this.safeString(e,"status"));d===void 0&&EL.stringEquals(a,"0")&&(d="closed");const c=void 0;t=this.safeMarket(void 0,t);const u=this.safeString(e,"type");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:u,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:t.symbol,price:o,stopPrice:void 0,triggerPrice:void 0,cost:void 0,trades:c,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n=this.extend({id:e,coin:i.baseId},s),r=await this.privatePostTradeView(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrdersByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const r=this.market(t),a={type:e,coin:r.baseId},o=await this.privatePostTradeList(this.extend(a,n)),d=this.parseOrders(o,r,s,i);if(e==="open")for(let c=0;c<d.length;c++)d[c].status="open";return d}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("all",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("open",e,t,s,i)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.extend({key:this.apiKey,nonce:o},i),c=this.urlencode(d),u=this.hash(this.encode(this.secret));d.signature=this.hmac(this.encode(c),this.encode(u)),r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=400)return;const c=this.safeValue(a,"result");if(c===void 0||c===!0)return;const u=this.safeValue(a,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new xw(h)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){let d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d=="string"){if(d=this.strip(d),!this.isJsonEncodedObject(d))throw new xw(this.id+" "+d);d=JSON.parse(d)}return d}};const LL=re,{TICK_SIZE:RL}=ne,{ExchangeError:Bc,NotSupported:wl,RequestTimeout:Cw,DDoSProtection:Nc,InvalidOrder:Wt,InvalidAddress:bl,BadRequest:Ge,InsufficientFunds:Mw,OrderNotFound:DL,AuthenticationError:is,ExchangeNotAvailable:Pw,ArgumentsRequired:zn}=Q,jn=ae;var bT=class extends LL{describe(){return this.deepExtend(super.describe(),{id:"btcex",name:"BTCEX",countries:["CA"],version:"v1",certified:!1,pro:!0,requiredCredentials:{apiKey:!0,secret:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/173489620-d49807a4-55cd-4f4e-aca9-534921298bbf.jpg",www:"https://www.btcex.com/",api:{rest:"https://api.btcex.com"},doc:"https://docs.btcex.com/",fees:"https://support.btcex.com/hc/en-us/articles/4415995130647",referral:{url:"https://www.btcex.com/en-us/register?i=48biatg1",discount:.1}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,signIn:!0,withdraw:!1},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","4h":"240","6h":"360","12h":"720","1d":"1D","3d":"3D","1M":"30D"},api:{public:{get:["get_last_trades_by_currency","get_last_trades_by_instrument","get_order_book","tickers","get_instruments","get_tradingview_chart_data","cmc_spot_summary","cmc_spot_ticker","cmc_spot_orderbook","cmc_market_trades","cmc_contracts","cmc_contract_orderbook","coin_gecko_spot_pairs","coin_gecko_spot_ticker","coin_gecko_spot_orderbook","coin_gecko_market_trades","coin_gecko_contracts","coin_gecko_contract_orderbook"],post:["auth"]},private:{get:["get_deposit_record","get_withdraw_record","get_position","get_positions","get_open_orders_by_currency","get_open_orders_by_instrument","get_order_history_by_currency","get_order_history_by_instrument","get_order_state","get_user_trades_by_currency","get_user_trades_by_instrument","get_user_trades_by_order"],post:["logout","get_assets_info","add_withdraw_address","buy","sell","cancel","cancel_all_by_currency","cancel_all_by_instrument","close_position"],delete:[]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},margin:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},perpetual:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{9999:Bc,9900:Pw,401:is,403:is,1e3:Pw,1001:Ge,2e3:is,2001:is,2002:is,2003:is,3e3:is,3002:is,3003:is,3004:Ge,3005:wl,3007:is,3008:is,3009:is,3011:is,3012:is,3013:Cw,3015:is,3016:is,3018:Ge,3019:Ge,3020:Ge,3021:Ge,3022:Ge,3023:Ge,3024:Ge,3025:Ge,3026:Ge,3027:Ge,3028:Ge,3029:Nc,3030:Nc,3031:Ge,3032:Ge,3033:Ge,3034:is,3035:Ge,3036:Ge,3037:Ge,3038:Ge,3039:Ge,3040:is,3041:Ge,4e3:Ge,4001:bl,4002:bl,4003:Ge,4004:wl,4005:Bc,4006:Mw,4007:Ge,4008:wl,4009:bl,4010:Ge,4011:Ge,5001:Wt,5002:DL,5003:Wt,5004:Wt,5005:Wt,5006:Wt,5007:Wt,5008:Wt,5009:Wt,5010:Wt,5011:Wt,5012:Wt,5013:Wt,5014:Wt,5109:Wt,5135:Wt,5901:Wt,5902:Wt,5903:Wt,5904:Wt,5905:Wt,5906:Wt,5907:Mw,8e3:Ge,8001:Ge,8100:Ge,8101:Cw,8102:Nc,8103:Ge,8104:Ge,8105:Ge,8106:Nc,8107:Bc,1e4:is,11e3:Ge},broad:{}},precisionMode:RL,options:{accountsByType:{wallet:"WALLET",spot:"SPOT",perpetual:"PERPETUAL",margin:"MARGIN",swap:"PERPETUAL",BTC:"BTC",ETH:"ETH"}},commonCurrencies:{}})}async fetchMarkets(e={}){const t=await this.publicGetGetInstruments(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeString(r,"kind");let d=o;o==="perpetual"&&(d="swap");let c=this.safeString(r,"quote_currency");const u=this.safeString(r,"base_currency"),h=o==="perpetual",f=o==="spot",l=o==="margin",m=o==="option",g=o==="future",y=h||g||m;let w;(m||g)&&(c=this.safeString(r,"currency"),w=this.safeInteger(r,"expiration_timestamp"));let b,S,v;y&&(S=u,v=this.safeCurrencyCode(S));let T,I;m&&(T=this.safeString(r,"option_type"),I=this.safeNumber(r,"strike"));const A=this.safeCurrencyCode(c),N=this.safeCurrencyCode(u);let B;if(l?B=a:B=A+"/"+N,y&&(b=this.safeNumber(r,"contract_size"),B=B+":"+v,(g||m)&&(B=B+"-"+this.yymmdd(w),m))){const L=T==="call"?"C":"P";B=B+":"+this.numberToString(I)+":"+L}const x=this.safeNumber(r,"min_trade_amount"),k=this.safeNumber(r,"tick_size"),O=this.safeNumber(r,"maker_commission"),P=this.safeNumber(r,"taker_commission"),q=!(m||g);i.push({id:a,symbol:B,base:A,quote:N,baseId:c,quoteId:u,settleId:S,settle:v,type:d,maker:O,taker:P,percentage:q,spot:f,margin:l,swap:h,future:g,option:m,active:this.safeValue(r,"is_active"),contract:y,linear:y?!0:void 0,inverse:y?!1:void 0,contractSize:b,expiry:w,expiryDatetime:this.iso8601(w),strike:I,optionType:T,precision:{amount:x,price:k},limits:{leverage:{min:void 0,max:this.safeString(r,"leverage")},amount:{min:x,max:void 0},price:{min:k,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){let s=this.safeString(e,"instrument_name");s.indexOf("PERPETUAL")<0&&(s=s+"-SPOT"),t=this.safeMarket(s,t);const i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"stats");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:this.safeString(e,"best_bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString(e,"best_ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:this.safeString(e,"last_price"),last:this.safeString(e,"last_price"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"price_change"),average:void 0,baseVolume:this.safeString(r,"volume"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp"),d=this.parseOrderBook(a,i.symbol,o);return d.nonce=this.safeInteger(a,"version"),d}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"tick"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=10);const a={resolution:this.timeframes[t]};let o=r.id;if((r.spot||r.margin)&&(o=r.baseId+"-"+r.quoteId),a.instrument_name=o,s===void 0)a.end_timestamp=this.milliseconds(),a.start_timestamp=0;else{const h=this.parseTimeframe(t)*1e3;a.start_timestamp=s,a.end_timestamp=this.sum(a.start_timestamp,i*h)}const d=await this.publicGetGetTradingviewChartData(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"role"),u=this.safeString(e,"fee");let h;if(u!==void 0){const f=this.safeString(e,"fee_coin_type"),l=this.safeCurrencyCode(f);h={cost:u,currency:l}}return this.safeTrade({info:e,id:s,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:c,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetLastTradesByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}async signIn(e={}){let t=this.safeString(this.options,"accessToken");if(t!==void 0)return t;this.checkRequiredCredentials();const s={grant_type:"client_credentials",client_id:this.apiKey,client_secret:this.secret},i=await this.publicPostAuth(this.extend(s,e)),n=this.safeValue(i,"result");return t=this.safeString(n,"access_token"),this.options.accessToken=t,t}parseBalance(e){const t={info:e},s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeValue(e,n);if(n==="WALLET"||n==="SPOT"){const a=this.safeValue(r,"details");if(a!==void 0)for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"coin_type"),u=this.safeCurrencyCode(c),h=this.safeValue(t,u,this.account());h.free=this.safeString(d,"available"),h.used=this.safeString(d,"freeze"),h.total=this.safeString(d,"total"),t[u]=h}}else{const a="USDT",o=this.account();o.total=this.safeString(r,"wallet_balance"),o.free=this.safeString(r,"available_withdraw_funds"),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.signIn(),await this.loadMarkets();const t=this.safeStringLower(e,"type","spot"),s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);e=this.omit(e,"type");const n={asset_type:[i]},r=await this.privatePostGetAssetsInfo(this.extend(n,e)),a=this.safeValue(r,"result",[]);return this.parseBalance(a)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected"};return this.safeString(t,e,e)}parseTimeInForce(e){if(e==="-")return;const t={good_til_cancelled:"GTC",good_til_date:"GTD",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp"),i=this.safeInteger(e,"last_update_timestamp"),n=this.safeString(e,"order_id");let r=this.safeString(e,"price");r==="-1"&&(r=void 0);const a=this.safeString(e,"average_price"),o=this.safeString(e,"amount"),d=this.safeString(e,"filled_amount");let c;d!==void 0&&jn.stringGt(d,"0")&&(c=i);const u=this.parseOrderStatus(this.safeString(e,"order_state")),h=this.safeString(e,"instrument_name");t=this.safeMarket(h,t);const f=this.safeStringLower(e,"direction");let l=this.safeString(e,"commission"),m;l!==void 0&&(l=jn.stringAbs(l),m={cost:l,currency:t.base});const g=this.safeString(e,"order_type"),y=this.safeValue(e,"trades"),w=this.parseTimeInForce(this.safeString(e,"time_in_force")),b=this.safeValue(e,"trigger_price"),S=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:n,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:c,symbol:t.symbol,type:g,timeInForce:w,postOnly:S,side:f,price:r,stopPrice:b,triggerPrice:b,amount:o,cost:void 0,average:a,filled:d,remaining:void 0,status:u,fee:m,trades:y},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.signIn(),await this.loadMarkets();const a=this.market(e),o={instrument_name:a.id,amount:this.amountToPrecision(e,i),type:t};if(t==="limit"&&(o.price=this.priceToPrecision(e,n)),a.contract){const f=this.safeStringUpper(r,"timeInForce");f==="GTC"?o.time_in_force="good_till_cancelled":f==="FOK"?o.time_in_force="fill_or_kill":f==="IOC"&&(o.time_in_force="immediate_or_cancel");const l=t==="market",m=this.safeValue(r,"post_only",!1);this.isPostOnly(l,m,r)&&(o.post_only=!0),this.safeValue(r,"reduceOnly",!1)&&(o.reduce_only=!0),r=this.omit(r,["timeInForce","postOnly","reduceOnly"])}const d="privatePost"+this.capitalize(s),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"order");return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.signIn(),await this.loadMarkets();const i={order_id:e},n=await this.privatePostCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new zn(this.id+" cancelAllOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id};return await this.privatePostCancelAllByInstrument(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zn(this.id+" fetchOpenOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id},a=await this.privateGetGetOpenOrdersByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zn(this.id+" fetchClosedOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetOrderHistoryByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(e===void 0)throw new zn(this.id+" fetchOrderTrades() requires a id argument");await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.count=i);const a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zn(this.id+" fetchMyTrades() requires a id argument");await this.signIn(),await this.loadMarkets();const n={};let r;const a=this.market(e);n.instrument_name=a.id,t===void 0?r="privateGetGetUserTradesByInstrument":r="privateGetGetUserTradesByInstrumentAndTime",s!==void 0&&(n.count=s);const o=await this[r](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,a,t,s)}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n=this.safeString(e,"direction");n=n==="buy"?"long":"short";const r=this.safeString(e,"maintenance_margin"),a=this.safeString(e,"risk_level"),o=jn.stringDiv(r,a),d=this.safeString(e,"mark_price"),c=jn.stringMul(d,i),u=this.safeString(e,"floating_profit_loss"),h=this.safeString(e,"initial_margin"),f=jn.stringMul(jn.stringDiv(u,h),"100"),l=this.safeString(e,"margin_type");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(jn.stringDiv(h,c)),maintenanceMargin:this.parseNumber(r),maintenanceMarginPercentage:this.parseNumber(jn.stringDiv(r,c)),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(c),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.safeValue(t,"contractSize"),marginRatio:this.parseNumber(a),liquidationPrice:this.safeNumber(e,"liquid_price"),markPrice:this.parseNumber(d),collateral:this.parseNumber(o),marginType:l,side:n,percentage:this.parseNumber(f)}}async fetchPosition(e,t={}){await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.signIn(),await this.loadMarkets();const s={currency:"PERPETUAL"},i=await this.privateGetGetPositions(this.extend(s,t)),n=this.safeValue(i,"result");return this.parsePositions(n,e)}parseTransactionStatus(e){const t={deposit_confirmed:"ok",deposit_waiting_confirm:"pending",withdraw_init:"pending",withdraw_noticed_block_chain:"pending",withdraw_waiting_confirm:"pending",withdraw_confirmed:"ok",withdraw_failed:"failed",withdraw_auditing:"pending",withdraw_audit_reject:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin_type"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"id"),r=this.safeString(e,"tx_hash"),a=this.safeInteger(e,"create_time"),o=this.safeInteger(e,"update_time"),d=this.safeNumber(e,"amount"),c=this.safeString(e,"state");return{info:e,id:n,txid:r,timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:void 0,amount:d,currency:i,status:this.parseTransactionStatus(c),updated:o,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zn(this.id+" fetchDeposits() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetDepositRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zn(this.id+" fetchWithdrawals() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new zn(this.id+" fetchWithdrawal() requires the code argument");await this.signIn(),await this.loadMarkets();const i=this.safeCurrency(t),n={coin_type:i.id,withdraw_id:e},r=await this.privateGetGetWithdrawRecord(this.extend(n,s)),a=this.safeValue(r,"result",[]),o=this.filterBy(a,"id",e),d=this.safeValue(o,0);return this.parseTransaction(d,i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials(),s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.safeString(this.options,"accessToken");if(d===void 0)throw new is(this.id+" sign() requires access token");if(n={Authorization:"bearer "+d},s==="POST"&&(n["Content-Type"]="application/json",Object.keys(i).length)){const c={jsonrpc:"2.0",id:this.nonce(),method:"/"+t+"/"+e,params:i};r=this.json(c)}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c){const u=this.id+" "+r,h=this.safeString(c,"code"),f=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,f,u),new Bc(u)}}};const FL=re,{ArgumentsRequired:Aw,ExchangeError:Bw,OrderNotFound:HL,InvalidOrder:Ia,InsufficientFunds:GL,DDoSProtection:UL,BadRequest:$L}=Q,{TICK_SIZE:WL}=ne,Nw=ae;var zL=class extends FL{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:["AU"],rateLimit:1e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net"},www:"https://btcmarkets.net",doc:["https://api.btcmarkets.net/doc/v3","https://github.com/BTCMarkets/API"]},api:{public:{get:["markets","markets/{marketId}/ticker","markets/{marketId}/trades","markets/{marketId}/orderbook","markets/{marketId}/candles","markets/tickers","markets/orderbooks","time"]},private:{get:["orders","orders/{id}","batchorders/{ids}","trades","trades/{id}","withdrawals","withdrawals/{id}","deposits","deposits/{id}","transfers","transfers/{id}","addresses","withdrawal-fees","assets","accounts/me/trading-fees","accounts/me/withdrawal-limits","accounts/me/balances","accounts/me/transactions","reports/{id}"],post:["orders","batchorders","withdrawals","reports"],delete:["orders","orders/{id}","batchorders/{ids}"],put:["orders/{id}"]}},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},precisionMode:WL,exceptions:{3:Ia,6:UL,InsufficientFund:GL,InvalidPrice:Ia,InvalidAmount:Ia,MissingArgument:Ia,OrderAlreadyCancelled:Ia,OrderNotFound:HL,OrderStatusIsFinal:Ia,InvalidPaginationParameter:$L},fees:{percentage:!0,tierBased:!0,maker:this.parseNumber("-0.0005"),taker:this.parseNumber("0.0020")},options:{fees:{AUD:{maker:this.parseNumber("0.0085"),taker:this.parseNumber("0.0085")}}}})}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};i!==void 0&&(r.limit=i),s!==void 0&&(r.after=s);let a;t!==void 0&&(a=this.currency(t));const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetTransfers",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetDeposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetWithdrawals",e,t,s,i)}parseTransactionStatus(e){const t={Accepted:"pending","Pending Authorization":"pending",Complete:"ok",Cancelled:"cancelled",Failed:"failed"};return this.safeString(t,e,e)}parseTransactionType(e){const t={Withdraw:"withdrawal",Deposit:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.parse8601(this.safeString(e,"lastUpdate"));let n=this.parseTransactionType(this.safeStringLower(e,"type"));n==="withdraw"&&(n="withdrawal");const r=this.safeValue(e,"paymentDetail",{}),a=this.safeString(r,"txId");let o=this.safeString(r,"address"),d;if(o!==void 0){const b=o.split("?dt=");b.length>1&&(o=b[0],d=b[1])}const c=o,u=d,h=void 0,f=void 0,l=this.safeNumber(e,"fee"),m=this.parseTransactionStatus(this.safeString(e,"status")),g=this.safeString(e,"assetName"),y=this.safeCurrencyCode(g);let w=this.safeNumber(e,"amount");return l&&(w-=l),{id:this.safeString(e,"id"),txid:a,timestamp:s,datetime:this.iso8601(s),network:void 0,address:o,addressTo:c,addressFrom:h,tag:d,tagTo:u,tagFrom:f,type:n,amount:w,currency:y,status:m,updated:i,comment:void 0,fee:{currency:y,cost:l,rate:void 0},info:e}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseAssetName"),a=this.safeString(n,"quoteAssetName"),o=this.safeString(n,"marketId"),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(a),u=d+"/"+c,h=this.safeValue(this.safeValue(this.options,"fees",{}),c,this.fees),f=this.parseNumber(this.parsePrecision(this.safeString(n,"priceDecimals"))),l=this.safeNumber(n,"minOrderAmount"),m=this.safeNumber(n,"maxOrderAmount");let g;c==="AUD"&&(g=f),s.push({id:o,symbol:u,base:d,quote:c,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:h.taker,maker:h.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amountDecimals"))),price:f},limits:{leverage:{min:void 0,max:void 0},amount:{min:l,max:m},price:{min:g,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"timestamp"))}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetName"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"locked"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsMeBalances(e);return this.parseBalance(t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,0)),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id,timeWindow:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsMarketIdCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={marketId:this.market(e).id},r=await this.publicGetMarketsMarketIdOrderbook(this.extend(n,s)),a=this.safeIntegerProduct(r,"snapshotId",.001),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"snapshotId"),o}parseTicker(e,t=void 0){const s=this.safeString(e,"marketId");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"lastPrice"),a=this.safeString(e,"volume24h"),o=this.safeString(e,"volumeQte24h"),d=this.safeString(e,"price24h"),c=this.safeString(e,"pricePct24h");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low"),bid:this.safeString(e,"bestBid"),bidVolume:void 0,ask:this.safeString(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:d,percentage:c,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketId:s.id},n=await this.publicGetMarketsMarketIdTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTicker2(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetMarketIdTick(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");const n=t.quote==="AUD"?t.quote:t.base;let r=this.safeString(e,"side");r==="Bid"?r="buy":r==="Ask"&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"orderId");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:n});const f=this.safeStringLower(e,"liquidityType");return this.safeTrade({info:e,id:a,timestamp:s,datetime:this.iso8601(s),order:c,symbol:t.symbol,type:void 0,side:r,price:o,amount:d,cost:void 0,takerOrMaker:f,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketId:n.id},a=await this.publicGetMarketsMarketIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={marketId:a.id,amount:this.amountToPrecision(e,i),side:s==="buy"?"Bid":"Ask"},d=t.toLowerCase(),c=this.safeValue(this.options,"orderTypes",{limit:"Limit",market:"Market",stop:"Stop","stop limit":"Stop Limit","take profit":"Take Profit"});o.type=this.safeString(c,d,t);let u=!1,h=!1;if(d==="limit"?u=!0:d==="stop limit"?(h=!0,u=!0):(d==="take profit"||d==="stop")&&(h=!0),u){if(n===void 0)throw new Aw(this.id+" createOrder() requires a price argument for a "+t+"order");o.price=this.priceToPrecision(e,n)}if(h){const m=this.safeNumber(r,"triggerPrice");if(r=this.omit(r,"triggerPrice"),m===void 0)throw new Aw(this.id+" createOrder() requires a triggerPrice parameter for a "+t+"order");o.triggerPrice=this.priceToPrecision(e,m)}const f=this.safeString(r,"clientOrderId");f!==void 0&&(o.clientOrderId=f),r=this.omit(r,"clientOrderId");const l=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(l,a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();for(let n=0;n<e.length;n++)e[n]=parseInt(e[n]);const i={ids:e};return await this.privateDeleteBatchordersIds(this.extend(i,s))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privateDeleteOrdersId(this.extend(i,s))}calculateFee(e,t,s,i,n,r="taker",a={}){const o=this.markets[e];let d,c;if(o.quote==="AUD"){d=o.quote;const f=this.numberToString(i),l=this.numberToString(n),m=Nw.stringMul(f,l);c=this.costToPrecision(e,m)}else d=o.base,c=this.amountToPrecision(e,i);const u=o[r],h=Nw.stringMul(this.numberToString(u),c);return{type:r,currency:d,rate:u,cost:parseFloat(this.feeToPrecision(e,h))}}parseOrderStatus(e){const t={Accepted:"open",Placed:"open","Partially Matched":"open","Fully Matched":"closed",Cancelled:"canceled","Partially Cancelled":"canceled",Failed:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");let n=this.safeString(e,"side");n==="Bid"?n="buy":n==="Ask"&&(n="sell");const r=this.safeStringLower(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"openAmount"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"orderId"),h=this.safeString(e,"clientOrderId"),f=this.safeString(e,"timeInForce"),l=this.safeNumber(e,"triggerPrice"),m=this.safeValue(e,"postOnly");return this.safeOrder({info:e,id:u,clientOrderId:h,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:f,postOnly:m,side:n,price:a,stopPrice:l,triggerPrice:l,cost:void 0,amount:o,filled:void 0,remaining:d,average:void 0,status:c,trades:void 0,fee:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={status:"all"};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:this.currencyToPrecision(e,t)};e!=="AUD"&&(this.checkAddress(s),a.toAddress=s),i!==void 0&&(a.toAddress=s+"?dt="+i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.keysort(this.omit(i,this.extractParams(e)));if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.base64ToBinary(this.encode(this.secret));let h=s+a+c;s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),h+=r);const f=this.hmac(this.encode(h),u,"sha512","base64");n={Accept:"application/json","Accept-Charset":"UTF-8","Content-Type":"application/json","BM-AUTH-APIKEY":this.apiKey,"BM-AUTH-TIMESTAMP":c,"BM-AUTH-SIGNATURE":f}}else t==="public"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return{url:this.urls.api[t]+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("success"in a&&!a.success){const c=this.safeString(a,"errorCode"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new Bw(u)}if(e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new Bw(h)}}}};const jL=re,{ExchangeError:Vw,ArgumentsRequired:KL}=Q,{TICK_SIZE:XL}=ne,kl=ae;var YL=class extends jL{describe(){return this.deepExtend(super.describe(),{id:"btctradeua",name:"BTC Trade UA",countries:["UA"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0},urls:{referral:"https://btc-trade.com.ua/registration/22689",logo:"https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg",api:{rest:"https://btc-trade.com.ua/api"},www:"https://btc-trade.com.ua",doc:"https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit"},api:{public:{get:["deals/{symbol}","trades/sell/{symbol}","trades/buy/{symbol}","japan_stat/high/{symbol}"]},private:{post:["auth","ask/{symbol}","balance","bid/{symbol}","buy/{symbol}","my_orders/{symbol}","order/status/{id}","remove/order/{id}","sell/{symbol}"]}},precisionMode:XL,markets:{"BCH/UAH":{id:"bch_uah",symbol:"BCH/UAH",base:"BCH",quote:"UAH",baseId:"bch",quoteId:"uah",type:"spot",spot:!0},"BTC/UAH":{id:"btc_uah",symbol:"BTC/UAH",base:"BTC",quote:"UAH",baseId:"btc",quoteId:"uah",precision:{price:this.parseNumber("1e-1")},limits:{amount:{min:this.parseNumber("1e-10")}},type:"spot",spot:!0},"DASH/BTC":{id:"dash_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"dash",quoteId:"btc",type:"spot",spot:!0},"DASH/UAH":{id:"dash_uah",symbol:"DASH/UAH",base:"DASH",quote:"UAH",baseId:"dash",quoteId:"uah",type:"spot",spot:!0},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc",type:"spot",spot:!0},"DOGE/UAH":{id:"doge_uah",symbol:"DOGE/UAH",base:"DOGE",quote:"UAH",baseId:"doge",quoteId:"uah",type:"spot",spot:!0},"ETH/UAH":{id:"eth_uah",symbol:"ETH/UAH",base:"ETH",quote:"UAH",baseId:"eth",quoteId:"uah",type:"spot",spot:!0},"ITI/UAH":{id:"iti_uah",symbol:"ITI/UAH",base:"ITI",quote:"UAH",baseId:"iti",quoteId:"uah",type:"spot",spot:!0},"KRB/UAH":{id:"krb_uah",symbol:"KRB/UAH",base:"KRB",quote:"UAH",baseId:"krb",quoteId:"uah",type:"spot",spot:!0},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",type:"spot",spot:!0},"LTC/UAH":{id:"ltc_uah",symbol:"LTC/UAH",base:"LTC",quote:"UAH",baseId:"ltc",quoteId:"uah",type:"spot",spot:!0},"NVC/BTC":{id:"nvc_btc",symbol:"NVC/BTC",base:"NVC",quote:"BTC",baseId:"nvc",quoteId:"btc",type:"spot",spot:!0},"NVC/UAH":{id:"nvc_uah",symbol:"NVC/UAH",base:"NVC",quote:"UAH",baseId:"nvc",quoteId:"uah",type:"spot",spot:!0},"PPC/BTC":{id:"ppc_btc",symbol:"PPC/BTC",base:"PPC",quote:"BTC",baseId:"ppc",quoteId:"btc",type:"spot",spot:!0},"SIB/UAH":{id:"sib_uah",symbol:"SIB/UAH",base:"SIB",quote:"UAH",baseId:"sib",quoteId:"uah",type:"spot",spot:!0},"XMR/UAH":{id:"xmr_uah",symbol:"XMR/UAH",base:"XMR",quote:"UAH",baseId:"xmr",quoteId:"uah",type:"spot",spot:!0},"ZEC/UAH":{id:"zec_uah",symbol:"ZEC/UAH",base:"ZEC",quote:"UAH",baseId:"zec",quoteId:"uah",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}}})}async signIn(e={}){return await this.privatePostAuth(e)}parseBalance(e){const t={info:e},s=this.safeValue(e,"accounts",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetTradesBuySymbol(this.extend(n,s)),a=await this.publicGetTradesSellSymbol(this.extend(n,s)),o={bids:[],asks:[]};return r&&"list"in r&&(o.bids=r.list),a&&"list"in a&&(o.asks=a.list),this.parseOrderBook(o,i.symbol,void 0,"bids","asks","price","currency_trade")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n={symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},r=e.length;if(r>0){const a=Math.max(r-48,0);for(let d=a;d<e.length;d++){const c=e[d];n.open===void 0&&(n.open=this.safeString(c,1));const u=this.safeString(c,2);(n.high===void 0||u!==void 0&&kl.stringLt(n.high,u))&&(n.high=u);const h=this.safeString(c,3);(n.low===void 0||h!==void 0&&kl.stringLt(n.low,h))&&(n.low=h);const f=this.safeString(c,5);n.baseVolume===void 0?n.baseVolume=f:n.baseVolume=kl.stringAdd(n.baseVolume,f)}const o=r-1;n.last=this.safeString(e[o],4),n.close=n.last}return this.safeTicker(n,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetJapanStatHighSymbol(this.extend(i,t)),r=this.safeValue(n,"trades");return this.parseTicker(r,s)}convertMonthNameToString(e){const t={Jan:"01",Feb:"02",Mar:"03",Apr:"04",May:"05",Jun:"06",Jul:"07",Aug:"08",Sept:"09",Oct:"10",Nov:"11",Dec:"12"};return this.safeString(t,e)}parseExchangeSpecificDatetime(e){const t=e.split(" ");let s=t[0],i=t[1].replace(",","");i.length<2&&(i="0"+i);const n=t[2].replace(",","");if(s=s.replace(",",""),s=s.replace(".",""),s=this.convertMonthNameToString(s),!s)throw new Vw(this.id+" parseTrade() unrecognized month name: "+e);const a=t[3].split(":");let o=this.safeString(a,0),d="00";const c=this.safeString(t,4);if(o==="noon")o="12";else{let m=parseInt(o);c!==void 0&&c[0]==="p"&&(m=12+m,m>23&&(m=0)),o=m.toString(),o.length<2&&(o="0"+o),d=this.safeString(a,1,"00"),d.length<2&&(d="0"+d)}const h=[n,s,i].join("-")+"T"+o+":"+d+":00",f=this.parse8601(h),l=parseInt(d);return l<11||l>2?f-72e5:f-108e5}parseTrade(e,t=void 0){const s=this.parseExchangeSpecificDatetime(this.safeString(e,"pub_date")),i=this.safeString(e,"id"),n="limit",r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amnt_trade");return t=this.safeMarket(void 0,t),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetDealsSymbol(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++)this.safeInteger(a[d],"id")%2&&o.push(a[d]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Vw(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o="privatePost"+this.capitalize(s)+"Id",d={count:i,currency1:a.quoteId,currency:a.baseId,price:n};return this[o](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostRemoveOrderId(this.extend(i,s))}parseOrder(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"amnt_trade"),o=this.safeString(e,"amnt_trade");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:"open",symbol:i,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:void 0,triggerPrice:void 0,amount:a,filled:void 0,remaining:o,trades:void 0,info:e,cost:void 0,average:void 0,fee:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new KL(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.privatePostMyOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"your_open_orders");return this.parseOrders(o,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+=this.implodeParams(e,o));else{this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({out_order_id:d,nonce:d},o));const c=r+this.secret;n={"public-key":this.apiKey,"api-sign":this.hash(this.encode(c),"sha256"),"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}};const ZL=re,{BadRequest:QL,ExchangeError:Ew,InsufficientFunds:JL,InvalidOrder:qw}=Q,{TICK_SIZE:e3}=ne,Sl=ae;var t3=class extends ZL{describe(){return this.deepExtend(super.describe(),{id:"btcturk",name:"BTCTurk",countries:["TR"],rateLimit:100,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":1,"15m":15,"30m":30,"1h":60,"4h":240,"1d":"1 day","1w":"1 week","1y":"1 year"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153926-efbef500-c2c0-11ea-9842-05b63612c4b9.jpg",api:{public:"https://api.btcturk.com/api/v2",private:"https://api.btcturk.com/api/v1",graph:"https://graph-api.btcturk.com/v1"},www:"https://www.btcturk.com",doc:"https://github.com/BTCTrader/broker-api-docs"},api:{public:{get:{orderbook:1,ticker:.1,trades:1,"server/exchangeinfo":1}},private:{get:{"users/balances":1,openOrders:1,allOrders:1,"users/transactions/trade":1},post:{order:1,cancelOrder:1},delete:{order:1}},graph:{get:{ohlcs:1,"klines/history":1}}},fees:{trading:{maker:this.parseNumber("0.0005"),taker:this.parseNumber("0.0009")}},exceptions:{exact:{FAILED_ORDER_WITH_OPEN_ORDERS:JL,FAILED_LIMIT_ORDER:qw,FAILED_MARKET_ORDER:qw}},precisionMode:e3})}async fetchMarkets(e={}){const t=await this.publicGetServerExchangeinfo(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"numerator"),c=this.safeString(a,"denominator"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeValue(a,"filters",[]);let l,m,g,y,w;for(let S=0;S<f.length;S++){const v=f[S];this.safeString(v,"filterType")==="PRICE_FILTER"&&(l=this.safeNumber(v,"minPrice"),m=this.safeNumber(v,"maxPrice"),g=this.safeNumber(v,"minAmount"),y=this.safeNumber(v,"maxAmount"),w=this.safeNumber(v,"minExchangeValue"))}const b=this.safeString(a,"status");n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:b==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"numeratorScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"denominatorScale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:y},price:{min:l,max:m},cost:{min:w,max:void 0}},info:a})}return n}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"free"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUsersBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pairSymbol:i.id},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks",0,1)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily"),percentage:this.safeString(e,"dailyPercent"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data");return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"date","timestamp"),i=this.safeString2(e,"tid","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=Sl.stringAbs(this.safeString(e,"amount")),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString2(e,"side","orderType");let u;const h=this.safeString(e,"fee");if(h!==void 0){const f=this.safeString(e,"denominatorSymbol");u={cost:Sl.stringAbs(h),currency:this.safeCurrencyCode(f)}}return this.safeTrade({info:e,id:i,order:n,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:c,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1h",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.safeValue(this.timeframes,t,t)},o=this.safeInteger(n,"until",this.milliseconds());if(a.to=parseInt(o/1e3),s!==void 0?a.from=parseInt(s/1e3):i===void 0&&(i=100),i!==void 0){if(t==="1y")throw new QL(this.id+' fetchOHLCV () does not accept a limit parameter when timeframe == "1y"');const u=this.parseTimeframe(t)*(i-1);if(s!==void 0){const h=parseInt(s/1e3)+u;a.to=Math.min(a.to,h)}else a.from=parseInt(o/1e3)-u}const d=await this.graphGetKlinesHistory(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[],a=this.safeValue(e,"t"),o=this.safeValue(e,"h"),d=this.safeValue(e,"o"),c=this.safeValue(e,"l"),u=this.safeValue(e,"c"),h=this.safeValue(e,"v");for(let m=0;m<a.length;m++){const g={timestamp:this.safeValue(a,m),high:this.safeValue(o,m),open:this.safeValue(d,m),low:this.safeValue(c,m),close:this.safeValue(u,m),volume:this.safeValue(h,m)};r.push(this.parseOHLCV(g,t))}const f=this.sortBy(r,0),l=i===void 0;return this.filterBySinceLimit(f,i,n,0,l)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={orderType:s,orderMethod:t,pairSymbol:a.id,quantity:this.amountToPrecision(e,i)};t!=="market"&&(o.price=this.priceToPrecision(e,n)),"clientOrderId"in r?o.newClientOrderId=r.clientOrderId:"newClientOrderId"in r||(o.newClientOrderId=this.uuid());const d=await this.privatePostOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pairSymbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"bids",[]),c=this.safeValue(o,"asks",[]);return this.parseOrders(this.arrayConcat(d,c),r,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s),t!==void 0&&(r.startTime=Math.floor(t/1e3));const a=await this.privateGetAllOrders(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Untouched:"open",Partial:"open",Canceled:"canceled",Closed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t){const s=this.safeString(e,"id"),i=this.safeString(e,"price"),n=this.safeString2(e,"amount","quantity"),r=Sl.stringAbs(n),a=this.safeString(e,"leftAmount"),o=this.safeString(e,"pairSymbol"),d=this.safeSymbol(o,t),c=this.safeString(e,"type"),u=this.safeString(e,"method"),h=this.safeString(e,"orderClientId"),f=this.safeInteger2(e,"updateTime","datetime"),l=this.safeString(e,"status"),m=this.parseOrderStatus(l);return this.safeOrder({info:e,id:s,price:i,amount:r,remaining:a,filled:void 0,cost:void 0,average:void 0,status:m,side:c,type:u,clientOrderId:h,timestamp:f,datetime:this.iso8601(f),symbol:d,fee:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetUsersTransactionsTrade(),a=this.safeValue(r,"data");return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(this.id==="btctrader")throw new Ew(this.id+" is an abstract base API for BTCExchange, BTCTurk");let a=this.urls.api[t]+"/"+e;if(s==="GET"||s==="DELETE"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):r=this.json(i),t==="private"){this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.base64ToBinary(this.secret),c=this.apiKey+o;n={"X-PCK":this.apiKey,"X-Stamp":o,"X-Signature":this.hmac(this.encode(c),d,"sha256","base64"),"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code","0"),u=this.safeString(a,"message"),h=u===void 0?r:u;if(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+h),c!=="0"&&c!=="SUCCESS")throw new Ew(this.id+" "+h)}};const s3=re,{AddressPending:i3,AuthenticationError:n3,ExchangeError:jo,NotSupported:Lw,PermissionDenied:r3,ArgumentsRequired:Rw}=Q,{TICK_SIZE:a3}=ne,vl=ae;var o3=class extends s3{describe(){return this.deepExtend(super.describe(),{id:"buda",name:"Buda",countries:["AR","CL","CO","PE"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg",api:{rest:"https://www.buda.com/api"},www:"https://www.buda.com",doc:"https://api.buda.com",fees:"https://www.buda.com/comisiones"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{public:{get:["pairs","markets","currencies","markets/{market}","markets/{market}/ticker","markets/{market}/volume","markets/{market}/order_book","markets/{market}/trades","currencies/{currency}/fees/deposit","currencies/{currency}/fees/withdrawal","tv/history"],post:["markets/{market}/quotations"]},private:{get:["balances","balances/{currency}","currencies/{currency}/balances","orders","orders/{id}","markets/{market}/orders","deposits","currencies/{currency}/deposits","withdrawals","currencies/{currency}/withdrawals","currencies/{currency}/receive_addresses","currencies/{currency}/receive_addresses/{id}"],post:["markets/{market}/orders","currencies/{currency}/deposits","currencies/{currency}/withdrawals","currencies/{currency}/simulated_withdrawals","currencies/{currency}/receive_addresses"],put:["orders/{id}"]}},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","2h":"120","1d":"D","1w":"W"},fees:{trading:{tierBased:!0,percentage:!0,taker:.008,maker:.004,tiers:{taker:[[0,.008],[2e3,.007],[2e4,.006],[1e5,.005],[5e5,.004],[25e5,.003],[125e5,.002]],maker:[[0,.004],[2e3,.0035],[2e4,.003],[1e5,.0025],[5e5,.002],[25e5,.0015],[125e5,.001]]}}},precisionMode:a3,exceptions:{not_authorized:n3,forbidden:r3,invalid_record:jo,not_found:jo,parameter_missing:jo,bad_parameter:jo}})}async fetchCurrencyInfo(e,t=void 0){if(!t){const s=await this.publicGetCurrencies();t=this.safeValue(s,"currencies")}for(let s=0;s<t.length;s++){const i=t[s];if(i.id===e)return i}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"markets",[]),i=await this.publicGetCurrencies(),n=this.safeValue(i,"currencies"),r=[];for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"base_currency"),c=this.safeString(o,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=await this.fetchCurrencyInfo(d,n),l=await this.fetchCurrencyInfo(c,n),m=this.safeValue(o,"minimum_order_amount",[]),g=this.safeString(o,"taker_fee"),y=this.safeString(o,"maker_fee");r.push({id:this.safeString(o,"id"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,taker:this.parseNumber(vl.stringDiv(g,"1000")),maker:this.parseNumber(vl.stringDiv(y,"1000")),precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(f,"input_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(l,"input_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(m,0),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}async fetchCurrencies(e={}){const s=(await this.publicGetCurrencies()).currencies,i={};for(let n=0;n<s.length;n++){const r=s[n];if(!this.safeValue(r,"managed",!1))continue;const o=this.safeString(r,"id"),d=this.safeCurrencyCode(o),c=this.parseNumber(this.parsePrecision(this.safeString(r,"input_decimals"))),u=this.safeValue(r,"deposit_minimum",[]),h=this.safeValue(r,"withdrawal_minimum",[]),f=this.safeNumber(u,0),l=this.safeNumber(h,0);i[d]={id:o,code:d,info:r,name:void 0,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:f,max:void 0},withdraw:{min:l}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i={},n={};e===void 0&&(e=Object.keys(this.currencies));for(let r=0;r<e.length;r++){const a=e[r],d={currency:this.currency(a).id},c=await this.publicGetCurrenciesCurrencyFeesWithdrawal(d),u=await this.publicGetCurrenciesCurrencyFeesDeposit(d);s[a]=this.parseTransactionFee(c.fee),i[a]=this.parseTransactionFee(u.fee),n[a]={withdraw:c,deposit:u}}return{withdraw:s,deposit:i,info:n}}parseTransactionFee(e,t=void 0){return t===void 0&&(t=e.name),t==="withdrawal"&&(t="withdraw"),{type:t,currency:e.base[1],rate:e.percent,cost:parseFloat(e.base[0])}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetMarketsMarketTicker(this.extend(i,t)),r=this.safeValue(n,"ticker");return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeValue(e,"last_price",[]),a=this.safeString(r,0);let o=this.safeString(e,"price_variation_24h");o=vl.stringMul(o,"100");const d=this.safeValue(e,"max_bid",[]),c=this.safeValue(e,"min_ask",[]),u=this.safeValue(e,"volume",[]);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(d,0),bidVolume:void 0,ask:this.safeString(c,0),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(u,0),quoteVolume:void 0,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsMarketTrades(this.extend(r,i));return this.parseTrades(a.trades.entries,n,t,s)}parseTrade(e,t=void 0){let s,i,r,a,o,u;return t&&(u=t.symbol),Array.isArray(e)&&(s=this.safeInteger(e,0),r=this.safeString(e,1),a=this.safeString(e,2),i=this.safeString(e,3),o=this.safeString(e,4)),this.safeTrade({id:o,order:void 0,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:void 0,side:i,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id},r=await this.publicGetMarketsMarketOrderBook(this.extend(n,s)),a=this.safeValue(r,"order_book");return this.parseOrderBook(a,i.symbol)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);s===void 0&&(s=this.milliseconds()-864e5);const a={symbol:r.id,resolution:this.timeframes[t],from:s/1e3,to:this.seconds()},o=await this.publicGetTvHistory(this.extend(a,n));return this.parseTradingViewOHLCV(o,r,t,s,i)}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"id"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n.available_amount,0),o.total=this.safeString(n.amount,0),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={market:n.id,per:s},a=await this.privateGetMarketsMarketOrders(this.extend(r,i)),o=this.safeValue(a,"orders");return this.parseOrders(o,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"pending"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"traded"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),s=s==="buy"?"Bid":"Ask";const o={market:this.market(e).id,price_type:t,type:s,amount:this.amountToPrecision(e,i)};t==="limit"&&(o.limit=this.priceToPrecision(e,n));const d=await this.privatePostMarketsMarketOrders(this.extend(o,r)),c=this.safeValue(d,"order");return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e),state:"canceling"},n=await this.privatePutOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}parseOrderStatus(e){const t={traded:"closed",received:"open",canceling:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.iso8601(i),r=this.safeString(e,"market_id"),a=this.safeSymbol(r,t,"-"),o=this.safeString(e,"price_type"),d=this.safeStringLower(e,"type"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeValue(e,"original_amount",[]),h=this.safeString(u,0),f=this.safeValue(e,"amount",[]),l=this.safeString(f,0),m=this.safeValue(e,"traded_amount",[]),g=this.safeString(m,0),y=this.safeValue(e,"total_exchanged",[]),w=this.safeString(y,0),b=this.safeValue(e,"limit",[]);let S=this.safeString(b,0);S===void 0&&b!==void 0&&(S=b);const v=this.safeValue(e,"paid_fee",[]),T=this.safeString(v,0);let I;if(T!==void 0){const A=this.safeString(v,1),N=this.safeCurrencyCode(A);I={cost:T,code:N,currency:N}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,datetime:n,timestamp:i,lastTradeTimestamp:void 0,status:c,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:S,stopPrice:void 0,triggerPrice:void 0,average:void 0,cost:w,amount:h,filled:g,remaining:l,trades:void 0,fee:I},t)}isFiat(e){const t={ARS:!0,CLP:!0,COP:!0,PEN:!0};return this.safeValue(t,e,!1)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new Lw(this.id+" fetchDepositAddress() for fiat "+e+" is not supported");const i={currency:s.id},n=await this.privateGetCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeValue(n,"receive_addresses"),a=[];for(let c=1;c<r.length;c++){const u=r[c];if(u.ready){const h=u.address;this.checkAddress(h),a.push(h)}}if(a.length<1)throw new i3(this.id+": there are no addresses ready for receiving "+e+", retry again later)");const d=a[0];return{currency:e,address:d,tag:void 0,network:void 0,info:r}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new Lw(this.id+" createDepositAddress() of fiat for "+e+" is not supported");const i={currency:s.id},n=await this.privatePostCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeString(n.receive_address,"address");return{currency:e,address:r,tag:void 0,info:n}}parseTransactionStatus(e){const t={rejected:"failed",confirmed:"ok",anulled:"canceled",retained:"canceled",pending_confirmation:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=parseFloat(e.amount[0]),o=parseFloat(e.fee[0]),d=e.fee[1],c=this.parseTransactionStatus(this.safeString(e,"state")),u="deposit_data"in e?"deposit":"withdrawal",h=this.safeValue(e,u+"_data",{}),f=this.safeValue(h,"target_address"),l=this.safeString(h,"tx_hash"),m=this.parse8601(this.safeString(h,"updated_at"));return{info:e,id:s,txid:l,timestamp:i,datetime:this.iso8601(i),network:void 0,address:f,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:a,currency:r,status:c,updated:m,fee:{cost:o,rate:d}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Rw(this.id+" fetchDeposits() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyDeposits(this.extend(r,i)),o=this.safeValue(a,"deposits");return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Rw(this.id+" fetchWithdrawals() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyWithdrawals(this.extend(r,i)),o=this.safeValue(a,"withdrawals");return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,withdrawal_data:{target_address:s}},o=await this.privatePostCurrenciesCurrencyWithdrawals(this.extend(a,n)),d=this.safeValue(o,"withdrawal");return this.parseTransaction(d)}nonce(){return this.microseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));Object.keys(o).length&&(s==="GET"?a+="?"+this.urlencode(o):r=this.json(o));const d=this.urls.api.rest+"/"+this.version+"/"+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=[s,"/api/"+this.version+"/"+a];if(r){const l=this.stringToBase64(r);u.push(this.decode(l))}u.push(c);const h=u.join(" "),f=this.hmac(this.encode(h),this.encode(this.secret),"sha384");n={"X-SBTC-APIKEY":this.apiKey,"X-SBTC-SIGNATURE":f,"X-SBTC-NONCE":c,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message",r),h=this.id+" "+u;if(c!==void 0)throw this.throwExactlyMatchedException(this.exceptions,c,h),new jo(h)}}};const d3=re,{TICK_SIZE:c3}=ne,{AuthenticationError:xn,ExchangeError:ns,ArgumentsRequired:st,PermissionDenied:Gs,InvalidOrder:ee,OrderNotFound:Tl,InsufficientFunds:et,BadRequest:ke,RateLimitExceeded:Ko,InvalidNonce:u3,NotSupported:Ft}=Q,$e=ae;var kT=class extends d3{describe(){return this.deepExtend(super.describe(),{id:"bybit",name:"Bybit",countries:["VG"],version:"v3",userAgent:void 0,rateLimit:20,hostname:"bybit.com",pro:!0,certified:!0,has:{CORS:!0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchIndexOHLCV:!0,fetchLedger:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M","1y":"Y"},urls:{test:{spot:"https://api-testnet.{hostname}",futures:"https://api-testnet.{hostname}",v2:"https://api-testnet.{hostname}",public:"https://api-testnet.{hostname}",private:"https://api-testnet.{hostname}"},logo:"https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg",api:{spot:"https://api.{hostname}",futures:"https://api.{hostname}",v2:"https://api.{hostname}",public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://www.bybit.com",doc:["https://bybit-exchange.github.io/docs/inverse/","https://bybit-exchange.github.io/docs/linear/","https://github.com/bybit-exchange"],fees:"https://help.bybit.com/hc/en-us/articles/360039261154",referral:"https://www.bybit.com/register?affiliate_id=35953"},api:{public:{get:{"v2/public/orderBook/L2":1,"v2/public/kline/list":3,"v2/public/tickers":1,"v2/public/trading-records":1,"v2/public/symbols":1,"v2/public/mark-price-kline":3,"v2/public/index-price-kline":3,"v2/public/premium-index-kline":2,"v2/public/open-interest":1,"v2/public/big-deal":1,"v2/public/account-ratio":1,"v2/public/funding-rate":1,"v2/public/elite-ratio":1,"v2/public/funding/prev-funding-rate":1,"v2/public/risk-limit/list":1,"public/linear/kline":3,"public/linear/recent-trading-records":1,"public/linear/risk-limit":1,"public/linear/funding/prev-funding-rate":1,"public/linear/mark-price-kline":1,"public/linear/index-price-kline":1,"public/linear/premium-index-kline":1,"spot/v1/time":1,"spot/v1/symbols":1,"spot/quote/v1/depth":1,"spot/quote/v1/depth/merged":1,"spot/quote/v1/trades":1,"spot/quote/v1/kline":1,"spot/quote/v1/ticker/24hr":1,"spot/quote/v1/ticker/price":1,"spot/quote/v1/ticker/book_ticker":1,"spot/v3/public/symbols":1,"spot/v3/public/quote/depth":1,"spot/v3/public/quote/depth/merged":1,"spot/v3/public/quote/trades":1,"spot/v3/public/quote/kline":1,"spot/v3/public/quote/ticker/24hr":1,"spot/v3/public/quote/ticker/price":1,"spot/v3/public/quote/ticker/bookTicker":1,"spot/v3/public/server-time":1,"spot/v3/public/infos":1,"v2/public/time":1,"v3/public/time":1,"v2/public/announcement":1,"option/usdc/openapi/public/v1/order-book":1,"option/usdc/openapi/public/v1/symbols":1,"option/usdc/openapi/public/v1/tick":1,"option/usdc/openapi/public/v1/delivery-price":1,"option/usdc/openapi/public/v1/query-trade-latest":1,"option/usdc/openapi/public/v1/query-historical-volatility":1,"option/usdc/openapi/public/v1/all-tickers":1,"perpetual/usdc/openapi/public/v1/order-book":1,"perpetual/usdc/openapi/public/v1/symbols":1,"perpetual/usdc/openapi/public/v1/tick":1,"perpetual/usdc/openapi/public/v1/kline/list":1,"perpetual/usdc/openapi/public/v1/mark-price-kline":1,"perpetual/usdc/openapi/public/v1/index-price-kline":1,"perpetual/usdc/openapi/public/v1/premium-index-kline":1,"perpetual/usdc/openapi/public/v1/open-interest":1,"perpetual/usdc/openapi/public/v1/big-deal":1,"perpetual/usdc/openapi/public/v1/account-ratio":1,"perpetual/usdc/openapi/public/v1/prev-funding-rate":1,"perpetual/usdc/openapi/public/v1/risk-limit/list":1,"asset/v1/public/deposit/allowed-deposit-list":1,"contract/v3/public/copytrading/symbol/list":1,"derivatives/v3/public/order-book/L2":1,"derivatives/v3/public/kline":1,"derivatives/v3/public/tickers":1,"derivatives/v3/public/instruments-info":1,"derivatives/v3/public/mark-price-kline":1,"derivatives/v3/public/index-price-kline":1,"derivatives/v3/public/funding/history-funding-rate":1,"derivatives/v3/public/risk-limit/list":1,"derivatives/v3/public/delivery-price":1,"derivatives/v3/public/recent-trade":1,"derivatives/v3/public/open-interest":1,"derivatives/v3/public/insurance":1}},private:{get:{"v2/private/order/list":5,"v2/private/order":5,"v2/private/stop-order/list":5,"v2/private/stop-order":1,"v2/private/position/list":25,"v2/private/position/fee-rate":40,"v2/private/execution/list":25,"v2/private/trade/closed-pnl/list":1,"v2/public/risk-limit/list":1,"v2/public/funding/prev-funding-rate":25,"v2/private/funding/prev-funding":25,"v2/private/funding/predicted-funding":25,"v2/private/account/api-key":5,"v2/private/account/lcp":1,"v2/private/wallet/balance":25,"v2/private/wallet/fund/records":25,"v2/private/wallet/withdraw/list":25,"v2/private/exchange-order/list":1,"private/linear/order/list":5,"private/linear/order/search":5,"private/linear/stop-order/list":5,"private/linear/stop-order/search":5,"private/linear/position/list":25,"private/linear/trade/execution/list":25,"private/linear/trade/closed-pnl/list":25,"public/linear/risk-limit":1,"private/linear/funding/predicted-funding":25,"private/linear/funding/prev-funding":25,"futures/private/order/list":5,"futures/private/order":5,"futures/private/stop-order/list":5,"futures/private/stop-order":5,"futures/private/position/list":25,"futures/private/execution/list":25,"futures/private/trade/closed-pnl/list":1,"spot/v1/account":2.5,"spot/v1/order":2.5,"spot/v1/open-orders":2.5,"spot/v1/history-orders":2.5,"spot/v1/myTrades":2.5,"spot/v1/cross-margin/order":10,"spot/v1/cross-margin/accounts/balance":10,"spot/v1/cross-margin/loan-info":10,"spot/v1/cross-margin/repay/history":10,"spot/v3/private/order":2.5,"spot/v3/private/open-orders":2.5,"spot/v3/private/history-orders":2.5,"spot/v3/private/my-trades":2.5,"spot/v3/private/account":2.5,"spot/v3/private/reference":2.5,"spot/v3/private/record":2.5,"spot/v3/private/cross-margin-orders":10,"spot/v3/private/cross-margin-account":10,"spot/v3/private/cross-margin-loan-info":10,"spot/v3/private/cross-margin-repay-history":10,"asset/v1/private/transfer/list":50,"asset/v3/private/transfer/inter-transfer/list/query":.84,"asset/v1/private/sub-member/transfer/list":50,"asset/v3/private/transfer/sub-member/list/query":.84,"asset/v3/private/transfer/sub-member-transfer/list/query":.84,"asset/v3/private/transfer/universal-transfer/list/query":.84,"asset/v1/private/sub-member/member-ids":50,"asset/v1/private/deposit/record/query":50,"asset/v1/private/withdraw/record/query":25,"asset/v1/private/coin-info/query":25,"asset/v3/private/coin-info/query":25,"asset/v1/private/asset-info/query":50,"asset/v1/private/deposit/address":100,"asset/v3/private/deposit/address/query":.17,"asset/v1/private/universal/transfer/list":50,"contract/v3/private/copytrading/order/list":1,"contract/v3/private/copytrading/position/list":1,"contract/v3/private/copytrading/wallet/balance":1,"contract/v3/private/position/limit-info":25,"contract/v3/private/order/unfilled-orders":1,"contract/v3/private/order/list":1,"contract/v3/private/position/list":1,"contract/v3/private/execution/list":1,"contract/v3/private/position/closed-pnl":1,"contract/v3/private/account/wallet/balance":1,"contract/v3/private/account/fee-rate":1,"contract/v3/private/account/wallet/fund-records":1,"unified/v3/private/order/unfilled-orders":1,"unified/v3/private/order/list":1,"unified/v3/private/position/list":1,"unified/v3/private/execution/list":1,"unified/v3/private/delivery-record":1,"unified/v3/private/settlement-record":1,"unified/v3/private/account/wallet/balance":1,"unified/v3/private/account/transaction-log":1,"asset/v2/private/exchange/exchange-order-all":1,"unified/v3/private/account/borrow-history":1,"unified/v3/private/account/borrow-rate":1,"user/v3/private/frozen-sub-member":10,"user/v3/private/query-sub-members":5,"user/v3/private/query-api":5,"asset/v3/private/transfer/transfer-coin/list/query":.84,"asset/v3/private/transfer/account-coin/balance/query":.84,"asset/v3/private/transfer/asset-info/query":.84,"asset/v3/public/deposit/allowed-deposit-list/query":.17,"asset/v3/private/deposit/record/query":.17,"asset/v3/private/withdraw/record/query":.17},post:{"v2/private/order/create":30,"v2/private/order/cancel":30,"v2/private/order/cancelAll":300,"v2/private/order/replace":30,"v2/private/stop-order/create":30,"v2/private/stop-order/cancel":30,"v2/private/stop-order/cancelAll":300,"v2/private/stop-order/replace":30,"v2/private/position/change-position-margin":40,"v2/private/position/trading-stop":40,"v2/private/position/leverage/save":40,"v2/private/tpsl/switch-mode":40,"v2/private/position/switch-isolated":2.5,"v2/private/position/risk-limit":2.5,"v2/private/position/switch-mode":2.5,"private/linear/order/create":30,"private/linear/order/cancel":30,"private/linear/order/cancel-all":300,"private/linear/order/replace":30,"private/linear/stop-order/create":30,"private/linear/stop-order/cancel":30,"private/linear/stop-order/cancel-all":300,"private/linear/stop-order/replace":30,"private/linear/position/set-auto-add-margin":40,"private/linear/position/switch-isolated":40,"private/linear/position/switch-mode":40,"private/linear/tpsl/switch-mode":2.5,"private/linear/position/add-margin":40,"private/linear/position/set-leverage":40,"private/linear/position/trading-stop":40,"private/linear/position/set-risk":2.5,"futures/private/order/create":30,"futures/private/order/cancel":30,"futures/private/order/cancelAll":30,"futures/private/order/replace":30,"futures/private/stop-order/create":30,"futures/private/stop-order/cancel":30,"futures/private/stop-order/cancelAll":30,"futures/private/stop-order/replace":30,"futures/private/position/change-position-margin":40,"futures/private/position/trading-stop":40,"futures/private/position/leverage/save":40,"futures/private/position/switch-mode":40,"futures/private/tpsl/switch-mode":40,"futures/private/position/switch-isolated":40,"futures/private/position/risk-limit":2.5,"spot/v1/order":2.5,"spot/v1/cross-margin/loan":10,"spot/v1/cross-margin/repay":10,"spot/v3/private/order":2.5,"spot/v3/private/cancel-order":2.5,"spot/v3/private/cancel-orders":2.5,"spot/v3/private/cancel-orders-by-ids":2.5,"spot/v3/private/purchase":2.5,"spot/v3/private/redeem":2.5,"spot/v3/private/cross-margin-loan":10,"spot/v3/private/cross-margin-repay":10,"asset/v1/private/transfer":150,"asset/v3/private/transfer/inter-transfer":2.5,"asset/v1/private/sub-member/transfer":150,"asset/v1/private/withdraw":50,"asset/v3/private/withdraw/create":1,"asset/v1/private/withdraw/cancel":50,"asset/v3/private/withdraw/cancel":.84,"asset/v1/private/transferable-subs/save":3e3,"asset/v1/private/universal/transfer":1500,"asset/v3/private/transfer/sub-member-transfer":2.5,"asset/v3/private/transfer/transfer-sub-member-save":2.5,"asset/v3/private/transfer/universal-transfer":2.5,"user/v3/private/create-sub-member":10,"user/v3/private/create-sub-api":10,"user/v3/private/update-api":10,"user/v3/private/delete-api":10,"user/v3/private/update-sub-api":10,"user/v3/private/delete-sub-api":10,"option/usdc/openapi/private/v1/place-order":2.5,"option/usdc/openapi/private/v1/batch-place-order":2.5,"option/usdc/openapi/private/v1/replace-order":2.5,"option/usdc/openapi/private/v1/batch-replace-orders":2.5,"option/usdc/openapi/private/v1/cancel-order":2.5,"option/usdc/openapi/private/v1/batch-cancel-orders":2.5,"option/usdc/openapi/private/v1/cancel-all":2.5,"option/usdc/openapi/private/v1/query-active-orders":2.5,"option/usdc/openapi/private/v1/query-order-history":2.5,"option/usdc/openapi/private/v1/execution-list":2.5,"option/usdc/openapi/private/v1/query-transaction-log":2.5,"option/usdc/openapi/private/v1/query-wallet-balance":2.5,"option/usdc/openapi/private/v1/query-asset-info":2.5,"option/usdc/openapi/private/v1/query-margin-info":2.5,"option/usdc/openapi/private/v1/query-position":2.5,"option/usdc/openapi/private/v1/query-delivery-list":2.5,"option/usdc/openapi/private/v1/query-position-exp-date":2.5,"option/usdc/openapi/private/v1/mmp-modify":2.5,"option/usdc/openapi/private/v1/mmp-reset":2.5,"perpetual/usdc/openapi/private/v1/place-order":2.5,"perpetual/usdc/openapi/private/v1/replace-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-all":2.5,"perpetual/usdc/openapi/private/v1/position/leverage/save":2.5,"option/usdc/openapi/private/v1/session-settlement":2.5,"option/usdc/private/asset/account/setMarginMode":2.5,"perpetual/usdc/openapi/public/v1/risk-limit/list":2.5,"perpetual/usdc/openapi/private/v1/position/set-risk-limit":2.5,"perpetual/usdc/openapi/private/v1/predicted-funding":2.5,"contract/v3/private/copytrading/order/create":2.5,"contract/v3/private/copytrading/order/cancel":2.5,"contract/v3/private/copytrading/order/close":2.5,"contract/v3/private/copytrading/position/close":2.5,"contract/v3/private/copytrading/position/set-leverage":2.5,"contract/v3/private/copytrading/wallet/transfer":2.5,"contract/v3/private/copytrading/order/trading-stop":2.5,"contract/v3/private/order/create":1,"contract/v3/private/order/cancel":1,"contract/v3/private/order/cancel-all":1,"contract/v3/private/order/replace":1,"contract/v3/private/position/set-auto-add-margin":1,"contract/v3/private/position/switch-isolated":1,"contract/v3/private/position/switch-mode":1,"contract/v3/private/position/switch-tpsl-mode":1,"contract/v3/private/position/set-leverage":1,"contract/v3/private/position/trading-stop":1,"contract/v3/private/position/set-risk-limit":1,"contract/v3/private/account/setMarginMode":1,"unified/v3/private/order/create":2.5,"unified/v3/private/order/replace":2.5,"unified/v3/private/order/cancel":2.5,"unified/v3/private/order/create-batch":2.5,"unified/v3/private/order/replace-batch":2.5,"unified/v3/private/order/cancel-batch":2.5,"unified/v3/private/order/cancel-all":2.5,"unified/v3/private/position/set-leverage":2.5,"unified/v3/private/position/tpsl/switch-mode":2.5,"unified/v3/private/position/set-risk-limit":2.5,"unified/v3/private/position/trading-stop":2.5,"unified/v3/private/account/upgrade-unified-account":2.5,"fht/compliance/tax/v3/private/registertime":50,"fht/compliance/tax/v3/private/create":50,"fht/compliance/tax/v3/private/status":50,"fht/compliance/tax/v3/private/url":50},delete:{"spot/v1/order":2.5,"spot/v1/order/fast":2.5,"spot/order/batch-cancel":2.5,"spot/order/batch-fast-cancel":2.5,"spot/order/batch-cancel-by-ids":2.5}}},httpExceptions:{403:Ko},exceptions:{exact:{"-10009":ke,"-1004":ke,"-1021":ke,"-1103":ke,"-1140":ee,"-1197":ee,"-2013":ee,"-2015":xn,"-6017":ke,"-6025":ke,"-6029":ke,5004:ns,7001:ke,10001:ke,10002:u3,10003:xn,10004:xn,10005:Gs,10006:Ko,10007:xn,10008:xn,10009:xn,10010:Gs,10014:ke,10016:ns,10017:ke,10018:Ko,10020:Gs,10027:Gs,12201:ke,110001:ee,110003:ee,110004:et,110005:ee,110006:et,110007:et,110008:ee,110009:ee,110010:ee,110011:ee,110012:et,110013:ke,110014:et,110015:ke,110016:ee,110017:ee,110018:ke,110019:ee,110020:ee,110021:ee,110022:ee,110023:ee,110024:ee,110025:ee,110026:ee,110027:ee,110028:ee,110029:ee,110030:ee,110031:ee,110032:ee,110033:ee,110034:ee,110035:ee,110036:ee,110037:ee,110038:ee,110039:ee,110040:ee,110041:ee,110042:ee,110043:ke,110044:et,110045:et,110046:ke,110047:ke,110048:ke,110049:ke,110050:ke,110051:et,110052:et,110053:et,110054:ee,110055:ee,110056:ee,110057:ee,110058:ee,110059:ee,110060:ke,110061:ke,110062:ke,110063:ns,110064:ee,110065:Gs,110066:ns,110067:Gs,110068:Gs,110069:Gs,110070:ee,130006:ee,130021:et,130074:ee,131001:et,140003:ee,140004:et,140005:ee,140006:et,140007:et,140008:ee,140009:ee,140010:ee,140011:ee,140012:et,140013:ke,140014:et,140015:ee,140016:ee,140017:ee,140018:ke,140019:ee,140020:ee,140021:ee,140022:ee,140023:ee,140024:ke,140025:ke,140026:ke,140027:ke,140028:ee,140029:ke,140030:ee,140031:ke,140032:ee,140033:ee,140034:ee,140035:ee,140036:ke,140037:ee,140038:ke,140039:ke,140040:ee,140041:ee,140042:ee,140043:ke,140044:et,140045:et,140046:ke,140047:ke,140048:ke,140049:ke,140050:ee,140051:et,140052:et,140053:et,140054:ee,140055:ee,140056:ee,140057:ee,140058:ee,140059:ee,140060:ke,140061:ke,140062:ke,140063:ns,140064:ee,140065:Gs,140066:ns,140067:Gs,140068:Gs,140069:Gs,140070:ee,20001:Tl,20003:ee,20004:ee,20005:ee,20006:ee,20007:ee,20008:ee,20009:ee,20010:ee,20011:ee,20012:ee,20013:ee,20014:ee,20015:ee,20016:ee,20017:ee,20018:ee,20019:ee,20020:ee,20021:ee,20022:ke,20023:ke,20031:ke,20070:ke,20071:ke,20084:ke,30001:ke,30003:ee,30004:ee,30005:ee,30007:ee,30008:ee,30009:ns,30010:et,30011:Gs,30012:Gs,30013:Gs,30014:ee,30015:ee,30016:ns,30017:ee,30018:ee,30019:ee,30020:ee,30021:ee,30022:ee,30023:ee,30024:ee,30025:ee,30026:ee,30027:ee,30028:ee,30029:ee,30030:ee,30031:et,30032:ee,30033:Ko,30034:Tl,30035:Ko,30036:ns,30037:ee,30041:ns,30042:et,30043:ee,30044:ee,30045:ee,30049:et,30050:ns,30051:ns,30052:ns,30054:ns,30057:ns,30063:ns,30067:et,30068:ns,30074:ee,30075:ee,30078:ns,33004:xn,34026:ns,34036:ke,35015:ke,3100116:ke,3100198:ke,3200300:et},broad:{"unknown orderInfo":Tl,"invalid api_key":xn,oc_diff:et,new_oc:et,"openapi sign params error!":xn}},precisionMode:c3,options:{createMarketBuyOrderRequiresPrice:!0,createUnifiedMarginAccount:!1,defaultType:"swap",defaultSubType:"linear",defaultSettle:"USDT",code:"BTC",recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,brokerId:"CCXT",accountsByType:{spot:"SPOT",margin:"SPOT",future:"CONTRACT",swap:"CONTRACT",option:"OPTION",investment:"INVESTMENT",unified:"UNIFIED",funding:"FUND"},accountsById:{SPOT:"spot",MARGIN:"spot",CONTRACT:"contract",OPTION:"option",INVESTMENT:"investment",UNIFIED:"unified"},networks:{ERC20:"ETH",TRC20:"TRX",BEP20:"BSC",OMNI:"OMNI",SPL:"SOL"},networksById:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20",OMNI:"OMNI",SPL:"SOL"},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:75e-5,maker:1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{GAS:"GASDAO"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async isUnifiedMarginEnabled(e={}){if(this.safeValue(this.options,"enableUnifiedMargin")===void 0){const s=await this.privateGetUserV3PrivateQueryApi(e),i=this.safeValue(s,"result",{});this.options.enableUnifiedMargin=this.safeInteger(i,"unified")===1}return this.options.enableUnifiedMargin}async upgradeUnifiedAccount(e={}){if(!this.safeValue(this.options,"createUnifiedMarginAccount"))throw new Ft(this.id+' upgradeUnifiedAccount() warning this method can only be called once, it is not reverseable and you will be stuck with a unified margin account, you also need at least 5000 USDT in your bybit account to do this. If you want to disable this warning set exchange.options["createUnifiedMarginAccount"]=true.');return await this.privatePostUnifiedV3PrivateAccountUpgradeUnifiedAccount(e)}async fetchTime(e={}){const t=await this.publicGetV3PublicTime(e);return this.safeInteger(t,"time")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetV3PrivateCoinInfoQuery(e),s=this.safeValue(t,"result",[]),i=this.safeValue(s,"rows",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"chains",[]),h={};let f;for(let l=0;l<u.length;l++){const m=u[l],g=this.safeString(m,"chain"),y=this.networkIdToCode(g),w=this.parseNumber(this.parsePrecision(this.safeString(m,"minAccuracy")));f=f===void 0?w:Math.min(f,w);const b=this.safeInteger(m,"chainDeposit")===1,S=this.safeInteger(m,"chainWithdraw")===1;h[y]={info:m,id:g,network:y,active:void 0,deposit:b,withdraw:S,fee:this.safeNumber(m,"withdrawFee"),precision:w,limits:{withdraw:{min:this.safeNumber(m,"withdrawMin"),max:void 0},deposit:{min:this.safeNumber(m,"depositMin"),max:void 0}}}}n[d]={info:a,code:d,id:o,name:c,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:f,limits:{amount:{min:void 0,max:void 0}},networks:h}}return n}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t=[this.fetchSpotMarkets(e),this.fetchDerivativesMarkets({category:"linear"}),this.fetchDerivativesMarkets({category:"inverse"})];t=await Promise.all(t);const s=t[0],i=t[1],n=t[2];let r=s;return r=this.arrayConcat(r,i),this.arrayConcat(r,n)}async fetchSpotMarkets(e){const t=await this.publicGetSpotV3PublicSymbols(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"list",[]),n=[],r=this.parseNumber("0.001"),a=this.parseNumber("0.001");for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"name"),u=this.safeString(d,"baseCoin"),h=this.safeString(d,"quoteCoin"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h),m=f+"/"+l,g=this.safeInteger(d,"showStatus")===1,y=this.safeNumber(d,"quotePrecision");n.push({id:c,symbol:m,base:f,quote:l,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:r,maker:a,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(d,"basePrecision"),price:this.safeNumber(d,"minPricePrecision",y)},limits:{leverage:{min:this.parseNumber("1"),max:void 0},amount:{min:this.safeNumber(d,"minTradeQty"),max:this.safeNumber(d,"maxTradeQty")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"minTradeAmt"),max:this.safeNumber(d,"maxTradeAmt")}},info:d})}return n}async fetchDerivativesMarkets(e){e.limit=1e3;const t=await this.publicGetDerivativesV3PublicInstrumentsInfo(e),s=this.safeValue(t,"result",{});let i=this.safeValue(s,"list",[]),n=this.safeString(s,"nextPageCursor");if(n!==void 0)for(;n!==void 0;){e.cursor=n;const o=await this.publicGetDerivativesV3PublicInstrumentsInfo(e),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"list",[]);if(c.length===0)break;i=this.arrayConcat(c,i),n=this.safeString(d,"nextPageCursor")}const r=[];let a=this.safeString(s,"category");for(let o=0;o<i.length;o++){const d=i[o];a===void 0&&(a=this.safeString(d,"category"));const c=a==="linear",u=a==="inverse",h=this.safeString(d,"contractType"),f=h==="InverseFutures",l=h==="LinearPerpetual",m=h==="InversePerpetual",g=this.safeString(d,"symbol"),y=this.safeString(d,"baseCoin"),w=this.safeString(d,"quoteCoin"),b=c?w:y,S=this.safeString(d,"settleCoin",b),v=this.safeCurrencyCode(y),T=this.safeCurrencyCode(w);let I;l&&S==="USD"?I="USDC":I=this.safeCurrencyCode(S);let A=v+"/"+T;const N=this.safeValue(d,"lotSizeFilter",{}),B=this.safeValue(d,"priceFilter",{}),x=this.safeValue(d,"leverageFilter",{}),k=this.safeString(d,"status");let O;k!==void 0&&(O=k==="Trading");const P=l||m,q=f,L=a==="option";let D;P?D="swap":q?D="future":L&&(D="option");let H=this.omitZero(this.safeString(d,"deliveryTime"));H!==void 0&&(H=parseInt(H));const R=this.iso8601(H);let _,E;if(A=A+":"+I,H!==void 0&&(A=A+"-"+this.yymmdd(H),L)){const G=g.split("-");_=this.safeString(G,2);const $=this.safeString(G,3);A=A+"-"+_+"-"+$,$==="P"?E="put":$==="C"&&(E="call")}const U=u?this.safeNumber2(N,"minTradingQty","minOrderQty"):this.parseNumber("1");r.push({id:g,symbol:A,base:v,quote:T,settle:I,baseId:y,quoteId:w,settleId:S,type:D,spot:!1,margin:void 0,swap:P,future:q,option:L,active:O,contract:!0,linear:c,inverse:u,taker:this.safeNumber(d,"takerFee",this.parseNumber("0.0006")),maker:this.safeNumber(d,"makerFee",this.parseNumber("0.0001")),contractSize:U,expiry:H,expiryDatetime:R,strike:_,optionType:E,precision:{amount:this.safeNumber(N,"qtyStep"),price:this.safeNumber(B,"tickSize")},limits:{leverage:{min:this.safeNumber(x,"minLeverage"),max:this.safeNumber(x,"maxLeverage")},amount:{min:this.safeNumber2(N,"minTradingQty","minOrderQty"),max:this.safeNumber2(N,"maxTradingQty","maxOrderQty")},price:{min:this.safeNumber(B,"minPrice"),max:this.safeNumber(B,"maxPrice")},cost:{min:void 0,max:void 0}},info:d})}return r}parseTicker(e,t=void 0){return"s"in e?this.parseSpotTicker(e,t):this.parseContractTicker(e,t)}parseSpotTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeSymbol(s,t,void 0,"spot"),n=this.safeInteger(e,"t");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"bp"),bidVolume:this.safeString(e,"bq"),ask:this.safeString(e,"ap"),askVolume:this.safeString(e,"aq"),vwap:void 0,open:this.safeString(e,"o"),close:this.safeString2(e,"lp","c"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"qv"),info:e},t)}parseContractTicker(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,void 0,"contract"),r=this.safeString2(e,"last_price","lastPrice"),a=this.safeStringN(e,["prev_price_24h","openPrice","prevPrice24h"]);let o=this.safeStringN(e,["price_24h_pcnt","change24h","price24hPcnt"]);o=$e.stringMul(o,"100");const d=this.safeStringN(e,["turnover_24h","turnover24h","quoteVolume"]),c=this.safeStringN(e,["volume_24h","volume24h","volume"]),u=this.safeStringN(e,["bid_price","bid","bestBidPrice","bidPrice","bid1Price"]),h=this.safeStringN(e,["ask_price","ask","bestAskPrice","askPrice","ask1Price"]),f=this.safeStringN(e,["high_price_24h","high24h","highPrice","highPrice24h"]),l=this.safeStringN(e,["low_price_24h","low24h","lowPrice","lowPrice24h"]);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:f,low:l,bid:u,bidVolume:this.safeString2(e,"bidSize","bid1Size"),ask:h,askVolume:this.safeString2(e,"askSize","ask1Size"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:c,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;s.spot?n="publicGetSpotV3PublicQuoteTicker24hr":(n="publicGetDerivativesV3PublicTickers",s.option?i.category="option":s.linear?i.category="linear":s.inverse&&(i.category="inverse"));const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"result",[]);let o;if(Array.isArray(a))o=this.safeValue(a,0);else{const d=this.safeValue(a,"list");d!==void 0?o=this.safeValue(d,0):o=a}return this.parseTicker(o,s)}async fetchSpotTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetSpotV3PublicQuoteTicker24hr(t),i=this.safeValue(s,"result",[]),n=this.safeValue(i,"list"),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchDerivativesTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},[i,n]=this.handleSubTypeAndParams("fetchTickers",void 0,t,"linear");if(i==="option")throw new Ft(this.id+" fetchTickers() is not supported for option markets");s.category=i;const r=await this.publicGetDerivativesV3PublicTickers(this.extend(s,n));let a=this.safeValue(r,"result",[]);Array.isArray(a)||(a=this.safeValue(a,"list"));const o={};for(let d=0;d<a.length;d++){const c=this.parseTicker(a[d]),u=c.symbol;o[u]=c}return this.filterByArray(o,"symbol",e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(e=this.marketSymbols(e),s=this.market(e[0]));const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t);return i==="spot"?await this.fetchSpotTickers(e,n):await this.fetchDerivativesTickers(e,n)}parseOHLCV(e,t=void 0){return"t"in e?this.parseSpotOHLCV(e,t):this.parseContractOHLCV(e,t)}parseSpotOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseContractOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchSpotOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=this.parseTimeframe(t),d=this.seconds();let c;i===void 0&&(i=200),s===void 0?c=d-i*o:c=parseInt(s/1e3),i!==void 0&&(a.limit=i),a.interval=t,a.from=c;const u=await this.publicGetSpotV3PublicQuoteKline(this.extend(a,n)),h=this.safeValue(u,"result",{}),f=this.safeValue(h,"list",[]);return this.parseOHLCVs(f,r,t,s,i)}async fetchDerivativesOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(r.option)throw new Ft(this.id+" fetchOHLCV() is not supported for option markets");const a={symbol:r.id},o=this.parseTimeframe(t),d=this.milliseconds();i===void 0?i=200:a.limit=i,s===void 0&&(s=d-i*o*1e3);let c=this.safeInteger(n,"end");c===void 0&&(c=this.sum(s,i*o*1e3)),r.linear?a.category="linear":r.inverse&&(a.category="inverse"),a.start=s,a.end=c,a.interval=this.timeframes[t];const u=this.safeString(n,"price");n=this.omit(n,"price");const h={mark:"publicGetDerivativesV3PublicMarkPriceKline",index:"publicGetDerivativesV3PublicIndexPriceKline"},f=this.safeValue(h,u,"publicGetDerivativesV3PublicKline"),l=await this[f](this.extend(a,n)),m=this.safeValue(l,"result",{}),g=this.safeValue(m,"list",[]);return this.parseOHLCVs(g,r,t,s,i)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){return await this.loadMarkets(),this.market(e).spot?await this.fetchSpotOHLCV(e,t,s,i,n):await this.fetchDerivativesOHLCV(e,t,s,i,n)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"timestamp");e=this.omit(e,"timestamp");const i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,void 0,"swap"),r=this.safeNumber(e,"fundingRate"),a=this.safeInteger(e,"nextFundingTime"),o=this.safeNumber(e,"markPrice"),d=this.safeNumber(e,"indexPrice");return{info:e,symbol:n,markPrice:o,indexPrice:d,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:this.iso8601(s),fundingRate:r,fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);t.symbol=s.id;const i=[s.symbol];return await this.fetchFundingRates(i,t)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i="swap",n;s!==void 0&&(n=this.market(s),i=n.type);const r={};let a;if([a,t]=this.handleSubTypeAndParams("fetchFundingRates",n,t,"linear"),i!=="swap")throw new Ft(this.id+" fetchFundingRates() does not support "+i+" markets");r.category=a;const o=await this.publicGetDerivativesV3PublicTickers(this.extend(r,t));let d=this.safeValue(o,"result",[]);const c=this.safeInteger(o,"time");Array.isArray(d)||(d=this.safeValue(d,"list"));const u={};for(let h=0;h<d.length;h++){const f=d[h];f.timestamp=c;const l=this.parseFundingRate(d[h],void 0),m=l.symbol;u[m]=l}return this.filterByArray(u,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new st(this.id+" fetchFundingRateHistory() requires a symbol");await this.loadMarkets();const n={},r=this.market(e);if(e=r.symbol,n.symbol=r.id,r.option)throw new Ft(this.id+" fetchFundingRateHistory() is not supported for option markets");r.linear?n.category="linear":r.inverse&&(n.category="inverse"),t!==void 0&&(n.startTime=t);const a=this.safeInteger2(i,"until","till"),o=this.safeInteger(i,"endTime",a);i=this.omit(i,["endTime","till","until"]),o!==void 0&&(n.endTime=o),s!==void 0&&(n.limit=s);const d=await this.publicGetDerivativesV3PublicFundingHistoryFundingRate(this.extend(n,i)),c=[],u=this.safeValue(d,"result"),h=this.safeValue(u,"list");for(let l=0;l<h.length;l++){const m=h[l],g=this.safeInteger(m,"fundingRateTimestamp");c.push({info:m,symbol:this.safeSymbol(this.safeString(m,"symbol"),void 0,void 0,"swap"),fundingRate:this.safeNumber(m,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const f=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(f,e,t,s)}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}parseTrade(e,t=void 0){return"isBuyerMaker"in e||"feeTokenId"in e?this.parseSpotTrade(e,t):this.parseContractTrade(e,t)}parseSpotTrade(e,t=void 0){const s=this.safeIntegerN(e,["time","creatTime"]);let i,n;const r=this.safeInteger(e,"isBuyerMaker");if(r!==void 0)n=r===1?"buy":"sell";else{const c=this.safeInteger(e,"isBuyer");i=this.safeInteger(e,"isMaker")===0?"maker":"taker",n=c===0?"buy":"sell"}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t,void 0,"spot");let o;const d=this.safeString(e,"execFee");if(d!==void 0){const c=this.safeString(e,"feeTokenId"),u=this.safeCurrencyCode(c);o={cost:d,currency:u}}return this.safeTrade({id:this.safeString(e,"tradeId"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"orderId"),type:void 0,side:n,takerOrMaker:i,price:this.safeString2(e,"price","orderPrice"),amount:this.safeString2(e,"qty","orderQty"),cost:void 0,fee:o},t)}parseContractTrade(e,t=void 0){const s=this.safeStringN(e,["execId","id","tradeId"]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,void 0,"contract");const n=t.symbol,r=this.safeStringN(e,["execQty","orderQty","size"]),a=this.safeStringN(e,["execPrice","orderPrice","price"]),o=this.safeString(e,"execValue"),d=this.safeIntegerN(e,["time","execTime","tradeTime"]);let c=this.safeStringLower(e,"side");if(c===void 0){const g=this.safeInteger(e,"isBuyer");g!==void 0&&(c=g?"buy":"sell")}const u=this.safeValue(e,"isMaker");let h;if(u!==void 0)h=u?"maker":"taker";else{let g=this.safeString(e,"lastLiquidityInd");g==="UNKNOWN"&&(g=void 0),g!==void 0&&(g==="TAKER"||g==="MAKER"?h=g.toLowerCase():h=g==="AddedLiquidity"?"maker":"taker")}let f=this.safeStringLower(e,"orderType");f==="unknown"&&(f=void 0);const l=this.safeString(e,"execFee");let m;if(l!==void 0){let g;t.spot?g=this.safeString(e,"commissionAsset"):g=t.inverse?t.base:t.settle,m={cost:l,currency:g}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:n,order:this.safeString(e,"orderId"),type:f,side:c,takerOrMaker:h,price:a,amount:r,cost:o,fee:m},t)}async fetchSpotTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetSpotV3PublicQuoteTrades(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTrades(d,n,t,s)}async fetchDerivativesTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),n.option?r.category="option":n.linear?r.category="linear":n.inverse&&(r.category="inverse");const a=await this.publicGetDerivativesV3PublicRecentTrade(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTrades(d,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.market(e).type==="spot"?await this.fetchSpotTrades(e,t,s,i):await this.fetchDerivativesTrades(e,t,s,i)}async fetchSpotOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetSpotV3PublicQuoteDepth(this.extend(n,s)),a=this.safeValue(r,"result",[]),o=this.safeInteger(a,"time");return this.parseOrderBook(a,e,o)}async fetchDerivativesOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t),i.option?n.category="option":i.linear?n.category="linear":i.inverse&&(n.category="inverse");const r=await this.publicGetDerivativesV3PublicOrderBookL2(this.extend(n,s)),a=this.safeValue(r,"result",[]),o=this.safeInteger(a,"ts");return this.parseOrderBook(a,e,o,"b","a")}async fetchOrderBook(e,t=void 0,s={}){return await this.loadMarkets(),this.market(e).spot?await this.fetchSpotOrderBook(e,t,s):await this.fetchDerivativesOrderBook(e,t,s)}parseBalance(e){const t={info:e},s=this.safeValue(e,"result",{}),i=this.safeValueN(s,["loanAccountList","list","coin","balances"]);if(i===void 0){const n="USDC",r=this.account();r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"walletBalance"),t[n]=r}else for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.safeString(r,"loan"),d=this.safeString(r,"interest");o!==void 0&&d!==void 0&&(a.debt=$e.stringAdd(o,d)),a.total=this.safeString2(r,"total","walletBalance"),a.free=this.safeStringN(r,["free","availableBalanceWithoutConvert","availableBalance"]),a.used=this.safeString(r,"locked");const c=this.safeStringN(r,["tokenId","coin","currencyCoin"]),u=this.safeCurrencyCode(c);t[u]=a}return this.safeBalance(t)}async fetchSpotBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarginModeAndParams("fetchBalance",e);let s="privateGetSpotV3PrivateAccount";t!==void 0&&(s="privateGetSpotV3PrivateCrossMarginAccount");const i=await this[s](e);return this.parseBalance(i)}async fetchUnifiedMarginBalance(e={}){await this.loadMarkets();const t=await this.privateGetUnifiedV3PrivateAccountWalletBalance(e);return this.parseBalance(t)}async fetchDerivativesBalance(e={}){await this.loadMarkets();const t={},s=await this.privateGetContractV3PrivateAccountWalletBalance(this.extend(t,e));return this.parseBalance(s)}async fetchUSDCBalance(e={}){await this.loadMarkets();const t=await this.privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance(e);return this.parseBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t;return[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),t==="spot"?await this.fetchSpotBalance(e):await this.isUnifiedMarginEnabled()?await this.fetchUnifiedMarginBalance(e):await this.fetchDerivativesBalance(e)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"open",PENDING_NEW:"open",REJECTED:"rejected",Created:"open",New:"open",Rejected:"rejected",PartiallyFilled:"open",Filled:"closed",PendingCancel:"open",Cancelled:"canceled",Untriggered:"open",Deactivated:"canceled",Triggered:"open",Active:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK",PostOnly:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){return"orderCategory"in e?this.parseSpotOrder(e,t):this.parseContractOrder(e,t)}parseContractOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=t.symbol,n=this.safeInteger(e,"createdTime"),r=this.safeString(e,"orderId"),a=this.safeStringLower(e,"orderType"),o=this.safeString(e,"price"),d=this.safeString(e,"qty"),c=this.safeString(e,"cumExecValue"),u=this.safeString(e,"cumExecQty"),h=this.safeString(e,"leavesQty"),f=this.safeInteger(e,"updateTime"),l=this.safeString(e,"orderStatus"),m=this.parseOrderStatus(l),g=this.safeStringLower(e,"side");let y;if(this.safeValue(t,"contract")){const I=this.safeString(e,"cumExecFee");I!==void 0&&(y={cost:I,currency:t.settle})}let b=this.safeString(e,"orderLinkId");b!==void 0&&b.length<1&&(b=void 0);const S=this.safeString(e,"timeInForce"),v=this.parseTimeInForce(S),T=this.omitZero(this.safeString(e,"triggerPrice"));return this.safeOrder({info:e,id:r,clientOrderId:b,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:f,symbol:i,type:a,timeInForce:v,postOnly:void 0,side:g,price:o,stopPrice:T,triggerPrice:T,amount:d,cost:c,average:void 0,filled:u,remaining:h,status:m,fee:y,trades:void 0},t)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"spot");const i=this.safeInteger(e,"createTime"),n=this.safeStringLower(e,"orderType");let r=this.safeString(e,"orderPrice");r==="0"&&n==="market"&&(r=void 0);const a=this.safeString(e,"execQty"),o=this.safeStringLower(e,"side"),d=this.parseTimeInForce(this.safeString(e,"timeInForce")),c=this.safeString(e,"triggerPrice"),u=d==="PO";let h=this.safeString(e,"orderQty");return(h===void 0||h==="0")&&t.spot&&n==="market"&&o==="buy"&&(h=a),this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"orderLinkId"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updateTime"),symbol:t.symbol,type:n,timeInForce:d,postOnly:u,side:o,price:r,triggerPrice:c,stopPrice:c,amount:h,cost:this.safeString(e,"cummulativeQuoteQty"),average:this.safeString(e,"avgPrice"),filled:a,remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),fee:void 0,trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;if([n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),n==="spot"){const r={orderId:e},a=await this.privateGetSpotV3PrivateOrder(this.extend(s,r)),o=this.safeValue(a,"result",{});return this.parseOrder(o,i)}else{if(i===void 0)throw new st(this.id+" fetchOrder() requires a symbol argument for "+n+" markets");const r={orderId:e},a=await this.fetchOrders(t,void 0,void 0,this.extend(r,s));if(a.length>1)throw new ee(this.id+" returned more than one order");return this.safeValue(a,0)}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=await this.isUnifiedMarginEnabled(),d=a.settle==="USDC";return a.spot?await this.createSpotOrder(e,t,s,i,n,r):o&&!a.inverse?await this.createUnifiedMarginOrder(e,t,s,i,n,r):d?await this.createUsdcOrder(e,t,s,i,n,r):await this.createContractV3Order(e,t,s,i,n,r)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){const g=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),n===void 0&&g===void 0)throw new ee(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const y=this.numberToString(i),w=this.numberToString(n),b=$e.stringMul(y,w);i=g!==void 0?g:this.parseNumber(b)}}const o=t.toUpperCase(),d={symbol:a.id,side:this.capitalize(s),orderType:o,timeInForce:"GTC",orderQty:this.amountToPrecision(e,i)};if(o==="LIMIT"||o==="LIMIT_MAKER"){if(n===void 0)throw new ee(this.id+" createOrder requires a price argument for a "+t+" order");d.orderPrice=this.priceToPrecision(e,n)}this.isPostOnly(o==="MARKET",t==="LIMIT_MAKER",r)&&(d.orderType="LIMIT_MAKER");const u=this.safeString2(r,"clientOrderId","orderLinkId");u!==void 0&&(d.orderLinkId=u),r=this.omit(r,["clientOrderId","orderLinkId","postOnly"]);const h=this.safeString(this.options,"brokerId");h!==void 0&&(d.agentSource=h);const f=this.safeNumber2(r,"triggerPrice","stopPrice");f!==void 0&&(r.triggerPrice=this.priceToPrecision(e,f)),r=this.omit(r,"stopPrice");const l=await this.privatePostSpotV3PrivateOrder(this.extend(d,r)),m=this.safeValue(l,"result",{});return this.parseOrder(m)}async createUnifiedMarginOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(!a.linear&&!a.option)throw new Ft(this.id+" createOrder does not allow inverse market orders for "+e+" markets");if(n===void 0&&t==="limit")throw new st(this.id+" createOrder requires a price argument for limit orders");const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),orderType:this.capitalize(o),timeInForce:"GoodTillCancel",qty:this.amountToPrecision(e,i)};a.linear?d.category="linear":d.category="option";const c=o==="market";o==="limit"&&(d.price=this.priceToPrecision(e,n));const h=this.safeString(r,"time_in_force"),f=this.safeStringLower(r,"timeInForce");this.isPostOnly(c,h==="PostOnly",r)?d.timeInForce="PostOnly":f==="gtc"?d.timeInForce="GoodTillCancel":f==="fok"?d.timeInForce="FillOrKill":f==="ioc"&&(d.timeInForce="ImmediateOrCancel");const m=this.safeValue2(r,"stopPrice","triggerPrice"),g=this.safeValue(r,"stopLossPrice",m),y=g!==void 0,w=this.safeValue(r,"takeProfitPrice");if(y||w!==void 0){d.triggerBy="LastPrice";const I=y?g:w,A=this.priceToPrecision(e,I);d.triggerPrice=A;const N=s==="buy",B=g?!N:N,x=this.numberToString(a.precision.price);d.basePrice=B?$e.stringAdd(A,x):$e.stringSub(A,x)}const S=this.safeString(r,"clientOrderId");S!==void 0?d.orderLinkId=S:a.option&&(d.orderLinkId=this.uuid16()),r=this.omit(r,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const v=await this.privatePostUnifiedV3PrivateOrderCreate(this.extend(d,r)),T=this.safeValue(v,"result",{});return this.parseOrder(T)}async createContractV3Order(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(n===void 0&&t==="limit")throw new st(this.id+" createContractV3Order requires a price argument for limit orders");const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),orderType:this.capitalize(o),timeInForce:"GoodTillCancel",qty:this.amountToPrecision(e,i)};if(a.future){const I=this.safeInteger(r,"position_idx",0);d.position_idx=I,r=this.omit(r,"position_idx")}const c=o==="market";o==="limit"&&(d.price=this.priceToPrecision(e,n));const h=this.safeString(r,"time_in_force"),f=this.safeStringLower(r,"timeInForce");this.isPostOnly(c,h==="PostOnly",r)?d.timeInForce="PostOnly":f==="gtc"?d.timeInForce="GoodTillCancel":f==="fok"?d.timeInForce="FillOrKill":f==="ioc"&&(d.timeInForce="ImmediateOrCancel");const m=this.safeValue2(r,"stopPrice","triggerPrice"),g=this.safeValue(r,"stopLossPrice",m),y=g!==void 0,w=this.safeValue(r,"takeProfitPrice");if(y||w!==void 0){const I=y?g:w,A=this.priceToPrecision(e,I),N=s==="buy",B=g?!N:N;d.triggerDirection=B?2:1,d.triggerBy="LastPrice",d.triggerPrice=this.priceToPrecision(e,A)}const S=this.safeString(r,"clientOrderId");S!==void 0?d.orderLinkId=S:a.option&&(d.orderLinkId=this.uuid16()),r=this.omit(r,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const v=await this.privatePostContractV3PrivateOrderCreate(this.extend(d,r)),T=this.safeValue(v,"result",{});return this.parseOrder(T)}async createUsdcOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market")throw new Ft(this.id+"createOrder does not allow market orders for "+e+" markets");if(n===void 0&&t==="limit")throw new st(this.id+" createOrder requires a price argument for limit orders");const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),orderType:this.capitalize(o),timeInForce:"GoodTillCancel",orderQty:this.amountToPrecision(e,i)},c=o==="market";o==="limit"!==void 0&&(d.orderPrice=this.priceToPrecision(e,n));const h=this.safeString(r,"time_in_force"),f=this.safeStringLower(r,"timeInForce");if(this.isPostOnly(c,h==="PostOnly",r)?d.time_in_force="PostOnly":f==="gtc"?d.time_in_force="GoodTillCancel":f==="fok"?d.time_in_force="FillOrKill":f==="ioc"&&(d.time_in_force="ImmediateOrCancel"),a.swap){const b=this.safeValue2(r,"stopPrice","triggerPrice"),S=this.safeValue(r,"stopLossPrice",b),v=S!==void 0,T=this.safeValue(r,"takeProfitPrice");if(v||T!==void 0){d.orderFilter="StopOrder",d.trigger_by="LastPrice";const N=v?S:T,B=this.priceToPrecision(e,N);d.triggerPrice=B;const x=this.numberToString(a.precision.price);d.basePrice=v?$e.stringSub(B,x):$e.stringAdd(B,x)}else d.orderFilter="Order"}const m=this.safeString(r,"clientOrderId");m!==void 0?d.orderLinkId=m:a.option&&(d.orderLinkId=this.uuid16()),r=this.omit(r,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const g=a.option?"privatePostOptionUsdcOpenapiPrivateV1PlaceOrder":"privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder",y=await this[g](this.extend(d,r)),w=this.safeValue(y,"result",{});return this.parseOrder(w)}async editUnifiedMarginOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);if(!o.linear&&!o.option)throw new Ft(this.id+" editOrder does not allow inverse market orders for "+t+" markets");if(r===void 0&&s==="limit")throw new st(this.id+" editOrder requires a price argument for limit orders");const d=s.toLowerCase(),c={orderId:e,symbol:o.id,side:this.capitalize(i),orderType:this.capitalize(d),timeInForce:"GoodTillCancel",qty:this.amountToPrecision(t,n)};o.linear?c.category="linear":c.category="option";const u=d==="market";d==="limit"&&(c.price=this.priceToPrecision(t,r));const f=this.safeString(a,"time_in_force"),l=this.safeStringLower(a,"timeInForce");this.isPostOnly(u,f==="PostOnly",a)?c.timeInForce="PostOnly":l==="gtc"?c.timeInForce="GoodTillCancel":l==="fok"?c.timeInForce="FillOrKill":l==="ioc"&&(c.timeInForce="ImmediateOrCancel");const g=this.safeValue2(a,"stopPrice","triggerPrice"),y=this.safeValue(a,"stopLossPrice"),w=y!==void 0,b=this.safeValue(a,"takeProfitPrice"),S=b!==void 0;w&&(c.stopLoss=this.priceToPrecision(t,y)),S&&(c.takeProfit=this.priceToPrecision(t,b)),g!==void 0&&(c.triggerBy="LastPrice",c.triggerPrice=this.priceToPrecision(t,g));const v=this.safeString(a,"clientOrderId");v!==void 0&&(c.orderLinkId=v),a=this.omit(a,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const T=await this.privatePostUnifiedV3PrivateOrderReplace(this.extend(c,a)),I=this.safeValue(T,"result",{});return this.parseOrder(I)}async editContractV3Order(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const d={symbol:this.market(t).id,orderId:e,qty:this.amountToPrecision(t,n)};r!==void 0&&(d.price=this.priceToPrecision(t,r));const c=this.safeValue2(a,"stopPrice","triggerPrice"),u=this.safeValue(a,"stopLossPrice"),h=u!==void 0,f=this.safeValue(a,"takeProfitPrice"),l=f!==void 0;h&&(d.stopLoss=this.priceToPrecision(t,u)),l&&(d.takeProfit=this.priceToPrecision(t,f)),c!==void 0&&(d.triggerPrice=this.priceToPrecision(t,c)),a=this.omit(a,["stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]);const m=await this.privatePostContractV3PrivateOrderReplace(this.extend(d,a)),g=this.safeValue(m,"result",{});return{info:m,id:this.safeString(g,"orderId")}}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(t===void 0)throw new st(this.id+" editOrder() requires an symbol argument");await this.loadMarkets();const o=this.market(t),d=await this.isUnifiedMarginEnabled();if(o.spot)throw new Ft(this.id+" editOrder() does not support spot markets");return d&&!o.inverse?await this.editUnifiedMarginOrder(e,t,s,i,n,r,a):await this.editContractV3Order(e,t,s,i,n,r,a)}async cancelSpotOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={};e!==void 0&&(n.orderId=e);const r=await this.privatePostSpotV3PrivateCancelOrder(this.extend(n,s)),a=this.safeValue(r,"result",{});return this.parseOrder(a,i)}async cancelUnifiedMarginOrder(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" cancelUnifiedMarginOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeValue(s,"stop",!1);if(s=this.omit(s,["stop"]),n.orderFilter=r?"StopOrder":"Order",e!==void 0&&(n.orderId=e),i.option)n.category="option";else if(i.linear)n.category="linear";else throw new Ft(this.id+" cancelUnifiedMarginOrder() does not allow inverse market orders for "+t+" markets");const a=await this.privatePostUnifiedV3PrivateOrderCancel(this.extend(n,s)),o=this.safeValue(a,"result",{});return this.parseOrder(o,i)}async cancelUSDCOrder(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" cancelUSDCOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeValue(s,"stop",!1);s=this.omit(s,["stop"]);let a;e!==void 0&&(n.orderId=e),i.option?a="privatePostOptionUsdcOpenapiPrivateV1CancelOrder":(a="privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder",n.orderFilter=r?"StopOrder":"Order");const o=await this[a](this.extend(n,s)),d=this.safeValue(o,"result",{});return this.parseOrder(d,i)}async cancelDerivativesOrder(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" cancelDerivativesOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,orderId:e},r=await this.privatePostContractV3PrivateOrderCancel(this.extend(n,s)),a=this.safeValue(r,"result",{});return this.parseOrder(a,i)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=await this.isUnifiedMarginEnabled(),r=i.settle==="USDC";return i.spot?await this.cancelSpotOrder(e,t,s):n&&!i.inverse?await this.cancelUnifiedMarginOrder(e,t,s):r?await this.cancelUSDCOrder(e,t,s):await this.cancelDerivativesOrder(e,t,s)}async cancelAllSpotOrders(e=void 0,t={}){if(e===void 0)throw new st(this.id+" cancelAllSpotOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.privateDeleteSpotOrderBatchCancel(this.extend(i,t)),r=this.safeValue(n,"result",[]);return Array.isArray(r)?this.parseOrders(r,s):n}async cancelAllUnifiedMarginOrders(e=void 0,t={}){await this.loadMarkets();let s,i;const n={};e!==void 0&&(s=this.market(e),i=s.settle,n.symbol=s.id);let r;[r,t]=this.handleSubTypeAndParams("cancelAllOrders",s,t,"linear"),n.category=r,[i,t]=this.handleOptionAndParams(t,"cancelAllOrders","settle",i),i!==void 0&&(n.settleCoin=i);const a=this.safeValue(t,"stop",!1);t=this.omit(t,["stop"]),a&&(n.orderFilter="StopOrder");const o=await this.privatePostUnifiedV3PrivateOrderCancelAll(this.extend(n,t)),d=this.safeValue(o,"result",[]),c=this.safeValue(d,"list");return Array.isArray(c)?this.parseOrders(c,s):o}async cancelAllUSDCOrders(e=void 0,t={}){if(e===void 0)throw new st(this.id+" cancelAllUSDCOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e);let i;const n={symbol:s.id};s.option?i="privatePostOptionUsdcOpenapiPrivateV1CancelAll":(i="privatePostPerpetualUsdcOpenapiPrivateV1CancelAll",this.safeValue(t,"stop",!1)?n.orderFilter="StopOrder":n.orderFilter="Order",t=this.omit(t,["stop"]));const r=await this[i](this.extend(n,t)),a=this.safeValue(r,"result",[]);return Array.isArray(a)?this.parseOrders(a,s):r}async cancelAllDerivativesOrders(e=void 0,t={}){await this.loadMarkets();let s,i;const n={};e!==void 0&&(s=this.market(e),i=s.settle,n.symbol=s.id),[i,t]=this.handleOptionAndParams(t,"cancelAllOrders","settle",i),i!==void 0&&(n.settleCoin=i);const r=await this.privatePostContractV3PrivateOrderCancelAll(this.extend(n,t)),a=this.safeValue(r,"result",[]),o=this.safeValue(a,"list",[]);return this.parseOrders(o,s)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s,i=this.safeString(t,"settleCoin");i===void 0&&([i,t]=this.handleOptionAndParams(t,"cancelAllOrders","settle",i)),e!==void 0&&(s=this.market(e),i=s.settle);let n;[n,t]=this.handleSubTypeAndParams("cancelAllOrders",s,t);const r=i==="USDC",a=n==="inverse";if(a&&(r||i==="USDT"))throw new st(this.id+" cancelAllOrders with inverse subType requires settle to not be USDT or USDC");const[d,c]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),u=await this.isUnifiedMarginEnabled();return d==="spot"?await this.cancelAllSpotOrders(e,c):u&&!a?await this.cancelAllUnifiedMarginOrders(e,c):r?await this.cancelAllUSDCOrders(e,c):await this.cancelAllDerivativesOrders(e,c)}async fetchUnifiedMarginOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e===void 0){let u;[u,i]=this.handleSubTypeAndParams("fetchUnifiedMarginOrders",r,i,"linear"),n.category=u}else if(r=this.market(e),n.symbol=r.id,r.option)n.category="option";else if(r.linear)n.category="linear";else throw new Ft(this.id+" fetchUnifiedMarginOrders() does not allow inverse market orders for "+e+" markets");const a=this.safeValue(i,"stop",!1);i=this.omit(i,["stop"]),a&&(n.orderFilter="StopOrder"),s!==void 0&&(n.limit=s);const o=await this.privateGetUnifiedV3PrivateOrderList(this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"list",[]);return this.parseOrders(c,r,t,s)}async fetchDerivativesOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={};e!==void 0&&(n=this.market(e),r=n.settle,a.symbol=n.id),[r,i]=this.handleOptionAndParams(i,"cancelAllOrders","settle",r),r!==void 0&&(a.settleCoin=r);const o=this.safeValue(i,"stop",!1);i=this.omit(i,["stop"]),o&&(a.orderFilter="StopOrder");const d=await this.privateGetContractV3PrivateOrderList(this.extend(a,i)),c=this.safeValue(d,"result",{}),u=this.safeValue2(c,"data","list",[]);return this.parseOrders(u,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r=this.safeString(i,"settleCoin");r===void 0&&([r,i]=this.handleOptionAndParams(i,"fetchOrders","settle",r)),e!==void 0&&(n=this.market(e),r=n.settle);let a;[a,i]=this.handleSubTypeAndParams("fetchOpenOrders",n,i);const o=a==="inverse";if(o&&(r==="USDC"||r==="USDT"))throw new st(this.id+" fetchOrders with inverse subType requires settle to not be USDT or USDC");const[u,h]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),f=await this.isUnifiedMarginEnabled();if(u==="spot")throw new Ft(this.id+" fetchOrders() does not support "+n.type+" markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead");return f&&!o?await this.fetchUnifiedMarginOrders(e,t,s,h):await this.fetchDerivativesOrders(e,t,s,h)}async fetchSpotClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};e!==void 0&&(r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.startTime=t);const a=await this.privateGetSpotV3PrivateHistoryOrders(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseOrders(d,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;if([r,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),r==="spot")return await this.fetchSpotClosedOrders(e,t,s,i);const a={};return await this.isUnifiedMarginEnabled()?a.orderStatus="Canceled":a.orderStatus=["Filled","Canceled"],await this.fetchOrders(e,t,s,this.extend(a,i))}async fetchSpotOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=e),s!==void 0&&(n.limit=s);const a=await this.privateGetSpotV3PrivateOpenOrders(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseOrders(d,r,t,s)}async fetchUnifiedMarginOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e===void 0){let f;[f,i]=this.handleSubTypeAndParams("fetchUnifiedMarginOrders",r,i,"linear"),n.category=f}else if(r=this.market(e),n.symbol=r.id,r.option)n.category="option";else if(r.linear)n.category="linear";else throw new Ft(this.id+" fetchUnifiedMarginOpenOrders() does not allow inverse market orders for "+e+" markets");let a;[a,i]=this.handleMarketTypeAndParams("fetchUnifiedMarginOpenOrders",r,i);const d=this.safeValue(i,"stop",!1)||a==="stop"||a==="conditional";i=this.omit(i,["stop"]),d&&(n.orderFilter="StopOrder"),s!==void 0&&(n.limit=s);const c=await this.privateGetUnifiedV3PrivateOrderUnfilledOrders(this.extend(n,i)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"list",[]);return this.parseOrders(h,r,t,s)}async fetchDerivativesOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={};e!==void 0&&(n=this.market(e),r=n.settle,a.symbol=n.id),[r,i]=this.handleOptionAndParams(i,"cancelAllOrders","settle",r),r!==void 0&&(a.settleCoin=r);const o=this.safeValue(i,"stop",!1);i=this.omit(i,["stop"]),o&&(a.orderFilter="StopOrder");const d=await this.privateGetContractV3PrivateOrderUnfilledOrders(this.extend(a,i)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"list",[]);return this.parseOrders(u,n,t,s)}async fetchUSDCOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a;[a,i]=this.handleMarketTypeAndParams("fetchUSDCOpenOrders",r,i),n.category=a==="swap"?"perpetual":"option";const o=await this.privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders(this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"dataList",[]);return this.parseOrders(c,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r=this.safeString(i,"settleCoin");r===void 0&&([r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","settle",r)),e!==void 0&&(n=this.market(e),r=n.settle);let a;[a,i]=this.handleSubTypeAndParams("fetchOpenOrders",n,i);const o=a==="inverse",d=r==="USDC";if(o&&(d||r==="USDT"))throw new st(this.id+" fetchOpenOrders with inverse subType requires settle to not be USDT or USDC");const[u,h]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),f=await this.isUnifiedMarginEnabled();return u==="spot"?await this.fetchSpotOpenOrders(e,t,s,h):f&&!o?await this.fetchUnifiedMarginOpenOrders(e,t,s,h):d?await this.fetchUSDCOpenOrders(e,t,s,h):await this.fetchDerivativesOpenOrders(e,t,s,h)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMySpotTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new st(this.id+" fetchMySpotTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetSpotV3PrivateMyTrades(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTrades(d,n,t,s)}async fetchMyUnifiedMarginTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={};e!==void 0&&(n=this.market(e),r=n.settle,a.symbol=n.id);let o;[o,i]=this.handleSubTypeAndParams("fetchMyTrades",n,i,"linear"),a.category=o,[r,i]=this.handleOptionAndParams(i,"cancelAllOrders","settle",r),r!==void 0&&(a.settleCoin=r),t!==void 0&&(a.startTime=t),s!==void 0&&(a.limit=s);const d=await this.privateGetUnifiedV3PrivateExecutionList(this.extend(a,i)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"list",[]);return this.parseTrades(u,n,t,s)}async fetchMyContractTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new st(this.id+" fetchMyContractTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetContractV3PrivateExecutionList(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTrades(d,n,t,s)}async fetchMyUsdcTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0?(n=this.market(e),r.symbol=n.id,r.category=n.option?"OPTION":"PERPETUAL"):r.category="PERPETUAL";const a=await this.privatePostOptionUsdcOpenapiPrivateV1ExecutionList(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"dataList",[]);return this.parseTrades(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r=this.safeString(i,"settleCoin");r===void 0&&([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","settle",r)),e!==void 0&&(n=this.market(e),r=n.settle);let a;[a,i]=this.handleSubTypeAndParams("fetchMyTrades",n,i);const o=a==="inverse",d=r==="USDC";if(o&&(d||r==="USDT"))throw new st(this.id+" fetchMyTrades with inverse subType requires settle to not be USDT or USDC");const[u,h]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),f=await this.isUnifiedMarginEnabled();return u==="spot"?await this.fetchMySpotTrades(e,t,s,h):f&&!o?await this.fetchMyUnifiedMarginTrades(e,t,s,h):d?await this.fetchMyUsdcTrades(e,t,s,h):await this.fetchMyContractTrades(e,t,s,h)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addressDeposit"),i=this.safeString(e,"tagDeposit"),n=this.safeString(t,"code"),r=this.safeString(e,"chain");return this.checkAddress(s),{currency:n,address:s,tag:i,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let s=this.currency(e);const i={coin:s.id},n=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(i,t)),r=this.safeValue(n,"result",[]),a=this.safeValue(r,"chains",[]),o=this.safeString(r,"coin");s=this.currency(o);const d=this.parseDepositAddresses(a,[e],!1,{currency:s.id});return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const[s,i]=this.handleNetworkCodeAndParams(t),n=this.networkCodeToId(s),r=this.currency(e),a={coin:r.id};n!==void 0&&(a.chainType=n);const o=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(a,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"chains",[]),u=this.indexBy(c,"chain"),h=this.selectNetworkIdFromRawNetworks(e,s,u),f=this.safeValue(u,h,{});return this.parseDepositAddress(f,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={wallet_fund_type:"Deposit"};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateDepositRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateWithdrawRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={ToBeConfirmed:"pending",UnderReview:"pending",Success:"ok",Expire:"expired",0:"unknown",1:"pending",2:"processing",3:"ok",4:"fail",SecurityCheck:"pending",Pending:"pending",success:"ok",CancelByUser:"canceled",Reject:"rejected",Fail:"failed",BlockchainConfirmed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"createTime","successAt"),r=this.safeInteger(e,"updateTime"),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber2(e,"depositFee","withdrawFee",0),d="depositFee"in e?"deposit":"withdrawal";let c;o!==void 0&&(c={cost:o,currency:i});const u=this.safeString(e,"toAddress");return{info:e,id:this.safeString2(e,"id","withdrawId"),txid:this.safeString(e,"txID"),timestamp:n,datetime:this.iso8601(n),network:this.networkIdToCode(this.safeString(e,"chain")),address:void 0,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"tag"),tagTo:void 0,tagFrom:void 0,type:d,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:c}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.start_date=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetV2PrivateWalletFundRecords(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseLedger(d,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"amount"),r=this.safeString(e,"wallet_balance"),a=$e.stringLt(n,"0")?"out":"in";let o;if(r!==void 0&&n!==void 0){const f=a==="out"?n:$e.stringNeg(n);o=$e.stringAdd(r,f)}const d=this.parse8601(this.safeString(e,"exec_time")),c=this.parseLedgerEntryType(this.safeString(e,"type")),u=this.safeString(e,"id"),h=this.safeString(e,"tx_id");return{id:u,currency:i,account:this.safeString(e,"wallet_id"),referenceAccount:void 0,referenceId:h,status:void 0,amount:this.parseNumber(n),before:this.parseNumber(o),after:this.parseNumber(r),fee:void 0,direction:a,timestamp:d,datetime:this.iso8601(d),type:c,info:e}}parseLedgerEntryType(e){const t={Deposit:"transaction",Withdraw:"transaction",RealisedPNL:"trade",Commission:"fee",Refund:"cashback",Prize:"prize",ExchangeOrderWithdraw:"transaction",ExchangeOrderDeposit:"transaction"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={coin:r.id,amount:this.numberToString(t),address:s};i!==void 0&&(a.tag=i);const[o,d]=this.handleNetworkCodeAndParams(n),c=this.networkCodeToId(o);c!==void 0&&(a.chain=c.toUpperCase());const u=await this.privatePostAssetV3PrivateWithdrawCreate(this.extend(a,d)),h=this.safeValue(u,"result",{});return this.parseTransaction(h,r)}async fetchPosition(e=void 0,t={}){if(e===void 0)throw new st(this.id+" fetchPosition() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;const r=await this.isUnifiedMarginEnabled(),a=s.settle==="USDC";if(r)if(n="privateGetUnifiedV3PrivatePositionList",s.option)i.category="option";else if(s.linear)i.category="linear";else throw new Ft(this.id+" fetchPosition() does not allow inverse market orders for "+e+" markets");else a?(n="privatePostOptionUsdcOpenapiPrivateV1QueryPosition",s.option?i.category="OPTION":s.linear&&(i.category="PERPETUAL")):n="privateGetContractV3PrivatePositionList";const o=await this[n](this.extend(i,t)),d=this.safeValue(o,"result",{}),c=this.safeValue2(d,"list","dataList",[]),u=this.safeInteger(o,"time"),h=this.safeValue(c,0),f=this.parsePosition(h);return this.extend(f,{timestamp:u,datetime:this.iso8601(u)})}async fetchUnifiedMarginPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(Array.isArray(e)){if(e.length>1)throw new st(this.id+" fetchPositions() does not accept an array with more than one symbol")}else e!==void 0&&(e=[e]);e=this.marketSymbols(e),[i,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);let n;[n,t]=this.handleSubTypeAndParams("fetchPositions",void 0,t,"linear"),s.category=n,i==="option"&&(s.category="option");const r=await this.privateGetUnifiedV3PrivatePositionList(this.extend(s,t)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"list",[]),d=[];for(let c=0;c<o.length;c++){let u=o[c];"data"in u&&"is_valid"in u&&(u=this.safeValue(u,"data")),d.push(this.parsePosition(u))}return this.filterByArray(d,"symbol",e,!1)}async fetchUSDCPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n;if(Array.isArray(e)){if(e.length!==1)throw new st(this.id+" fetchUSDCPositions() takes an array with exactly one symbol");const u=this.safeString(e,0);i=this.market(u),s.symbol=i.id}else e!==void 0&&(i=this.market(e),s.symbol=i.id);[n,t]=this.handleMarketTypeAndParams("fetchUSDCPositions",i,t),s.category=n==="option"?"OPTION":"PERPETUAL";const r=await this.privatePostOptionUsdcOpenapiPrivateV1QueryPosition(this.extend(s,t)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"dataList",[]),d=[];for(let c=0;c<o.length;c++){let u=o[c];"data"in u&&"is_valid"in u&&(u=this.safeValue(u,"data")),d.push(this.parsePosition(u,i))}return this.filterByArray(d,"symbol",e,!1)}async fetchDerivativesPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(Array.isArray(e)){if(e.length>1)throw new st(this.id+" fetchPositions() does not accept an array with more than one symbol");e.length===1&&(s.symbol=this.marketId(e[0]))}else e!==void 0?s.symbol=this.marketId(e):s.dataFilter="valid";let i;[i,t]=this.handleOptionAndParams(t,"fetchPositions","settle",i),i!==void 0&&(s.settleCoin=i);const n=await this.privateGetContractV3PrivatePositionList(this.extend(s,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"list",[]);return this.parsePositions(a,e,t)}async fetchPositions(e=void 0,t={}){if(Array.isArray(e)){if(e.length>1)throw new st(this.id+" fetchPositions() does not accept an array with more than one symbol")}else e!==void 0&&(e=[e]);await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.isUnifiedMarginEnabled();let i=this.safeString(t,"settleCoin");i===void 0&&([i,t]=this.handleOptionAndParams(t,"fetchPositions","settle",i));const n=i==="USDC",[r,a]=this.handleSubTypeAndParams("fetchPositions",void 0,t),o=r==="inverse";if(o&&(n||i==="USDT"))throw new st(this.id+" fetchPositions with inverse subType requires settle to not be USDT or USDC");return s&&!o?await this.fetchUnifiedMarginPositions(e,a):n?await this.fetchUSDCPositions(e,a):await this.fetchDerivativesPositions(e,a)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=$e.stringAbs(this.safeString(e,"size"));let n=this.safeString(e,"side");n!==void 0&&(n==="Buy"?n="long":n==="Sell"?n="short":n=void 0);const r=this.safeString(e,"positionValue"),a=this.omitZero(this.safeString(e,"unrealisedPnl"));let o=this.safeString(e,"positionIM"),d=this.safeString(e,"positionMM"),c=this.parse8601(this.safeString(e,"updated_at"));c===void 0&&(c=this.safeInteger(e,"updatedAt"));const h=this.safeInteger(e,"tradeMode",0)?"isolated":"cross";let f=this.safeString(e,"positionBalance");const l=this.omitZero(this.safeString(e,"entryPrice")),m=this.omitZero(this.safeString(e,"liqPrice")),g=this.safeString(e,"leverage");if(m!==void 0)if(t.settle==="USDC"){const S=$e.stringAbs($e.stringSub(l,m));f=$e.stringAdd($e.stringAdd($e.stringMul(S,i),d),a)}else{const S=this.safeString(e,"bustPrice");if(t.linear){const v=$e.stringAbs($e.stringSub(m,S));d=$e.stringMul(v,i),o=$e.stringDiv($e.stringMul(i,l),g)}else{const v=$e.stringAbs($e.stringSub(S,m)),T=$e.stringMul(S,m);d=$e.stringDiv($e.stringMul(i,v),T),o=$e.stringDiv(i,$e.stringMul(l,g))}}const y=$e.stringDiv(d,r),w=$e.stringMul($e.stringDiv(a,o),"100"),b=$e.stringDiv(d,f,4);return{info:e,id:void 0,symbol:t.symbol,timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber($e.stringDiv(o,r)),maintenanceMargin:this.parseNumber(d),maintenanceMarginPercentage:this.parseNumber(y),entryPrice:this.parseNumber(l),notional:this.parseNumber(r),leverage:this.parseNumber(g),unrealizedPnl:this.parseNumber(a),contracts:this.parseNumber(i),contractSize:this.safeNumber(t,"contractSize"),marginRatio:this.parseNumber(b),liquidationPrice:this.parseNumber(m),markPrice:this.safeNumber(e,"markPrice"),collateral:this.parseNumber(f),marginMode:h,side:n,percentage:this.parseNumber(w)}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(i.settle==="USDC")throw new Ft(this.id+" setMarginMode() does not support market "+t);if(e=e.toUpperCase(),e!=="ISOLATED"&&e!=="CROSS")throw new ke(this.id+" setMarginMode() marginMode must be either isolated or cross");const n=this.safeString(s,"leverage");let r,a;if(n===void 0){if(r=this.safeNumber2(s,"sell_leverage","sellLeverage"),a=this.safeNumber2(s,"buy_leverage","buyLeverage"),r===void 0||a===void 0)throw new st(this.id+" setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters");s=this.omit(s,["buy_leverage","sell_leverage","sellLeverage","buyLeverage"])}else s=this.omit(s,"leverage"),r=n,a=n;const o=e==="ISOLATED"?1:0,d={symbol:i.id,tradeMode:o,buyLeverage:n,sellLeverage:n};return await this.privatePostContractV3PrivatePositionSwitchIsolated(this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new st(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.settle==="USDC",r=await this.isUnifiedMarginEnabled();e=this.numberToString(e);let a,o;if(r||!n)if(o={symbol:i.id,buyLeverage:e,sellLeverage:e},r&&!i.inverse){if(i.option)o.category="option";else if(i.linear)o.category="linear";else throw new Ft(this.id+" setUnifiedMarginLeverage() leverage doesn't support inverse market in unified margin");a="privatePostUnifiedV3PrivatePositionSetLeverage"}else a="privatePostContractV3PrivatePositionSetLeverage";else o={symbol:i.id,leverage:e},a="privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave";return await this[a](this.extend(o,s))}async setPositionMode(e,t=void 0,s={}){await this.loadMarkets();let i;e?i=3:i=0;const n={mode:i};if(t===void 0)n.coin="USDT";else{const r=this.market(t);n.symbol=r.id}return await this.privatePostContractV3PrivatePositionSwitchMode(this.extend(n,s))}async fetchDerivativesOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){await this.loadMarkets();let r=this.market(e);const a=r.linear?"linear":"inverse",o=this.safeString(n,"category",a),d={symbol:r.id,interval:t,category:o};s!==void 0&&(d.since=s),i!==void 0&&(d.limit=i);const c=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(d,n)),u=this.safeValue(c,"result",{}),h=this.safeString(u,"symbol");r=this.safeMarket(h,r,void 0,"contract");const f=this.safeValue(u,"list",[]);return this.parseOpenInterests(f,r,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();let s=this.market(e);if(!s.contract)throw new ke(this.id+" fetchOpenInterest() supports contract markets only");const i=this.safeString(t,"interval","1h");if(i==="1m")throw new ke(this.id+" fetchOpenInterest() cannot use the 1m timeframe");const n=s.linear?"linear":"inverse",r=this.safeString(t,"category",n),a={symbol:s.id,interval:i,category:r},o=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(a,t)),d=this.safeValue(o,"result",{}),c=this.safeString(d,"symbol");s=this.safeMarket(c,s,void 0,"contract");const u=this.safeValue(d,"list",[]);return this.parseOpenInterest(u[0],s)}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t==="1m")throw new ke(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();const r=this.market(e);if(r.spot||r.option)throw new ke(this.id+" fetchOpenInterestHistory() symbol does not support market "+e);return r.id,await this.fetchDerivativesOpenInterestHistory(e,t,s,i,n)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber2(e,"open_interest","openInterest");return{symbol:t.symbol,openInterestAmount:void 0,openInterestValue:i,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetSpotV3PrivateCrossMarginLoanInfo(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseBorrowRate(r,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"coin");return{currency:this.safeCurrencyCode(i,t),rate:this.safeNumber(e,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={},a=await this.privateGetSpotV3PrivateCrossMarginAccount(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"loanAccountList",[]),c=this.parseBorrowInterests(d,void 0);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){return{symbol:void 0,marginMode:"cross",currency:this.safeCurrencyCode(this.safeString(e,"tokenId")),interest:this.safeNumber(e,"interest"),interestRate:void 0,amountBorrowed:this.safeNumber(e,"loan"),timestamp:void 0,datetime:void 0,info:e}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeString(n,"transferId",this.uuid()),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.currency(e),u=this.currencyToPrecision(e,t);let h;[h,n]=this.handleOptionAndParams(n,"transfer","method","privatePostAssetV1PrivateTransfer");let f;h==="privatePostAssetV3PrivateTransferInterTransfer"?f={transferId:r,fromAccountType:o,toAccountType:d,coin:c.id,amount:u}:f={transfer_id:r,from_account_type:o,to_account_type:d,coin:c.id,amount:u};const l=await this[h](this.extend(f,n)),m=this.safeInteger2(l,"time","time_now"),g=this.safeValue(l,"result",{}),y=this.safeStringN(l,["retCode","retMsg","ret_code","ret_msg"]),w=this.parseTransferStatus(y);return this.extend(this.parseTransfer(g,c),{timestamp:m,datetime:this.iso8601(m),amount:this.parseNumber(u),fromAccount:s,toAccount:i,status:w})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.coin=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetV3PrivateTransferInterTransferListQuery(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTransfers(d,n,t,s)}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("borrowMargin",i);if(r==="isolated")throw new Ft(this.id+" borrowMargin () cannot use isolated margin");const o={coin:n.id,qty:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV3PrivateCrossMarginLoan(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("repayMargin",i);if(r==="isolated")throw new Ft(this.id+" repayMargin () cannot use isolated margin");const o={coin:n.id,qty:this.numberToString(t)},d=await this.privatePostSpotV3PrivateCrossMarginRepay(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeString2(e,"transactId","repayId"),currency:this.safeString(t,"code"),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}parseTransferStatus(e){const t={0:"ok",OK:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString2(e,"fromAccountType","from_account_type"),r=this.safeString2(e,"toAccountType","to_account_type"),a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,n,n),d=this.safeString(a,r,r);return{info:e,id:this.safeString2(e,"transferId","transfer_id"),timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:o,toAccount:d,status:this.parseTransferStatus(this.safeString(e,"status"))}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t])+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.rawencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=a.indexOf("openapi")>=0,d=a.indexOf("unified/v3")>=0,c=this.nonce().toString();if(o){Object.keys(i).length?r=this.json(i):r="{}";const u=c+this.apiKey+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","hex");n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-TIMESTAMP":c,"X-BAPI-SIGN":h}}else if(d){n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":c,"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()};const u=i,h=this.rawencode(u),f=c.toString()+this.apiKey+this.options.recvWindow.toString();let l;s==="POST"?(r=this.json(u),l=f+r):(l=f+h,e==="unified/v3/private/order/list"?a+="?"+this.rawencode(u):a+="?"+this.urlencode(u)),n["X-BAPI-SIGN"]=this.hmac(this.encode(l),this.encode(this.secret))}else{const u=this.extend(i,{api_key:this.apiKey,recv_window:this.options.recvWindow,timestamp:c}),h=this.keysort(u),f=this.rawencode(h),l=this.hmac(this.encode(f),this.encode(this.secret));if(s==="POST"){const m=a.indexOf("spot")>=0,g=this.extend(u,{sign:l});m?(r=this.urlencode(g),n={"Content-Type":"application/x-www-form-urlencoded"}):(r=this.json(g),n={"Content-Type":"application/json"})}else e==="contract/v3/private/order/list"?a+="?"+this.rawencode(h):a+="?"+this.urlencode(h),a+="&sign="+l}}if(s==="POST"){const o=this.safeString(this.options,"brokerId");o!==void 0&&(n.Referer=o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString2(a,"ret_code","retCode");if(c!=="0"){if(c==="30084")return;let u;throw c==="10005"?u=this.id+' private api uses /user/v3/private/query-api to check if you have a unified account. The API key of user id must own one of permissions: "Account Transfer", "Subaccount Transfer", "Withdrawal" '+r:u=this.id+" "+r,this.throwBroadlyMatchedException(this.exceptions.broad,r,u),this.throwExactlyMatchedException(this.exceptions.exact,c,u),new ns(u)}}async fetchDerivativesMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};s.linear?i.category="linear":s.inverse&&(i.category="inverse");const n=await this.publicGetDerivativesV3PublicRiskLimitList(this.extend(i,t)),r=this.safeValue(n,"result"),a=this.safeValue(r,"list");return this.parseMarketLeverageTiers(a,s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();let s;if(s=this.market(e),s.spot||s.option)throw new ke(this.id+" fetchMarketLeverageTiers() symbol does not support market "+e);return s.id,await this.fetchDerivativesMarketLeverageTiers(e,t)}parseMarketLeverageTiers(e,t){let s=0;const i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"limit");i.push({tier:this.sum(n,1),currency:t.base,minNotional:s,maxNotional:a,maintenanceMarginRate:this.safeNumber2(r,"maintain_margin","maintainMargin"),maxLeverage:this.safeNumber2(r,"max_leverage","maxLeverage"),info:r}),s=a}return i}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,void 0,void 0,"contract");return{info:e,symbol:i,maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate")}}async fetchTradingFee(e,t={}){if(this.version!=="v3")throw new Ft(this.id+" fetchTradingFee() is only support for v3");await this.loadMarkets();const s=this.market(e);if(s.spot)throw new Ft(this.id+" fetchTradingFee() is not supported for spot market");const i={symbol:s.id},n=await this.privateGetContractV3PrivateAccountFeeRate(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"list",[]),o=this.safeValue(a,0,{});return this.parseTradingFee(o)}async fetchTradingFees(e={}){if(this.version!=="v3")throw new Ft(this.id+" fetchTradingFees() is only support for v3");await this.loadMarkets();let t;if([t,e]=this.handleOptionAndParams(e,"fetchTradingFees","type","future"),t==="spot")throw new Ft(this.id+" fetchTradingFees() is not supported for spot market");const s=await this.privateGetContractV3PrivateAccountFeeRate(e);let i=this.safeValue(s,"result",{});i=this.safeValue(i,"list",[]);const n={};for(let r=0;r<i.length;r++){const a=this.parseTradingFee(i[r]),o=a.symbol;n[o]=a}return n}};const h3=re,{ExchangeError:Dw,ArgumentsRequired:Ol,AuthenticationError:f3,NullResponse:Fw,InvalidOrder:Il,InsufficientFunds:l3,InvalidNonce:p3,OrderNotFound:m3,RateLimitExceeded:g3,DDoSProtection:y3,BadSymbol:Hw}=Q,{TICK_SIZE:w3}=ne,xl=ae;var ST=class extends h3{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:{rest:"https://cex.io/api"},www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"],referral:"https://cex.io/r/0/up105393824/0/"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_profile","currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_crypto_address","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/","raw_tx_history"]}},fees:{trading:{maker:this.parseNumber("0.0016"),taker:this.parseNumber("0.0025")},funding:{withdraw:{},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},precisionMode:w3,exceptions:{exact:{},broad:{"Insufficient funds":l3,"Nonce must be incremented":p3,"Invalid Order":Il,"Order not found":m3,"limit exceeded":g3,"Invalid API key":f3,"There was an error while placing your order":Il,"Sorry, too many clients already":y3,"Invalid Symbols Pair":Hw,"Wrong currency pair":Hw}},options:{fetchOHLCVWarning:!0,createMarketBuyOrderRequiresPrice:!0,order:{status:{c:"canceled",d:"closed",cd:"canceled",a:"open"}},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},networks:{ERC20:"Ethereum",BTC:"BTC",BEP20:"Binance Smart Chain",BSC:"Binance Smart Chain",TRC20:"Tron"},networksById:{Ethereum:"ERC20",BTC:"BTC","Binance Smart Chain":"BEP20",Tron:"TRC20"}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrencyProfile(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const s=this.safeValue(t,"data",[]),i=this.safeValue(s,"symbols",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"code"),d=this.safeCurrencyCode(o),c=!0;n[d]={id:o,code:d,name:o,active:c,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.safeString(a,"precision")),fee:void 0,limits:{amount:{min:this.safeNumber(a,"minimumCurrencyAmount"),max:void 0},withdraw:{min:this.safeNumber(a,"minimalWithdrawalAmount"),max:void 0}},info:a}}return n}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=this.indexBy(i,"code"),r=this.safeValue(s,"pairs",[]),a=await this.publicGetCurrencyLimits(e),o=[],d=this.safeValue(a.data,"pairs");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"symbol1"),f=this.safeString(u,"symbol2"),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f),g=this.safeValue(n,h,{}),y=this.safeValue(n,f,{});let w=this.safeString(y,"precision","8");for(let T=0;T<r.length;T++){const I=r[T];I.symbol1===h&&I.symbol2===f&&(w=this.safeString(I,"pricePrecision",w))}const b=this.safeString(g,"precision","8"),S=this.safeString(g,"scale","0"),v=xl.stringSub(b,S);o.push({id:h+"/"+f,symbol:l+"/"+m,base:l,quote:m,settle:void 0,baseId:h,quoteId:f,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(v)),price:this.parseNumber(this.parsePrecision(w))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minLotSize"),max:this.safeNumber(u,"maxLotSize")},price:{min:this.safeNumber(u,"minPrice"),max:this.safeNumber(u,"maxPrice")},cost:{min:this.safeNumber(u,"minLotSizeS2"),max:void 0}},info:u})}return o}parseBalance(e){const t={info:e},s=["username","timestamp"],i=this.omit(e,s),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a,{}),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"orders","0");const c=this.safeCurrencyCode(a);t[c]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(s===void 0)s=this.milliseconds()-864e5;else if(this.options.fetchOHLCVWarning)throw new Dw(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");const a={pair:r.id,yyyymmdd:this.yyyymmdd(s,"")};try{const o=await this.publicGetOhlcvHdYyyymmddPair(this.extend(a,n)),d="data"+this.timeframes[t],c=this.safeString(o,d),u=JSON.parse(c);return this.parseOHLCVs(u,r,t,s,i)}catch(o){if(o instanceof Fw)return[]}}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"volume"),n=this.safeString(e,"high"),r=this.safeString(e,"low"),a=this.safeString(e,"bid"),o=this.safeString(e,"ask"),d=this.safeString(e,"last"),c=this.safeSymbol(void 0,t);return this.safeTicker({symbol:c,timestamp:s,datetime:this.iso8601(s),high:n,low:r,bid:a,bidVolume:void 0,ask:o,askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:i,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const i={currencies:Object.keys(this.currencies).join("/")},n=await this.publicGetTickersCurrencies(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"pair"),u=this.safeMarket(c,void 0,":"),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradeHistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetMyfee(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{}),d=this.safeString(o,"buyMaker"),c=this.safeString(o,"buy"),u=this.parseNumber(xl.stringDiv(d,"100")),h=this.parseNumber(xl.stringDiv(c,"100"));i[r]={info:o,symbol:r,maker:u,taker:h,percentage:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Il(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i};t==="limit"?o.price=n:o.order_type=t;const d=await this.privatePostPlaceOrderPair(this.extend(o,r)),c=this.safeNumber(d,"amount"),u=this.safeNumber(d,"pending"),h=this.safeValue(d,"time"),l=this.safeValue(d,"complete")?"closed":"open";let m;return c!==void 0&&u!==void 0&&(m=Math.max(c-u,0)),{id:this.safeString(d,"id"),info:d,clientOrderId:void 0,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,type:t,side:this.safeString(d,"type"),symbol:a.symbol,status:l,price:this.safeNumber(d,"price"),amount:c,cost:void 0,average:void 0,remaining:u,filled:m,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeValue(e,"time");typeof s=="string"&&s.indexOf("T")>=0?s=this.parse8601(s):s=parseInt(s);let i;if(t===void 0){const m=this.safeString(e,"symbol1"),g=this.safeString(e,"symbol2"),y=this.safeCurrencyCode(m),w=this.safeCurrencyCode(g);i=y+"/"+w,i in this.markets&&(t=this.market(i))}const n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeNumber(e,"price");let a=this.safeNumber(e,"amount");a!==void 0&&(a=Math.abs(a));const o=this.safeNumber2(e,"pending","remains"),d=a-o;let c,u;if(t!==void 0){i=t.symbol;const m=this.safeNumber(e,"ta:"+t.quote),g=this.safeNumber(e,"tta:"+t.quote);u=this.sum(m,g);const y="fa:"+t.base,w="tfa:"+t.base,b="fa:"+t.quote,S="tfa:"+t.quote;let v=this.safeNumber(e,"tradingFeeMaker");if(v||(v=this.safeNumber(e,"tradingFeeTaker",v)),v&&(v/=100),y in e||w in e){const T=this.safeNumber2(e,y,w);c={currency:t.base,rate:v,cost:T}}else if(b in e||S in e){const T=this.safeNumber2(e,b,S);c={currency:t.quote,rate:v,cost:T}}}u||(u=r*d);const h=e.type;let f;const l=e.id;if("vtx"in e){f=[];for(let m=0;m<e.vtx.length;m++){const g=e.vtx[m],y=this.safeString(g,"type");if(y==="cancel")continue;const w=this.safeNumber(g,"price");if(w===void 0||y==="costsNothing")continue;const b=this.parse8601(this.safeString(g,"time")),S=this.safeNumber(g,"amount"),v=this.safeNumber(g,"fee_amount");let T=S<0?-S:S,I;y==="sell"?(I=T,T=this.sum(v,I)/w):I=T*w,f.push({id:this.safeString(g,"id"),timestamp:b,datetime:this.iso8601(b),order:l,symbol:i,price:w,amount:T,cost:I,side:y,fee:{cost:v,currency:t.quote},info:g,type:void 0,takerOrMaker:void 0})}}return{id:l,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:n,symbol:i,type:r===void 0?"market":"limit",timeInForce:void 0,postOnly:void 0,side:h,price:r,stopPrice:void 0,triggerPrice:void 0,cost:u,amount:a,filled:d,remaining:o,trades:f,fee:c,info:e,average:void 0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostOpenOrders",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair");const o=await this[r](this.extend(n,i));for(let d=0;d<o.length;d++)o[d]=this.extend(o[d],{status:"open"});return this.parseOrders(o,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="privatePostArchivedOrdersPair";if(e===void 0)throw new Ol(this.id+" fetchClosedOrders() requires a symbol argument");const r=this.market(e),a={pair:r.id},o=await this[n](this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e.toString()},n=await this.privatePostGetOrderTx(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={limit:s,pair:n.id,dateFrom:t},a=await this.privatePostArchivedOrdersPair(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.parseOrderStatus(this.safeString(c,"status")),h=this.safeString(c,"symbol1"),f=this.safeString(c,"symbol2"),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f),g=l+"/"+m,y=this.safeString(c,"type"),w=this.safeNumber(c,"a:"+h+":cds"),b=this.safeNumber(c,"a:"+f+":cds"),S=this.safeNumber(c,"f:"+f+":cds"),v=this.safeNumber(c,"amount"),T=this.safeNumber(c,"price"),I=this.safeNumber(c,"remains"),A=v-I;let N,B,x,k;if(!T)k="market",N=w,B=b,x=N/B;else{const L=this.safeNumber(c,"ta:"+f,0),D=this.safeNumber(c,"tta:"+f,0),H=this.safeNumber(c,"fa:"+f,0),R=this.safeNumber(c,"tfa:"+f,0);y==="sell"?B=this.sum(this.sum(L,D),this.sum(H,R)):B=this.sum(L,D)-this.sum(H,R),k="limit",N=v,x=B/A}const O=this.safeString(c,"time"),P=this.safeString(c,"lastTxTime"),q=this.parse8601(O);o.push({id:this.safeString(c,"id"),timestamp:q,datetime:this.iso8601(q),lastUpdated:this.parse8601(P),status:u,symbol:g,side:y,price:T,amount:N,average:x,type:k,filled:A,cost:B,remaining:I,fee:{cost:S,currency:m},info:c})}return o}parseOrderStatus(e){return this.safeString(this.options.order.status,e,e)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new Ol(this.id+" editOrder() requires a amount argument");if(r===void 0)throw new Ol(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o=this.market(t),d={pair:o.id,type:i,amount:n,price:r,order_id:e},c=await this.privatePostCancelReplaceOrderPair(this.extend(d,a));return this.parseOrder(c,o)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},[n,r]=this.handleNetworkCodeAndParams(t),a=await this.privatePostGetCryptoAddress(this.extend(i,r)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"addresses",[]),c=this.indexBy(d,"blockchain"),u=this.selectNetworkIdFromRawNetworks(e,n,c),h=this.safeValue(c,u,{}),f=this.safeString2(h,"address","destination");return this.checkAddress(f),{currency:e,address:f,tag:this.safeString2(h,"destinationTag","memo"),network:this.networkIdToCode(u),info:o}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.hmac(this.encode(c),this.encode(this.secret));r=this.json(this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o)),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(Array.isArray(a))return a;if(r!=="true"){if(a===void 0)throw new Fw(this.id+" returned "+this.json(a));if(!("e"in a&&"ok"in a&&a.ok==="ok")&&"error"in a){const c=this.safeString(a,"error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Dw(u)}}}};const b3=re,{ExchangeError:cn,ArgumentsRequired:Gw,AuthenticationError:bi,BadRequest:k3,RateLimitExceeded:S3,InvalidNonce:v3}=Q,{TICK_SIZE:T3}=ne,Xo=ae;var O3=class extends b3{describe(){return this.deepExtend(super.describe(),{id:"coinbase",name:"Coinbase",countries:["US"],rateLimit:400,version:"v2",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:void 0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyBuys:!0,fetchMySells:!0,fetchMyTrades:void 0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!1,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:void 0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg",api:{rest:"https://api.coinbase.com"},www:"https://www.coinbase.com",doc:["https://developers.coinbase.com/api/v2","https://docs.cloud.coinbase.com/advanced-trade-api/docs/welcome"],fees:["https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees","https://www.coinbase.com/advanced-fees"],referral:"https://www.coinbase.com/join/58cbe25a355148797479dbd2"},requiredCredentials:{apiKey:!0,secret:!0},api:{v2:{public:{get:["currencies","time","exchange-rates","users/{user_id}","prices/{symbol}/buy","prices/{symbol}/sell","prices/{symbol}/spot"]},private:{get:["accounts","accounts/{account_id}","accounts/{account_id}/addresses","accounts/{account_id}/addresses/{address_id}","accounts/{account_id}/addresses/{address_id}/transactions","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}","payment-methods","payment-methods/{payment_method_id}","user","user/auth"],post:["accounts","accounts/{account_id}/primary","accounts/{account_id}/addresses","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}/complete","accounts/{account_id}/transactions/{transaction_id}/resend","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}/commit","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}/commit","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}/commit","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}/commit"],put:["accounts/{account_id}","user"],delete:["accounts/{id}","accounts/{account_id}/transactions/{transaction_id}"]}},v3:{private:{get:["brokerage/accounts","brokerage/accounts/{account_uuid}","brokerage/orders/historical/batch","brokerage/orders/historical/fills","brokerage/orders/historical/{order_id}","brokerage/products","brokerage/products/{product_id}","brokerage/products/{product_id}/candles","brokerage/products/{product_id}/ticker","brokerage/transaction_summary"],post:["brokerage/orders","brokerage/orders/batch_cancel"]}}},fees:{trading:{taker:this.parseNumber("0.006"),maker:this.parseNumber("0.004"),tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.006")],[this.parseNumber("10000"),this.parseNumber("0.004")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("75000000"),this.parseNumber("0.0012")],[this.parseNumber("250000000"),this.parseNumber("0.0008")],[this.parseNumber("400000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0025")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("15000000"),this.parseNumber("0.0006")],[this.parseNumber("75000000"),this.parseNumber("0.0003")],[this.parseNumber("250000000"),this.parseNumber("0.0")],[this.parseNumber("400000000"),this.parseNumber("0.0")]]}}},stablePairs:["BUSD-USD","CBETH-ETH","DAI-USD","GUSD-USD","GYEN-USD","PAX-USD","PAX-USDT","USDC-EUR","USDC-GBP","USDT-EUR","USDT-GBP","USDT-USD","USDT-USDC","WBTC-BTC"],precisionMode:T3,exceptions:{exact:{two_factor_required:bi,param_required:cn,validation_error:cn,invalid_request:cn,personal_details_required:bi,identity_verification_required:bi,jumio_verification_required:bi,jumio_face_match_verification_required:bi,unverified_email:bi,authentication_error:bi,invalid_authentication_method:bi,invalid_token:bi,revoked_token:bi,expired_token:bi,invalid_scope:bi,not_found:cn,rate_limit_exceeded:S3,internal_server_error:cn},broad:{"request timestamp expired":v3}},commonCurrencies:{CGLD:"CELO"},options:{fetchCurrencies:{expires:5e3},accounts:["wallet","fiat"],advanced:!0,fetchMarkets:"fetchMarketsV3",fetchTicker:"fetchTickerV3",fetchTickers:"fetchTickersV3"}})}async fetchTime(e={}){const t=await this.v2PublicGetTime(e),s=this.safeValue(t,"data",{});return this.safeTimestamp(s,"epoch")}async fetchAccounts(e={}){await this.loadMarkets();const t={limit:100},s=await this.v2PrivateGetAccounts(this.extend(t,e)),i=this.safeValue(s,"data",[]);return this.parseAccounts(i,e)}parseAccount(e){const t=this.safeValue(e,"currency",{}),s=this.safeString(t,"code"),i=this.safeCurrencyCode(s);return{id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:i,info:e}}async createDepositAddress(e,t={}){let s=this.safeString(t,"account_id");if(t=this.omit(t,"account_id"),s===void 0){await this.loadAccounts();for(let d=0;d<this.accounts.length;d++){const c=this.accounts[d];if(c.code===e&&c.type==="wallet"){s=c.id;break}}}if(s===void 0)throw new cn(this.id+" createDepositAddress() could not find the account with matching currency code, specify an `account_id` extra param");const i={account_id:s},n=await this.v2PrivatePostAccountsAccountIdAddresses(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"destination_tag"),o=this.safeString(r,"address");return{currency:e,tag:a,address:o,info:n}}async fetchMySells(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.v2PrivateGetAccountsAccountIdSells(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchMyBuys(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.v2PrivateGetAccountsAccountIdBuys(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){const r=await this.prepareAccountRequestWithCurrencyCode(t,i,n);await this.loadMarkets();const a=this.omit(n,["account_id","accountId"]),o=await this[e](this.extend(r,a));return this.parseTransactions(o.data,void 0,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdWithdrawals",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdDeposits",e,t,s,i)}parseTransactionStatus(e){const t={created:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"subtotal",{}),i=this.safeValue(e,"fee",{}),n=this.safeString(e,"id"),r=this.parse8601(this.safeValue(e,"created_at")),a=this.parse8601(this.safeValue(e,"updated_at")),o=this.safeString(e,"resource"),d=this.safeNumber(s,"amount"),c=this.safeString(s,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(i,"amount"),f=this.safeString(i,"currency"),l=this.safeCurrencyCode(f),m={cost:h,currency:l};let g=this.parseTransactionStatus(this.safeString(e,"status"));return g===void 0&&(g=this.safeValue(e,"committed")?"ok":"pending"),{info:e,id:n,txid:n,timestamp:r,datetime:this.iso8601(r),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:d,currency:u,status:g,updated:a,fee:m}}parseTrade(e,t=void 0){let s;const i=this.safeValue(e,"total",{}),n=this.safeValue(e,"amount",{}),r=this.safeValue(e,"subtotal",{}),a=this.safeValue(e,"fee",{}),o=this.safeString(e,"id"),d=this.parse8601(this.safeValue(e,"created_at"));if(t===void 0){const T=this.safeString(n,"currency"),I=this.safeString(i,"currency");if(T!==void 0&&I!==void 0){const A=this.safeCurrencyCode(T),N=this.safeCurrencyCode(I);s=A+"/"+N}}const c=void 0,u=this.safeString(e,"resource"),h=void 0,f=this.safeString(r,"amount"),l=this.safeString(n,"amount"),m=this.parseNumber(f),g=this.parseNumber(l),y=this.parseNumber(Xo.stringDiv(f,l)),w=this.safeNumber(a,"amount"),b=this.safeString(a,"currency"),S=this.safeCurrencyCode(b),v={cost:w,currency:S};return{info:e,id:o,order:c,timestamp:d,datetime:this.iso8601(d),symbol:s,type:h,side:u,takerOrMaker:void 0,price:y,amount:g,cost:m,fee:v}}async fetchMarkets(e={}){const t=this.safeString(this.options,"fetchMarkets","fetchMarketsV3");return await this[t](e)}async fetchMarketsV2(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeCurrencyCode(u);if((u in r?"fiat":"crypto")==="crypto")for(let l=0;l<n.length;l++){const m=n[l],g=this.safeString(m,"id"),y=this.safeCurrencyCode(g);d.push({id:u+"-"+g,symbol:h+"/"+y,base:h,quote:y,settle:void 0,baseId:u,quoteId:g,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(m,"min_size"),max:void 0}},info:m})}}return d}async fetchMarketsV3(e={}){const t=await this.v3PrivateGetBrokerageProducts(e),s=await this.v3PrivateGetBrokerageTransactionSummary(e),i=this.safeValue(s,"fee_tier",{}),n=this.safeValue(t,"products",[]),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"product_id"),c=this.safeString(o,"base_currency_id"),u=this.safeString(o,"quote_currency_id"),h=this.safeCurrencyCode(c),f=this.safeCurrencyCode(u),l=this.safeStringLower(o,"product_type"),m=this.safeValue(o,"trading_disabled");r.push({id:d,symbol:h+"/"+f,base:h,quote:f,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:l,spot:l==="spot",margin:void 0,swap:!1,future:!1,option:!1,active:!m,contract:!1,linear:void 0,inverse:void 0,taker:this.inArray(d,this.stablePairs)?1e-5:this.safeNumber(i,"taker_fee_rate"),maker:this.inArray(d,this.stablePairs)?0:this.safeNumber(i,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(o,"base_increment"),price:this.safeNumber(o,"quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"base_min_size"),max:this.safeNumber(o,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(o,"quote_min_size"),max:this.safeNumber(o,"quote_max_size")}},info:o})}return r}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.v2PublicGetCurrencies(e),a=await this.v2PublicGetExchangeRates(e);this.options.fetchCurrencies=this.extend(t,{currencies:r,exchangeRates:a,timestamp:n})}return this.safeValue(this.options,"fetchCurrencies",{})}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d={};for(let c=0;c<o.length;c++){const u=o[c],h=u in r?"fiat":"crypto",f=this.safeValue(r,u,{}),l=this.safeString(f,"id",u),m=this.safeString(f,"name"),g=this.safeCurrencyCode(l);d[g]={id:l,code:g,info:f,type:h,name:m,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(f,"min_size"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return d}async fetchTickers(e=void 0,t={}){return this.safeString(this.options,"fetchTickers","fetchTickersV3")==="fetchTickersV3"?await this.fetchTickersV3(e,t):await this.fetchTickersV2(e,t)}async fetchTickersV2(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.v2PublicGetExchangeRates(this.extend(s,t)),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"rates",{}),a=this.safeString(n,"currency"),o={},d=Object.keys(r),c="-";for(let u=0;u<d.length;u++){const h=d[u],f=h+c+a,l=this.safeMarket(f,void 0,c),m=l.symbol;o[m]=this.parseTicker(r[h],l)}return this.filterByArray(o,"symbol",e)}async fetchTickersV3(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v3PrivateGetBrokerageProducts(t),i=this.safeValue(s,"products",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"product_id"),d=this.safeMarket(o,void 0,"-"),c=d.symbol;n[c]=this.parseTicker(a,d)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){return this.safeString(this.options,"fetchTicker","fetchTickerV3")==="fetchTickerV3"?await this.fetchTickerV3(e,t):await this.fetchTickerV2(e,t)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.extend({symbol:s.id},t),n=await this.v2PublicGetPricesSymbolSpot(i),r=await this.v2PublicGetPricesSymbolBuy(i),a=await this.v2PublicGetPricesSymbolSell(i),o=this.safeValue(n,"data",{}),d=this.safeValue(r,"data",{}),c=this.safeValue(a,"data",{}),u={bid:this.safeNumber(c,"amount"),ask:this.safeNumber(d,"amount"),price:this.safeNumber(o,"amount")};return this.parseTicker(u,s)}async fetchTickerV3(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_id:s.id,limit:1},n=await this.v3PrivateGetBrokerageProductsProductIdTicker(this.extend(i,t)),r=this.safeValue(n,"trades",[]);return this.parseTicker(r[0],s)}parseTicker(e,t=void 0){const s=this.safeString(e,"product_id"),i=this.safeNumber(e,"price");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,bid:this.safeNumber(e,"bid"),ask:this.safeNumber(e,"ask"),last:i,high:void 0,low:void 0,bidVolume:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:i,previousClose:void 0,change:void 0,percentage:this.safeNumber(e,"price_percentage_change_24h"),average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}parseBalance(e,t={}){const s=this.safeValue(e,"data",[]),i=this.safeValue(t,"type",this.options.accounts),n={info:e};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"type");if(this.inArray(o,i)){const d=this.safeValue(a,"balance");if(d!==void 0){const c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.safeString(d,"amount"),f=h;let l=this.safeValue(n,u);l===void 0?(l=this.account(),l.free=f,l.total=h):(l.free=Xo.stringAdd(l.free,h),l.total=Xo.stringAdd(l.total,h)),n[u]=l}}}return this.safeBalance(n)}async fetchBalance(e={}){await this.loadMarkets();const t={limit:100},s=await this.v2PrivateGetAccounts(this.extend(t,e));return this.parseBalance(s,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.prepareAccountRequestWithCurrencyCode(e,s,i),a=this.omit(i,["account_id","accountId"]),o=await this.v2PrivateGetAccountsAccountIdTransactions(this.extend(r,a));return this.parseLedger(o.data,n,t,s)}parseLedgerEntryStatus(e){const t={completed:"ok"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={buy:"trade",sell:"trade",fiat_deposit:"transaction",fiat_withdrawal:"transaction",exchange_deposit:"transaction",exchange_withdrawal:"transaction",send:"transaction",pro_deposit:"transaction",pro_withdrawal:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeValue(e,"amount",{});let i=this.safeString(s,"amount"),n;Xo.stringLt(i,"0")?(n="out",i=Xo.stringNeg(i)):n="in";const r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r,t);let o;const d=this.safeValue(e,"network",{}),c=this.safeValue(d,"transaction_fee");if(c!==void 0){const y=this.safeString(c,"currency"),w=this.safeCurrencyCode(y,t);o={cost:this.safeNumber(c,"amount"),currency:w}}const u=this.parse8601(this.safeValue(e,"created_at")),h=this.safeString(e,"id"),f=this.parseLedgerEntryType(this.safeString(e,"type")),l=this.parseLedgerEntryStatus(this.safeString(e,"status")),m=this.safeString(e,"resource_path");let g;if(m!==void 0){const y=m.split("/");y.length>3&&(g=y[3])}return{info:e,id:h,timestamp:u,datetime:this.iso8601(u),direction:n,account:g,referenceId:void 0,referenceAccount:void 0,type:f,currency:a,amount:this.parseNumber(i),before:void 0,after:void 0,status:l,fee:o}}async findAccountId(e){await this.loadMarkets(),await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const s=this.accounts[t];if(s.code===e)return s.id}}prepareAccountRequest(e=void 0,t={}){const s=this.safeString2(t,"account_id","accountId");if(s===void 0)throw new Gw(this.id+" prepareAccountRequest() method requires an account_id (or accountId) parameter");const i={account_id:s};return e!==void 0&&(i.limit=e),i}async prepareAccountRequestWithCurrencyCode(e=void 0,t=void 0,s={}){let i=this.safeString2(s,"account_id","accountId");if(i===void 0){if(e===void 0)throw new Gw(this.id+" prepareAccountRequestWithCurrencyCode() method requires an account_id (or accountId) parameter OR a currency code argument");if(i=await this.findAccountId(e),i===void 0)throw new cn(this.id+" prepareAccountRequestWithCurrencyCode() could not find account id for "+e)}const n={account_id:i};return t!==void 0&&(n.limit=t),n}parseOrder(e,t=void 0){const s=this.safeString(e,"product_id"),i=this.safeSymbol(s,t,"-");i!==void 0&&(t=this.market(i));const n=this.safeString(e,"side"),r=n!==void 0?n.toLowerCase():void 0;return this.safeOrder({info:e,id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:i,type:void 0,timeInForce:void 0,postOnly:void 0,side:r,price:void 0,stopPrice:void 0,triggerPrice:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,average:void 0,status:void 0,fee:{cost:void 0},trades:void 0},t)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.cancelOrders([e],t,s);return this.safeValue(i,0,{})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={order_ids:e},r=await this.v3PrivatePostBrokerageOrdersBatchCancel(this.extend(n,s)),a=this.safeValue(r,"results",[]);if(this.safeValue(a,"success")!==!0)throw new k3(this.id+" cancelOrders() has failed, check your arguments and parameters");return this.parseOrders(a,i)}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1]==="private";let c="/"+(a==="v3"?"api/v3":"v2")+"/"+this.implodeParams(e,i);const u=this.omit(i,this.extractParams(e)),h=c;s==="GET"&&Object.keys(u).length&&(c+="?"+this.urlencode(u));const f=this.urls.api.rest+c;if(o){const l=this.safeString(this.headers,"Authorization");if(l!==void 0)n={Authorization:l,"Content-Type":"application/json"};else if(this.token)n={Authorization:"Bearer "+this.token,"Content-Type":"application/json"};else{this.checkRequiredCredentials();const m=this.nonce().toString();let g="";s!=="GET"&&Object.keys(u).length&&(r=this.json(u),g=r);let y;a==="v3"?y=m+s+h+g:y=m+s+c+g;const w=this.hmac(this.encode(y),this.encode(this.secret));n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":w,"CB-ACCESS-TIMESTAMP":m,"Content-Type":"application/json"}}}return{url:f,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r;let u=this.safeString(a,"error");if(u!==void 0){const m=this.safeString(a,"error_description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,m,c),new cn(c)}const h=this.safeValue(a,"errors");if(h!==void 0&&Array.isArray(h)&&h.length>0){u=this.safeString(h[0],"id");const g=this.safeString(h[0],"message");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,g,c),new cn(c)}const f=this.options.advanced;if(this.safeValue(a,"data")===void 0&&!f)throw new cn(this.id+" failed due to a malformed response "+this.json(a))}};const I3=re,{InsufficientFunds:x3,ArgumentsRequired:Uw,ExchangeError:Br,InvalidOrder:Yo,InvalidAddress:_3,AuthenticationError:Vc,NotSupported:C3,OrderNotFound:_l,OnMaintenance:$w,PermissionDenied:M3,RateLimitExceeded:P3}=Q,{TICK_SIZE:A3}=ne,Cl=ae;var fg=class extends I3{describe(){return this.deepExtend(super.describe(),{id:"coinbasepro",name:"Coinbase Pro",countries:["US"],rateLimit:100,userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},hostname:"pro.coinbase.com",urls:{test:{public:"https://api-public.sandbox.pro.coinbase.com",private:"https://api-public.sandbox.pro.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://pro.coinbase.com/",doc:"https://docs.pro.coinbase.com",fees:["https://docs.pro.coinbase.com/#fees","https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time","products/spark-lines"]},private:{get:["accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","fills","funding","fees","margin/profile_information","margin/buying_power","margin/withdrawal_power","margin/withdrawal_power_all","margin/exit_plan","margin/liquidation_history","margin/position_refresh_amounts","margin/status","oracle","orders","orders/{id}","orders/client:{client_oid}","otc/orders","payment-methods","position","profiles","profiles/{id}","reports/{report_id}","transfers","transfers/{transfer_id}","users/self/exchange-limits","users/self/hold-balances","users/self/trailing-volume","withdrawals/fee-estimate","conversions/{conversion_id}"],post:["conversions","deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","profiles/transfer","reports","withdrawals/coinbase","withdrawals/coinbase-account","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/client:{client_oid}","orders/{id}"]}},commonCurrencies:{CGLD:"CELO"},precisionMode:A3,fees:{trading:{tierBased:!0,percentage:!0,maker:.4/100,taker:.6/100},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}},exceptions:{exact:{"Insufficient funds":x3,NotFound:_l,"Invalid API Key":Vc,"invalid signature":Vc,"Invalid Passphrase":Vc,"Invalid order id":Yo,"Private rate limit exceeded":P3,"Trading pair not available":M3,"Product not found":Yo},broad:{"Order already done":_l,"order not found":_l,"price too small":Yo,"price too precise":Yo,"under maintenance":$w,"size is too small":Yo,"Cancel only mode":$w}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"name"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"details",{}),u=this.safeString(n,"status")==="online";s[o]={id:r,code:o,info:n,type:this.safeString(d,"type"),name:a,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.safeNumber(n,"max_precision"),limits:{amount:{min:this.safeNumber(d,"min_size"),max:void 0},withdraw:{min:this.safeNumber(d,"min_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),[a,o]=r.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"status");s.push(this.extend(this.fees.trading,{id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(n,"margin_enabled"),swap:!1,future:!1,option:!1,active:u==="online",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"base_increment"),price:this.safeNumber(n,"quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_market_funds"),max:void 0}},info:n}))}return s}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseAccounts(t,e)}parseAccount(e){const t=this.safeString(e,"currency");return{id:this.safeString(e,"id"),type:void 0,code:this.safeCurrencyCode(t),info:e}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"hold"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={id:this.marketId(e),level:2},n=await this.publicGetProductsIdBook(this.extend(i,s)),r=this.parseOrderBook(n,e);return r.nonce=this.safeInteger(n,"sequence"),r}parseTicker(e,t=void 0){let s,i,n,r,a,o,d,c;const u=t===void 0?void 0:t.symbol;return Array.isArray(e)?(r=this.safeString(e,4),s=this.milliseconds()):(s=this.parse8601(this.safeValue(e,"time")),i=this.safeString(e,"bid"),n=this.safeString(e,"ask"),a=this.safeString(e,"high"),o=this.safeString(e,"low"),d=this.safeString(e,"open"),r=this.safeString2(e,"price","last"),c=this.safeString(e,"volume")),this.safeTicker({symbol:u,timestamp:s,datetime:this.iso8601(s),high:a,low:o,bid:i,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.publicGetProductsSparkLines(this.extend(s,t)),n={},r=Object.keys(i),a="-";for(let o=0;o<r.length;o++){const d=r[o],c=this.safeValue(i,d,[]),u=this.safeValue(c,0,[]),h=this.safeMarket(d,void 0,a),f=h.symbol;n[f]=this.parseTicker(u,h)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetProductsIdTicker"),r=await this[n](this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"time","created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n,r,a;const o=this.safeStringLower(t,"quoteId");if(o!==void 0){const w=o+"_value";a=this.safeString(e,w);const b=this.safeString(e,"liquidity");b!==void 0&&(r=b==="T"?"taker":"maker",n=this.safeString(t,r))}const c={cost:this.safeString2(e,"fill_fees","fee"),currency:t.quote,rate:n},u=this.safeString(e,"trade_id");let h=e.side==="buy"?"sell":"buy";const f=this.safeString(e,"order_id"),l=this.safeString(e,"maker_order_id"),m=this.safeString(e,"taker_order_id");(f!==void 0||l!==void 0&&m!==void 0)&&(h=e.side==="buy"?"buy":"sell");const g=this.safeString(e,"price"),y=this.safeString(e,"size");return this.safeTrade({id:u,order:f,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,takerOrMaker:r,side:h,price:g,amount:y,fee:c,cost:a},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Uw(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={product_id:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetFills(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetProductsIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"maker_fee_rate"),i=this.safeNumber(t,"taker_fee_rate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,3),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={id:r.id,granularity:a};s!==void 0&&(o.start=this.iso8601(s),i===void 0?i=300:i=Math.min(300,i),o.end=this.iso8601(this.sum((i-1)*a*1e3,s)));const d=await this.publicGetProductsIdCandles(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeTimestamp(t,"epoch")}parseOrderStatus(e){const t={pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled",canceling:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n=this.parseOrderStatus(this.safeString(e,"status"));const r=this.safeString(e,"done_reason");n==="closed"&&r==="canceled"&&(n="canceled");const a=this.safeString(e,"price"),o=this.safeString(e,"filled_size"),d=this.safeString(e,"size",o),c=this.safeString(e,"executed_value"),u=this.safeNumber(e,"fill_fees");let h;u!==void 0&&(h={cost:u,currency:t.quote,rate:void 0});const f=this.safeString(e,"id"),l=this.safeString(e,"type"),m=this.safeString(e,"side"),g=this.safeString(e,"time_in_force"),y=this.safeValue(e,"post_only"),w=this.safeNumber(e,"stop_price"),b=this.safeString(e,"client_oid");return this.safeOrder({id:f,clientOrderId:b,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:n,symbol:t.symbol,type:l,timeInForce:g,postOnly:y,side:m,price:a,stopPrice:w,triggerPrice:w,cost:c,amount:d,filled:o,remaining:void 0,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateGetOrdersId",i.id=e):(r="privateGetOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));const a=await this[r](this.extend(i,s));return this.parseOrder(a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.privateGetFills(this.extend(a,n));return this.parseTrades(o,r,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"all"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_id=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"done"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,product_id:a.id},d=this.safeString2(r,"clientOrderId","client_oid");d!==void 0&&(o.client_oid=d);const c=this.safeNumber2(r,"stopPrice","stop_price");c!==void 0&&(o.stop_price=this.priceToPrecision(e,c));const u=this.safeString2(r,"timeInForce","time_in_force");if(u!==void 0&&(o.time_in_force=u),this.safeValue2(r,"postOnly","post_only",!1)&&(o.post_only=!0),r=this.omit(r,["timeInForce","time_in_force","stopPrice","stop_price","clientOrderId","client_oid","postOnly","post_only"]),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market"){let l=this.safeNumber2(r,"cost","funds");l===void 0?n!==void 0&&(l=i*n):r=this.omit(r,["cost","funds"]),l!==void 0?o.funds=this.costToPrecision(e,l):o.size=this.amountToPrecision(e,i)}const f=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(f,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateDeleteOrdersId",i.id=e):(r="privateDeleteOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));let a;return t!==void 0&&(a=this.market(t),i.product_id=a.symbol),await this[r](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.product_id=i.symbol),await this.privateDeleteOrders(this.extend(s,t))}async fetchPaymentMethods(e={}){return await this.privateGetPaymentMethods(e)}async deposit(e,t,s,i={}){await this.loadMarkets();const r={currency:this.currency(e).id,amount:t};let a="privatePostDeposits";if("payment_method_id"in i)a+="PaymentMethod";else if("coinbase_account_id"in i)a+="CoinbaseAccount";else throw new C3(this.id+" deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params");const o=await this[a](this.extend(r,i));if(!o)throw new Br(this.id+" deposit() error: "+this.json(o));return{info:o,id:o.id}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t};let o="privatePostWithdrawals";"payment_method_id"in n?o+="PaymentMethod":"coinbase_account_id"in n?o+="CoinbaseAccount":(o+="Crypto",a.crypto_address=s,i!==void 0&&(a.destination_tag=i));const d=await this[o](this.extend(a,n));if(!d)throw new Br(this.id+" withdraw() error: "+this.json(d));return this.parseTransaction(d,r)}parseLedgerEntryType(e){const t={transfer:"transfer",match:"trade",fee:"fee",rebate:"rebate",conversion:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeString(e,"amount"),n;const r=this.safeString(e,"balance"),a=Cl.stringSub(r,i);Cl.stringLt(i,"0")?(n="out",i=Cl.stringAbs(i)):n="in";const o=this.parseNumber(i),d=this.parseNumber(r),c=this.parseNumber(a),u=this.parse8601(this.safeValue(e,"created_at")),h=this.parseLedgerEntryType(this.safeString(e,"type")),f=this.safeCurrencyCode(void 0,t),l=this.safeValue(e,"details",{});let m,g,y;return h==="transfer"?(m=this.safeString(l,"from"),g=this.safeString(l,"to"),y=this.safeString(l,"profile_transfer_id")):y=this.safeString(l,"order_id"),{id:s,currency:f,account:m,referenceAccount:g,referenceId:y,status:"ok",amount:o,before:c,after:d,fee:void 0,direction:n,timestamp:u,datetime:this.iso8601(u),type:h,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Uw(this.id+" fetchLedger() requires a code param");await this.loadMarkets(),await this.loadAccounts();const n=this.currency(e),r=this.indexBy(this.accounts,"code"),a=this.safeValue(r,e);if(a===void 0)throw new Br(this.id+" fetchLedger() could not find account id for "+e);const o={id:a.id};t!==void 0&&(o.start_date=this.iso8601(t)),s!==void 0&&(o.limit=s);const d=await this.privateGetAccountsIdLedger(this.extend(o,i));for(let c=0;c<d.length;c++)d[c].currency=e;return this.parseLedger(d,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id");if(r===void 0&&e!==void 0){n=this.currency(e);const d=this.indexBy(this.accounts,"code"),c=this.safeValue(d,e);if(c===void 0)throw new Br(this.id+" fetchTransactions() could not find account id for "+e);r=c.id}const a={};r!==void 0&&(a.id=r),s!==void 0&&(a.limit=s);let o;if(r===void 0){o=await this.privateGetTransfers(this.extend(a,i));for(let d=0;d<o.length;d++){const c=this.safeString(o[d],"account_id"),u=this.safeValue(this.accountsById,c),h=this.safeString(u,"code");o[d].currency=h}}else{o=await this.privateGetAccountsIdTransfers(this.extend(a,i));for(let d=0;d<o.length;d++)o[d].currency=e}return this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"withdraw"},i))}parseTransactionStatus(e){if(this.safeValue(e,"canceled_at"))return"canceled";const s=this.safeValue(e,"processed_at"),i=this.safeValue(e,"completed_at");return i?"ok":s&&!i?"failed":"pending"}parseTransaction(e,t=void 0){const s=this.safeValue(e,"details",{}),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t);let a=this.safeNumber(e,"amount"),o=this.safeString(e,"type"),d=this.safeString(s,"crypto_address");d=this.safeString(e,"crypto_address",d);const c={currency:void 0,cost:void 0,rate:void 0};if(o==="withdraw"){o="withdrawal",d=this.safeString(s,"sent_to_address",d);const h=this.safeNumber(s,"fee");h!==void 0&&(a!==void 0&&(a-=h),c.cost=h,c.currency=r)}const u=this.safeString(s,"network");return{info:e,id:this.safeString(e,"id"),txid:this.safeString(s,"crypto_transaction_hash"),type:o,currency:r,network:this.networkIdToCode(u),amount:a,status:this.parseTransactionStatus(e),timestamp:i,datetime:this.iso8601(i),address:d,addressFrom:void 0,addressTo:this.safeString(s,"crypto_address"),tag:this.safeString(s,"destination_tag"),tagFrom:void 0,tagTo:void 0,updated:this.parse8601(this.safeString(e,"processed_at")),comment:void 0,fee:c}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeValue(this.options,"coinbaseAccounts");i===void 0&&(i=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=i,this.options.coinbaseAccountsByCurrencyId=this.indexBy(i,"currency"));const n=s.id,r=this.safeValue(this.options.coinbaseAccountsByCurrencyId,n);if(r===void 0)throw new _3(this.id+" createDepositAddress() could not find currency code "+e+" with id = "+n+" in this.options['coinbaseAccountsByCurrencyId']");const a={id:r.id},o=await this.privatePostCoinbaseAccountsIdAddresses(this.extend(a,t)),d=this.safeString(o,"address"),c=this.safeString(o,"destination_tag");return{currency:e,address:this.checkAddress(d),tag:c,info:o}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.implodeHostname(this.urls.api[t])+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u="";s!=="GET"&&Object.keys(o).length&&(r=this.json(o),u=r);const h=c+s+a+u;let f;try{f=this.base64ToBinary(this.secret)}catch{throw new Vc(this.id+" sign() invalid base64 secret")}const l=this.hmac(this.encode(h),f,"sha256","base64");n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":l,"CB-ACCESS-TIMESTAMP":c,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===400||e===404){if(r[0]==="{"){const c=this.safeString(a,"message"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Br(u)}throw new Br(this.id+" "+r)}}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d!="string"&&"message"in d)throw new Br(this.id+" "+this.json(d));return d}};const B3=fg;var N3=class extends B3{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",pro:!0,hostname:"exchange.coinbase.com",urls:{test:{public:"https://public.sandbox.exchange.coinbase.com",private:"https://public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com"}})}};const V3=re,{BadSymbol:E3,ExchangeError:q3,AuthenticationError:Ww}=Q,{TICK_SIZE:L3}=ne;var R3=class extends V3{describe(){return this.deepExtend(super.describe(),{id:"coincheck",name:"coincheck",countries:["JP","ID"],rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg",api:{rest:"https://coincheck.com/api"},www:"https://coincheck.com",doc:"https://coincheck.com/documents/exchange/api",fees:["https://coincheck.com/exchange/fee","https://coincheck.com/info/fee"]},api:{public:{get:["exchange/orders/rate","order_books","rate/{pair}","ticker","trades"]},private:{get:["accounts","accounts/balance","accounts/leverage_balance","bank_accounts","deposit_money","exchange/orders/opens","exchange/orders/transactions","exchange/orders/transactions_pagination","exchange/leverage/positions","lending/borrows/matches","send_money","withdraws"],post:["bank_accounts","deposit_money/{id}/fast","exchange/orders","exchange/transfers/to_leverage","exchange/transfers/from_leverage","lending/borrows","lending/borrows/{id}/repay","send_money","withdraws"],delete:["bank_accounts/{id}","exchange/orders/{id}","withdraws/{id}"]}},markets:{"BTC/JPY":{id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",type:"spot",spot:!0},"ETC/JPY":{id:"etc_jpy",symbol:"ETC/JPY",base:"ETC",quote:"JPY",baseId:"etc",quoteId:"jpy",type:"spot",spot:!0},"FCT/JPY":{id:"fct_jpy",symbol:"FCT/JPY",base:"FCT",quote:"JPY",baseId:"fct",quoteId:"jpy",type:"spot",spot:!0},"MONA/JPY":{id:"mona_jpy",symbol:"MONA/JPY",base:"MONA",quote:"JPY",baseId:"mona",quoteId:"jpy",type:"spot",spot:!0},"ETC/BTC":{id:"etc_btc",symbol:"ETC/BTC",base:"ETC",quote:"BTC",baseId:"etc",quoteId:"btc",type:"spot",spot:!0}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0"),taker:this.parseNumber("0")}},precisionMode:L3,exceptions:{exact:{"disabled API Key":Ww,"invalid authentication":Ww},broad:{}}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id;if(a in e){const o=this.account(),d=a+"_reserved";o.free=this.safeString(e,a),o.used=this.safeString(e,d),t[n]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetExchangeOrdersOpens(i),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,n,t,s),d=[];for(let c=0;c<o.length;c++)d.push(this.extend(o[c],{status:"open"}));return d}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_type"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"pending_amount"),a=this.safeString(e,"pending_amount"),o=this.safeString(e,"rate"),d=void 0,c=this.safeString(e,"pair"),u=this.safeSymbol(c,t,"_");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:i,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:u,price:o,stopPrice:void 0,triggerPrice:void 0,cost:void 0,fee:void 0,info:e,average:void 0,trades:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBooks(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/JPY")throw new E3(this.id+" fetchTicker() supports BTC/JPY only");await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),n=this.safeString(e,"rate"),r=this.safeString(e,"pair");t=this.safeMarket(r,t,"_");const a=t.baseId,o=t.quoteId,d=t.symbol;let c,u,h,f,l,m;if("liquidity"in e){this.safeString(e,"liquidity")==="T"?c="taker":this.safeString(e,"liquidity")==="M"&&(c="maker");const g=this.safeValue(e,"funds",{});u=this.safeString(g,a),h=this.safeString(g,o),l={currency:this.safeString(e,"fee_currency"),cost:this.safeString(e,"fee")},f=this.safeString(e,"side"),m=this.safeString(e,"order_id")}else u=this.safeString(e,"amount"),f=this.safeString(e,"order_type");return this.safeTrade({id:i,info:e,datetime:this.iso8601(s),timestamp:s,symbol:d,type:void 0,side:f,order:m,takerOrMaker:c,price:n,amount:u,cost:h,fee:l},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};s!==void 0&&(r.limit=s);const a=await this.privateGetExchangeOrdersTransactionsPagination(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),s=this.safeValue(t,"exchange_fees",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]={info:o,symbol:r,maker:this.safeNumber(o,"maker_fee"),taker:this.safeNumber(o,"taker_fee"),percentage:!0,tierBased:!1}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id};if(t==="market"){const u=t+"_"+s;o.order_type=u;const h=s==="buy"?u+"_":"";o[h+"amount"]=i}else o.order_type=s,o.rate=n,o.amount=i;const d=await this.privatePostExchangeOrders(this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteExchangeOrdersId(this.extend(i,s))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetDepositMoney(this.extend(r,i)),o=this.safeValue(a,"deposits",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.limit=s);const a=await this.privateGetWithdraws(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}parseTransactionStatus(e){const t={pending:"pending",processing:"pending",finished:"ok",canceled:"canceled",confirmed:"pending",received:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"address"),r=this.safeNumber(e,"amount"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parseTransactionStatus(this.safeString(e,"status")),c=this.parse8601(this.safeString(e,"confirmed_at"));let u;const h=this.safeNumber(e,"fee");return h!==void 0&&(u={cost:h,currency:o}),{info:e,id:s,txid:void 0,timestamp:i,datetime:this.iso8601(i),network:void 0,address:n,addressTo:n,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:r,currency:o,status:d,updated:c,internal:void 0,fee:u}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c="";s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(this.keysort(o))):Object.keys(o).length&&(r=this.urlencode(this.keysort(o)),c=r);const u=d+a+c;n={"Content-Type":"application/x-www-form-urlencoded","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(u),this.encode(this.secret))}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!0)){const u=this.safeString(a,"error"),h=this.id+" "+this.json(a);throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new q3(this.id+" "+this.json(a))}}};const D3=re,{ExchangeError:zw,ArgumentsRequired:rs,BadRequest:Kn,BadSymbol:Ec,RateLimitExceeded:F3,InsufficientFunds:H3,OrderNotFound:G3,InvalidOrder:xa,AuthenticationError:Ml,PermissionDenied:U3,ExchangeNotAvailable:$3,RequestTimeout:W3}=Q,{TICK_SIZE:z3}=ne,qc=ae;var vT=class extends D3{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v1",countries:["CN"],rateLimit:2.5,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressByNetwork:!1,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositWithdrawFees:!0,fetchDepsoitWithdrawFee:"emulated",fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",api:{public:"https://api.coinex.com",private:"https://api.coinex.com",perpetualPublic:"https://api.coinex.com/perpetual",perpetualPrivate:"https://api.coinex.com/perpetual"},www:"https://www.coinex.com",doc:"https://github.com/coinexcom/coinex_exchange_api/wiki",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{public:{get:{"amm/market":1,"common/currency/rate":1,"common/asset/config":1,"common/maintain/info":1,"common/temp-maintain/info":1,"margin/market":1,"market/info":1,"market/list":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/detail":1}},private:{get:{"account/amm/balance":40,"account/investment/balance":40,"account/balance/history":40,"account/market/fee":40,"balance/coin/deposit":40,"balance/coin/withdraw":40,"balance/info":40,"balance/deposit/address/{coin_type}":40,"contract/transfer/history":40,"credit/info":40,"credit/balance":40,"investment/transfer/history":40,"margin/account":1,"margin/config":1,"margin/loan/history":40,"margin/transfer/history":40,"order/deals":40,"order/finished":40,"order/pending":4,"order/status":4,"order/status/batch":4,"order/user/deals":40,"order/stop/finished":40,"order/stop/pending":4,"order/user/trade/fee":1,"order/market/trade/info":1,"sub_account/balance":1,"sub_account/transfer/history":40,"sub_account/auth/api/{user_auth_id}":40},post:{"balance/coin/withdraw":40,"contract/balance/transfer":40,"margin/flat":40,"margin/loan":40,"margin/transfer":40,"order/limit/batch":13.334,"order/ioc":6.667,"order/limit":6.667,"order/market":6.667,"order/modify":6.667,"order/stop/limit":6.667,"order/stop/market":6.667,"order/stop/modify":6.667,"sub_account/transfer":40,"sub_account/register":1,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api":40},put:{"balance/deposit/address/{coin_type}":40,"sub_account/auth/api/{user_auth_id}":40,"v1/account/settings":40},delete:{"balance/coin/withdraw":40,"order/pending/batch":13.334,"order/pending":6.667,"order/stop/pending":13.334,"order/stop/pending/{id}":13.334,"sub_account/auth/api/{user_auth_id}":40}},perpetualPublic:{get:{ping:1,time:1,"market/list":1,"market/limit_config":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/funding_history":1,"market/user_deals":1,"market/kline":1}},perpetualPrivate:{get:{"asset/query":40,"order/pending":4,"order/finished":40,"order/stop_finished":40,"order/stop_pending":4,"order/status":4,"order/stop_status":4,"position/pending":40,"position/funding":40},post:{"market/adjust_leverage":1,"market/position_expect":1,"order/put_limit":10,"order/put_market":10,"order/put_stop_limit":10,"order/put_stop_market":10,"order/modify":10,"order/modify_stop":10,"order/cancel":10,"order/cancel_all":20,"order/cancel_batch":20,"order/cancel_stop":10,"order/cancel_stop_all":20,"order/close_limit":10,"order/close_market":10,"position/adjust_margin":10,"position/stop_loss":10,"position/take_profit":10,"position/market_close":10}}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},options:{createMarketBuyOrderRequiresPrice:!0,defaultType:"spot",defaultSubType:"linear",fetchDepositAddress:{fillResponseFromRequest:!0},accountsById:{spot:"0"}},commonCurrencies:{ACM:"Actinium"},precisionMode:z3})}async fetchCurrencies(e={}){const t=await this.publicGetCommonAssetConfig(e),s=this.safeValue(t,"data",[]),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"asset"),c=this.safeString(o,"chain"),u=this.safeCurrencyCode(d),h=this.parseNumber(this.parsePrecision(this.safeString(o,"withdrawal_precision")));this.safeValue(n,u)===void 0&&(n[u]={id:d,numericId:void 0,code:u,info:o,name:void 0,active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:h,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}}});const f=this.safeValue(n[u],"networks",{}),l={info:o,id:c,network:c,name:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}},active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:h};f[c]=l,n[u].networks=f}return n}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchContractMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1];return this.arrayConcat(s,i)}async fetchSpotMarkets(e){const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i=[],n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=s[a],d=this.safeString(o,"name"),c=this.safeString(o,"trading_name"),u=c,h=this.safeString(o,"pricing_name"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h);let m=f+"/"+l;c===d&&(m=d),i.push({id:d,symbol:m,base:f,quote:l,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(o,"taker_fee_rate"),maker:this.safeNumber(o,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"trading_decimal"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"pricing_decimal")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return i}async fetchContractMarkets(e){const t=await this.perpetualPublicGetMarketList(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.fees,o=this.safeValue(r,"leverages",[]),d=this.safeInteger(r,"type"),c=d===1,u=d===2,h=this.safeString(r,"name"),f=this.safeString(r,"stock"),l=this.safeString(r,"money"),m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l),y=d===1?"USDT":f,w=this.safeCurrencyCode(y),b=m+"/"+g+":"+w,S=o.length;i.push({id:h,symbol:b,base:m,quote:g,settle:w,baseId:f,quoteId:l,settleId:y,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:this.safeValue(r,"available"),contract:!0,linear:c,inverse:u,taker:a.trading.taker,maker:a.trading.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"stock_prec"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"money_prec")))},limits:{leverage:{min:this.safeString(o,0),max:this.safeString(o,S-1)},amount:{min:this.safeString(r,"amount_min"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t);e=this.safeValue(e,"ticker",{});const n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString2(e,"vol","volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=s.swap?"perpetualPublicGetMarketTicker":"publicGetMarketTicker",r=await this[n](this.extend(i,t));return this.parseTicker(r.data,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const f=this.safeValue(e,0);s=this.market(f)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),a=await this[i==="swap"?"perpetualPublicGetMarketTickerAll":"publicGetMarketTickerAll"](n),o=this.safeValue(a,"data"),d=this.safeInteger(o,"date"),c=this.safeValue(o,"ticker",{}),u=Object.keys(c),h={};for(let f=0;f<u.length;f++){const l=u[f],m=this.safeMarket(l,void 0,void 0,i),g=m.symbol,y=this.parseTicker({date:d,ticker:c[l]},m);y.symbol=g,h[g]=y}return this.filterByArray(h,"symbol",e)}async fetchTime(e={}){const t=await this.perpetualPublicGetTime(e);return this.safeNumber(t,"data")}async fetchOrderBook(e,t=20,s={}){if(e===void 0)throw new rs(this.id+" fetchOrderBook() requires a symbol argument");await this.loadMarkets();const i=this.market(e);t===void 0&&(t=20);const n={market:this.marketId(e),merge:"0",limit:t.toString()},r=i.swap?"perpetualPublicGetMarketDepth":"publicGetMarketDepth",a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"time");return this.parseOrderBook(o,e,d)}parseTrade(e,t=void 0){let s=this.safeTimestamp2(e,"create_time","time");s===void 0&&(s=this.safeInteger(e,"date_ms"));const i=this.safeString(e,"id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"market"),d=this.safeString(this.options,"defaultType");t=this.safeMarket(o,t,void 0,d);const c=this.safeSymbol(o,t),u=this.safeString(e,"deal_money");let h;const f=this.safeString2(e,"fee","deal_fee");if(f!==void 0){const g=this.safeString(e,"fee_asset"),y=this.safeCurrencyCode(g);h={cost:f,currency:y}}let l=this.safeString(e,"role");l==="1"?l="maker":l==="2"&&(l="taker");let m;return t.type==="swap"?(m=this.safeInteger(e,"side"),m===1?m="sell":m===2&&(m="buy"),m===void 0&&(m=this.safeString(e,"type"))):m=this.safeString(e,"type"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:i,order:n,type:void 0,side:m,takerOrMaker:l,price:r,amount:a,cost:u,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=n.swap?"perpetualPublicGetMarketDeals":"publicGetMarketDeals",o=await this[a](this.extend(r,i));return this.parseTrades(o.data,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.publicGetMarketDetail(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]=this.parseTradingFee(o,a)}return i}parseTradingFee(e,t=void 0){const s=this.safeValue(e,"name"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:!0,tierBased:!0}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.swap?"perpetualPublicGetMarketKline":"publicGetMarketKline",d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchMarginBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");let s=this.safeString(e,"market"),i;if(t!==void 0)i=this.market(t),s=i.id;else if(s===void 0)throw new rs(this.id+" fetchMarginBalance() fetching a margin account requires a market parameter or a symbol parameter");e=this.omit(e,["symbol","market"]);const n={market:s},r=await this.privateGetMarginAccount(this.extend(n,e)),a={info:r},o=this.safeValue(r,"data",{}),d=this.safeValue(o,"can_transfer",{}),c=this.safeValue(o,"balance",{}),u=this.safeValue(o,"loan",{}),h=this.safeValue(o,"interest",{}),f=this.account(),l=this.safeString(o,"sell_asset_type"),m=this.safeCurrencyCode(l);f.free=this.safeString(d,"sell_type"),f.total=this.safeString(c,"sell_type");const g=this.safeString(u,"sell_type"),y=this.safeString(h,"sell_type");f.debt=qc.stringAdd(g,y),a[m]=f;const w=this.account(),b=this.safeString(o,"buy_asset_type"),S=this.safeCurrencyCode(b);w.free=this.safeString(d,"buy_type"),w.total=this.safeString(c,"buy_type");const v=this.safeString(u,"buy_type"),T=this.safeString(h,"buy_type");return w.debt=qc.stringAdd(v,T),a[S]=w,this.safeBalance(a)}async fetchSpotBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalanceInfo(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),s[o]=c}return this.safeBalance(s)}async fetchSwapBalance(e={}){await this.loadMarkets();const t=await this.perpetualPrivateGetAssetQuery(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),c.total=this.safeString(d,"balance_total"),s[o]=c}return this.safeBalance(s)}async fetchBalance(e={}){let t;return[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),t=this.safeValue(e,"margin",!1)?"margin":t,e=this.omit(e,"margin"),t==="margin"?await this.fetchMarginBalance(e):t==="swap"?await this.fetchSwapBalance(e):await this.fetchSpotBalance(e)}parseOrderStatus(e){const t={not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeTimestamp(e,"create_time"),i=this.safeString(e,"price"),n=this.safeString(e,"deal_money"),r=this.safeString(e,"amount"),a=this.safeString(e,"deal_amount"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"left"),c=this.safeString(e,"market"),u=this.safeString(this.options,"defaultType");t=this.safeMarket(c,t,void 0,u);const h=this.safeString(e,"fee_asset");let f=this.safeCurrencyCode(h);f===void 0&&(f=t.quote);const l=this.parseOrderStatus(this.safeString(e,"status"));let m=this.safeInteger(e,"side");m===1?m="sell":m===2?m="buy":m=this.safeString(e,"type");let g=this.safeString(e,"order_type");return g===void 0&&(g=this.safeInteger(e,"type"),g===1?g="limit":g===2&&(g="market")),this.safeOrder({id:this.safeString2(e,"id","order_id"),clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:this.safeTimestamp(e,"update_time"),status:l,symbol:t.symbol,type:g,timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:m,price:i,stopPrice:this.safeString(e,"stop_price"),triggerPrice:this.safeString(e,"stop_price"),cost:n,average:o,amount:r,filled:a,remaining:d,trades:void 0,fee:{currency:f,cost:this.safeString(e,"deal_fee")},info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.swap,d=this.safeValue2(r,"stopPrice","triggerPrice"),c=this.safeValue(r,"stopLossPrice"),u=this.safeValue(r,"takeProfitPrice"),h=this.safeString(r,"option"),f=t==="market",l=this.isPostOnly(f,h==="MAKER_ONLY",r),m=this.safeInteger2(r,"position_id","positionId");let g=this.safeString(r,"timeInForce");const y=this.safeValue(r,"reduceOnly");if(y!==void 0&&a.type!=="swap")throw new xa(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap markets only");let w;const b={market:a.id};if(o)if(c||u){if(b.stop_type=this.safeInteger(r,"stop_type",1),m===void 0)throw new rs(this.id+" createOrder() requires a position_id parameter for stop loss and take profit orders");b.position_id=m,c?(w="perpetualPrivatePostPositionStopLoss",b.stop_loss_price=this.priceToPrecision(e,c)):u&&(w="perpetualPrivatePostPositionTakeProfit",b.take_profit_price=this.priceToPrecision(e,u))}else w="perpetualPrivatePostOrderPut"+this.capitalize(t),s=s==="buy"?2:1,d!==void 0&&(b.stop_price=this.priceToPrecision(e,d),b.stop_type=this.safeInteger(r,"stop_type",1),b.amount=this.amountToPrecision(e,i),b.side=s,t==="limit"?(w="perpetualPrivatePostOrderPutStopLimit",b.price=this.priceToPrecision(e,n)):t==="market"&&(w="perpetualPrivatePostOrderPutStopMarket"),b.amount=this.amountToPrecision(e,i)),(t!=="market"||d!==void 0)&&(l?b.option=1:g!==void 0&&(g==="IOC"?g=2:g==="FOK"?g=3:g=1,b.effect_type=g)),t==="limit"&&d===void 0?(y?(w="perpetualPrivatePostOrderCloseLimit",b.position_id=m):b.side=s,b.price=this.priceToPrecision(e,n),b.amount=this.amountToPrecision(e,i)):t==="market"&&d===void 0&&(y?(w="perpetualPrivatePostOrderCloseMarket",b.position_id=m):(b.side=s,b.amount=this.amountToPrecision(e,i)));else{if(w="privatePostOrder"+this.capitalize(t),b.type=s,t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new xa(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const A=this.amountToPrecision(e,i),N=this.priceToPrecision(e,n),B=qc.stringMul(A,N),x=this.parseNumber(B);b.amount=this.costToPrecision(e,x)}}else b.amount=this.costToPrecision(e,i);else b.amount=this.amountToPrecision(e,i);if((t==="limit"||t==="ioc")&&(b.price=this.priceToPrecision(e,n)),d!==void 0&&(b.stop_price=this.priceToPrecision(e,d),t==="limit"?w="privatePostOrderStopLimit":t==="market"&&(w="privatePostOrderStopMarket")),(t!=="market"||d!==void 0)&&(g!==void 0||l)){if((l||g!=="IOC")&&t==="limit"&&d!==void 0)throw new xa(this.id+" createOrder() only supports the IOC option for stop-limit orders");l?b.option="MAKER_ONLY":g!==void 0&&(b.option=g)}}const S=this.safeInteger(r,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(S===void 0)throw new Kn(this.id+" createOrder() requires an account_id parameter for margin orders");b.account_id=S}r=this.omit(r,["reduceOnly","positionId","timeInForce","postOnly","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]);const T=await this[w](this.extend(b,r)),I=this.safeValue(T,"data");return this.parseOrder(I,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"stop"),r=i.swap,a={market:i.id},o=r?"order_id":"id";a[o]=e;let d=r?"perpetualPrivatePostOrderCancel":"privateDeleteOrderPending";n&&(r?d="perpetualPrivatePostOrderCancelStop":d="privateDeleteOrderStopPendingId");const c=this.safeInteger(s,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Kn(this.id+" cancelOrder() requires an account_id parameter for margin orders");a.account_id=c}const h=this.omit(s,["stop","account_id"]),f=await this[d](this.extend(a,h)),l=this.safeValue(f,"data");return this.parseOrder(l,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new rs(this.id+" cancellAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=s.id,n=this.safeInteger(t,"account_id",0),r={market:i},a=s.swap,o=this.safeValue(t,"stop");let d;return a?(d="perpetualPrivatePostOrderCancelAll",o&&(d="perpetualPrivatePostOrderCancelStopAll")):(d="privateDeleteOrderPending",o&&(d="privateDeleteOrderStopPending"),r.account_id=n),t=this.omit(t,["stop","account_id"]),await this[d](this.extend(r,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new rs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r=this.safeValue(s,"stop"),a={market:i.id},o=n?"order_id":"id";a[o]=e;let d;n?d=r?"perpetualPrivateGetOrderStopStatus":"perpetualPrivateGetOrderStatus":d="privateGetOrderStatus",s=this.omit(s,"stop");const c=await this[d](this.extend(a,s)),u=this.safeValue(c,"data");return this.parseOrder(u,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i=i===void 0?100:i;const r={limit:i},a=this.safeValue(n,"stop"),o=this.safeInteger(n,"side");n=this.omit(n,"stop");let d;t!==void 0&&(d=this.market(t),r.market=d.id);const[c,u]=this.handleMarketTypeAndParams("fetchOrdersByStatus",d,n);let h;if(c==="swap"){if(t===void 0)throw new rs(this.id+" fetchOrdersByStatus() requires a symbol argument for swap markets");h="perpetualPrivateGetOrder"+this.capitalize(e),a&&(h="perpetualPrivateGetOrderStopPending"),o!==void 0?r.side=o:r.side=0,r.offset=0}else h="privateGetOrder"+this.capitalize(e),a&&(h="privateGetOrderStop"+this.capitalize(e)),r.page=1;const f=this.safeInteger(n,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(f===void 0)throw new Kn(this.id+" fetchOpenOrders() and fetchClosedOrders() require an account_id parameter for margin orders");r.account_id=f}n=this.omit(u,"account_id");const m=await this[h](this.extend(r,n)),g=c==="swap"?"records":"data",y=this.safeValue(m,"data"),w=this.safeValue(y,g,[]);return this.parseOrders(w,d,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("pending",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id};if("network"in t){const a=this.safeString(t,"network");t=this.omit(t,"network"),i.smart_contract_name=a}const n=await this.privatePutBalanceDepositAddressCoinType(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id},n=this.safeValue(s,"networks",{}),r=this.safeString(t,"network");t=this.omit(t,"network");const o=Object.keys(n).length;if(n!==void 0&&o>1){if(r===void 0)throw new rs(this.id+" fetchDepositAddress() "+e+" requires a network parameter");if(!(r in n))throw new zw(this.id+" fetchDepositAddress() "+r+" network not supported for "+e)}r!==void 0&&(i.smart_contract_name=r);const d=await this.privateGetBalanceDepositAddressCoinType(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.parseDepositAddress(c,s),h=this.safeValue(this.options,"fetchDepositAddress",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.network=this.safeNetworkCode(r,s)),u}safeNetwork(e,t=void 0){const s=this.safeValue(t,"networks",{}),i=Object.keys(s);return e===void 0&&i.length===1?s[i[0]]:{id:e,network:e===void 0?void 0:e.toUpperCase()}}safeNetworkCode(e,t=void 0){return this.safeNetwork(e,t).network}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin_address"),i=s.split(":");let n,r;return i.length>1?(n=i[0],r=i[1]):n=s,{info:e,currency:this.safeCurrencyCode(void 0,t),address:n,tag:r,network:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;s===void 0&&(s=100);const r={limit:s,offset:0};e!==void 0&&(n=this.market(e),r.market=n.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),a!=="spot"&&e===void 0)throw new rs(this.id+" fetchMyTrades() requires a symbol argument for non-spot markets");const o=a==="swap";let d;if(o){d="perpetualPublicGetMarketUserDeals";const g=this.safeInteger(i,"side");if(g===void 0)throw new rs(this.id+" fetchMyTrades() requires a side parameter for swap markets");t!==void 0&&(r.start_time=t),r.side=g,i=this.omit(i,"side")}else d="privateGetOrderUserDeals",r.page=1;const c=this.safeInteger(i,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Kn(this.id+" fetchMyTrades() requires an account_id parameter for margin trades");r.account_id=c,i=this.omit(i,"account_id")}const h=await this[d](this.extend(r,i)),f=o?"records":"data",l=this.safeValue(h,"data"),m=this.safeValue(l,f,[]);return this.parseTrades(m,n,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i;if(e!==void 0){let o;if(Array.isArray(e)){if(e.length>1)throw new Kn(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");o=e[0]}else o=e;i=this.market(o),s.market=i.id}const n=await this.perpetualPrivateGetPositionPending(this.extend(s,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o],i));return this.filterByArray(a,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.perpetualPrivateGetPositionPending(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePosition(r[0],s)}parsePosition(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeString(this.options,"defaultType");t=this.safeMarket(s,t,void 0,i);const n=t.symbol,r=this.safeInteger(e,"position_id"),o=this.safeInteger(e,"type")===1?"isolated":"cross",d=this.safeString(e,"liq_price"),c=this.safeString(e,"open_price"),u=this.safeString(e,"profit_unreal"),h=this.safeString(e,"amount"),l=this.safeInteger(e,"side")===1?"short":"long",m=this.safeTimestamp(e,"update_time"),g=this.safeString(e,"mainten_margin_amount"),y=this.safeString(e,"mainten_margin"),w=this.safeString(e,"margin_amount"),b=this.safeNumber(e,"leverage");return{info:e,id:r,symbol:n,notional:void 0,marginMode:o,liquidationPrice:d,entryPrice:c,unrealizedPnl:u,percentage:void 0,contracts:void 0,contractSize:h,markPrice:void 0,side:l,hedged:void 0,timestamp:m,datetime:this.iso8601(m),maintenanceMargin:g,maintenanceMarginPercentage:y,collateral:w,initialMargin:void 0,initialMarginPercentage:void 0,leverage:b,marginRatio:void 0}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new rs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Kn(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new Ec(this.id+" setMarginMode() supports swap contracts only");let n;e==="isolated"?n=1:e==="cross"&&(n=2);const r=this.safeInteger(s,"leverage"),a=this.safeInteger(i.limits.leverage,"max",100),o=this.safeInteger(s,"position_type",n);if(r===void 0)throw new rs(this.id+" setMarginMode() requires a leverage parameter");if(o===void 0)throw new rs(this.id+" setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair");if(r<3||r>a)throw new Kn(this.id+" setMarginMode() leverage should be between 3 and "+a.toString()+" for "+t);const d={market:i.id,leverage:r.toString(),position_type:o};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new rs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(this.options,"defaultMarginMode","marginMode");let n;i==="isolated"?n=1:i==="cross"&&(n=2);const r=this.safeInteger(s,"position_type",n);if(r===void 0)throw new rs(this.id+" setLeverage() requires a position_type parameter that will transfer margin to the specified trading pair");const a=this.market(t),o=this.safeInteger(a.limits.leverage,"max",100);if(a.type!=="swap")throw new Ec(this.id+" setLeverage() supports swap contracts only");if(e<3||e>o)throw new Kn(this.id+" setLeverage() leverage should be between 3 and "+o.toString()+" for "+t);const d={market:a.id,leverage:e.toString(),position_type:r};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.perpetualPublicGetMarketLimitConfig(t),i=this.safeValue(s,"data",{});return this.parseLeverageTiers(i,e,void 0)}parseLeverageTiers(e,t=void 0,s=void 0){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a,void 0,void 0,"spot"),d=this.safeString(o,"symbol");let c=0;t!==void 0&&(c=t.length),d!==void 0&&(c===0||this.inArray(t,d))&&(i[d]=this.parseMarketLeverageTiers(e[a],o))}return i}parseMarketLeverageTiers(e,t=void 0){const s=[];let i=0;for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,0);s.push({tier:n+1,currency:t.linear?t.base:t.quote,minNotional:i,maxNotional:a,maintenanceMarginRate:this.safeNumber(r,2),maxLeverage:this.safeInteger(r,1),info:r}),i=a}return s}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id,amount:this.amountToPrecision(e,t),type:s},a=await this.perpetualPrivatePostPositionAdjustMargin(this.extend(r,i)),o=this.safeString(a,"message"),d=s===1?"add":"reduce";return this.extend(this.parseMarginModification(a,n),{amount:this.parseNumber(t),type:d,status:o})}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:this.safeSymbol(void 0,t),status:void 0}}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rs(this.id+" fetchFundingHistory() requires a symbol argument");s=s===void 0?100:s,await this.loadMarkets();const r={market:this.market(e).id,limit:s};t!==void 0&&(r.start_time=t);const a=await this.perpetualPrivateGetPositionFunding(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"records",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.safeTimestamp(h,"time"),l=this.safeString(h,"asset"),m=this.safeCurrencyCode(l);c.push({info:h,symbol:e,code:m,timestamp:f,datetime:this.iso8601(f),id:this.safeNumber(h,"position_id"),amount:this.safeNumber(h,"funding")})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ec(this.id+" fetchFundingRate() supports swap contracts only");const i={market:s.id},n=await this.perpetualPublicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"ticker",{});return this.parseFundingRate(a,s)}parseFundingRate(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"sign_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate_next"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.safeNumber(e,"funding_rate_predict"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"funding_rate_last"),previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const d=this.safeValue(e,0);if(s=this.market(d),!s.swap)throw new Ec(this.id+" fetchFundingRates() supports swap contracts only")}const i=await this.perpetualPublicGetMarketTickerAll(t),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"ticker",{}),a=[],o=Object.keys(r);for(let d=0;d<o.length;d++){const c=o[d];if(c.indexOf("_")===-1){const u=this.safeMarket(c,void 0,void 0,"swap"),h=r[c];a.push(this.parseFundingRate(h,u))}}return this.filterByArray(a,"symbol",e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a={coin_type:r.id,coin_address:s,actual_amount:parseFloat(t),transfer_method:"onchain"},o=await this.privatePostBalanceCoinWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={audit:"pending",pass:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",fail:"failed"};return this.safeString(t,e,e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new rs(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id,limit:s,offset:0};t!==void 0&&(r.start_time=t);const a=await this.perpetualPublicGetMarketFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"records",[]),c=[];for(let h=0;h<d.length;h++){const f=d[h],l=this.safeString(f,"market"),m=this.safeSymbol(l),g=this.safeTimestamp(f,"time");c.push({info:f,symbol:m,fundingRate:this.safeString(f,"funding_rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"coin_withdraw_id","coin_deposit_id"),i=this.safeString(e,"coin_address");let n=this.safeString(e,"remark");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeValue(e,"tx_id");r!==void 0&&r.length<1&&(r=void 0);const a=this.safeString(e,"coin_type"),o=this.safeCurrencyCode(a,t),d=this.safeTimestamp(e,"create_time"),c="coin_withdraw_id"in e?"withdraw":"deposit",u=this.parseTransactionStatus(this.safeString(e,"status")),h=this.safeString(e,"smart_contract_name"),f=this.safeNumber(e,"actual_amount");let l=this.safeString(e,"tx_fee"),m,g;c==="deposit"?(l="0",m=i):g=i;const y={cost:this.parseNumber(l),currency:o};return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:this.networkIdToCode(h),address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:m,tagFrom:g,type:c,amount:this.parseNumber(f),currency:o,status:u,updated:void 0,fee:y}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={amount:a,coin_type:r.id};let d="privatePostContractBalanceTransfer";if(s==="spot"&&i==="swap")o.transfer_side="in";else if(s==="swap"&&i==="spot")o.transfer_side="out";else{const u=this.safeValue(this.options,"accountsById",{}),h=this.safeString(u,s,s),f=this.safeString(u,i,i);o.from_account=parseInt(h),o.to_account=parseInt(f),d="privatePostMarginTransfer"}const c=await this[d](this.extend(o,n));return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={0:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_at"),i=this.safeString(e,"transfer_type");let n,r;i==="transfer_out"?(n="swap",r="spot"):i==="transfer_in"?(n="spot",r="swap"):i==="IN"?(n="spot",r="margin"):i==="OUT"&&(n="margin",r="spot");const a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t);return{id:this.safeInteger(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:o,amount:this.safeNumber(e,"amount"),fromAccount:n,toAccount:r,status:this.parseTransferStatus(this.safeString2(e,"code","status"))}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={page:1,limit:s},a=this.safeInteger(i,"page");a!==void 0&&(r.page=a),e!==void 0&&(n=this.safeCurrencyCode(e),r.asset=n.id),t!==void 0&&(r.start_time=t),i=this.omit(i,"page");const d=this.safeString(this.options,"defaultType")==="margin"?"privateGetMarginTransferHistory":"privateGetContractTransferHistory",c=await this[d](this.extend(r,i)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"records",[]);return this.parseTransfers(h,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rs(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinWithdraw(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rs(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinDeposit(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeValue(e,t,{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const a=this.safeString(this.options,"defaultSettle","USDT");s=this.market(e+"/"+a)}const i={market:s.id},n=await this.privateGetMarginConfig(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseBorrowRate(r,s.base)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetMarginConfig(e),s=this.milliseconds(),i=this.safeValue(t,"data",{}),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"market"),d=this.safeMarket(o,void 0,void 0,"spot"),c=this.safeValue(a,d.base);n.push({currency:d.base,rate:this.safeNumber(c,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a})}return n}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=i);const o=await this.privateGetMarginLoanHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"data",[]),u=this.parseBorrowInterests(c,a);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market_type");t=this.safeMarket(s,t,void 0,"spot");const i=this.safeString(t,"symbol"),n=this.safeTimestamp(e,"expire_time"),r=this.safeString(e,"unflat_amount"),a=this.safeString(e,"loan_amount");let o=qc.stringSub(r,a);return r==="0"&&(o=void 0),{account:void 0,symbol:i,marginMode:"isolated",marginType:void 0,currency:this.safeCurrencyCode(this.safeString(e,"coin_type")),interest:this.parseNumber(o),interestRate:this.safeNumber(e,"day_rate"),amountBorrowed:this.parseNumber(a),timestamp:n,datetime:this.iso8601(n),info:e}}async borrowMargin(e,t,s=void 0,i={}){if(s===void 0)throw new rs(this.id+" borrowMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=await this.privatePostMarginLoan(this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(s===void 0)throw new rs(this.id+" repayMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=this.safeInteger(i,"loan_id");o!==void 0&&(a.loan_id=o);const d=await this.privatePostMarginFlat(this.extend(a,i)),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"loan_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&e.length===1&&(s.coin_type=this.safeValue(e,0));const i=await this.publicGetCommonAssetConfig(this.extend(s,t));return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const n=this.safeValue(e,"data"),r=Object.keys(n);for(let o=0;o<r.length;o++){const d=r[o],c=d.split("-"),u=n[r[o]],h=this.safeString(u,"asset"),f=this.safeCurrency(h),l=this.safeString(f,"code");if(t===void 0||this.inArray(l,t)){this.safeValue(i,l)===void 0&&(i[l]=this.depositWithdrawFee({})),i[l].info[d]=u;const g=this.safeString(c,1),y=this.safeValue(u,"withdraw_tx_fee"),w={fee:y,percentage:y!==void 0?!1:void 0},b={fee:void 0,percentage:void 0};if(g!==void 0){const S=this.networkIdToCode(g);i[l].networks[S]={withdraw:w,deposit:b}}else i[l].withdraw=w,i[l].deposit=b}}const a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.currency(d);i[d]=this.assignDefaultDepositWithdrawFees(i[d],c)}return i}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){e=this.implodeParams(e,i);let a=this.urls.api[t]+"/"+this.version+"/"+e,o=this.omit(i,this.extractParams(e));const d=this.nonce().toString();if(t==="perpetualPrivate"||a==="https://api.coinex.com/perpetual/v1/market/user_deals"){this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,timestamp:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret),"sha256").toLowerCase(),AccessId:this.apiKey},s==="GET"||s==="PUT"?a+="?"+c:(n["Content-Type"]="application/x-www-form-urlencoded",r=c)}else if(t==="public"||t==="perpetualPublic")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,tonce:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret)).toUpperCase(),"Content-Type":"application/json"},s==="GET"||s==="DELETE"||s==="PUT"?a+="?"+c:r=this.json(o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeValue(a,"data"),h=this.safeString(a,"message");if(c!=="0"||h!=="Success"&&h!=="Succeeded"&&h!=="Ok"&&!u){const f={23:U3,24:Ml,25:Ml,34:Ml,35:$3,36:W3,213:F3,107:H3,600:G3,601:xa,602:xa,606:xa},l=this.safeValue(f,c,zw);throw new l(a.message)}}};const j3=re,{ExchangeError:K3,AuthenticationError:X3,RateLimitExceeded:Y3,ArgumentsRequired:Z3}=Q,{TICK_SIZE:Q3}=ne,jw=ae;var J3=class extends j3{describe(){return this.deepExtend(super.describe(),{id:"coinfalcon",name:"CoinFalcon",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradinFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg",api:{rest:"https://coinfalcon.com"},www:"https://coinfalcon.com",doc:"https://docs.coinfalcon.com",fees:"https://coinfalcon.com/fees",referral:"https://coinfalcon.com/?ref=CFJSVGTUPASB"},api:{public:{get:["markets","markets/{market}","markets/{market}/orders","markets/{market}/trades"]},private:{get:["user/accounts","user/orders","user/orders/{id}","user/orders/{id}/trades","user/trades","user/fees","account/withdrawals/{id}","account/withdrawals","account/deposit/{id}","account/deposits","account/deposit_address"],post:["user/orders","account/withdraw"],delete:["user/orders/{id}","account/withdrawals/{id}"]}},fees:{trading:{tierBased:!0,maker:0,taker:.002}},precisionMode:Q3})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],[a,o]=r.name.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);i.push({id:r.name,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"size_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minPrice"),max:void 0},price:{min:this.safeNumber(r,"minVolume"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"name");t=this.safeMarket(s,t,"-");const i=this.milliseconds(),n=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"highest_bid"),bidVolume:void 0,ask:this.safeString(e,"lowest_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"change_in_24h"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){return await this.loadMarkets(),(await this.fetchTickers([e],t))[e]}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarkets(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id,level:"3"},r=await this.publicGetMarketsMarketOrders(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","size")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=t.symbol,a=this.safeString(e,"id"),o=this.safeString(e,"side"),d=this.safeString(e,"order_id");let c;const u=this.safeString(e,"fee");if(u!==void 0){const h=this.safeString(e,"fee_currency_code");c={cost:u,currency:this.safeCurrencyCode(h)}}return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,id:a,order:d,type:void 0,side:o,takerOrMaker:void 0,price:i,amount:n,cost:void 0,fee:c},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Z3(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetUserTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.since=this.iso8601(t));const a=await this.publicGetMarketsMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetUserFees(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee"),r=this.parseNumber(jw.stringDiv(i,"100")),a=this.parseNumber(jw.stringDiv(n,"100")),o={};for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];o[c]={info:t,symbol:c,maker:r,taker:a,percentage:!0,tierBased:!0}}return o}parseBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available_balance"),o.used=this.safeString(n,"hold_balance"),o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAccounts(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeCurrency(e),i={currency:this.safeStringLower(s,"id")},n=await this.privateGetAccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseOrderStatus(e){const t={fulfilled:"closed",canceled:"canceled",pending:"open",open:"open",partially_filled:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"size_filled"),d=this.parseOrderStatus(this.safeString(e,"status"));let c=this.safeString(e,"operation_type");c!==void 0&&(c=c.split("_"),c=c[0]);const u=this.safeString(e,"order_type"),h=this.safeValue(e,"post_only");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,status:d,symbol:i,type:c,timeInForce:void 0,postOnly:h,side:u,price:r,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,size:this.amountToPrecision(e,i),order_type:s};t==="limit"&&(n=this.priceToPrecision(e,n),o.price=n.toString()),o.operation_type=t+"_order";const d=await this.privatePostUserOrders(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateDeleteUserOrdersId(this.extend(i,s)),r=this.market(t),a=this.safeValue(n,"data",{});return this.parseOrder(a,r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetUserOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetUserOrders(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=this.filterByArray(o,"status",["pending","open","partially_filled"],!1);return this.parseOrders(d,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:this.safeStringLower(r,"id"),address:s,amount:t};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={completed:"ok",denied:"failed",approval_pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString(e,"tag"),r=this.safeString(e,"txid"),a=this.safeString(e,"currency_code"),o=this.safeCurrencyCode(a,t);let d=this.safeString(e,"type");d==="withdraw"&&(d="withdrawal");const c=this.parseTransactionStatus(this.safeString(e,"status")),u=this.safeString(e,"amount"),h=this.parseNumber(u),f=this.safeString(e,"fee");let l=0;return f!==void 0&&(l=this.parseNumber(f)),{info:e,id:s,txid:r,timestamp:void 0,datetime:void 0,network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:d,amount:h,currency:o,status:c,updated:void 0,fee:{currency:o,cost:l}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):r=this.json(o);const c=this.seconds().toString();let u=[c,s,a].join("|");r&&(u+="|"+r);const h=this.hmac(this.encode(u),this.encode(this.secret));n={"CF-API-KEY":this.apiKey,"CF-API-TIMESTAMP":c,"CF-API-SIGNATURE":h,"Content-Type":"application/json"}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e<400)return;const c=this.safeValue({401:X3,429:Y3},e,K3);throw new c(r)}};const eR=re,{ExchangeError:Lc,ArgumentsRequired:tR,InvalidOrder:Pl,OrderNotFound:sR,RateLimitExceeded:iR,InsufficientFunds:nR,AuthenticationError:rR}=Q,{TICK_SIZE:aR}=ne,Kw=ae;var oR=class extends eR{describe(){return this.deepExtend(super.describe(),{id:"coinmate",name:"CoinMate",countries:["GB","CZ","EU"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg",api:{rest:"https://coinmate.io/api"},www:"https://coinmate.io",fees:"https://coinmate.io/fees",doc:["https://coinmate.docs.apiary.io","https://coinmate.io/developers"],referral:"https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["orderBook","ticker","transactions","tradingPairs"]},private:{post:["balances","bitcoinCashWithdrawal","bitcoinCashDepositAddresses","bitcoinDepositAddresses","bitcoinWithdrawal","bitcoinWithdrawalFees","buyInstant","buyLimit","cancelOrder","cancelOrderWithInfo","createVoucher","dashDepositAddresses","dashWithdrawal","ethereumWithdrawal","ethereumDepositAddresses","litecoinWithdrawal","litecoinDepositAddresses","openOrders","order","orderHistory","orderById","pusherAuth","redeemVoucher","replaceByBuyLimit","replaceByBuyInstant","replaceBySellLimit","replaceBySellInstant","rippleDepositAddresses","rippleWithdrawal","sellInstant","sellLimit","transactionHistory","traderFees","tradeHistory","transfer","transferHistory","unconfirmedBitcoinDeposits","unconfirmedBitcoinCashDeposits","unconfirmedDashDeposits","unconfirmedEthereumDeposits","unconfirmedLitecoinDeposits","unconfirmedRippleDeposits"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0012"),taker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0035")],[this.parseNumber("10000"),this.parseNumber("0.0023")],[this.parseNumber("100000"),this.parseNumber("0.0021")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0013")],[this.parseNumber("3000000"),this.parseNumber("0.0010")],[this.parseNumber("15000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("10000"),this.parseNumber("0.0011")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0005")],[this.parseNumber("1000000"),this.parseNumber("0.0003")],[this.parseNumber("3000000"),this.parseNumber("0.0002")],[this.parseNumber("15000000"),this.parseNumber("0")]]}}},options:{withdraw:{fillResponsefromRequest:!0,methods:{BTC:"privatePostBitcoinWithdrawal",LTC:"privatePostLitecoinWithdrawal",BCH:"privatePostBitcoinCashWithdrawal",ETH:"privatePostEthereumWithdrawal",XRP:"privatePostRippleWithdrawal",DASH:"privatePostDashWithdrawal",DAI:"privatePostDaiWithdrawal"}}},exceptions:{exact:{"No order with given ID":sR},broad:{"Not enough account balance available":nR,"Incorrect order ID":Pl,"Minimum Order Size ":Pl,"max allowed precision":Pl,"TOO MANY REQUESTS":iR,"Access denied.":rR}},precisionMode:aR})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"firstCurrency"),d=this.safeString(r,"secondCurrency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"lotDecimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceDecimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"data",{}),s={info:e},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(t,r),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"reserved"),d.total=this.safeString(o,"balance"),s[a]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currencyPair:i.id,groupByPriceLimit:"False"},a=(await this.publicGetOrderBook(this.extend(n,s))).data,o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeTimestamp(r,"timestamp"),o=this.safeNumber(r,"last");return{symbol:s.symbol,timestamp:a,datetime:this.iso8601(a),high:this.safeNumber(r,"high"),low:this.safeNumber(r,"low"),bid:this.safeNumber(r,"bid"),bidVolume:void 0,ask:this.safeNumber(r,"ask"),vwap:void 0,askVolume:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(r,"amount"),quoteVolume:void 0,info:r}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={limit:1e3};if(s!==void 0&&(n.limit=s),t!==void 0&&(n.timestampFrom=t),e!==void 0){const o=this.currency(e);n.currency=o.id}const a=(await this.privatePostTransferHistory(this.extend(n,i))).data;return this.parseTransactions(a,void 0,t,s)}parseTransactionStatus(e){const t={COMPLETED:"ok",WAITING:"pending",SENT:"pending",CREATED:"pending",OK:"ok",NEW:"pending",CANCELED:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber(e,"amount"),n=this.safeNumber(e,"fee"),r=this.safeString(e,"txid"),a=this.safeString(e,"destination"),o=this.safeString(e,"destinationTag"),d=this.safeString(e,"amountCurrency"),c=this.safeCurrencyCode(d,t),u=this.safeStringLower(e,"transferType"),h=this.parseTransactionStatus(this.safeString(e,"transferStatus")),f=this.safeString2(e,"transactionId","id"),l=this.safeString(e,"walletType");return{id:f,timestamp:s,datetime:this.iso8601(s),currency:c,amount:i,type:u,txid:r,network:l,address:a,addressTo:void 0,addressFrom:void 0,tag:o,tagTo:void 0,tagFrom:void 0,status:h,fee:{cost:n,currency:c},info:e}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"withdraw",{}),o=this.safeValue(a,"methods",{}),d=this.safeString(o,e);if(d===void 0){const m=Object.keys(o);throw new Lc(this.id+" withdraw() only allows withdrawing the following currencies: "+m.join(", "))}const c={amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(c.destinationTag=i);const u=await this[d](this.extend(c,n)),h=this.safeValue(u,"data"),f=this.parseTransaction(h,r);return this.safeValue(a,"fillResponseFromRequest",!0)&&(f.amount=t,f.currency=e,f.address=s,f.tag=i,f.type="withdrawal",f.status="pending"),f}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=1e3);const n={limit:s};if(e!==void 0){const o=this.market(e);n.currencyPair=o.id}t!==void 0&&(n.timestampFrom=t);const r=await this.privatePostTradeHistory(this.extend(n,i)),a=this.safeValue(r,"data",[]);return this.parseTrades(a,void 0,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"currencyPair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeStringLower2(e,"type","tradeType"),a=this.safeStringLower(e,"orderType"),o=this.safeString(e,"orderId"),d=this.safeString(e,"transactionId"),c=this.safeInteger2(e,"timestamp","createdTimestamp");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:t.quote});let f=this.safeString(e,"feeType");return f=f==="MAKER"?"maker":"taker",this.safeTrade({id:d,info:e,timestamp:c,datetime:this.iso8601(c),symbol:t.symbol,type:a,side:r,order:o,takerOrMaker:f,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id,minutesIntoHistory:10},a=await this.publicGetTransactions(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.privatePostTraderFees(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"maker"),o=this.safeString(r,"taker"),d=this.parseNumber(Kw.stringDiv(a,"100")),c=this.parseNumber(Kw.stringDiv(o,"100"));return{info:r,symbol:s.symbol,maker:d,taker:c,percentage:!0,tierBased:!0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.privatePostOpenOrders(this.extend({},i)),r={status:"open"};return this.parseOrders(n.data,void 0,t,s,r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tR(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id};s!==void 0&&(r.limit=s);const a=await this.privatePostOrderHistory(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}parseOrderStatus(e){const t={FILLED:"closed",CANCELLED:"canceled",PARTIALLY_FILLED:"open",OPEN:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={LIMIT:"limit",MARKET:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeStringLower(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"originalAmount"),o=this.safeString2(e,"remainingAmount","amount"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.parseOrderType(this.safeString(e,"orderTradeType")),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"currencyPair"),f=this.safeSymbol(h,t,"_"),l=this.safeString(e,"clientOrderId"),m=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:l,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:f,type:c,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:m,triggerPrice:m,amount:a,cost:void 0,average:u,filled:void 0,remaining:o,status:d,trades:void 0,info:e,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost"+this.capitalize(s);const d={currencyPair:this.market(e).id};t==="market"?(s==="buy"?d.total=this.amountToPrecision(e,i):d.amount=this.amountToPrecision(e,i),a+="Instant"):(d.amount=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),a+=this.capitalize(t));const c=await this[a](this.extend(d,r)),u=this.safeString(c,"data");return{info:c,id:u}}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};let n;t&&(n=this.market(t));const r=await this.privatePostOrderById(this.extend(i,s)),a=this.safeValue(r,"data");return this.parseOrder(a,n)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return{info:await this.privatePostCancelOrderWithInfo(this.extend(i,s))}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=o+this.uid+this.apiKey,c=this.hmac(this.encode(d),this.encode(this.secret));r=this.urlencode(this.extend({clientId:this.uid,nonce:o,publicKey:this.apiKey,signature:c.toUpperCase()},i)),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a&&a.error){const c=this.safeString(a,"errorMessage"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Lc(this.id+" "+this.json(a))}if(e>400){if(r){const c=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,r,c),this.throwBroadlyMatchedException(this.exceptions.broad,r,c),new Lc(c)}throw new Lc(this.id+" "+r)}}};const dR=re,{BadSymbol:cR,BadRequest:uR,ExchangeError:Rc,ArgumentsRequired:Dc,OrderNotFound:hR,OnMaintenance:fR}=Q,{TICK_SIZE:lR}=ne,Al=ae;var pR=class extends dR{describe(){return this.deepExtend(super.describe(),{id:"coinone",name:"CoinOne",countries:["KR"],rateLimit:667,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",api:{rest:"https://api.coinone.co.kr"},www:"https://coinone.co.kr",doc:"https://doc.coinone.co.kr"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["orderbook/","trades/","ticker/"]},private:{post:["account/deposit_address/","account/btc_deposit_address/","account/balance/","account/daily_balance/","account/user_info/","account/virtual_account/","order/cancel_all/","order/cancel/","order/limit_buy/","order/limit_sell/","order/complete_orders/","order/limit_orders/","order/order_info/","transaction/auth_number/","transaction/history/","transaction/krw/history/","transaction/btc/","transaction/coin/"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002}},precisionMode:lR,exceptions:{405:fR,104:hR,108:cR,107:uR},commonCurrencies:{SOC:"Soda Coin"}})}async fetchMarkets(e={}){const t={currency:"all"},s=await this.publicGetTicker(t),i=[],n="krw",r=this.safeCurrencyCode(n),a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(s,d,{});if(this.safeValue(c,"currency")===void 0)continue;const h=this.safeCurrencyCode(d);i.push({id:d,symbol:h+"/"+r,base:h,quote:r,settle:void 0,baseId:d,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-4"),price:this.parseNumber("1e-4"),cost:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:c})}return i}parseBalance(e){const t={info:e},s=this.omit(e,["errorCode","result","normalWallets"]),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=s[r],o=this.safeCurrencyCode(r),d=this.account();d.free=this.safeString(a,"avail"),d.total=this.safeString(a,"balance"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id,format:"json"},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a,"bid","ask","price","qty")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={currency:"all",format:"json"},i=await this.publicGetTicker(this.extend(s,t)),n={},r=Object.keys(i),a=this.safeTimestamp(i,"timestamp");for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=i[d];n[u]=this.parseTicker(h,c),n[u].timestamp=a}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id,format:"json"},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"first"),n=this.safeString(e,"last"),r=this.safeString(e,"yesterday_last"),a=this.safeSymbol(void 0,t);return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:i,close:n,last:n,previousClose:r,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");t=this.safeMarket(void 0,t);const i=this.safeString(e,"is_ask");let n=this.safeString(e,"type");i!==void 0?i==="1"?n="sell":i==="0"&&(n="buy"):n==="ask"?n="sell":n==="bid"&&(n="buy");const r=this.safeString(e,"price"),a=this.safeString(e,"qty"),o=this.safeString(e,"orderId");let d=this.safeString(e,"fee"),c;if(d!==void 0){d=Al.stringAbs(d);let u=this.safeString(e,"feeRate");u=Al.stringAbs(u);const h=n==="sell"?t.quote:t.base;c={cost:d,currency:h,rate:u}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),order:o,symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id,format:"json"},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new Rc(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={price:n,currency:a.id,qty:i},d="privatePostOrder"+this.capitalize(t)+this.capitalize(s),c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Dc(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,currency:i.id},r=await this.privatePostOrderOrderInfo(this.extend(n,s)),a=this.safeValue(r,"info",{});return a.status=this.safeString(a,"status"),this.parseOrder(a,i)}parseOrderStatus(e){const t={live:"open",partially_filled:"open",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"price"),n=this.safeTimestamp(e,"timestamp");let r=this.safeString(e,"type");r==="ask"?r="sell":r==="bid"&&(r="buy");const a=this.safeString(e,"remainQty"),o=this.safeString(e,"qty");let d=this.safeString(e,"status");d==="live"&&a!==void 0&&o!==void 0&&Al.stringLt(a,o)&&(d="canceled"),d=this.parseOrderStatus(d);const c=t.symbol,u=t.base,h=t.quote;let f;const l=this.safeString(e,"fee");if(l!==void 0){const m=r==="sell"?h:u;f={cost:l,rate:this.safeString(e,"feeRate"),currency:m}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:c,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:void 0,amount:o,filled:void 0,remaining:a,status:d,fee:f,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rc(this.id+" fetchOpenOrders() allows fetching closed orders with a specific symbol");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderLimitOrders(this.extend(r,i)),o=this.safeValue(a,"limitOrders",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Dc(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderCompleteOrders(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Dc(this.id+" cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");const i=this.safeNumber(s,"price"),n=this.safeNumber(s,"qty"),r=this.safeInteger(s,"is_ask");if(i===void 0||n===void 0||r===void 0)throw new Dc(this.id+" cancelOrder() requires {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument.");await this.loadMarkets();const a={order_id:e,price:i,qty:n,is_ask:r,currency:this.marketId(t)};return await this.privatePostOrderCancel(this.extend(a,s))}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAccountDepositAddress(t),i=this.safeValue(s,"walletAddress",{}),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=i[o];if(!d||d==="-1")continue;const c=o.split("_"),u=this.safeValue(c,0),h=this.safeValue(c,1),f=this.safeCurrencyCode(u);let l=this.safeValue(r,f);l===void 0&&(l={currency:f,address:void 0,tag:void 0,info:d});const m=this.safeString(l,"address",d);this.checkAddress(m),l.address=m,l.info=m,(h==="tag"||h==="memo")&&(l.tag=d,l.info=[m,d]),r[f]=l}return r}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));let d=this.urls.api.rest+"/";if(t==="public")d+=a,Object.keys(o).length&&(d+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),d+=this.version+"/"+a;const c=this.nonce().toString(),u=this.json(this.extend({access_token:this.apiKey,nonce:c},i)),h=this.stringToBase64(u);r=this.decode(h);const f=this.secret.toUpperCase(),l=this.hmac(h,this.encode(f),"sha512");n={"Content-Type":"application/json","X-COINONE-PAYLOAD":h,"X-COINONE-SIGNATURE":l}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0)if("result"in a){if(a.result!=="success"){const u=this.safeString(a,"errorCode"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new Rc(h)}}else throw new Rc(this.id+" "+r)}};const mR=re,{ExchangeError:gR,ArgumentsRequired:yR}=Q,{TICK_SIZE:wR}=ne;var bR=class extends mR{describe(){return this.deepExtend(super.describe(),{id:"coinspot",name:"CoinSpot",countries:["AU"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",api:{public:"https://www.coinspot.com.au/pubapi",private:"https://www.coinspot.com.au/api"},www:"https://www.coinspot.com.au",doc:"https://www.coinspot.com.au/api",referral:"https://www.coinspot.com.au/register?code=PJURCU"},api:{public:{get:["latest"]},private:{post:["orders","orders/history","my/coin/deposit","my/coin/send","quote/buy","quote/sell","my/balances","my/orders","my/buy","my/sell","my/buy/cancel","my/sell/cancel","ro/my/balances","ro/my/balances/{cointype}","ro/my/deposits","ro/my/withdrawals","ro/my/transactions","ro/my/transactions/{cointype}","ro/my/transactions/open","ro/my/transactions/{cointype}/open","ro/my/sendreceive","ro/my/affiliatepayments","ro/my/referralpayments"]}},markets:{"ADA/AUD":{id:"ada",symbol:"ADA/AUD",base:"ADA",quote:"AUD",baseId:"ada",quoteId:"aud",type:"spot",spot:!0},"BTC/AUD":{id:"btc",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"btc",quoteId:"aud",type:"spot",spot:!0},"ETH/AUD":{id:"eth",symbol:"ETH/AUD",base:"ETH",quote:"AUD",baseId:"eth",quoteId:"aud",type:"spot",spot:!0},"XRP/AUD":{id:"xrp",symbol:"XRP/AUD",base:"XRP",quote:"AUD",baseId:"xrp",quoteId:"aud",type:"spot",spot:!0},"LTC/AUD":{id:"ltc",symbol:"LTC/AUD",base:"LTC",quote:"AUD",baseId:"ltc",quoteId:"aud",type:"spot",spot:!0},"DOGE/AUD":{id:"doge",symbol:"DOGE/AUD",base:"DOGE",quote:"AUD",baseId:"doge",quoteId:"aud",type:"spot",spot:!0},"RFOX/AUD":{id:"rfox",symbol:"RFOX/AUD",base:"RFOX",quote:"AUD",baseId:"rfox",quoteId:"aud",type:"spot",spot:!0},"POWR/AUD":{id:"powr",symbol:"POWR/AUD",base:"POWR",quote:"AUD",baseId:"powr",quoteId:"aud",type:"spot",spot:!0},"NEO/AUD":{id:"neo",symbol:"NEO/AUD",base:"NEO",quote:"AUD",baseId:"neo",quoteId:"aud",type:"spot",spot:!0},"TRX/AUD":{id:"trx",symbol:"TRX/AUD",base:"TRX",quote:"AUD",baseId:"trx",quoteId:"aud",type:"spot",spot:!0},"EOS/AUD":{id:"eos",symbol:"EOS/AUD",base:"EOS",quote:"AUD",baseId:"eos",quoteId:"aud",type:"spot",spot:!0},"XLM/AUD":{id:"xlm",symbol:"XLM/AUD",base:"XLM",quote:"AUD",baseId:"xlm",quoteId:"aud",type:"spot",spot:!0},"RHOC/AUD":{id:"rhoc",symbol:"RHOC/AUD",base:"RHOC",quote:"AUD",baseId:"rhoc",quoteId:"aud",type:"spot",spot:!0},"GAS/AUD":{id:"gas",symbol:"GAS/AUD",base:"GAS",quote:"AUD",baseId:"gas",quoteId:"aud",type:"spot",spot:!0}},commonCurrencies:{DRK:"DASH"},options:{fetchBalance:"private_post_my_balances"},precisionMode:wR})}parseBalance(e){const t={info:e},s=this.safeValue2(e,"balance","balances");if(Array.isArray(s))for(let i=0;i<s.length;i++){const n=s[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o),u=this.account();u.total=this.safeString(d,"balance"),t[c]=u}}else{const i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(s,r),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(this.options,"fetchBalance","private_post_my_balances"),s=await this[t](e);return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={cointype:i.id},r=await this.privatePostOrders(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buyorders","sellorders","rate","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.publicGetLatest(t);let n=s.id;n=n.toLowerCase();const r=this.safeValue(i,"prices"),a=this.safeValue(r,n);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetLatest(t),i={},n=this.safeValue(s,"prices"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o);if(d.spot){const c=d.symbol,u=n[o];i[c]=this.parseTicker(u,d)}}return this.filterByArray(i,"symbol",e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={cointype:n.id},a=await this.privatePostOrdersHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"rate"),i=this.safeString(e,"amount"),n=this.safeNumber(e,"total"),r=this.safeInteger(e,"solddate"),a=this.safeString(e,"market"),o=this.safeSymbol(a,t,"/");return this.safeTrade({info:e,id:void 0,symbol:o,timestamp:r,datetime:this.iso8601(r),order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:s,amount:i,cost:n,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a="privatePostMy"+this.capitalize(s);if(t==="market")throw new gR(this.id+" createOrder() allows limit orders only");const d={cointype:this.market(e).id,amount:i,rate:n};return await this[a](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i!=="buy"&&i!=="sell")throw new yR(this.id+' cancelOrder() requires a side parameter, "buy" or "sell"');s=this.omit(s,"side");const n="privatePostMy"+this.capitalize(i)+"Cancel",r={id:e};return await this[n](this.extend(r,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urls.api[t]+"/"+e;if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.json(this.extend({nonce:o},i)),n={"Content-Type":"application/json",key:this.apiKey,sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}};const kR=re,{AuthenticationError:SR,ArgumentsRequired:Fc,ExchangeError:Bl,InsufficientFunds:vR,DDoSProtection:TR,InvalidNonce:OR,PermissionDenied:Nl,BadRequest:Us,BadSymbol:IR,NotSupported:Xw,AccountNotEnabled:xR,OnMaintenance:_R,InvalidOrder:Ui}=Q,{TICK_SIZE:CR}=ne,Yw=ae;var TT=class extends kR{describe(){return this.deepExtend(super.describe(),{id:"cryptocom",name:"Crypto.com",countries:["MT"],version:"v2",rateLimit:10,pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:void 0,future:void 0,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawals:!0,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",test:{v1:"https://uat-api.3ona.co/exchange/v1",v2:"https://uat-api.3ona.co/v2",derivatives:"https://uat-api.3ona.co/v2"},api:{v1:"https://api.crypto.com/exchange/v1",v2:"https://api.crypto.com/v2",derivatives:"https://deriv-api.crypto.com/v1"},www:"https://crypto.com/",referral:"https://crypto.com/exch/5835vstech",doc:["https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html","https://exchange-docs.crypto.com/spot/index.html","https://exchange-docs.crypto.com/derivatives/index.html"],fees:"https://crypto.com/exchange/document/fees-limits"},api:{v1:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/create-order-list":10/3,"private/cancel-order":2/3,"private/cancel-order-list":10/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3,"private/create-subaccount-transfer":10/3,"private/get-subaccount-balances":10/3,"private/get-order-list":10/3,"private/create-withdrawal":10/3,"private/get-currency-networks":10/3,"private/get-deposit-address":10/3,"private/get-accounts":10/3}}},v2:{public:{get:{"public/auth":1,"public/get-instruments":1,"public/get-book":1,"public/get-candlestick":1,"public/get-ticker":1,"public/get-trades":1,"public/margin/get-transfer-currencies":1,"public/margin/get-load-currenices":1,"public/respond-heartbeat":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/create-withdrawal":10/3,"private/get-withdrawal-history":10/3,"private/get-currency-networks":10/3,"private/get-deposit-history":10/3,"private/get-deposit-address":10/3,"private/get-account-summary":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/create-order-list":10/3,"private/get-order-history":10/3,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/margin/get-user-config":10/3,"private/margin/get-account-summary":10/3,"private/margin/transfer":10/3,"private/margin/borrow":10/3,"private/margin/repay":10/3,"private/margin/get-transfer-history":10/3,"private/margin/get-borrow-history":10/3,"private/margin/get-interest-history":10/3,"private/margin/get-repay-history":10/3,"private/margin/get-liquidation-history":10/3,"private/margin/get-liquidation-orders":10/3,"private/margin/create-order":2/3,"private/margin/cancel-order":2/3,"private/margin/cancel-all-orders":2/3,"private/margin/get-order-history":10/3,"private/margin/get-open-orders":10/3,"private/margin/get-order-detail":1/3,"private/margin/get-trades":100,"private/deriv/transfer":10/3,"private/deriv/get-transfer-history":10/3,"private/get-accounts":10/3,"private/get-subaccount-balances":10/3,"private/create-subaccount-transfer":10/3,"private/otc/get-otc-user":10/3,"private/otc/get-instruments":10/3,"private/otc/request-quote":100,"private/otc/accept-quote":100,"private/otc/get-quote-history":10/3,"private/otc/get-trade-history":10/3}}},derivatives:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/create-order-list":10/3,"private/cancel-order":2/3,"private/cancel-order-list":10/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/convert-collateral":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3,"private/create-subaccount-transfer":10/3,"private/get-subaccount-balances":10/3,"private/get-order-list":10/3}}}},fees:{trading:{maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("250000"),this.parseNumber("0.0009")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("20000000"),this.parseNumber("0.0007")],[this.parseNumber("100000000"),this.parseNumber("0.0006")],[this.parseNumber("200000000"),this.parseNumber("0.0004")]],taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0016")],[this.parseNumber("250000"),this.parseNumber("0.00015")],[this.parseNumber("1000000"),this.parseNumber("0.00014")],[this.parseNumber("20000000"),this.parseNumber("0.00013")],[this.parseNumber("100000000"),this.parseNumber("0.00012")],[this.parseNumber("200000000"),this.parseNumber("0.0001")]]}}},options:{defaultType:"spot",accountsById:{funding:"SPOT",spot:"SPOT",margin:"MARGIN",derivatives:"DERIVATIVES",swap:"DERIVATIVES",future:"DERIVATIVES"}},commonCurrencies:{USD_STABLE_COIN:"USDC"},precisionMode:CR,exceptions:{exact:{10001:Bl,10002:Nl,10003:Nl,10004:Us,10005:Nl,10006:TR,10007:OR,10008:Us,10009:Us,20001:Us,20002:vR,20005:xR,30003:IR,30004:Us,30005:Us,30006:Ui,30007:Ui,30008:Ui,30009:Ui,30010:Us,30013:Ui,30014:Ui,30016:Ui,30017:Ui,30023:Ui,30024:Ui,30025:Ui,40001:Us,40002:Us,40003:Us,40004:Us,40005:Us,40006:Us,40007:Us,40101:SR,50001:Us,9010001:_R}}})}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchDerivativesMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1];return this.arrayConcat(s,i)}async fetchSpotMarkets(e={}){const t=await this.v2PublicGetPublicGetInstruments(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"instruments",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_name"),d=this.safeString(a,"base_currency"),c=this.safeString(a,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeString(a,"min_price"),l=this.safeString(a,"min_quantity");let m=this.parseNumber("1");this.safeValue(a,"margin_trading_enabled_5x")&&(m=this.parseNumber("5")),this.safeValue(a,"margin_trading_enabled_10x")&&(m=this.parseNumber("10")),n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(a,"margin_trading_enabled"),swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantity_tick_size"),price:this.safeNumber(a,"price_tick_size")},limits:{leverage:{min:this.parseNumber("1"),max:m},amount:{min:this.parseNumber(l),max:this.safeNumber(a,"max_quantity")},price:{min:this.parseNumber(f),max:this.safeNumber(a,"max_price")},cost:{min:this.parseNumber(Yw.stringMul(l,f)),max:void 0}},info:a})}return n}async fetchDerivativesMarkets(e={}){const t=[],s=await this.derivativesPublicGetPublicGetInstruments(),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"inst_type"),d=o==="PERPETUAL_SWAP",c=o==="FUTURE";if(o==="CCY_PAIR")continue;const u=this.safeString(a,"base_ccy"),h=this.safeString(a,"quote_ccy"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h);let m=f+"/"+l+":"+l,g=this.safeInteger(a,"expiry_timestamp_ms");g===0&&(g=void 0);let y="swap";c&&(y="future",m=m+"-"+this.yymmdd(g));const w=this.safeNumber(a,"contract_size");t.push({id:this.safeString(a,"symbol"),symbol:m,base:f,quote:l,settle:l,baseId:u,quoteId:h,settleId:h,type:y,spot:!1,margin:!1,swap:d,future:c,option:!1,active:this.safeValue(a,"tradable"),contract:!0,linear:!0,inverse:!1,contractSize:w,expiry:g,expiryDatetime:this.iso8601(g),strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(a,"quote_decimals"))),amount:this.parseNumber(this.parsePrecision(this.safeString(a,"quantity_decimals")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_leverage")},amount:{min:this.parseNumber(w),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return t}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const c=this.safeValue(e,0);s=this.market(c)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),r=this.getSupportedMapping(i,{spot:"v2PublicGetPublicGetTicker",future:"derivativesPublicGetPublicGetTickers",swap:"derivativesPublicGetPublicGetTickers"}),a=await this[r](n),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t);if(n!=="spot")throw new Xw(this.id+" fetchTicker() only supports spot markets");const a=await this.v2PublicGetPublicGetTicker(this.extend(i,r)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",{}),c=this.safeValue(d,0,{});return this.parseTicker(c,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Fc(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",n,i);let d=this.getSupportedMapping(a,{spot:"v2PrivatePostPrivateGetOrderHistory",margin:"v2PrivatePostPrivateMarginGetOrderHistory",future:"derivativesPrivatePostPrivateGetOrderHistory",swap:"derivativesPrivatePostPrivateGetOrderHistory"});const[c,u]=this.customHandleMarginModeAndParams("fetchOrders",o);c!==void 0&&(d="v2PrivatePostPrivateMarginGetOrderHistory");const h=await this[d](this.extend(r,u)),f=this.safeValue(h,"result",{}),l=this.safeValue2(f,"order_list","data",[]);return this.parseOrders(l,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"v2PublicGetPublicGetTrades",future:"derivativesPublicGetPublicGetTrades",swap:"derivativesPublicGetPublicGetTrades"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"data",[]);return this.parseTrades(h,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,timeframe:this.timeframes[t]},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"v2PublicGetPublicGetCandlestick",future:"derivativesPublicGetPublicGetCandlestick",swap:"derivativesPublicGetPublicGetCandlestick"});if(o!=="spot"){let l=100;i!==void 0&&(l=i),a.count=l}const u=await this[c](this.extend(a,d)),h=this.safeValue(u,"result",{}),f=this.safeValue(h,"data",[]);return this.parseOHLCVs(f,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t&&(n.depth=t);const[r,a]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),o=this.getSupportedMapping(r,{spot:"v2PublicGetPublicGetBook",future:"derivativesPublicGetPublicGetBook",swap:"derivativesPublicGetPublicGetBook"}),d=await this[o](this.extend(n,a)),c=this.safeValue(d,"result"),u=this.safeValue(c,"data"),h=this.safeValue(u,0),f=this.safeInteger(h,"t");return this.parseOrderBook(h,e,f)}parseSwapBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"data",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"total_cash_balance"),d.free=this.safeString(r,"total_available_balance"),i[o]=d}return this.safeBalance(i)}parseSpotBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.free=this.safeString(r,"available"),d.used=this.safeString(r,"order"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i=this.getSupportedMapping(t,{spot:"v2PrivatePostPrivateGetAccountSummary",margin:"v2PrivatePostPrivateMarginGetAccountSummary",future:"derivativesPrivatePostPrivateUserBalance",swap:"derivativesPrivatePostPrivateUserBalance"});const[n,r]=this.customHandleMarginModeAndParams("fetchBalance",s);n!==void 0&&(i="v2PrivatePostPrivateMarginGetAccountSummary");const a=await this[i](r),o=this.getSupportedMapping(t,{spot:"parseSpotBalance",margin:"parseSpotBalance",future:"parseSwapBalance",swap:"parseSwapBalance"});return this[o](a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("fetchOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("fetchOrder",a);r==="spot"||r==="margin"||o!==void 0?n.order_id=e.toString():n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"v2PrivatePostPrivateGetOrderDetail",margin:"v2PrivatePostPrivateMarginGetOrderDetail",future:"derivativesPrivatePostPrivateGetOrderDetail",swap:"derivativesPrivatePostPrivateGetOrderDetail"});o!==void 0&&(c="v2PrivatePostPrivateMarginGetOrderDetail");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",{}),f=this.safeValue(h,"order_info",h);return this.parseOrder(f,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_name:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)};(o==="LIMIT"||o==="STOP_LIMIT")&&(d.price=this.priceToPrecision(e,n)),this.safeValue(r,"postOnly",!1)&&(d.exec_inst="POST_ONLY",r=this.omit(r,["postOnly"]));const[u,h]=this.handleMarketTypeAndParams("createOrder",a,r);let f=this.getSupportedMapping(u,{spot:"v2PrivatePostPrivateCreateOrder",margin:"v2PrivatePostPrivateMarginCreateOrder",future:"derivativesPrivatePostPrivateCreateOrder",swap:"derivativesPrivatePostPrivateCreateOrder"});const[l,m]=this.customHandleMarginModeAndParams("createOrder",h);l!==void 0&&(f="v2PrivatePostPrivateMarginCreateOrder");const g=await this[f](this.extend(d,m)),y=this.safeValue(g,"result",{});return this.parseOrder(y,a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={},[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=this.customHandleMarginModeAndParams("cancelAllOrders",r);if(n==="spot"||n==="margin"||a!==void 0){if(e===void 0)throw new Fc(this.id+" cancelAllOrders() requires a symbol argument for "+n+" orders");i.instrument_name=s.id}let d=this.getSupportedMapping(n,{spot:"v2PrivatePostPrivateCancelAllOrders",margin:"v2PrivatePostPrivateMarginCancelAllOrders",future:"derivativesPrivatePostPrivateCancelAllOrders",swap:"derivativesPrivatePostPrivateCancelAllOrders"});return a!==void 0&&(d="v2PrivatePostPrivateMarginCancelAllOrders"),await this[d](this.extend(i,o))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("cancelOrder",a);if(r==="spot"||r==="margin"||o!==void 0){if(t===void 0)throw new Fc(this.id+" cancelOrder() requires a symbol argument for "+r+" orders");n.instrument_name=i.id,n.order_id=e.toString()}else n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"v2PrivatePostPrivateCancelOrder",margin:"v2PrivatePostPrivateMarginCancelOrder",future:"derivativesPrivatePostPrivateCancelOrder",swap:"derivativesPrivatePostPrivateCancelOrder"});o!==void 0&&(c="v2PrivatePostPrivateMarginCancelOrder");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",u);return this.parseOrder(h)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument_name=n.id),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let d=this.getSupportedMapping(a,{spot:"v2PrivatePostPrivateGetOpenOrders",margin:"v2PrivatePostPrivateMarginGetOpenOrders",future:"derivativesPrivatePostPrivateGetOpenOrders",swap:"derivativesPrivatePostPrivateGetOpenOrders"});const[c,u]=this.customHandleMarginModeAndParams("fetchOpenOrders",o);c!==void 0&&(d="v2PrivatePostPrivateMarginGetOpenOrders");const h=await this[d](this.extend(r,u)),f=this.safeValue(h,"result",{}),l=this.safeValue2(f,"order_list","data",[]);return this.parseOrders(l,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_name=r.id),t!==void 0){n.start_ts=t;const m=this.sum(t,24*60*60*1e3);n.end_ts=m}s!==void 0&&(n.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);let d=this.getSupportedMapping(a,{spot:"v2PrivatePostPrivateGetTrades",margin:"v2PrivatePostPrivateMarginGetTrades",future:"derivativesPrivatePostPrivateGetTrades",swap:"derivativesPrivatePostPrivateGetTrades"});const[c,u]=this.customHandleMarginModeAndParams("fetchMyTrades",o);c!==void 0&&(d="v2PrivatePostPrivateMarginGetTrades");const h=await this[d](this.extend(n,u)),f=this.safeValue(h,"result",{}),l=this.safeValue2(f,"trade_list","data",[]);return this.parseTrades(l,r,t,s)}parseAddress(e){let t,s,i;return e.indexOf("?")>0?([t,i]=e.split("?"),s=i.split("=")[1]):t=e,[t,s]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.address_tag=i);const o=await this.v2PrivatePostPrivateCreateWithdrawal(this.extend(a,n)),d=this.safeValue(o,"result");return this.parseTransaction(d,r)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.v2PrivatePostPrivateGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"deposit_address_list",[]);if(a.length===0)throw new Bl(this.id+" fetchDepositAddressesByNetwork() generating address...");const o={};for(let d=0;d<a.length;d++){const c=this.safeValue(a,d),u=this.safeString(c,"address"),h=this.safeString(c,"currency"),f=this.safeCurrencyCode(h),[l,m]=this.parseAddress(u);this.checkAddress(l);const g=this.safeString(c,"network"),y=this.safeNetwork(g);o[y]={info:c,currency:f,address:l,tag:m,network:y}}return o}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);if(s in i)return i[s];{const n=Object.keys(i);return i[n[0]]}}safeNetwork(e){const t={BTC:"BTC",ETH:"ETH",SOL:"SOL",BNB:"BNB",CRONOS:"CRONOS",MATIC:"MATIC",OP:"OP"};return this.safeString(t,e,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.v2PrivatePostPrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"deposit_list",[]);return this.parseTransactions(d,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.v2PrivatePostPrivateGetWithdrawalHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"withdrawal_list",[]);return this.parseTransactions(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);s=s.toLowerCase(),i=i.toLowerCase();const a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:parseFloat(t),from:o,to:d};let u="v2PrivatePostPrivateDerivTransfer";(s==="margin"||i==="margin")&&(u="v2PrivatePostPrivateMarginTransfer");const h=await this[u](this.extend(c,n));return this.parseTransfer(h,r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(!("direction"in i))throw new Fc(this.id+' fetchTransfers() requires a direction param to be either "IN" or "OUT"');await this.loadMarkets();let n;const r={direction:"OUT"};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);let a="v2PrivatePostPrivateDerivGetTransferHistory";const[o,d]=this.customHandleMarginModeAndParams("fetchTransfers",i);o!==void 0&&(a="v2PrivatePostPrivateMarginGetTransferHistory");const c=await this[a](this.extend(r,d)),u=[];return u.push({response:c}),this.parseTransfers(u,n,t,s,i)}parseTransferStatus(e){const t={COMPLETED:"ok",PROCESSING:"pending"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"response",{}),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"transfer_list",[]);let r,a,o,d,c;for(let f=0;f<n.length;f++){const l=n[f];r=this.safeInteger(l,"time"),a=this.safeNumber(l,"amount");const m=this.safeString(l,"currency");o=this.safeCurrencyCode(m),d=this.safeString(l,"information");const g=this.safeString(l,"status");c=this.parseTransferStatus(g)}let u,h;if(d!==void 0){const f=d.split(" "),l=this.safeStringLower(f,0),m=this.safeString(s,"method");l==="from"?(u=this.safeStringLower(f,1),m==="private/margin/get-transfer-history"?h="margin":h="derivative"):l==="to"&&(h=this.safeStringLower(f,1),m==="private/margin/get-transfer-history"?u="margin":u="derivative")}return{info:n,id:this.safeString(s,"id"),timestamp:r,datetime:this.iso8601(r),currency:o,amount:a,fromAccount:u,toAccount:h,status:c}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"i");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"a"),a=this.safeString(e,"c");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"b"),bidVolume:void 0,ask:this.safeString(e,"k"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"t","create_time"),i=this.safeString2(e,"i","instrument_name");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"p","traded_price"),a=this.safeString2(e,"q","traded_quantity");let o=this.safeString2(e,"s","side");o!==void 0&&(o=o.toLowerCase());const d=this.safeString2(e,"d","trade_id"),c=this.safeStringLower2(e,"liquidity_indicator","taker_side"),u=this.safeString(e,"order_id");let h,f=this.safeString2(e,"fee","fees");if(f!==void 0){this.safeValue(t,"contract",!1)&&(f=Yw.stringNeg(f));let m;t.spot?m=this.safeString(e,"fee_currency"):t.linear&&(m=t.quote),h={currency:m,cost:f}}return this.safeTrade({info:e,id:d,timestamp:s,datetime:this.iso8601(s),symbol:n,side:o,price:r,amount:a,cost:void 0,order:u,takerOrMaker:c,type:void 0,fee:h},t)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",FILLED:"closed",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GOOD_TILL_CANCEL:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"create_time"),i=this.safeInteger(e,"update_time"),n=this.safeString(e,"instrument_name"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"cumulative_quantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"order_id"),u=this.safeString(e,"client_oid"),h=this.safeString2(e,"price","limit_price"),f=this.safeString(e,"avg_price"),l=this.safeStringLower2(e,"type","order_type"),m=this.safeStringLower(e,"side"),g=this.parseTimeInForce(this.safeString(e,"time_in_force")),y=this.safeString(e,"exec_inst");let w;y!==void 0&&(w=y==="POST_ONLY");const b=this.safeString(e,"cumulative_value"),S=this.safeString(e,"cumulative_fee");let v;if(S!==void 0){const T=this.safeString(e,"fee_instrument_name");v={cost:S,currency:this.safeCurrencyCode(T)}}return this.safeOrder({info:e,id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:l,timeInForce:g,postOnly:w,side:m,price:h,amount:a,filled:o,remaining:void 0,cost:b,fee:v,average:f,trades:[]},t)}parseDepositStatus(e){const t={0:"pending",1:"ok",2:"failed",3:"pending"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={0:"pending",1:"pending",2:"failed",3:"pending",4:"failed",5:"ok",6:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"status");let n;"client_wid"in e?(s="withdrawal",n=this.parseWithdrawalStatus(i)):(s="deposit",n=this.parseDepositStatus(i));const r=this.safeString(e,"id"),a=this.safeString(e,"address"),[o,d]=this.parseAddress(a),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeInteger(e,"create_time"),f=this.safeNumber(e,"amount"),l=this.safeString(e,"txid"),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={currency:u,cost:m});const y=this.safeInteger(e,"update_time");return{info:e,id:r,txid:l,timestamp:h,datetime:this.iso8601(h),network:void 0,address:o,addressTo:o,addressFrom:void 0,tag:d,tagTo:d,tagFrom:void 0,type:s,amount:f,currency:u,status:n,updated:y,internal:void 0,fee:g}}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.v2PrivatePostPrivateMarginRepay(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.v2PrivatePostPrivateMarginBorrow(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a,o;t!==void 0&&(a=this.market(t)),e!==void 0&&(o=this.currency(e),r.currency=o.id),s!==void 0&&(r.start_ts=s),i!==void 0&&(r.page_size=i);const d=await this.v2PrivatePostPrivateMarginGetInterestHistory(this.extend(r,n)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"list",[]);let h;for(let f=0;f<u.length;f++)h=this.parseBorrowInterests(u,a);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeInteger(e,"time");let i;return t!==void 0&&(i=t.symbol),{symbol:i,marginMode:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interest_rate"),amountBorrowed:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.v2PrivatePostPrivateMarginGetUserConfig(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"currency_configs",[]);return this.parseBorrowRates(i,"currency")}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n];i.push({currency:this.safeCurrencyCode(this.safeString(r,"currency")),rate:this.safeNumber(r,"hourly_rate"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}customHandleMarginModeAndParams(e,t={}){const s=this.safeString(this.options,"defaultType"),i=this.safeValue(t,"margin",!1);t=this.omit(t,"margin");let n;if([n,t]=this.handleMarginModeAndParams(e,t),n!==void 0){if(n!=="cross")throw new Xw(this.id+" only cross margin is supported")}else(s==="margin"||i===!0)&&(n="cross");return[n,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+e;const c=this.omit(i,this.extractParams(e));if(o==="public")Object.keys(c).length&&(d+="?"+this.urlencode(c));else{this.checkRequiredCredentials();const u=this.nonce().toString(),h=this.extend({},i),f=this.keysort(h),l=Object.keys(f);let m="";for(let b=0;b<l.length;b++)m=m+l[b].toString()+h[l[b]].toString();const g=e+u+this.apiKey+m+u,y=this.hmac(this.encode(g),this.encode(this.secret)),w=l.length;if(r=this.json({id:u,method:e,params:i,api_key:this.apiKey,sig:y,nonce:u}),w===0){const b="{}",S="[]";r=r.replace(S,b)}n={"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new Bl(this.id+" "+r)}}};const MR=re,{BadSymbol:PR,ExchangeError:Hc,ArgumentsRequired:Vl,ExchangeNotAvailable:El,InsufficientFunds:AR,OrderNotFound:Zw,InvalidOrder:Xn,DDoSProtection:BR,InvalidNonce:NR,AuthenticationError:Zo,BadRequest:ql}=Q,{TICK_SIZE:VR}=ne,_n=ae;var OT=class extends MR{describe(){return this.deepExtend(super.describe(),{id:"currencycom",name:"Currency.com",countries:["BY"],rateLimit:100,certified:!1,pro:!0,version:"v2",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:"emulated",fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLedger:!0,fetchLedgerEntry:!1,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:!0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},hostname:"backend.currency.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg",api:{public:"https://api-adapter.{hostname}/api",private:"https://api-adapter.{hostname}/api",marketcap:"https://marketcap.{hostname}/api"},test:{public:"https://demo-api-adapter.{hostname}/api",private:"https://demo-api-adapter.{hostname}/api"},www:"https://www.currency.com",referral:"https://currency.com/trading/signup?c=362jaimv&pid=referral",doc:["https://currency.com/api"],fees:"https://currency.com/fees-charges"},api:{public:{get:{"v1/time":1,"v1/exchangeInfo":1,"v1/depth":1,"v1/aggTrades":1,"v1/klines":1,"v1/ticker/24hr":1,"v2/time":1,"v2/exchangeInfo":1,"v2/depth":1,"v2/aggTrades":1,"v2/klines":1,"v2/ticker/24hr":1}},marketcap:{get:{"v1/assets":1,"v1/candles":1,"v1/orderbook":1,"v1/summary":1,"v1/ticker":1,"v1/token/assets":1,"v1/token/orderbook":1,"v1/token/summary":1,"v1/token/ticker":1,"v1/token/trades":1,"v1/token_crypto/OHLC":1,"v1/token_crypto/assets":1,"v1/token_crypto/orderbook":1,"v1/token_crypto/summary":1,"v1/token_crypto/ticker":1,"v1/token_crypto/trades":1,"v1/trades":1}},private:{get:{"v1/account":1,"v1/currencies":1,"v1/deposits":1,"v1/depositAddress":1,"v1/ledger":1,"v1/leverageSettings":1,"v1/myTrades":1,"v1/openOrders":1,"v1/tradingPositions":1,"v1/tradingPositionsHistory":1,"v1/transactions":1,"v1/withdrawals":1,"v2/account":1,"v2/currencies":1,"v2/deposits":1,"v2/depositAddress":1,"v2/ledger":1,"v2/leverageSettings":1,"v2/myTrades":1,"v2/openOrders":1,"v2/tradingPositions":1,"v2/tradingPositionsHistory":1,"v2/transactions":1,"v2/withdrawals":1},post:{"v1/order":1,"v1/updateTradingPosition":1,"v1/updateTradingOrder":1,"v1/closeTradingPosition":1,"v2/order":1,"v2/updateTradingPosition":1,"v2/updateTradingOrder":1,"v2/closeTradingPosition":1},delete:{"v1/order":1,"v2/order":1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:VR,options:{defaultTimeInForce:"GTC",warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"RESULT",stop:"RESULT"},leverage_markets_suffix:"_LEVERAGE",collateralCurrencies:["USD","EUR","USDT"]},exceptions:{broad:{"FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order":Xn,"API key does not exist":Zo,"Order would trigger immediately.":Xn,"Account has insufficient balance for requested action.":AR,"Rest API trading is not enabled.":El,"Combination of parameters invalid":ql,"Invalid limit price":ql,"Only leverage symbol allowed here:":PR,"market data service is not available":El,"your time is ahead of server":NR},exact:{"-1000":El,"-1013":Xn,"-1022":Zo,"-1030":Xn,"-1100":Xn,"-1104":Hc,"-1025":Zo,"-1128":ql,"-2010":Hc,"-2011":Zw,"-2013":Zw,"-2014":Zo,"-2015":Zo}},commonCurrencies:{ACN:"Accenture",AMC:"AMC Entertainment Holdings",BNS:"Bank of Nova Scotia",CAR:"Avis Budget Group Inc",CLR:"Continental Resources",EDU:"New Oriental Education & Technology Group Inc",ETN:"Eaton",FOX:"Fox Corporation",GM:"General Motors Co",IQ:"iQIYI",OSK:"Oshkosh",PLAY:"Dave & Buster's Entertainment"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV2Time(e);return this.safeInteger(t,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetV2Currencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"displaySymbol"),a=this.safeCurrencyCode(r),o=this.safeNumber(n,"commissionFixed");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),type:this.safeStringLower(n,"type"),name:this.safeString(n,"name"),active:void 0,deposit:void 0,withdraw:void 0,fee:o,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"minWithdrawal"),max:this.safeNumber(n,"maxWithdrawal")},deposit:{min:this.safeNumber(n,"minDeposit"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const t=await this.publicGetV2ExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);let h=c+"/"+u;const f=this.safeString(r,"marketType"),l=f==="SPOT",m=!1,g=f==="LEVERAGE",y=g;g&&(h=h.replace(this.options.leverage_markets_suffix,""),h+=":"+u);const w=this.safeString(r,"status")==="TRADING",b=this.safeString2(r,"exchangeFee","tradingFee");let S=this.safeString(r,"makerFee",b),v=this.safeString(r,"takerFee",b);S=_n.stringDiv(S,"100"),v=_n.stringDiv(v,"100");const T=this.safeValue(r,"filters",[]),I=this.indexBy(T,"filterType");let A,N,B=this.safeNumber(r,"tickSize");if("PRICE_FILTER"in I){const L=this.safeValue(I,"PRICE_FILTER",{});B=this.safeNumber(L,"tickSize"),A=this.safeNumber(L,"minPrice");const D=this.safeString(L,"maxPrice");D!==void 0&&_n.stringGt(D,"0")&&(N=D)}let x=this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),k={min:void 0,max:void 0};if("LOT_SIZE"in I){const L=this.safeValue(I,"LOT_SIZE",{});x=this.safeNumber(L,"stepSize"),k={min:this.safeNumber(L,"minQty"),max:this.safeNumber(L,"maxQty")}}let O={min:void 0,max:void 0};if("MARKET_LOT_SIZE"in I){const L=this.safeValue(I,"MARKET_LOT_SIZE",{});O={min:this.safeNumber(L,"minQty"),max:this.safeNumber(L,"maxQty")}}let P;if("MIN_NOTIONAL"in I){const L=this.safeValue(I,"MIN_NOTIONAL",{});P=this.safeNumber(L,"minNotional")}const q=g||m;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:f,spot:l,margin:y,swap:g,future:m,option:!1,active:w,contract:q,linear:q?!0:void 0,inverse:void 0,taker:this.parseNumber(v),maker:this.parseNumber(S),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:x,price:B},limits:{leverage:{min:void 0,max:void 0},amount:k,market:O,price:{min:A,max:this.parseNumber(N)},cost:{min:P,max:void 0}},info:r})}return i}async fetchAccounts(e={}){const t=await this.privateGetV2Account(e),s=this.safeValue(t,"balances",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeInteger(r,"accountId"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e),s=this.safeNumber(t,"makerCommission"),i=this.safeNumber(t,"takerCommission"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!1}}return n}parseBalance(e,t=void 0){const s={info:e},i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetV2Depth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"closeTime","timestamp"),i=this.safeString2(e,"symbol","symbolName");t=this.safeMarket(i,t,"/");const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString2(e,"bidPrice","bid"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString2(e,"askPrice","ofr"),askVolume:this.safeString(e,"ofrQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:n,last:n,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2Ticker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV2Ticker24hr(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetV2Klines(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"a","id");let a;const o=this.safeString(e,"orderId");let d;"m"in e?(a=e.m?"sell":"buy",d="taker"):"isBuyer"in e&&(a=e.isBuyer?"buy":"sell",d=e.isMaker?"maker":"taker");let c;"commission"in e&&(c={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))});const u=this.safeString(e,"symbol"),h=this.safeSymbol(u,t);return this.safeTrade({id:r,order:o,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,takerOrMaker:d,side:a,price:i,amount:n,cost:void 0,fee:c,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.startTime=t);const a=await this.publicGetV2AggTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"/"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=this.safeString(e,"origQty"),o=this.safeString(e,"executedQty"),d=_n.stringAbs(o),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),h=this.parseOrderType(this.safeString(e,"type")),f=this.parseOrderSide(this.safeString(e,"side")),l=this.safeInteger2(e,"time","transactTime"),m=this.safeValue(e,"fills");return this.safeOrder({info:e,id:n,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:i,type:h,timeInForce:u,side:f,price:r,stopPrice:void 0,triggerPrice:void 0,amount:a,cost:void 0,average:void 0,filled:d,remaining:void 0,status:c,fee:void 0,trades:m},t)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",STOP:"stop"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;if(a.margin&&(o=this.safeString(this.options,"accountId"),o=this.safeString(r,"accountId",o),o===void 0))throw new Vl(this.id+" createOrder() requires an accountId parameter or an exchange.options['accountId'] option for "+a.type+" markets");const d=this.safeValue(this.options.newOrderRespType,t,"RESULT"),c={symbol:a.id,quantity:this.amountToPrecision(e,i),type:t.toUpperCase(),side:s.toUpperCase(),newOrderRespType:d};if(t==="limit")c.price=this.priceToPrecision(e,n),c.timeInForce=this.options.defaultTimeInForce;else if(t==="stop")c.type="STOP",c.price=this.priceToPrecision(e,n);else if(t==="market"){const h=this.safeValue2(r,"triggerPrice","stopPrice");r=this.omit(r,["triggerPrice","stopPrice"]),h!==void 0&&(c.type="STOP",c.price=this.priceToPrecision(e,h))}const u=await this.privatePostV2Order(this.extend(c,r));return this.parseOrder(u,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};if(e!==void 0)n=this.market(e),r.symbol=n.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const d=this.symbols.length,c=parseInt(d/2);throw new Hc(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+c.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}const a=await this.privateGetV2OpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,i)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Vl(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"origClientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=await this.privateDeleteV2Order(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Vl(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetV2MyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Deposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Withdrawals",e,t,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Transactions",e,t,s,i)}async fetchTransactionsByMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.currency(t)),s!==void 0&&(r.startTime=s),i!==void 0&&(r.limit=i);const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeString(e,"commission"),a={currency:void 0,cost:void 0,rate:void 0};return r!==void 0&&(a.currency=n,a.cost=r),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"blockchainTransactionHash"),type:this.parseTransactionType(this.safeString(e,"type")),currency:n,network:void 0,amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"state")),timestamp:s,datetime:this.iso8601(s),address:void 0,addressFrom:void 0,addressTo:void 0,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:void 0,comment:void 0,fee:a}}parseTransactionStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={deposit:"deposit",withdrawal:"withdrawal"};return this.safeString(t,e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e)),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetV2Ledger(this.extend(n,i));return this.parseLedger(a,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=_n.stringAbs(i),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"commission");let c;d!==void 0&&(c={currency:o,cost:d});const u=_n.stringLt(i,"0")?"out":"in";return{id:s,timestamp:r,datetime:this.iso8601(r),direction:u,account:void 0,referenceId:this.safeString(e,"blockchainTransactionHash"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:o,amount:n,before:void 0,after:this.safeString(e,"balance"),status:this.parseLedgerEntryStatus(this.safeString(e,"status")),fee:c,info:e}}parseLedgerEntryStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={deposit:"transaction",withdrawal:"transaction",exchange_commission:"fee"};return this.safeString(t,e,e)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetV2LeverageSettings(this.extend(i,t));return this.safeNumber(n,"value")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetV2DepositAddress(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),t=this.safeCurrency(void 0,t),{currency:t.code,address:s,tag:void 0,network:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(e==="historicalTrades"&&(n={"X-MBX-APIKEY":this.apiKey}),t==="private"){this.checkRequiredCredentials();let o=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},i));const d=this.hmac(this.encode(o),this.encode(this.secret));o+="&signature="+d,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?a+="?"+o:(r=o,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeHostname(a),{url:a,method:s,body:r,headers:n}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetV2TradingPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeNumber(e,"createdTimestamp"),n=this.safeString(e,"openQuantity"),r=_n.stringGt(n,"0")?"long":"short",a=_n.stringAbs(n),o=this.safeNumber(e,"openPrice"),d=this.safeNumber(e,"upl"),c=this.safeString(e,"margin"),u=_n.stringDiv("1",c);return{symbol:s,timestamp:i,datetime:this.iso8601(i),contracts:this.parseNumber(a),contractSize:void 0,entryPrice:o,collateral:void 0,side:r,unrealizedProfit:d,leverage:u,percentage:void 0,marginMode:void 0,notional:void 0,markPrice:void 0,liquidationPrice:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(c),maintenanceMarginPercentage:void 0,marginRatio:void 0,info:e,id:void 0}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new BR(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Xn(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Xn(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Xn(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0&&c!=="0"){const u=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,c,u);const h=this.safeString(a,"msg");throw this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new Hc(u)}}};const ER=re,{ExchangeError:qR,InsufficientFunds:LR,BadRequest:Qw,BadSymbol:RR,InvalidOrder:Qo,AuthenticationError:Jw,ArgumentsRequired:eb,OrderNotFound:DR,ExchangeNotAvailable:FR}=Q,{TICK_SIZE:HR}=ne,tb=ae;var GR=class extends ER{describe(){return this.deepExtend(super.describe(),{id:"delta",name:"Delta Exchange",countries:["VC"],rateLimit:300,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransfer:void 0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","1d":"1d","7d":"7d","1w":"1w","2w":"2w","1M":"30d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.delta.exchange",private:"https://api.delta.exchange"},www:"https://www.delta.exchange",doc:["https://docs.delta.exchange"],fees:"https://www.delta.exchange/fees",referral:"https://www.delta.exchange/app/signup/?code=IULYNB"},api:{public:{get:["assets","settings","indices","products","tickers","tickers/{symbol}","l2orderbook/{symbol}","trades/{symbol}","history/candles","history/sparklines"]},private:{get:["orders","orders/leverage","positions","positions/margined","orders/history","fills","fills/history/download/csv","wallet/balances","wallet/transactions","wallet/transactions/download","deposits/address"],post:["orders","orders/batch","orders/leverage","positions/change_margin"],put:["orders","orders/batch"],delete:["orders","orders/all","orders/batch"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.15/100,maker:.1/100,tiers:{taker:[[0,.15/100],[100,.13/100],[250,.13/100],[1e3,.1/100],[5e3,.09/100],[1e4,.075/100],[2e4,.065/100]],maker:[[0,.1/100],[100,.1/100],[250,.09/100],[1e3,.075/100],[5e3,.06/100],[1e4,.05/100],[2e4,.05/100]]}}},options:{networks:{TRC20:"TRC20(TRON)",TRX:"TRC20(TRON)",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},networksById:{"BEP20(BSC)":"BSC","TRC20(TRON)":"TRC20"}},precisionMode:HR,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{insufficient_margin:LR,order_size_exceed_available:Qo,risk_limits_breached:Qw,invalid_contract:RR,immediate_liquidation:Qo,out_of_bankruptcy:Qo,self_matching_disrupted_post_only:Qo,immediate_execution_post_only:Qo,bad_schema:Qw,invalid_api_key:Jw,invalid_signature:Jw,open_order_not_found:DR,unavailable:FR},broad:{}}})}async fetchTime(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{});return this.safeIntegerProduct(s,"server_time",.001)}async fetchStatus(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{}),n=this.safeString(s,"under_maintenance")==="true"?"maintenance":"ok",r=this.safeIntegerProduct(s,"server_time",.001,this.milliseconds());return{status:n,updated:r,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(a),c=this.safeString(r,"deposit_status"),u=this.safeString(r,"withdrawal_status"),h=c==="enabled",f=u==="enabled",l=h&&f;i[d]={id:a,numericId:o,code:d,name:this.safeString(r,"name"),info:r,active:l,deposit:h,withdraw:f,fee:this.safeNumber(r,"base_withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"min_withdrawal_amount"),max:void 0}}}}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),(this.safeValue(this.options,"marketsByNumericId")===void 0||e)&&(this.options.marketsByNumericId=this.indexBy(this.markets,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"contract_type");const o=this.safeValue(r,"quoting_asset",{}),d=this.safeValue(r,"underlying_asset",{}),c=this.safeValue(r,"settling_asset"),u=this.safeValue(r,"product_specs",{}),h=this.safeString(d,"symbol"),f=this.safeString(o,"symbol"),l=this.safeString(c,"symbol"),m=this.safeString(r,"symbol"),g=this.safeInteger(r,"id"),y=this.safeCurrencyCode(h),w=this.safeCurrencyCode(f),b=this.safeCurrencyCode(l),S=a==="call_options",v=a==="put_options",T=a==="move_options",I=a==="spot",A=a==="perpetual_futures",N=a==="futures",B=S||v||T,x=this.safeString(r,"strike_price"),k=this.safeString(r,"settlement_time"),O=this.parse8601(k),P=this.safeNumber(r,"contract_value");let q;I?q=this.parseNumber(this.parsePrecision(this.safeString(u,"underlying_precision"))):q=this.parseNumber("1");const L=b===y;let D,H=y+"/"+w;if(A||N||B)if(H=H+":"+b,N||B)if(H=H+"-"+this.yymmdd(O),B){a="option";let _="C";D="call",v?(_="P",D="put"):T&&(_="M",D="move"),H=H+":"+x+":"+_}else a="future";else a="swap";else H=m;const R=this.safeString(r,"state");i.push({id:m,numericId:g,symbol:H,base:y,quote:w,settle:b,baseId:h,quoteId:f,settleId:l,type:a,spot:I,margin:I?void 0:!1,swap:A,future:N,option:B,active:R==="live",contract:!I,linear:I?void 0:L,inverse:I?void 0:!L,taker:this.safeNumber(r,"taker_commission_rate"),maker:this.safeNumber(r,"maker_commission_rate"),contractSize:P,expiry:O,expiryDatetime:k,strike:this.parseNumber(x),optionType:D,precision:{amount:q,price:this.safeNumber(r,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber("1"),max:this.safeNumber(r,"position_size_limit")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_size"),max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"close"),a=this.safeString(e,"open"),o=this.safeString(e,"volume"),d=this.safeString(e,"turnover");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeValue(s,"result",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2orderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"result",{});return this.parseOrderBook(a,i.symbol,void 0,"buy","sell","price","size")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id");let n=this.parse8601(this.safeString(e,"created_at"));n=this.safeIntegerProduct(e,"timestamp",.001,n);const r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeValue(e,"product",{}),d=this.safeString(o,"symbol"),c=this.safeSymbol(d,t),u=this.safeString(e,"seller_role");let h=this.safeString(e,"side");h===void 0&&(u==="taker"?h="sell":u==="maker"&&(h="buy"));const f=this.safeString(e,"role"),l=this.safeValue(e,"meta_data",{});let m=this.safeString(l,"order_type");m!==void 0&&(m=m.replace("_order",""));const g=this.safeString(e,"commission");let y;if(g!==void 0){const w=this.safeValue(o,"settling_asset",{}),b=this.safeString(w,"symbol"),S=this.safeCurrencyCode(b);y={cost:g,currency:S}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:m,side:h,price:r,amount:a,cost:void 0,takerOrMaker:f,fee:y,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTradesSymbol(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(i=i||2e3,s===void 0){const u=this.seconds();a.end=u,a.start=u-i*o}else{const u=parseInt(s/1e3);a.start=u,a.end=this.sum(u,i*o)}const d=await this.publicGetHistoryCandles(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseBalance(e){const t=this.safeValue(e,"result",[]),s={info:e},i=this.safeValue(this.options,"currenciesByNumericId",{});for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"asset_id"),o=this.safeValue(i,a),d=o===void 0?a:o.code,c=this.account();c.total=this.safeString(r,"balance"),c.free=this.safeString(r,"available_balance"),s[d]=c}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWalletBalances(e);return this.parseBalance(t)}async fetchPosition(e,t={}){await this.loadMarkets();const i={product_id:this.market(e).numericId},n=await this.privateGetPositions(this.extend(i,t));return this.safeValue(n,"result",{})}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositionsMargined(t);return this.safeValue(s,"result",[])}parseOrderStatus(e){const t={open:"open",pending:"open",closed:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"product_id"),a=this.safeValue(this.options,"marketsByNumericId",{});t=this.safeValue(a,r,t);const o=t===void 0?r:t.symbol,d=this.parseOrderStatus(this.safeString(e,"state")),c=this.safeString(e,"side");let u=this.safeString(e,"order_type");u=u.replace("_order","");const h=this.safeString(e,"limit_price"),f=this.safeString(e,"size"),l=this.safeString(e,"unfilled_size"),m=this.safeString(e,"average_fill_price");let g;const y=this.safeString(e,"paid_commission");if(y!==void 0){let w;if(t!==void 0){const b=this.safeValue(t.info,"settling_asset",{}),S=this.safeString(b,"symbol");w=this.safeCurrencyCode(S)}g={cost:y,currency:w}}return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:o,type:u,side:c,price:h,amount:f,cost:void 0,average:m,filled:void 0,remaining:l,status:d,fee:g,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=t+"_order",o=this.market(e),d={product_id:o.numericId,size:this.amountToPrecision(o.symbol,i),side:s,order_type:a};t==="limit"&&(d.limit_price=this.priceToPrecision(o.symbol,n));const c=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),c!==void 0&&(d.client_order_id=c);const u=await this.privatePostOrders(this.extend(d,r)),h=this.safeValue(u,"result",{});return this.parseOrder(h,o)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:parseInt(e),product_id:o.numericId};n!==void 0&&(d.size=parseInt(this.amountToPrecision(t,n))),r!==void 0&&(d.limit_price=this.priceToPrecision(t,r));const c=await this.privatePutOrders(this.extend(d,a)),u=this.safeValue(c,"result");return this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new eb(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:parseInt(e),product_id:i.numericId},r=await this.privateDeleteOrders(this.extend(n,s)),a=this.safeValue(r,"result");return this.parseOrder(a,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new eb(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={product_id:this.market(e).numericId};return this.privateDeleteOrdersAll(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrders",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrdersHistory",e,t,s,i)}async fetchOrdersWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.product_ids=a.numericId),s!==void 0&&(r.start_time=s.toString()+"000"),i!==void 0&&(r.page_size=i);const o=await this[e](this.extend(r,n)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,a,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_ids=r.numericId),t!==void 0&&(n.start_time=t.toString()+"000"),s!==void 0&&(n.page_size=s);const a=await this.privateGetFills(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,r,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_id=r.numericId),s!==void 0&&(n.page_size=s);const a=await this.privateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseLedger(o,r,t,s)}parseLedgerEntryType(e){const t={pnl:"pnl",deposit:"transaction",withdrawal:"transaction",commission:"fee",conversion:"trade",referral_bonus:"referral",commission_rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"uuid");let i;const n=void 0,r=this.safeValue(e,"meta_data",{}),a=this.safeString(r,"transaction_id"),o=void 0;let d=this.safeString(e,"transaction_type");d==="deposit"||d==="commission_rebate"||d==="referral_bonus"||d==="pnl"||d==="withdrawal_cancellation"||d==="promo_credit"?i="in":(d==="withdrawal"||d==="commission"||d==="conversion"||d==="perpetual_futures_funding")&&(i="out"),d=this.parseLedgerEntryType(d);const c=this.safeInteger(e,"asset_id"),u=this.safeValue(this.options,"currenciesByNumericId");t=this.safeValue(u,c,t);const h=t===void 0?void 0:t.code,f=this.safeString(e,"amount"),l=this.parse8601(this.safeString(e,"created_at")),m=this.safeString(e,"balance"),g=tb.stringMax("0",tb.stringSub(m,f)),y="ok";return{info:e,id:s,direction:i,account:n,referenceId:a,referenceAccount:o,type:d,currency:h,amount:this.parseNumber(f),before:this.parseNumber(g),after:this.parseNumber(m),status:y,timestamp:l,datetime:this.iso8601(l),fee:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset_symbol:s.id},n=this.safeStringUpper(t,"network");n!==void 0&&(i.network=this.networkCodeToId(n,e),t=this.omit(t,"network"));const r=await this.privateGetDepositsAddress(this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"asset_symbol"),n=this.safeString(e,"network");return this.checkAddress(s),{currency:this.safeCurrencyCode(i,t),address:s,tag:this.safeString(e,"memo"),network:this.networkIdToCode(n),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.seconds().toString();n={"api-key":this.apiKey,timestamp:c};let u=s+c+a;if(s==="GET"||s==="DELETE"){if(Object.keys(d).length){const f="?"+this.urlencode(d);u+=f,o+=f}}else r=this.json(d),u+=r,n["Content-Type"]="application/json";const h=this.hmac(this.encode(u),this.encode(this.secret));n.signature=h}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new qR(h)}}};const UR=re,{TICK_SIZE:$R}=ne,{AuthenticationError:$s,ExchangeError:Ht,ArgumentsRequired:Jo,PermissionDenied:ki,InvalidOrder:Xe,OrderNotFound:Ll,DDoSProtection:ed,NotSupported:WR,ExchangeNotAvailable:zR,InsufficientFunds:jR,BadRequest:us,InvalidAddress:Rl,OnMaintenance:sb}=Q,Si=ae;var IT=class extends UR{describe(){return this.deepExtend(super.describe(),{id:"deribit",name:"Deribit",countries:["NL"],version:"v2",userAgent:void 0,rateLimit:50,pro:!0,has:{CORS:!0,spot:!1,margin:!1,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchHistoricalVolatility:!0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","10m":"10","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","6h":"360","12h":"720","1d":"1D"},urls:{test:{rest:"https://test.deribit.com"},logo:"https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg",api:{rest:"https://www.deribit.com"},www:"https://www.deribit.com",doc:["https://docs.deribit.com/v2","https://github.com/deribit"],fees:"https://www.deribit.com/pages/information/fees",referral:{url:"https://www.deribit.com/reg-1189.4038",discount:.1}},api:{public:{get:{auth:1,exchange_token:1,fork_token:1,set_heartbeat:1,disable_heartbeat:1,get_time:1,hello:1,status:1,test:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,get_announcements:1,get_book_summary_by_currency:1,get_book_summary_by_instrument:1,get_contract_size:1,get_currencies:1,get_delivery_prices:1,get_funding_chart_data:1,get_funding_rate_history:1,get_funding_rate_value:1,get_historical_volatility:1,get_index:1,get_index_price:1,get_index_price_names:1,get_instrument:1,get_instruments:1,get_last_settlements_by_currency:1,get_last_settlements_by_instrument:1,get_last_trades_by_currency:1,get_last_trades_by_currency_and_time:1,get_last_trades_by_instrument:1,get_last_trades_by_instrument_and_time:1,get_mark_price_history:1,get_order_book:1,get_trade_volumes:1,get_tradingview_chart_data:1,get_volatility_index_data:1,ticker:1}},private:{get:{logout:1,enable_cancel_on_disconnect:1,disable_cancel_on_disconnect:1,get_cancel_on_disconnect:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,change_api_key_name:1,change_scope_in_api_key:1,change_subaccount_name:1,create_api_key:1,create_subaccount:1,disable_api_key:1,disable_tfa_for_subaccount:1,enable_affiliate_program:1,enable_api_key:1,get_access_log:1,get_account_summary:1,get_affiliate_program_info:1,get_email_language:1,get_new_announcements:1,get_portfolio_margins:1,get_position:1,get_positions:1,get_subaccounts:1,get_subaccounts_details:1,get_transaction_log:1,list_api_keys:1,remove_api_key:1,remove_subaccount:1,reset_api_key:1,set_announcement_as_read:1,set_api_key_as_default:1,set_email_for_subaccount:1,set_email_language:1,set_password_for_subaccount:1,toggle_notifications_from_subaccount:1,toggle_subaccount_login:1,execute_block_trade:4,get_block_trade:1,get_last_block_trades_by_currency:1,invalidate_block_trade_signature:1,verify_block_trade:4,buy:4,sell:4,edit:4,edit_by_label:4,cancel:4,cancel_all:4,cancel_all_by_currency:4,cancel_all_by_instrument:4,cancel_by_label:4,close_position:4,get_margins:1,get_mmp_config:1,get_open_orders_by_currency:1,get_open_orders_by_instrument:1,get_order_history_by_currency:1,get_order_history_by_instrument:1,get_order_margin_by_ids:1,get_order_state:1,get_stop_order_history:1,get_trigger_order_history:1,get_user_trades_by_currency:1,get_user_trades_by_currency_and_time:1,get_user_trades_by_instrument:1,get_user_trades_by_instrument_and_time:1,get_user_trades_by_order:1,reset_mmp:1,set_mmp_config:1,get_settlement_history_by_instrument:1,get_settlement_history_by_currency:1,cancel_transfer_by_id:1,cancel_withdrawal:1,create_deposit_address:1,get_current_deposit_address:1,get_deposits:1,get_transfers:1,get_withdrawals:1,submit_transfer_to_subaccount:1,submit_transfer_to_user:1,withdraw:1}}},exceptions:{9999:ki,1e4:$s,10001:Ht,10002:Xe,10003:Xe,10004:Ll,10005:Xe,10006:Xe,10007:Xe,10008:Xe,10009:jR,10010:Ll,10011:Xe,10012:Xe,10013:ki,10014:ki,10015:ki,10016:ki,10017:ki,10018:ki,10019:ki,10020:Ht,10021:Xe,10022:Xe,10023:Xe,10024:Xe,10025:Xe,10026:Xe,10027:Xe,10028:ed,10029:Ll,10030:Ht,10031:Ht,10032:Xe,10033:WR,10034:Xe,10035:Xe,10036:Xe,10040:zR,10041:sb,10043:Xe,10044:Xe,10045:Xe,10046:Xe,10047:ed,10048:Ht,11008:Xe,11029:us,11030:Ht,11031:Ht,11035:ed,11036:Xe,11037:us,11038:Xe,11039:Xe,11041:Xe,11042:ki,11043:us,11044:Xe,11045:us,11046:us,11047:us,11048:Ht,11049:us,11050:us,11051:sb,11052:Ht,11053:Ht,11090:Rl,11091:Rl,11092:Rl,11093:ed,11094:Ht,11095:Ht,11096:Ht,12e3:$s,12001:ed,12002:Ht,12998:$s,12003:$s,12004:$s,12005:$s,12100:Ht,12999:$s,13e3:$s,13001:$s,13002:ki,13003:$s,13004:$s,13005:$s,13006:$s,13007:$s,13008:Ht,13009:$s,13010:us,13011:us,13012:ki,13013:us,13014:us,13015:us,13016:us,13017:Ht,13018:Ht,13019:Ht,13020:Ht,13021:ki,13025:Ht,"-32602":us,"-32601":us,"-32700":us,"-32000":us,11054:Xe},precisionMode:$R,options:{code:"BTC",fetchBalance:{code:"BTC"},fetchPositions:{code:"BTC"},transfer:{method:"privateGetSubmitTransferToSubaccount"}}})}async fetchTime(e={}){const t=await this.publicGetGetTime(e);return this.safeInteger(t,"result")}codeFromOptions(e,t={}){const s=this.safeValue(this.options,"code","BTC"),i=this.safeValue(this.options,e,{}),n=this.safeValue(i,"code",s);return this.safeValue(t,"code",n)}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"result"),i=this.safeString(s,"locked"),n=this.safeIntegerProduct(t,"usIn",.001,this.milliseconds());return{status:i==="false"?"ok":"maintenance",updated:n,eta:void 0,url:void 0,info:t}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetGetSubaccounts(e),s=this.safeValue(t,"result",[]);return this.parseAccounts(s)}parseAccount(e,t=void 0){return{info:e,id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:this.safeCurrencyCode(void 0,t)}}async fetchMarkets(e={}){const t=await this.publicGetGetCurrencies(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const a={currency:this.safeString(s[n],"currency")},o=await this.publicGetGetInstruments(this.extend(a,e)),d=this.safeValue(o,"result",[]);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"instrument_name"),f=this.safeString(u,"base_currency"),l=this.safeString(u,"counter_currency"),m=this.safeString(u,"settlement_currency"),g=this.safeCurrencyCode(f),y=this.safeCurrencyCode(l),w=this.safeCurrencyCode(m),b=this.safeString(u,"kind"),v=this.safeValue(u,"settlement_period")==="perpetual",T=!v&&b.indexOf("future")>=0,I=b.indexOf("option")>=0,A=b.indexOf("combo")>=0,N=this.safeInteger(u,"expiration_timestamp");let B,x,k=h,O="swap";if(T?O="future":I&&(O="option"),!A&&(k=g+"/"+y+":"+w,(I||T)&&(k=k+"-"+this.yymmdd(N,""),I))){B=this.safeNumber(u,"strike"),x=this.safeString(u,"option_type");const L=x==="call"?"C":"P";k=k+"-"+this.numberToString(B)+"-"+L}const P=this.safeNumber(u,"min_trade_amount"),q=this.safeNumber(u,"tick_size");i.push({id:h,symbol:k,base:g,quote:y,settle:w,baseId:f,quoteId:l,settleId:m,type:O,spot:!1,margin:!1,swap:v,future:T,option:I,active:this.safeValue(u,"is_active"),contract:!0,linear:w===y,inverse:w!==y,taker:this.safeNumber(u,"taker_commission"),maker:this.safeNumber(u,"maker_commission"),contractSize:this.safeNumber(u,"contract_size"),expiry:N,expiryDatetime:this.iso8601(N),strike:B,optionType:x,precision:{amount:P,price:q},limits:{leverage:{min:void 0,max:void 0},amount:{min:P,max:void 0},price:{min:q,max:void 0},cost:{min:void 0,max:void 0}},info:u})}}return i}parseBalance(e){const t={info:e},s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s),n=this.account();return n.free=this.safeString(e,"available_funds"),n.used=this.safeString(e,"maintenance_margin"),n.total=this.safeString(e,"equity"),t[i]=n,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchBalance",e),i={currency:this.currency(t).id},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{});return this.parseBalance(r)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetCreateDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetGetCurrentDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:n}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","creation_timestamp"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeString2(e,"last_price","last"),a=this.safeValue(e,"stats",e);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(a,"high","max_price"),low:this.safeString2(a,"low","min_price"),bid:this.safeString2(e,"best_bid_price","bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString2(e,"best_ask_price","ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(a,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.codeFromOptions("fetchTickers",t),n={currency:this.currency(s).id},r=await this.publicGetGetBookSummaryByCurrency(this.extend(n,t)),a=this.safeValue(r,"result",[]),o={};for(let d=0;d<a.length;d++){const c=this.parseTicker(a[d]),u=c.symbol;o[u]=c}return this.filterByArray(o,"symbol",e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t),d=this.milliseconds();s===void 0?(i===void 0&&(i=1e3),a.start_timestamp=d-(i-1)*o*1e3,a.end_timestamp=d):(a.start_timestamp=s,i===void 0?a.end_timestamp=d:a.end_timestamp=this.sum(s,i*o*1e3));const c=await this.publicGetGetTradingviewChartData(this.extend(a,n)),u=this.safeValue(c,"result",{}),h=this.convertTradingViewToOHLCV(u,"ticks","open","high","low","close","volume",!0);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price");t=this.safeMarket(i,t);const d=this.safeString(e,"amount");let c=Si.stringMul(d,o);t.inverse&&(c=Si.stringDiv(d,o));const u=this.safeString(e,"liquidity");let h;u!==void 0&&(h=u==="M"?"maker":"taker");const f=this.safeString(e,"fee");let l;if(f!==void 0){const m=this.safeString(e,"fee_currency"),g=this.safeCurrencyCode(m);l={cost:f,currency:g}}return this.safeTrade({id:s,info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:h,price:o,amount:d,cost:c,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id,include_old:!0},a=t===void 0?"publicGetGetLastTradesByInstrument":"publicGetGetLastTradesByInstrumentAndTime";t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.count=s);const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchTradingFees",e),i={currency:this.currency(t).id,extended:!0},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"fees",[]);let o={},d={},c={};for(let h=0;h<a.length;h++){const f=a[h],l=this.safeString(f,"instrument_type");l==="future"?d={info:f,maker:this.safeNumber(f,"maker_fee"),taker:this.safeNumber(f,"taker_fee")}:l==="perpetual"?o={info:f,maker:this.safeNumber(f,"maker_fee"),taker:this.safeNumber(f,"taker_fee")}:l==="option"&&(c={info:f,maker:this.safeNumber(f,"maker_fee"),taker:this.safeNumber(f,"taker_fee")})}const u={};for(let h=0;h<this.symbols.length;h++){const f=this.symbols[h],l=this.market(f);let m={info:l,symbol:f,percentage:!0,tierBased:!0,maker:l.maker,taker:l.taker};l.swap?m=this.extend(m,o):l.future?m=this.extend(m,d):l.option&&(m=this.extend(m,c)),u[f]=m}return u}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp"),d=this.safeInteger(a,"change_id"),c=this.parseOrderBook(a,i.symbol,o);return c.nonce=d,c}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected",untriggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={good_til_cancelled:"GTC",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrderType(e){const t={stop_limit:"limit",take_limit:"limit",stop_market:"market",take_market:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeInteger(e,"creation_timestamp"),n=this.safeInteger(e,"last_update_timestamp"),r=this.safeString(e,"order_id"),a=this.safeString(e,"price"),o=this.safeString(e,"average_price"),d=this.safeString(e,"filled_amount"),c=this.safeString(e,"amount");let u=Si.stringMul(d,o);t.inverse&&this.parseNumber(o)!==0&&(u=Si.stringDiv(c,o));let h;d!==void 0&&Si.stringGt(d,"0")&&(h=n);const f=this.parseOrderStatus(this.safeString(e,"order_state")),l=this.safeStringLower(e,"direction");let m=this.safeString(e,"commission"),g;m!==void 0&&(m=Si.stringAbs(m),g={cost:m,currency:t.base});const y=this.safeString(e,"order_type"),w=this.parseOrderType(y),b=this.safeValue(e,"trades"),S=this.parseTimeInForce(this.safeString(e,"time_in_force")),v=this.safeValue(e,"stop_price"),T=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:h,symbol:t.symbol,type:w,timeInForce:S,postOnly:T,side:l,price:a,stopPrice:v,triggerPrice:v,amount:c,cost:u,average:o,filled:d,remaining:void 0,status:f,fee:g,trades:b},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);a.inverse?i=this.amountToPrecision(e,i):a.settle==="USDC"?i=this.amountToPrecision(e,i):i=this.currencyToPrecision(e,i);const o={instrument_name:a.id,amount:i,type:t},d=this.safeStringUpper(r,"timeInForce"),c=this.safeValue2(r,"reduceOnly","reduce_only"),u=this.safeValue(r,"stopLossPrice"),h=this.safeValue(r,"takeProfitPrice"),f=t==="stop_limit",l=t==="stop_market",m=t==="take_limit",g=t==="take_market",y=f||l||u!==void 0,w=m||g||h!==void 0;if(y&&w)throw new Xe(this.id+" createOrder () only allows one of stopLossPrice or takeProfitPrice to be specified");const b=y||w,S=t==="limit"||f||m,v=t==="market"||l||g,T=this.safeValue(r,"post_only"),I=this.isPostOnly(v,T,r);if(S?(o.type="limit",o.price=this.priceToPrecision(e,n)):o.type="market",b){const O=u!==void 0?u:h;o.trigger_price=this.priceToPrecision(e,O),o.trigger="last_price",y?v?o.type="stop_market":o.type="stop_limit":v?o.type="take_market":o.type="take_limit"}c&&(o.reduce_only=!0),I&&(o.post_only=!0,o.reject_post_only=!0),d!==void 0&&(d==="GTC"&&(o.time_in_force="good_til_cancelled"),d==="IOC"&&(o.time_in_force="immediate_or_cancel"),d==="FOK"&&(o.time_in_force="fill_or_kill"));const A="privateGet"+this.capitalize(s);r=this.omit(r,["timeInForce","stopLossPrice","takeProfitPrice","postOnly","reduceOnly"]);const N=await this[A](this.extend(o,r)),B=this.safeValue(N,"result",{}),x=this.safeValue(B,"order"),k=this.safeValue(B,"trades",[]);return x.trades=k,this.parseOrder(x,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new Jo(this.id+" editOrder() requires an amount argument");if(r===void 0)throw new Jo(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o={order_id:e,amount:this.amountToPrecision(t,n),price:this.priceToPrecision(t,r)},d=await this.privateGetEdit(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"order"),h=this.safeValue(c,"trades",[]);return u.trades=h,this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e===void 0)i="privateGetCancelAll";else{i="privateGetCancelAllByInstrument";const r=this.market(e);s.instrument_name=r.id}return await this[i](this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchOpenOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOpenOrdersByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOpenOrdersByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchClosedOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOrderHistoryByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOrderHistoryByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e},a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{});return this.parseTrades(o,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={include_old:!0};let r,a;if(e===void 0){const u=this.codeFromOptions("fetchMyTrades",i),h=this.currency(u);n.currency=h.id,t===void 0?a="privateGetGetUserTradesByCurrency":(a="privateGetGetUserTradesByCurrencyAndTime",n.start_timestamp=t)}else r=this.market(e),n.instrument_name=r.id,t===void 0?a="privateGetGetUserTradesByInstrument":(a="privateGetGetUserTradesByInstrumentAndTime",n.start_timestamp=t);s!==void 0&&(n.count=s);const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jo(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetDeposits(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jo(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}parseTransactionStatus(e){const t={completed:"ok",unconfirmed:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"created_timestamp","received_timestamp"),r=this.safeInteger(e,"updated_timestamp"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.safeString(e,"address"),d=this.safeNumber(e,"fee");let c="deposit",u;return d!==void 0&&(c="withdrawal",u={cost:d,currency:i}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),timestamp:n,datetime:this.iso8601(n),address:o,addressTo:o,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:c,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:u}}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);let i=this.safeString(e,"direction");i=i==="buy"?"long":"short";const n=this.safeString(e,"floating_profit_loss"),r=this.safeString(e,"initial_margin"),a=this.safeString(e,"size_currency"),o=this.safeString(e,"maintenance_margin"),d=Si.stringMul(Si.stringDiv(n,r),"100"),c=this.milliseconds();return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(r),initialMarginPercentage:this.parseNumber(Si.stringMul(Si.stringDiv(r,a),"100")),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(Si.stringMul(Si.stringDiv(o,a),"100")),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(a),leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.parseNumber(n),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"estimated_liquidation_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:void 0,marginMode:void 0,side:i,percentage:this.parseNumber(d)}}async fetchPosition(e,t={}){await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e===void 0)s=this.codeFromOptions("fetchPositions",t);else if(typeof e=="string")s=e,e=void 0;else if(Array.isArray(e)){if(e.length!==1)throw new us(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");s=this.market(e[0]).base}const n={currency:this.currency(s).id},r=await this.privateGetGetPositions(this.extend(n,t)),a=this.safeValue(r,"result");return this.parsePositions(a,e)}async fetchHistoricalVolatility(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.publicGetGetHistoricalVolatility(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=[];for(let o=0;o<r.length;o++){const d=this.safeInteger(r[o],0),c=this.safeNumber(r[o],1);a.push({info:n,timestamp:d,datetime:this.iso8601(d),volatility:c})}return a}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jo(this.id+" fetchTransfers() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetTransfers(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransfers(d,n,t,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,destination:i};let o=this.safeString(n,"method");if(n=this.omit(n,"method"),o===void 0){const u=this.safeValue(this.options,"transfer",{});o=this.safeString(u,"method","privateGetSubmitTransferToSubaccount")}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"result",{});return this.parseTransfer(c,r)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_timestamp"),i=this.safeString(e,"state"),n=this.safeString(e,"other_side"),r=this.safeString(e,"direction"),a=this.safeString(e,"currency");return{info:e,id:this.safeString(e,"id"),status:this.parseTransferStatus(i),amount:this.safeNumber(e,"amount"),code:this.safeCurrencyCode(a,t),fromAccount:r!=="payment"?n:void 0,toAccount:r==="payment"?n:void 0,timestamp:s,datetime:this.iso8601(s)}}parseTransferStatus(e){const t={prepared:"pending",confirmed:"ok",cancelled:"cancelled",waiting_for_admin:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:t};this.twofa!==void 0&&(a.tfa=this.oath());const o=await this.privateGetWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=this.milliseconds().toString(),u="";Object.keys(i).length&&(a+="?"+this.urlencode(i));const h=s+`
`+a+`
`+u+`
`,f=c+`
`+d+`
`+h,l=this.hmac(this.encode(f),this.encode(this.secret),"sha256");n={Authorization:"deri-hmac-sha256 id="+this.apiKey+",ts="+c+",sig="+l+",nonce="+d}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new Ht(h)}}};const KR=re,{AccountSuspended:XR,BadRequest:Os,BadResponse:YR,NetworkError:ZR,NotSupported:QR,DDoSProtection:ib,AuthenticationError:nb,PermissionDenied:vi,ExchangeError:Gc,InsufficientFunds:rb,InvalidOrder:_a,InvalidNonce:JR,OrderNotFound:Dl,InvalidAddress:Fl,RateLimitExceeded:e4,BadSymbol:td}=Q,{TICK_SIZE:t4}=ne,sd=ae;var s4=class extends KR{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",api:{rest:"https://openapi.digifinex.com"},www:"https://www.digifinex.com",doc:["https://docs.digifinex.com"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp"},api:{public:{spot:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades","trades/symbols","ticker","currencies"]},swap:{get:["public/api_weight","public/candles","public/candles_history","public/depth","public/funding_rate","public/funding_rate_history","public/instrument","public/instruments","public/ticker","public/tickers","public/time","public/trades"]}},private:{spot:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/detail","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history","deposit/address","deposit/history","withdraw/history"],post:["{market}/order/cancel","{market}/order/new","{market}/order/batch_new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer","withdraw/new","withdraw/cancel"]},swap:{get:["account/balance","account/positions","account/finance_record","account/trading_fee_rate","account/transfer_record","trade/history_orders","trade/history_trades","trade/open_orders","trade/order_info"],post:["account/leverage","trade/batch_cancel_order","trade/batch_order","trade/cancel_order","trade/order_place"]}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:t4,exceptions:{exact:{10001:[Os,"Wrong request method, please check it's a GET ot POST request"],10002:[nb,"Invalid ApiKey"],10003:[nb,"Sign doesn't match"],10004:[Os,"Illegal request parameters"],10005:[ib,"Request frequency exceeds the limit"],10006:[vi,"Unauthorized to execute this request"],10007:[vi,"IP address Unauthorized"],10008:[JR,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[ZR,"Unexist endpoint, please check endpoint URL"],10011:[XR,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[vi,"Trade is not open for this trading pair"],20002:[vi,"Trade of this trading pair is suspended"],20003:[_a,"Invalid price or amount"],20007:[_a,"Price precision error"],20008:[_a,"Amount precision error"],20009:[_a,"Amount is less than the minimum requirement"],20010:[_a,"Cash Amount is less than the minimum requirement"],20011:[rb,"Insufficient balance"],20012:[Os,"Invalid trade type, valid value: buy/sell)"],20013:[_a,"No order info found"],20014:[Os,"Invalid date, Valid format: 2018-07-25)"],20015:[Os,"Date exceeds the limit"],20018:[vi,"Your trading rights have been banned by the system"],20019:[td,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[ib,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],5e4:[Gc,"Exception error"],20021:[Os,"Invalid currency"],20022:[Os,"The ending timestamp must be larger than the starting timestamp"],20023:[Os,"Invalid transfer type"],20024:[Os,"Invalid amount"],20025:[Os,"This currency is not transferable at the moment"],20026:[rb,"Transfer amount exceed your balance"],20027:[vi,"Abnormal account status"],20028:[vi,"Blacklist for transfer"],20029:[vi,"Transfer amount exceed your daily limit"],20030:[Os,"You have no position on this trading pair"],20032:[vi,"Withdrawal limited"],20033:[Os,"Wrong Withdrawal ID"],20034:[vi,"Withdrawal service of this crypto has been closed"],20035:[vi,"Withdrawal limit"],20036:[Gc,"Withdrawal cancellation failed"],20037:[Fl,"The withdrawal address, Tag or chain type is not included in the withdrawal management list"],20038:[Fl,"The withdrawal address is not on the white list"],20039:[Gc,"Can't be canceled in current status"],20040:[e4,"Withdraw too frequently; limitation: 3 times a minute, 100 times a day"],20041:[vi,"Beyond the daily withdrawal limit"],20042:[td,"Current trading pair does not support API trading"],400002:[Os,"Invalid Parameter"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"],accountsByType:{spot:"1",margin:"2",OTC:"3"},networks:{ARBITRUM:"Arbitrum",AVALANCEC:"AVAX-CCHAIN",AVALANCEX:"AVAX-XCHAIN",BEP20:"BEP20",BSC:"BEP20",CARDANO:"Cardano",CELO:"Celo",CHILIZ:"Chiliz",COSMOS:"COSMOS",CRC20:"Crypto.com",CRONOS:"Crypto.com",DOGECOIN:"DogeChain",ERC20:"ERC20",ETH:"ERC20",ETHW:"ETHW",IOTA:"MIOTA",KLAYTN:"KLAY",MATIC:"Polygon",METIS:"MetisDAO",MOONBEAM:"GLMR",MOONRIVER:"Moonriver",OPTIMISM:"OPETH",POLYGON:"Polygon",RIPPLE:"XRP",SOLANA:"SOL",STELLAR:"Stella",TERRACLASSIC:"TerraClassic",TERRA:"Terra",TON:"Ton",TRC20:"TRC20",TRON:"TRC20",TRX:"TRC20",VECHAIN:"Vechain"},networksById:{Arbitrum:"ARBITRUM","AVAX-CCHAIN":"AVALANCEC","AVAX-XCHAIN":"AVALANCEX",BEP20:"BEP20",Cardano:"CARDANO",Celo:"CELO",Chiliz:"CHILIZ",COSMOS:"COSMOS","Crypto.com":"CRC20",DogeChain:"DOGECOIN",ERC20:"ERC20",ETHW:"ETHW",MIOTA:"IOTA",KLAY:"KLAYTN",Polygon:"POLYGON",MetisDAO:"METIS",Moonriver:"MOONRIVER",GLMR:"MOONBEAM",OPETH:"OPTIMISM",XRP:"RIPPLE",SOL:"SOLANA",Stella:"STELLAR",Terra:"TERRA",TerraClassic:"TERRACLASSIC",Ton:"TON",TRC20:"TRC20",Vechain:"VECHAIN"}},commonCurrencies:{BHT:"Black House Test",EPS:"Epanus",FREE:"FreeRossDAO",MBN:"Mobilian Coin",TEL:"TEL666"}})}async fetchCurrencies(e={}){const t=await this.publicSpotGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeInteger(r,"deposit_status",1),c=this.safeInteger(r,"withdraw_status",1),u=d>0,h=c>0,f=u&&h,l=this.safeString(r,"min_withdraw_fee"),m=this.safeString(r,"min_withdraw_amount"),g=this.safeString(r,"min_deposit_amount"),y=this.parseNumber(g),w=this.parseNumber(m),b=this.parseNumber(l),S=sd.stringMin(l,sd.stringMin(g,m)),v=this.parseNumber(S),T=this.safeString(r,"chain"),I=this.networkIdToCode(T),A={info:r,id:T,network:I,active:f,fee:b,precision:v,deposit:u,withdraw:h,limits:{amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:y,max:void 0}}};o in i?(Array.isArray(i[o].info)?i[o].info.push(r):i[o].info=[i[o].info,r],h&&(i[o].withdraw=!0,i[o].limits.withdraw.min=Math.min(i[o].limits.withdraw.min,w)),u&&(i[o].deposit=!0,i[o].limits.deposit.min=Math.min(i[o].limits.deposit.min,y)),f&&(i[o].active=!0)):i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:f,deposit:u,withdraw:h,fee:this.parseNumber(l),precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:y,max:void 0}},networks:{}},T!==void 0?i[o].networks[T]=A:(i[o].active=f,i[o].fee=this.parseNumber(l),i[o].deposit=u,i[o].withdraw=h,i[o].limits={amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:y,max:void 0}}),i[o].precision=i[o].precision===void 0?v:Math.max(i[o].precision,v)}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeString(t,"method","fetch_markets_v2");return await this[s](e)}async fetchMarketsV2(e={}){const t=this.safeString(this.options,"defaultType"),[s,i]=this.handleMarginModeAndParams("fetchMarketsV2",e);let r=[this[s!==void 0?"publicSpotGetMarginSymbols":"publicSpotGetTradesSymbols"](i),this.publicSwapGetPublicInstruments(e)];r=await Promise.all(r);const a=r[0],o=r[1],d=this.safeValue(a,"symbol_list",[]),c=this.safeValue(o,"data",[]),u=this.arrayConcat(d,c),h=[];for(let f=0;f<u.length;f++){const l=u[f],m=this.safeString2(l,"symbol","instrument_id"),g=this.safeString2(l,"base_asset","base_currency"),y=this.safeString2(l,"quote_asset","quote_currency"),w=this.safeString(l,"clear_currency"),b=this.safeCurrencyCode(g),S=this.safeCurrencyCode(y),v=this.safeCurrencyCode(w);let T=this.safeInteger(l,"is_allow",1),I=t==="margin"?"margin":"spot";const A=v===void 0,N=!A,B=s!==void 0?!0:void 0;let x=b+"/"+S,k,O;N&&(I="swap",x=b+"/"+S+":"+v,k=this.safeValue(l,"is_inverse"),O=!k,this.safeValue(l,"isTrading")&&(T=!0)),h.push({id:m,symbol:x,base:b,quote:S,settle:v,baseId:g,quoteId:y,settleId:w,type:I,spot:A,margin:B,swap:N,future:!1,option:!1,active:!!T,contract:N,linear:O,inverse:k,contractSize:this.safeNumber(l,"contract_value"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(l,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(l,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(l,"minimum_amount","min_order_amount"),max:void 0},price:{min:this.safeNumber(l,"tick_size"),max:void 0},cost:{min:this.safeNumber(l,"minimum_value"),max:void 0}},info:l})}return h}async fetchMarketsV1(e={}){const t=await this.publicSpotGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"market"),[o,d]=a.split("_"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_amount"),max:void 0}},info:r})}return i}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account(),o=this.safeString2(i,"free","avail_balance"),d=this.safeString2(i,"total","equity");a.free=o,a.used=sd.stringSub(d,o),a.total=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let s=this.getSupportedMapping(t,{spot:"privateSpotGetSpotAssets",margin:"privateSpotGetMarginAssets",swap:"privateSwapGetAccountBalance"});const[i,n]=this.handleMarginModeAndParams("fetchBalance",e);i!==void 0&&(s="privateSpotGetMarginAssets",t="margin");const r=await this[s](n),a=t==="swap"?"data":"list",o=this.safeValue(r,a,[]);return this.parseBalance(o)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),a={};let o;n==="swap"?(o="publicSwapGetPublicDepth",a.instrument_id=i.id):(o="publicSpotGetOrderBook",a.symbol=i.id),t!==void 0&&(a.limit=t);const d=await this[o](this.extend(a,r));let c,u;return n==="swap"?(u=this.safeValue(d,"data",{}),c=this.safeInteger(u,"timestamp")):(u=d,c=this.safeTimestamp(d,"date")),this.parseOrderBook(u,i.symbol,c)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r="publicSpotGetTicker";const a={};n==="swap"&&(r="publicSwapGetPublicTickers");const o=await this[r](this.extend(a,t)),d={},c=this.safeValue2(o,"ticker","data",[]),u=this.safeInteger(o,"date");for(let h=0;h<c.length;h++){const f=this.extend({date:u},c[h]),l=this.parseTicker(f),m=l.symbol;d[m]=l}return this.filterByArray(d,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i="publicSpotGetTicker";const n={};s.swap?(i="publicSwapGetPublicTicker",n.instrument_id=s.id):n.symbol=s.id;const r=await this[i](this.extend(n,t)),a=this.safeInteger(r,"date"),o=this.safeValue(r,"ticker",[]),d=this.safeValue(r,"data",{}),c=this.safeValue(o,0,{});let u;return s.swap?u=d:u=this.extend({date:a},c),this.parseTicker(u,s)}parseTicker(e,t=void 0){const s=this.safeStringUpper2(e,"symbol","instrument_id"),i=this.safeSymbol(s,t);t=this.safeMarket(s);let n=this.safeTimestamp(e,"date");t.swap&&(n=this.safeInteger(e,"timestamp"));const r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString2(e,"high","high_24h"),low:this.safeString2(e,"low","low_24h"),bid:this.safeString2(e,"buy","best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString2(e,"sell","best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString2(e,"change","price_change_percent"),average:void 0,baseVolume:this.safeString2(e,"vol","volume_24h"),quoteVolume:this.safeString(e,"base_vol"),info:e},t)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","trade_id"),i=this.safeString(e,"order_id"),n=this.safeString(e,"price"),r=this.safeStringN(e,["amount","volume","size"]),a=this.safeStringUpper2(e,"symbol","instrument_id"),o=this.safeSymbol(a,t);t===void 0&&(t=this.safeMarket(a));let d=this.safeTimestamp2(e,"date","timestamp"),c=this.safeString2(e,"type","side"),u,h;if(t.type==="swap"){d=this.safeInteger(e,"trade_time");const m=this.safeString(e,"order_type"),g=this.safeString(e,"match_role"),y=this.safeString(e,"direction");m!==void 0&&(u=m==="0"?"limit":void 0),g==="1"?h="taker":g==="2"?h="maker":h=void 0,c==="1"||y==="1"?c="buy":c==="2"||y==="2"||c==="3"||y==="3"?c="sell":(c==="4"||y==="4")&&(c="buy")}else{const m=c.split("_");c=this.safeString(m,0),u=this.safeString(m,1),u===void 0&&(u="limit"),h=this.safeValue(e,"is_maker")?"maker":"taker"}let f;const l=this.safeString(e,"fee");if(l!==void 0){const m=this.safeString(e,"fee_currency");let g;m!==void 0&&(g=this.safeCurrencyCode(m)),f={cost:l,currency:g}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:o,type:u,order:i,side:c,price:n,amount:r,cost:void 0,takerOrMaker:h,fee:f},t)}async fetchTime(e={}){const t=await this.publicSpotGetTime(e);return this.safeTimestamp(t,"server_time")}async fetchStatus(e={}){const t=await this.publicSpotGetPing(e);return{status:this.safeInteger(t,"code")===0?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="publicSpotGetTrades";const a={};n.swap?(r="publicSwapGetPublicTrades",a.instrument_id=n.id):a.symbol=n.id,s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return t.swap?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,1)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);let a="publicSpotGetKline";const o={};if(r.swap)a="publicSwapGetPublicCandles",o.instrument_id=r.id,o.granularity=t,i!==void 0&&(o.limit=i);else if(o.symbol=r.id,o.period=this.timeframes[t],s!==void 0){const u=parseInt(s/1e3);if(o.start_time=u,i!==void 0){const h=this.parseTimeframe(t);o.end_time=this.sum(u,i*h)}}else if(i!==void 0){const u=this.seconds(),h=this.parseTimeframe(t);o.start_time=this.sum(u,-i*h)}const d=await this[a](this.extend(o,n));let c;if(r.swap){const u=this.safeValue(d,"data",{});c=this.safeValue(u,"candles",[])}else c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;let o,d;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);let c=this.getSupportedMapping(o,{spot:"privateSpotPostSpotOrderNew",margin:"privateSpotPostMarginOrderNew",swap:"privateSwapPostTradeOrderPlace"});[d,r]=this.handleMarginModeAndParams("createOrder",r),d!==void 0&&(c="privateSpotPostMarginOrderNew",o="margin");const u={},h=o==="swap",f=t==="market",l=t==="limit",m=h?"instrument_id":"symbol";u[m]=a.id;let g=this.isPostOnly(f,!1,r);if(h){const S=this.safeValue(r,"reduceOnly",!1),v=this.safeString(r,"timeInForce");let T;if(s==="buy"){const I=S?4:1;u.type=I}else{const I=S?3:2;u.type=I}l&&(T=0),v==="FOK"?T=f?15:9:v==="IOC"?T=f?13:4:v==="GTC"||f?T=14:v==="PO"&&(g=!0),n!==void 0&&(u.price=this.priceToPrecision(e,n)),u.order_type=T,u.size=i,r=this.omit(r,["reduceOnly","timeInForce"])}else{g=g===!0?1:2,u.market=o;let S="";t==="market"?S="_market":u.price=this.priceToPrecision(e,n),u.type=s+S,u.amount=this.amountToPrecision(e,i)}g&&(u.postOnly=g);const y=this.omit(r,["postOnly","post_only"]),w=await this[c](this.extend(u,y)),b=this.parseOrder(w,a);return this.extend(b,{symbol:e,type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotPostSpotOrderCancel",margin:"privateSpotPostMarginOrderCancel",swap:"privateSwapPostTradeCancelOrder"});const[a,o]=this.handleMarginModeAndParams("cancelOrder",s);a!==void 0&&(r="privateSpotPostMarginOrderCancel",n="margin"),e=e.toString();const d={order_id:e};n==="swap"?(this.checkRequiredSymbol("cancelOrder",t),d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o));if((n==="spot"||n==="margin")&&this.safeValue(c,"success",[]).length!==1)throw new Dl(this.id+" cancelOrder() "+e+" not found");return c}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString(this.options,"defaultType","spot"),n=this.safeString(s,"type",i);s=this.omit(s,"type");const r={market:n,order_id:e.join(",")},a=await this.privateSpotPostCancelOrder(this.extend(r,s));if(this.safeValue(a,"success",[]).length<1)throw new Dl(this.id+" cancelOrders() error");return a}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s,i,n,r,a=this.safeString(e,"type");const o=this.safeString2(e,"symbol","instrument_id"),d=this.safeSymbol(o,t,"_");if(t=this.market(d),t.type==="swap"){const c=this.safeInteger(e,"order_type");c===9||c===10||c===11||c===12||c===15?n="FOK":c===1||c===2||c===3||c===4||c===13?n="IOC":(c===6||c===7||c===8||c===14)&&(n="GTC"),c===0||c===1||c===4||c===5||c===9||c===10?r="limit":r="market",a==="1"?a="open long":a==="2"?a="open short":a==="3"?a="close long":a==="4"&&(a="close short"),s=this.safeInteger(e,"insert_time"),i=this.safeInteger(e,"time_stamp")}else if(s=this.safeTimestamp(e,"created_date"),i=this.safeTimestamp(e,"finished_date"),a!==void 0){const c=a.split("_");c.length>1?(a=c[0],r=c[1]):r="limit"}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","data"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,symbol:d,type:r,timeInForce:n,postOnly:void 0,side:a,price:this.safeNumber(e,"price"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeNumber2(e,"amount","size"),filled:this.safeNumber2(e,"executed_amount","filled_qty"),remaining:void 0,cost:void 0,average:this.safeNumber2(e,"avg_price","price_avg"),status:this.parseOrderStatus(this.safeString2(e,"status","state")),fee:{cost:this.safeNumber(e,"fee")},trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderCurrent",margin:"privateSpotGetMarginOrderCurrent",swap:"privateSwapGetTradeOpenOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderCurrent",r="margin");const c={},u=r==="swap";if(u?(t!==void 0&&(c.start_timestamp=t),s!==void 0&&(c.limit=s)):c.market=r,n!==void 0){const l=u?"instrument_id":"symbol";c[l]=n.id}const h=await this[a](this.extend(c,d)),f=this.safeValue(h,"data",[]);return this.parseOrders(f,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderHistory",margin:"privateSpotGetMarginOrderHistory",swap:"privateSwapGetTradeHistoryOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderHistory",r="margin");const c={};if(r==="swap"?t!==void 0&&(c.start_timestamp=t):(c.market=r,t!==void 0&&(c.start_time=parseInt(t/1e3))),n!==void 0){const f=r==="swap"?"instrument_id":"symbol";c[f]=n.id}s!==void 0&&(c.limit=s);const u=await this[a](this.extend(c,d)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotGetSpotOrder",margin:"privateSpotGetMarginOrder",swap:"privateSwapGetTradeOrderInfo"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateSpotGetMarginOrder",n="margin");const d={order_id:e};n==="swap"?i!==void 0&&(d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o)),u=this.safeValue(c,"data"),h=n==="swap"?u:this.safeValue(u,0);if(h===void 0)throw new Dl(this.id+" fetchOrder() order "+e.toString()+" not found");return this.parseOrder(h,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e));let a;[a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);let o=this.getSupportedMapping(a,{spot:"privateSpotGetSpotMytrades",margin:"privateSpotGetMarginMytrades",swap:"privateSwapGetTradeHistoryTrades"});const[d,c]=this.handleMarginModeAndParams("fetchMyTrades",i);d!==void 0&&(o="privateSpotGetMarginMytrades",a="margin"),a==="swap"?t!==void 0&&(r.start_timestamp=t):(r.market=a,t!==void 0&&(r.start_time=parseInt(t/1e3)));const u=a==="swap"?"instrument_id":"symbol";e!==void 0&&(r[u]=n.id),s!==void 0&&(r.limit=s);const h=await this[o](this.extend(r,c)),f=a==="swap"?"data":"list",l=this.safeValue(h,f,[]);return this.parseTrades(l,n,t,s)}parseLedgerEntryType(e){const t={};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString2(e,"type","finance_type")),i=this.safeCurrencyCode(this.safeString2(e,"currency_mark","currency"),t),n=this.safeNumber2(e,"num","change"),r=this.safeNumber(e,"balance");let a=this.safeTimestamp(e,"time");return a===void 0&&(a=this.safeInteger(e,"timestamp")),{info:e,id:void 0,direction:void 0,account:void 0,referenceId:void 0,referenceAccount:void 0,type:s,currency:i,amount:n,before:void 0,after:r,status:void 0,timestamp:a,datetime:this.iso8601(a),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;[r,i]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotFinancelog",margin:"privateSpotGetMarginFinancelog",swap:"privateSwapGetAccountFinanceRecord"});const[o,d]=this.handleMarginModeAndParams("fetchLedger",i);o!==void 0&&(a="privateSpotGetMarginFinancelog",r="margin"),r==="swap"?t!==void 0&&(n.start_timestamp=t):(n.market=r,t!==void 0&&(n.start_time=parseInt(t/1e3)));const c=r==="swap"?"currency":"currency_mark";let u;e!==void 0&&(u=this.currency(e),n[c]=u.id),s!==void 0&&(n.limit=s);const h=await this[a](this.extend(n,d));let f;if(r==="swap")f=this.safeValue(h,"data",[]);else{const l=this.safeValue(h,"data",{});f=this.safeValue(l,"finance",[])}return this.parseLedger(f,u,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeStringUpper(e,"currency"),r=this.safeCurrencyCode(n);return{info:e,currency:r,address:s,tag:i,network:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateSpotGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new Fl(this.id+" fetchDepositAddress() did not return an address for "+e+" - create the deposit address in the user settings on the exchange website first.");return o}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;const a={};t!==void 0&&(r=this.currency(t),a.currency=r.id),i!==void 0&&(a.size=Math.min(500,i));const d=await this[e==="deposit"?"privateSpotGetDepositHistory":"privateSpotGetWithdrawHistory"](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseTransactions(c,r,s,i,{type:e})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdrawal",e,t,s,i)}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdraw_id"),i=this.safeString(e,"address"),n=this.safeString(e,"memo"),r=this.safeString(e,"hash"),a=this.safeStringUpper(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parse8601(this.safeString(e,"created_date")),c=this.parse8601(this.safeString(e,"finished_date")),u=this.parseTransactionStatus(this.safeString(e,"state")),h=this.safeNumber(e,"amount"),f=this.safeNumber(e,"fee");let l;f!==void 0&&(l={currency:o,cost:f});const m=this.safeString(e,"chain");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:m,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:void 0,amount:h,currency:o,status:u,updated:c,fee:l}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){let s,i;const n=this.safeInteger(e,"type");n===1?(s="spot",i="swap"):n===2&&(s="swap",i="spot");const r=this.safeInteger(e,"timestamp");return{info:e,id:this.safeString(e,"transfer_id"),timestamp:r,datetime:this.iso8601(r),currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:s,toAccount:i,status:this.parseTransferStatus(this.safeString(e,"code"))}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency_mark:r.id,num:this.currencyToPrecision(e,t),from:o,to:d},u=await this.privateSpotPostTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,currency:e,fromAccount:s,toAccount:i})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={address:s,amount:this.currencyToPrecision(e,t),currency:r.id};i!==void 0&&(a.memo=i);const o=await this.privateSpotPostWithdrawNew(this.extend(a,n));return this.parseTransaction(o,r)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateSpotGetMarginPositions(this.extend(r,n)),d=this.safeValue(o,"positions"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"symbol"),i=this.safeString(e,"amount"),n=this.safeString(e,"leverage_ratio"),r=sd.stringDiv(i,n),a=sd.stringSub(i,r),o=t===void 0?void 0:t.base;return{account:this.safeSymbol(s,t),currency:o,interest:void 0,interestRate:.001,amountBorrowed:this.parseNumber(a),timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s={},i=await this.privateSpotGetMarginAssets(this.extend(s,t)),n=this.safeValue(i,"list",[]);let r=[];for(let o=0;o<n.length;o++){const d=n[o];this.safeString(d,"currency")===e&&(r=d)}const a=this.safeString(r,"currency");return this.parseBorrowRate(r,a)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateSpotGetMarginAssets(e),s=this.safeValue(t,"list");return this.parseBorrowRates(s,"currency")}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(i,t),rate:.001,period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}parseBorrowRates(e,t){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,t),a=this.safeCurrencyCode(r),o=this.parseBorrowRate(n,r);s[a]=o}return s}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new td(this.id+" fetchFundingRate() supports swap contracts only");const i={instrument_id:s.id},n=await this.publicSwapGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time");return{info:e,symbol:this.safeSymbol(s,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeString(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:this.safeString(e,"next_funding_rate"),nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredSymbol("fetchFundingRateHistory",e),await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new td(this.id+" fetchFundingRateHistory() supports swap contracts only");const r={instrument_id:n.id};t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.publicSwapGetPublicFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"funding_rates",[]),c=[];for(let h=0;h<d.length;h++){const f=d[h],l=this.safeString(o,"instrument_id"),m=this.safeSymbol(l),g=this.safeInteger(f,"time");c.push({info:f,symbol:m,fundingRate:this.safeString(f,"rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,e,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Os(this.id+" fetchTradingFee() supports swap markets only");const i={instrument_id:s.id},n=await this.privateSwapGetAccountTradingFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n;if(e!==void 0){let f;if(Array.isArray(e)){if(e.length>1)throw new Os(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");f=e[0]}else f=e;i=this.market(f)}[n,t]=this.handleMarketTypeAndParams("fetchPositions",i,t);const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);if(r!==void 0&&(n="margin"),i!==void 0){const f=n==="swap"?"instrument_id":"symbol";s[f]=i.id}const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=await this[o](this.extend(s,a)),c=n==="swap"?"data":"positions",u=this.safeValue(d,c,[]),h=[];for(let f=0;f<u.length;f++)h.push(this.parsePosition(u[f],i));return this.filterByArray(h,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;[n,t]=this.handleMarketTypeAndParams("fetchPosition",s,t);const[r,a]=this.handleMarginModeAndParams("fetchPosition",t);r!==void 0&&(n="margin");const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=n==="swap"?"instrument_id":"symbol";i[d]=s.id;const c=await this[o](this.extend(i,a)),u=n==="swap"?"data":"positions",h=this.safeValue(c,u,[]),f=this.parsePosition(h[0],s);return n==="swap"?f:this.extend(f,{collateral:this.safeNumber(c,"margin"),marginRatio:this.safeNumber(c,"margin_rate")})}parsePosition(e,t=void 0){const s=this.safeString2(e,"instrument_id","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeString(e,"margin_mode");n!==void 0?n=n==="crossed"?"cross":"isolated":n="crossed";const r=this.safeInteger(e,"timestamp");let a=this.safeString(e,"side");return a==="go_long"?a="long":a==="go_short"&&(a="short"),{info:e,id:void 0,symbol:i,notional:this.safeNumber(e,"amount"),marginMode:n,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber2(e,"avg_cost","entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),contracts:this.safeNumber(e,"avail_position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"last"),side:a,hedged:void 0,timestamp:r,datetime:this.iso8601(r),maintenanceMargin:this.safeNumber(e,"margin"),maintenanceMarginPercentage:this.safeNumber(e,"maint_margin_ratio"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber2(e,"leverage","leverage_ratio"),marginRatio:this.safeNumber(e,"margin_ratio"),percentage:void 0}}async setLeverage(e,t=void 0,s={}){await this.loadMarkets(),this.checkRequiredSymbol("setLeverage",t);const i=this.market(t);if(i.type!=="swap")throw new td(this.id+" setLeverage() supports swap contracts only");if(e<1||e>100)throw new Os(this.id+" leverage should be between 1 and 100");const n={instrument_id:i.id,leverage:e},r=this.safeString2(this.options,"marginMode","defaultMarginMode");let a=this.safeStringLower2(s,"marginMode","defaultMarginMode",r);if(a!==void 0&&(a=a==="cross"?"crossed":"isolated",n.margin_mode=a,s=this.omit(s,["marginMode","defaultMarginMode"])),a==="isolated"){const o=this.safeString(s,"side");o!==void 0?(n.side=o,s=this.omit(s,"side")):this.checkRequiredArgument("setLeverage",o,"side",["long","short"])}return await this.privateSwapPostAccountLeverage(this.extend(n,s))}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.currency=n.id),t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateSwapGetAccountTransferRecord(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransfers(o,n,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSwapGetPublicInstruments(t),i=this.safeValue(s,"data",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,"instrument_id"),o=this.safeMarket(a),d=this.safeSymbol(a,o);let c=0;this.parseMarketLeverageTiers(e[n],o),t!==void 0&&(c=t.length,this.inArray(d,t)&&(i[d]=this.parseMarketLeverageTiers(e[n],o))),d!==void 0&&(c===0||this.inArray(t,d))&&(i[d]=this.parseMarketLeverageTiers(e[n],o))}return i}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Os(this.id+" fetchMarketLeverageTiers() supports swap markets only");const i={instrument_id:s.id},n=await this.publicSwapGetPublicInstrument(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseMarketLeverageTiers(r,s)}parseMarketLeverageTiers(e,t){const s=[],i=this.safeValue(e,"open_max_limits",{});for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(e,"instrument_id");t=this.safeMarket(a),s.push({tier:this.sum(n,1),currency:t.settle,minNotional:void 0,maxNotional:this.safeNumber(r,"max_limit"),maintenanceMarginRate:void 0,maxLeverage:this.safeNumber(r,"leverage"),info:r})}return s}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="cross")throw new QR(this.id+" only cross margin is supported")}else(i==="margin"||n===!0)&&(r="cross");return[r,t]}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSpotGetCurrencies(t),i=this.safeValue(s,"data");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);for(let r=0;r<e.length;r++){const a=e[r],o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o);if(t===void 0||this.inArray(d,t)){this.safeValue(i,d)===void 0&&(i[d]=this.depositWithdrawFee({}),i[d].info=[]),i[d].info.push(a);const u=this.safeString(a,"chain"),h=this.safeValue(a,"min_withdraw_fee"),f={fee:h,percentage:h!==void 0?!1:void 0},l={fee:void 0,percentage:void 0};if(u!==void 0){const m=this.networkIdToCode(u);i[d].networks[m]={withdraw:f,deposit:l}}else i[d].withdraw=f,i[d].deposit=l}}const n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.currency(a);i[a]=this.assignDefaultDepositWithdrawFees(i[a],o)}return i}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",d=t[1]==="spot"?"/v3":"/swap/v2",c="/"+this.implodeParams(e,i),u=d+c;let h=this.urls.api.rest+u;const f=this.omit(i,this.extractParams(e));let l=this.urlencode(this.keysort(f));if(a){let m,g;if(d==="/swap/v2"){if(g=this.milliseconds().toString(),m=g+s+u,s==="GET")l&&(m+="?"+l);else if(s==="POST"){const w=JSON.stringify(i);l=w,m+=w}}else g=this.nonce().toString(),m=l;const y=this.hmac(this.encode(m),this.encode(this.secret));s==="GET"?l&&(h+="?"+l):s==="POST"&&(n={"Content-Type":"application/x-www-form-urlencoded"},l&&(r=l)),n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":y,"ACCESS-TIMESTAMP":g}}else l&&(h+="?"+l);return{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c==="0"||c==="200")return;const u=this.id+" "+r;if(c===void 0)throw new YR(u);const h=[Gc,u],[f,l]=this.safeValue(this.exceptions.exact,c,h);throw new f(l)}};const i4=re,{ArgumentsRequired:ab,ExchangeError:Uc,OrderNotFound:ob,AuthenticationError:db,InsufficientFunds:cb,InvalidOrder:id,InvalidNonce:n4,OnMaintenance:r4,RateLimitExceeded:ub,BadRequest:$c,PermissionDenied:hb}=Q,{TICK_SIZE:a4}=ne,Cn=ae;var xT=class extends i4{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["LT"],rateLimit:350,version:"v1.1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!0,setMargin:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","45m":"45","1h":"60","2h":"120","3h":"180","4h":"240","1d":"D","1w":"W","1M":"M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:{public:"https://api.exmo.com",private:"https://api.exmo.com",web:"https://exmo.me"},www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685"],fees:"https://exmo.com/en/docs/fees"},api:{web:{get:["ctrl/feesAndLimits","en/docs/fees"]},public:{get:["currency","currency/list/extended","order_book","pair_settings","ticker","trades","candles_history","required_amount","payments/providers/crypto/list"]},private:{post:["user_info","order_create","order_cancel","stop_market_order_create","stop_market_order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","code_check","wallet_history","wallet_operations","margin/user/order/create","margin/user/order/update","margin/user/order/cancel","margin/user/position/close","margin/user/position/margin_add","margin/user/position/margin_remove","margin/currency/list","margin/pair/list","margin/settings","margin/funding/list","margin/user/info","margin/user/order/list","margin/user/order/history","margin/user/order/trades","margin/user/order/max_quantity","margin/user/position/list","margin/user/position/margin_remove_info","margin/user/position/margin_add_info","margin/user/wallet/list","margin/user/wallet/history","margin/user/trade/list","margin/trades","margin/liquidation/feed"]}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004")},transaction:{tierBased:!1,percentage:!1}},options:{networks:{ETH:"ERC20",TRX:"TRC20"},fetchTradingFees:{method:"fetchPrivateTradingFees"},margin:{fillResponseFromRequest:!0}},commonCurrencies:{GMT:"GMT Token"},precisionMode:a4,exceptions:{exact:{40005:db,40009:n4,40015:Uc,40016:r4,40017:db,40032:hb,40033:hb,40034:ub,50052:cb,50054:cb,50304:ob,50173:ob,50277:id,50319:id,50321:id,50381:id},broad:{"range period is too long":$c,"invalid syntax":$c,"API rate limit exceeded":ub}}})}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={position_id:n.id,quantity:t};let a;s==="add"?a="privatePostMarginUserPositionMarginAdd":s==="reduce"&&(a="privatePostMarginUserPositionMarginReduce");const o=await this[a](this.extend(r,i)),d=this.parseMarginModification(o,n),c=this.safeValue(this.options,"margin",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.type=s,d.amount=t),d}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:this.safeValue(t,"quote"),symbol:this.safeSymbol(void 0,t),total:void 0,status:"ok"}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostMarginPairList(e),s=this.safeValue(t,"pairs",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeSymbol(a,void 0,"_"),d=this.safeString(r,"trade_maker_fee"),c=this.safeString(r,"trade_taker_fee"),u=this.parseNumber(Cn.stringDiv(d,"100")),h=this.parseNumber(Cn.stringDiv(c,"100"));i[o]={info:r,symbol:o,maker:u,taker:h,percentage:!0,tierBased:!0}}return i}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPairSettings(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.id,{}),o=this.safeString(a,"commission_maker_percent"),d=this.safeString(a,"commission_taker_percent"),c=this.parseNumber(Cn.stringDiv(o,"100")),u=this.parseNumber(Cn.stringDiv(d,"100"));s[n]={info:a,symbol:n,maker:c,taker:u,percentage:!0,tierBased:!0}}return s}parseFixedFloatValue(e){if(e===void 0||e==="-")return;if(e==="")return 0;const t=e.indexOf("%")>=0,i=e.split(" ")[0].replace("%",""),n=parseFloat(i);if(n>0&&t)throw new Uc(this.id+" parseFixedFloatValue() detected an unsupported non-zero percentage-based fee "+e);return n}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r];if(e!==void 0&&!this.inArray(a,e))continue;i[a]={deposit:void 0,withdraw:void 0};const o=this.currency(a),d=this.safeString(o,"id"),c=this.safeValue(s,d,[]);for(let u=0;u<c.length;u++){const h=c[u],f=this.safeString(h,"type"),l=this.safeString(h,"commission_desc"),m=this.parseFixedFloatValue(l);i[a][f]=m}i[a].info=c}return this.options.transactionFees=i,i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i=this.parseDepositWithdrawFees(s,e);return this.options.transactionFees=i,i}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e);for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"type"),a=this.safeString(n,"name"),o=this.networkIdToCode(a,this.safeString(t,"code")),d=this.safeString(n,"commission_desc");let c=[],u;d!==void 0&&(c=d.split("%"),u=c.length>=2),this.safeValue(s.networks,o)===void 0&&(s.networks[o]={withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}),s.networks[o][r]={fee:this.parseFixedFloatValue(this.safeString(c,0)),percentage:u}}return this.assignDefaultDepositWithdrawFees(s)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyListExtended(e),s=await this.publicGetPaymentsProvidersCryptoList(e),i={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"name"),o=this.safeString(r,"description"),d=this.safeValue(s,a);let c=!1,u="crypto";const h={deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}};let f,l,m;if(d===void 0)c=!0,u="fiat";else for(let y=0;y<d.length;y++){const w=d[y],b=this.safeString(w,"type"),S=this.safeNumber(w,"min");let v=this.safeNumber(w,"max");v===0&&(v=void 0);const T=this.safeValue(w,"enabled");if(b==="deposit"?T&&!l?l=!0:T||(l=!1):b==="withdraw"&&(T&&!m?m=!0:T||(m=!1)),T&&(c=!0,(h[b].min===void 0||S<h[b].min)&&(h[b].min=S,h[b].max=v,b==="withdraw"))){const I=this.safeString(w,"commission_desc");f=this.parseFixedFloatValue(I)}}const g=this.safeCurrencyCode(a);i[g]={id:a,code:g,name:o,type:u,active:c,deposit:l,withdraw:m,fee:f,precision:this.parseNumber("1e-8"),limits:h,info:d}}return i}async fetchMarkets(e={}){const t=await this.publicGetPairSettings(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=r.replace("_","/"),[d,c]=o.split("/"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeString(a,"commission_taker_percent"),l=this.safeString(a,"commission_maker_percent");i.push({id:r,symbol:o,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(Cn.stringDiv(f,"100")),maker:this.parseNumber(Cn.stringDiv(l,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_quantity"),max:this.safeNumber(a,"max_quantity")},price:{min:this.safeNumber(a,"min_price"),max:this.safeNumber(a,"max_price")},cost:{min:this.safeNumber(a,"min_amount"),max:this.safeNumber(a,"max_amount")}},info:a})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.safeValue(this.options,"fetchOHLCV"),d=this.safeInteger(o,"maxLimit",3e3),c=this.parseTimeframe(t),u=this.milliseconds();if(s===void 0)i===void 0&&(i=1e3),i>d&&(i=d),a.from=parseInt(u/1e3)-i*c-1,a.to=parseInt(u/1e3);else if(a.from=parseInt(s/1e3)-1,i===void 0)a.to=parseInt(u/1e3);else{if(i>d)throw new $c(this.id+" fetchOHLCV() will serve "+d.toString()+" candles at most");const l=this.sum(s,i*c*1e3);a.to=parseInt(l/1e3)}const h=await this.publicGetCandlesHistory(this.extend(a,n)),f=this.safeValue(h,"candles",[]);return this.parseOHLCVs(f,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",{}),i=this.safeValue(e,"reserved",{}),n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.account();a in s&&(d.free=this.safeString(s,a)),a in i&&(d.used=this.safeString(i,a)),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,i.id);return this.parseOrderBook(a,i.symbol,void 0,"bid","ask")}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>2048){const d=this.ids.length;throw new Uc(this.id+" fetchOrderBooks() has "+d.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a={},o=Object.keys(r);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeSymbol(c);a[u]=this.parseOrderBook(r[c],u,void 0,"bid","ask")}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last_trade");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"vol_curr"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a,void 0,"_"),d=o.symbol,c=this.safeValue(s,a);i[d]=this.parseTicker(c,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.market(e);return this.parseTicker(s[i.id],i)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"trade_id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.safeString(e,"amount"),d=this.safeString(e,"type"),c=void 0,u=this.safeString(e,"pair");t=this.safeMarket(u,t,"_");const h=t.symbol,f=this.safeString(e,"exec_type");let l;const m=this.safeString(e,"commission_amount");if(m!==void 0){const g=this.safeString(e,"commission_currency"),y=this.safeCurrencyCode(g);let w=this.safeString(e,"commission_percent");w!==void 0&&(w=Cn.stringDiv(w,"1000",18)),l={cost:m,currency:y,rate:w}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,order:n,type:c,side:d,takerOrMaker:f,price:r,amount:a,cost:o,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ab(this.id+" fetchMyTrades() requires a symbol argument (a single symbol or an array)");await this.loadMarkets();let n,r;if(Array.isArray(e)){if(e.length<1)throw new ab(this.id+" fetchMyTrades() requires a non-empty symbol array");n=this.marketIds(e).join(",")}else r=this.market(e),n=r.id;const a={pair:n};s!==void 0&&(a.limit=s);const o=await this.privatePostUserTrades(this.extend(a,i));let d=[];const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=c[u],f=this.safeMarket(h,void 0,"_"),l=o[h],m=this.parseTrades(l,f,t,s);d=this.arrayConcat(d,m)}return this.filterBySinceLimit(d,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=(t==="market"?t+"_":"")+s;let c=n;t==="market"&&n===void 0&&(c=0);const u={pair:a.id,quantity:this.amountToPrecision(a.symbol,i),type:d,price:this.priceToPrecision(a.symbol,c)};let h="privatePostOrderCreate",f=this.safeValue2(r,"client_id","clientOrderId");if(f!==void 0){if(f=this.safeInteger2(r,"client_id","clientOrderId"),f===void 0)throw new $c(this.id+" createOrder() client order id must be an integer / numeric literal");u.client_id=f,r=this.omit(r,["client_id","clientOrderId"])}if(t==="stop"||t==="stop_limit"||t==="trailing_stop"){const w=this.safeNumber2(r,"stop_price","stopPrice");if(w===void 0)throw new id(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");r=this.omit(r,["stopPrice","stop_price"]),u.stop_price=this.priceToPrecision(e,w),h="privatePostMarginUserOrderCreate"}const l=await this[h](this.extend(u,r)),m=this.safeString(l,"order_id"),g=this.milliseconds(),y="open";return{id:m,info:l,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,status:y,symbol:a.symbol,type:t,side:s,price:n,cost:void 0,amount:i,remaining:i,filled:0,fee:void 0,trades:void 0,clientOrderId:f,average:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e.toString()},n=await this.privatePostOrderTrades(this.extend(i,s)),r=this.parseOrder(n);return this.extend(r,{id:e.toString()})}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));const a={order_id:e.toString()},o=await this.privatePostOrderTrades(this.extend(a,n)),d=this.safeValue(o,"trades");return this.parseTrades(d,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.privatePostUserOpenOrders(i),r=Object.keys(n);let a=[];for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=this.parseOrders(n[d],c);a=this.arrayConcat(a,u)}return this.filterBySymbolSinceLimit(a,e,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeTimestamp(e,"created"),n=this.safeString(e,"type");let r;"pair"in e?r=e.pair:"in_currency"in e&&"out_currency"in e&&(n==="buy"?r=e.in_currency+"_"+e.out_currency:r=e.out_currency+"_"+e.in_currency),t=this.safeMarket(r,t);const a=t.symbol;let o=this.safeString(e,"quantity");if(o===void 0){const f=n==="buy"?"in_amount":"out_amount";o=this.safeString(e,f)}const d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeValue(e,"trades",[]),h=this.safeInteger(e,"client_id");return this.safeOrder({id:s,clientOrderId:h,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:void 0,symbol:a,type:"limit",timeInForce:void 0,postOnly:void 0,side:n,price:d,stopPrice:void 0,triggerPrice:void 0,cost:c,amount:o,filled:void 0,remaining:void 0,average:void 0,trades:u,fee:void 0,info:e},t)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.offset=s),s!==void 0&&(n.limit=s);let r;e!==void 0&&(r=this.market(e));const a=await this.privatePostUserCancelledOrders(this.extend(n,i));return this.parseOrders(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostDepositAddress(t),i=this.safeString(s,e);let n,r;if(i){const a=i.split(",");n=a[0],a.length>1&&(r=a[1])}return this.checkAddress(n),{currency:e,address:n,tag:r,network:void 0,info:s}}getMarketFromTrades(e){const t=this.indexBy(e,"pair"),s=Object.keys(t);if(s.length===1)return this.markets[s[0]]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,address:s};i!==void 0&&(a.invoice=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.transport=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawCrypt(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={transferred:"ok",paid:"ok",pending:"pending",processing:"pending",verifying:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp2(e,"dt","created");let i=this.safeString(e,"amount");i!==void 0&&(i=Cn.stringAbs(i));let n=this.safeString(e,"txid");if(n===void 0){const f=this.safeValue(e,"extra",{}),l=this.safeString(f,"txid");l!==""&&(n=l)}const r=this.safeString(e,"type"),a=this.safeString2(e,"curr","currency"),o=this.safeCurrencyCode(a,t);let d,c;const u=this.safeString(e,"account");if(r==="deposit")c=u;else if(r==="withdrawal"&&(d=u,d!==void 0)){const f=d.split(":");f.length===2&&(d=this.safeString(f,1),d=d.replace(" ",""))}const h={currency:void 0,cost:void 0,rate:void 0};if(!this.fees.transaction.percentage){const f=r==="withdrawal"?"withdraw":"deposit";let l=this.safeString(e,"commission");if(l===void 0){const g=this.safeValue(this.options,"transactionFees",{}),y=this.safeValue(g,o,{});l=this.safeString(y,f)}this.safeString(e,"provider")==="cashback"&&(l="0"),l!==void 0&&(r==="withdrawal"&&(i=Cn.stringSub(i,l)),h.cost=this.parseNumber(l),h.currency=o)}return{info:e,id:this.safeString2(e,"order_id","task_id"),txid:n,type:r,currency:o,network:this.safeString(e,"provider"),amount:i,status:this.parseTransactionStatus(this.safeStringLower(e,"status")),timestamp:s,datetime:this.iso8601(s),address:d,addressFrom:void 0,addressTo:d,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:this.safeTimestamp(e,"updated"),comment:c,fee:h}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.date=parseInt(t/1e3));let r;e!==void 0&&(r=this.currency(e));const a=await this.privatePostWalletHistory(this.extend(n,i));return this.parseTransactions(a.history,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"withdraw"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"withdraw"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposit(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"deposit"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"deposit"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";if(t!=="web"&&(a+=this.version+"/"),a+=e,t==="public"||t==="web")Object.keys(i).length&&(a+="?"+this.urlencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.urlencode(this.extend({nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&("result"in a||"errmsg"in a)){let c=this.safeValue(a,"result",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){let u;const h=this.safeString2(a,"error","errmsg"),f=h.split(":");if(f.length>1){const g=f[0].split(" ");u=g.length>1?g[1]:g[0]}const m=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,m),this.throwBroadlyMatchedException(this.exceptions.broad,h,m),new Uc(m)}}}};const o4=re,{ExchangeError:Wc,AuthenticationError:Nr,InsufficientFunds:d4,BadSymbol:c4,OrderNotFound:u4}=Q,{TICK_SIZE:h4}=ne,nd=ae;var Ah=class extends o4{describe(){return this.deepExtend(super.describe(),{id:"ndax",name:"NDAX",countries:["CA"],rateLimit:1e3,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2419200","4M":"9676800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",test:{public:"https://ndaxmarginstaging.cdnhop.net:8443/AP",private:"https://ndaxmarginstaging.cdnhop.net:8443/AP"},api:{public:"https://api.ndax.io:8443/AP",private:"https://api.ndax.io:8443/AP"},www:"https://ndax.io",doc:["https://apidoc.ndax.io/"],fees:"https://ndax.io/fees",referral:"https://one.ndax.io/bfQiSL"},api:{public:{get:{Activate2FA:1,Authenticate2FA:1,AuthenticateUser:1,GetL2Snapshot:1,GetLevel1:1,GetValidate2FARequiredEndpoints:1,LogOut:1,GetTickerHistory:1,GetProduct:1,GetProducts:1,GetInstrument:1,GetInstruments:1,Ping:1,trades:1,GetLastTrades:1,SubscribeLevel1:1,SubscribeLevel2:1,SubscribeTicker:1,SubscribeTrades:1,SubscribeBlockTrades:1,UnsubscribeBlockTrades:1,UnsubscribeLevel1:1,UnsubscribeLevel2:1,UnsubscribeTicker:1,UnsubscribeTrades:1,Authenticate:1}},private:{get:{GetUserAccountInfos:1,GetUserAccounts:1,GetUserAffiliateCount:1,GetUserAffiliateTag:1,GetUserConfig:1,GetAllUnredactedUserConfigsForUser:1,GetUnredactedUserConfigByKey:1,GetUserDevices:1,GetUserReportTickets:1,GetUserReportWriterResultRecords:1,GetAccountInfo:1,GetAccountPositions:1,GetAllAccountConfigs:1,GetTreasuryProductsForAccount:1,GetAccountTrades:1,GetAccountTransactions:1,GetOpenTradeReports:1,GetAllOpenTradeReports:1,GetTradesHistory:1,GetOpenOrders:1,GetOpenQuotes:1,GetOrderFee:1,GetOrderHistory:1,GetOrdersHistory:1,GetOrderStatus:1,GetOmsFeeTiers:1,GetAccountDepositTransactions:1,GetAccountWithdrawTransactions:1,GetAllDepositRequestInfoTemplates:1,GetDepositInfo:1,GetDepositRequestInfoTemplate:1,GetDeposits:1,GetDepositTicket:1,GetDepositTickets:1,GetOMSWithdrawFees:1,GetWithdrawFee:1,GetWithdraws:1,GetWithdrawTemplate:1,GetWithdrawTemplateTypes:1,GetWithdrawTicket:1,GetWithdrawTickets:1},post:{AddUserAffiliateTag:1,CancelUserReport:1,RegisterNewDevice:1,SubscribeAccountEvents:1,UpdateUserAffiliateTag:1,GenerateTradeActivityReport:1,GenerateTransactionActivityReport:1,GenerateTreasuryActivityReport:1,ScheduleTradeActivityReport:1,ScheduleTransactionActivityReport:1,ScheduleTreasuryActivityReport:1,CancelAllOrders:1,CancelOrder:1,CancelQuote:1,CancelReplaceOrder:1,CreateQuote:1,ModifyOrder:1,SendOrder:1,SubmitBlockTrade:1,UpdateQuote:1,CancelWithdraw:1,CreateDepositTicket:1,CreateWithdrawTicket:1,SubmitDepositTicketComment:1,SubmitWithdrawTicketComment:1,GetOrderHistoryByOrderId:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0,login:!0,password:!0},precisionMode:h4,exceptions:{exact:{Not_Enough_Funds:d4,"Server Error":Wc,"Resource Not Found":u4},broad:{"Invalid InstrumentId":c4,"This endpoint requires 2FACode along with the payload":Nr}},options:{omsId:1,orderTypes:{Market:1,Limit:2,StopMarket:3,StopLimit:4,TrailingStopMarket:5,TrailingStopLimit:6,BlockTrade:7}}})}async signIn(e={}){if(this.checkRequiredCredentials(),this.login===void 0||this.password===void 0)throw new Nr(this.id+" signIn() requires exchange.login, exchange.password");let t={grant_type:"client_credentials"};const s=await this.publicGetAuthenticate(this.extend(t,e));let i=this.safeString(s,"SessionToken");if(i!==void 0)return this.options.sessionToken=i,s;const n=this.safeString(s,"Pending2FaToken");if(n!==void 0){if(this.twofa===void 0)throw new Nr(this.id+" signIn() requires exchange.twofa credentials");this.options.pending2faToken=n,t={Code:this.oath()};const r=await this.publicGetAuthenticate2FA(this.extend(t,e));return i=this.safeString(r,"SessionToken"),this.options.sessionToken=i,r}return s}async fetchCurrencies(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetProducts(this.extend(s,e)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"ProductId"),d=this.safeString(a,"ProductFullName"),c=this.safeString(a,"ProductType"),u=this.safeCurrencyCode(this.safeString(a,"Product")),f=!this.safeValue(a,"IsDisabled");n[u]={id:o,name:d,code:u,type:c,precision:this.safeNumber(a,"TickSize"),info:a,active:f,deposit:void 0,withdraw:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchMarkets(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetInstruments(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"InstrumentId"),d=this.safeString(a,"Product1"),c=this.safeString(a,"Product2"),u=this.safeCurrencyCode(this.safeString(a,"Product1Symbol")),h=this.safeCurrencyCode(this.safeString(a,"Product2Symbol")),f=this.safeString(a,"SessionStatus"),l=this.safeValue(a,"IsDisable"),m=f==="Running";n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m&&!l,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"QuantityIncrement"),price:this.safeNumber(a,"PriceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"MinimumQuantity"),max:void 0},price:{min:this.safeNumber(a,"MinimumPrice"),max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=6,a=8){let o;const d={symbol:t,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let c=0;c<e.length;c++){const u=e[c];if(s===void 0)s=this.safeInteger(u,2);else{const m=this.safeInteger(u,2);s=Math.max(s,m)}if(o===void 0)o=this.safeInteger(u,0);else{const m=this.safeInteger(u,0);o=Math.max(o,m)}const h=this.parseBidAsk(u,r,a),l=this.safeInteger(u,9)?n:i;d[l].push(h)}return d.bids=this.sortBy(d.bids,0,!0),d.asks=this.sortBy(d.asks,0),d.timestamp=s,d.datetime=this.iso8601(s),d.nonce=o,d}async fetchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);t=t===void 0?100:t;const r={omsId:i,InstrumentId:n.id,Depth:t},a=await this.publicGetGetL2Snapshot(this.extend(r,s));return this.parseOrderBook(a,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"TimeStamp"),i=this.safeString(e,"InstrumentId");t=this.safeMarket(i,t);const n=this.safeSymbol(i,t),r=this.safeString(e,"LastTradedPx"),a=this.safeString(e,"Rolling24HrPxChangePercent"),o=this.safeString(e,"Rolling24HrPxChange"),d=this.safeString(e,"SessionOpen"),c=this.safeString(e,"Rolling24HrVolume"),u=this.safeString(e,"Rolling24HrNotional");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"SessionHigh"),low:this.safeString(e,"SessionLow"),bid:this.safeString(e,"BestBid"),bidVolume:void 0,ask:this.safeString(e,"BestOffer"),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n={omsId:s,InstrumentId:i.id},r=await this.publicGetGetLevel1(this.extend(n,t));return this.parseTicker(r,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,3),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e),o={omsId:r,InstrumentId:a.id,Interval:this.timeframes[t]},d=this.parseTimeframe(t),c=this.milliseconds();s===void 0?i!==void 0&&(o.FromDate=this.ymdhms(c-d*i*1e3),o.ToDate=this.ymdhms(c)):(o.FromDate=this.ymdhms(s),i===void 0?o.ToDate=this.ymdhms(c):o.ToDate=this.ymdhms(this.sum(s,d*i*1e3)));const u=await this.publicGetGetTickerHistory(this.extend(o,n));return this.parseOHLCVs(u,a,t,s,i)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u,h,f;if(Array.isArray(e))s=this.safeString(e,3),i=this.safeString(e,2),r=this.safeInteger(e,6),a=this.safeString(e,0),o=this.safeString(e,1),d=this.safeValue(e,8)?"sell":"buy",c=this.safeString(e,4);else{r=this.safeInteger2(e,"TradeTimeMS","ReceiveTime"),a=this.safeString(e,"TradeId"),c=this.safeString2(e,"OrderId","OrigOrderId"),o=this.safeString2(e,"InstrumentId","Instrument"),s=this.safeString(e,"Price"),i=this.safeString(e,"Quantity"),n=this.safeString2(e,"Value","GrossValueExecuted"),u=this.safeStringLower(e,"MakerTaker"),d=this.safeStringLower(e,"Side"),f=this.safeStringLower(e,"OrderType");const m=this.safeString(e,"Fee");if(m!==void 0){const g=this.safeString(e,"FeeProductId"),y=this.safeCurrencyCode(g);h={cost:m,currency:y}}}const l=this.safeSymbol(o,t);return this.safeTrade({info:e,id:a,symbol:l,timestamp:r,datetime:this.iso8601(r),order:c,type:f,side:d,takerOrMaker:u,price:s,amount:i,cost:n,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e),a={omsId:n,InstrumentId:r.id};s!==void 0&&(a.Count=s);const o=await this.publicGetGetLastTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchAccounts(e={}){if(!this.login)throw new Nr(this.id+" fetchAccounts() requires exchange.login email credential");const t=this.safeInteger(this.options,"omsId",1);this.checkRequiredCredentials();const s={omsId:t,UserId:this.uid,UserName:this.login},i=await this.privateGetGetUserAccounts(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=this.safeString(i,r);n.push({id:a,type:void 0,currency:void 0,info:a})}return n}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"ProductId");if(n in this.currencies_by_id){const r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"Amount"),a.used=this.safeString(i,"Hold"),t[r]=a}}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const s=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),i=this.safeInteger2(e,"accountId","AccountId",s);e=this.omit(e,["accountId","AccountId"]);const n={omsId:t,AccountId:i},r=await this.privateGetGetAccountPositions(this.extend(n,e));return this.parseBalance(r)}parseLedgerEntryType(e){const t={Trade:"trade",Deposit:"transaction",Withdraw:"transaction",Transfer:"transfer",OrderHold:"trade",WithdrawHold:"transaction",DepositHold:"transaction",MarginHold:"trade",ManualHold:"trade",ManualEntry:"trade",MarginAcquisition:"trade",MarginRelinquish:"trade",MarginQuoteHold:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"ProductId"),i=this.safeString(e,"CR"),n=this.safeString(e,"DR");let r,a;nd.stringLt(i,"0")?(r=i,a="in"):nd.stringLt(n,"0")&&(r=n,a="out");let o;const d=this.safeString(e,"Balance");a==="out"?o=nd.stringAdd(d,r):a==="in"&&(o=nd.stringMax("0",nd.stringSub(d,r)));const c=this.safeInteger(e,"TimeStamp");return{info:e,id:this.safeString(e,"TransactionId"),direction:a,account:this.safeString(e,"AccountId"),referenceId:this.safeString(e,"ReferenceId"),referenceAccount:this.safeString(e,"Counterparty"),type:this.parseLedgerEntryType(this.safeString(e,"ReferenceType")),currency:this.safeCurrencyCode(s,t),amount:this.parseNumber(r),before:this.parseNumber(o),after:this.parseNumber(d),status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};s!==void 0&&(o.Depth=s);const d=await this.privateGetGetAccountTransactions(this.extend(o,i));let c;return e!==void 0&&(c=this.currency(e)),this.parseLedger(d,c,t,s)}parseOrderStatus(e){const t={Accepted:"open",Rejected:"rejected",Working:"open",Canceled:"canceled",Expired:"expired",FullyExecuted:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"ReceiveTime"),i=this.safeString(e,"Instrument");return this.safeOrder({id:this.safeString2(e,"ReplacementOrderId","OrderId"),clientOrderId:this.safeString2(e,"ReplacementClOrdId","ClientOrderId"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"LastUpdatedTime"),status:this.parseOrderStatus(this.safeString(e,"OrderState")),symbol:this.safeSymbol(i,t),type:this.safeStringLower(e,"OrderType"),timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"Side"),price:this.safeString(e,"Price"),stopPrice:this.parseNumber(this.omitZero(this.safeString(e,"StopPrice"))),cost:this.safeString(e,"GrossValueExecuted"),amount:this.safeString(e,"OrigQuantity"),filled:this.safeString(e,"QuantityExecuted"),average:this.safeString(e,"AvgPrice"),remaining:void 0,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(r,"accountId","AccountId",o),c=this.safeInteger2(r,"ClientOrderId","clientOrderId");r=this.omit(r,["accountId","AccountId","clientOrderId","ClientOrderId"]);const u=this.market(e),h=s==="buy"?0:1,f={InstrumentId:parseInt(u.id),omsId:a,AccountId:d,TimeInForce:1,Side:h,Quantity:parseFloat(this.amountToPrecision(e,i)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(t))};n!==void 0&&(f.LimitPrice=parseFloat(this.priceToPrecision(e,n))),c!==void 0&&(f.ClientOrderId=c);const l=await this.privatePostSendOrder(this.extend(f,r));return this.parseOrder(l,u)}async editOrder(e,t,s,i,n,r=void 0,a={}){const o=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const d=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),c=this.safeInteger2(a,"accountId","AccountId",d),u=this.safeInteger2(a,"ClientOrderId","clientOrderId");a=this.omit(a,["accountId","AccountId","clientOrderId","ClientOrderId"]);const h=this.market(t),f=i==="buy"?0:1,l={OrderIdToReplace:parseInt(e),InstrumentId:parseInt(h.id),omsId:o,AccountId:c,TimeInForce:1,Side:f,Quantity:parseFloat(this.amountToPrecision(t,n)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(s))};r!==void 0&&(l.LimitPrice=parseFloat(this.priceToPrecision(t,r))),u!==void 0&&(l.ClientOrderId=u);const m=await this.privatePostCancelReplaceOrder(this.extend(l,a));return this.parseOrder(m,h)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetTradesHistory(this.extend(o,i));return this.parseTrades(c,d,t,s)}async cancelAllOrders(e=void 0,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r={omsId:s,AccountId:n};if(e!==void 0){const o=this.market(e);r.IntrumentId=o.id}return await this.privatePostCancelAllOrders(this.extend(r,t))}async cancelOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let n;t!==void 0&&(n=this.market(t));const r={omsId:i},a=this.safeInteger2(s,"clientOrderId","ClOrderId");a!==void 0?r.ClOrderId=a:r.OrderId=parseInt(e),s=this.omit(s,["clientOrderId","ClOrderId"]);const o=await this.privatePostCancelOrder(this.extend(r,s)),d=this.parseOrder(o,n);return this.extend(d,{id:e,clientOrderId:a})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.market(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetOpenOrders(this.extend(d,i));return this.parseOrders(c,o,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetOrdersHistory(this.extend(o,i));return this.parseOrders(c,d,t,s)}async fetchOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const n=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),r=this.safeInteger2(s,"accountId","AccountId",n);s=this.omit(s,["accountId","AccountId"]);let a;t!==void 0&&(a=this.market(t));const o={omsId:i,AccountId:r,OrderId:parseInt(e)},d=await this.privateGetGetOrderStatus(this.extend(o,s));return this.parseOrder(d,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let a;t!==void 0&&(a=this.market(t));const o={OMSId:parseInt(r),OrderId:parseInt(e)},d=await this.privatePostGetOrderHistoryByOrderId(this.extend(o,n)),c=this.groupBy(d,"ChangeReason"),u=this.safeValue(c,"Trade",[]);return this.parseTrades(u,a,s,i)}async fetchDepositAddress(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r=this.currency(e),a={omsId:s,AccountId:n,ProductId:r.id,GenerateNewKey:!1},o=await this.privateGetGetDepositInfo(this.extend(a,t));return this.parseDepositAddress(o,r)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"DepositInfo"),i=JSON.parse(s),n=i.length,a=this.safeString(i,n-1).split("?memo="),o=this.safeString(a,0),d=this.safeString(a,1);let c;return t!==void 0&&(c=t.code),this.checkAddress(o),{currency:c,address:o,tag:d,network:void 0,info:e}}async createDepositAddress(e,t={}){const s={GenerateNewKey:!0};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetDeposits(this.extend(d,i));return this.parseTransactions(c,o,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetWithdraws(this.extend(d,i));return this.parseTransactions(c,o,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Confirmed:"pending",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected"},withdrawal:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Pending2Fa:"pending",AutoAccepted:"pending",Delayed:"pending",UserCanceled:"canceled",AdminCanceled:"canceled",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected",Submitted:"pending",Confirmed:"pending",ManuallyConfirmed:"pending",Confirmed2Fa:"pending"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"ProductId"),r=this.safeCurrencyCode(n,t);let a,o;"DepositId"in e?(s=this.safeString(e,"DepositId"),o="deposit"):"WithdrawId"in e&&(s=this.safeString(e,"WithdrawId"),o="withdrawal");const d=this.safeString(e,"TemplateForm");let c,u=this.safeInteger(e,"LastUpdateTimeStamp");if(d!==void 0){const y=JSON.parse(d);c=this.safeString(y,"ExternalAddress"),i=this.safeString(y,"TxId"),a=this.safeInteger(y,"TimeSubmitted"),u=this.safeInteger(y,"LastUpdated",u)}const h=c,f=this.parseTransactionStatusByType(this.safeString(e,"TicketStatus"),o),l=this.safeNumber(e,"Amount"),m=this.safeNumber(e,"FeeAmount");let g;return m!==void 0&&(g={currency:r,cost:m}),{info:e,id:s,txid:i,timestamp:a,datetime:this.iso8601(a),address:c,addressTo:h,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:l,currency:r,status:f,updated:u,fee:g}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.safeString(this.options,"sessionToken")===void 0)throw new Nr(this.id+" call signIn() method to obtain a session token");if(this.twofa===void 0)throw new Nr(this.id+" withdraw() requires exchange.twofa credentials");this.checkAddress(s);const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(n,"accountId","AccountId",o);n=this.omit(n,["accountId","AccountId"]);const c=this.currency(e),u={omsId:a,AccountId:d,ProductId:c.id},h=await this.privateGetGetWithdrawTemplateTypes(u),f=this.safeValue(h,"TemplateTypes",[]),l=this.safeValue(f,0);if(l===void 0)throw new Wc(this.id+" withdraw() could not find a withdraw template type for "+c.code);const m=this.safeString(l,"TemplateName"),g={omsId:a,AccountId:d,ProductId:c.id,TemplateType:m,AccountProviderId:l.AccountProviderId},y=await this.privateGetGetWithdrawTemplate(g),w=this.safeString(y,"Template");if(w===void 0)throw new Wc(this.id+" withdraw() could not find a withdraw template for "+c.code);const b=JSON.parse(w);b.ExternalAddress=s,i!==void 0&&"Memo"in b&&(b.Memo=i);const S={omsId:a,AccountId:d,ProductId:c.id,TemplateForm:this.json(b),TemplateType:m},v={TfaType:"Google",TFaCode:this.oath(),Payload:this.json(S)},T=await this.privatePostCreateWithdrawTicket(this.deepExtend(v,n));return this.parseTransaction(T,c)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public"){if(e==="Authenticate"){const d=this.login+":"+this.password,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c)}}else if(e==="Authenticate2FA"){const d=this.safeString(this.options,"pending2faToken");d!==void 0&&(n={Pending2FaToken:d},o=this.omit(o,"pending2faToken"))}Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="private"){this.checkRequiredCredentials();const d=this.safeString(this.options,"sessionToken");if(d===void 0){const c=this.nonce().toString(),u=c+this.uid+this.apiKey,h=this.hmac(this.encode(u),this.encode(this.secret));n={Nonce:c,APIKey:this.apiKey,Signature:h,UserId:this.uid}}else n={APToken:d};s==="POST"?(n["Content-Type"]="application/json",r=this.json(o)):Object.keys(o).length&&(a+="?"+this.urlencode(o))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===404)throw new Nr(this.id+" "+r);if(a===void 0)return;const c=this.safeString(a,"errormsg");if(c!==void 0&&c!==""){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new Wc(u)}}};const f4=Ah;var l4=class extends f4{describe(){return this.deepExtend(super.describe(),{id:"flowbtc",name:"flowBTC",countries:["BR"],rateLimit:1e3,urls:{logo:"https://user-images.githubusercontent.com/51840849/87443317-01c0d080-c5fe-11ea-95c2-9ebe1a8fafd9.jpg",api:{public:"https://api.flowbtc.com.br:8443/ap/",private:"https://api.flowbtc.com.br:8443/ap/"},www:"https://www.flowbtc.com.br",doc:"https://www.flowbtc.com.br/api.html"},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.005}}})}};const p4=re,_e=ae,{TICK_SIZE:m4}=ne,{ExchangeError:ze,BadRequest:Ws,ArgumentsRequired:Mn,AuthenticationError:Ca,PermissionDenied:fb,AccountSuspended:lb,InsufficientFunds:rd,RateLimitExceeded:g4,ExchangeNotAvailable:zc,BadSymbol:ad,InvalidOrder:Tt,OrderNotFound:jc,NotSupported:y4,AccountNotEnabled:w4,OrderImmediatelyFillable:pb,BadResponse:b4}=Q;var lg=class extends p4{describe(){return this.deepExtend(super.describe(),{id:"gate",name:"Gate.io",countries:["KR"],rateLimit:10/3,version:"v4",certified:!0,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",doc:"https://www.gate.io/docs/apiv4/en/index.html",www:"https://gate.io/",api:{public:{wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",sub_accounts:"https://api.gateio.ws/api/v4"},private:{withdrawals:"https://api.gateio.ws/api/v4",wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",subAccounts:"https://api.gateio.ws/api/v4"}},test:{public:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"},private:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"}},referral:{url:"https://www.gate.io/ref/2436035",discount:.2}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchNetworkDepositAddress:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchWithdrawals:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},api:{public:{wallet:{get:{currency_chains:1.5}},spot:{get:{currencies:1,"currencies/{currency}":1,currency_pairs:1,"currency_pairs/{currency_pair}":1,tickers:1,order_book:1,trades:1,candlesticks:1}},margin:{get:{currency_pairs:1,"currency_pairs/{currency_pair}":1,"cross/currencies":1,"cross/currencies/{currency}":1,funding_book:1}},futures:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/funding_rate":1.5,"{settle}/insurance":1.5,"{settle}/contract_stats":1.5,"{settle}/liq_orders":1.5}},delivery:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/insurance":1.5}},options:{get:{underlyings:1.5,expirations:1.5,contracts:1.5,"contracts/{contract}":1.5,settlements:1.5,"settlements/{contract}":1.5,order_book:1.5,tickers:1.5,"underlying/tickers/{underlying}":1.5,candlesticks:1.5,"underlying/candlesticks":1.5,trades:1.5}}},private:{withdrawals:{post:{withdrawals:3e3},delete:{"withdrawals/{withdrawal_id}":300}},wallet:{get:{deposit_address:300,withdrawals:300,deposits:300,sub_account_transfers:300,withdraw_status:300,sub_account_balances:300,fee:300,total_balance:300},post:{transfers:300,sub_account_transfers:300}},subAccounts:{get:{sub_accounts:1,"sub_accounts/{user_id}":1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/keys/{key}":1},post:{sub_accounts:1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/lock":1,"sub_accounts/{user_id}/unlock":1},put:{"sub_accounts/{user_id}/keys/{key}":1},delete:{"sub_accounts/{user_id}/keys/{key}":1}},spot:{get:{accounts:1,open_orders:1,orders:1,"orders/{order_id}":1,my_trades:1,price_orders:1,"price_orders/{order_id}":1},post:{batch_orders:1,orders:1,cancel_batch_orders:1,price_orders:1},delete:{orders:1,"orders/{order_id}":1,price_orders:1,"price_orders/{order_id}":1},patch:{"orders/{order_id}":1}},margin:{get:{accounts:1.5,account_book:1.5,funding_accounts:1.5,loans:1.5,"loans/{loan_id}":1.5,"loans/{loan_id}/repayment":1.5,loan_records:1.5,"loan_records/{load_record_id}":1.5,auto_repay:1.5,transferable:1.5,"cross/accounts":1.5,"cross/account_book":1.5,"cross/loans":1.5,"cross/loans/{loan_id}":1.5,"cross/loans/repayments":1.5,"cross/transferable":1.5,"loan_records/{loan_record_id}":1.5,borrowable:1.5,"cross/repayments":1.5,"cross/borrowable":1.5},post:{loans:1.5,merged_loans:1.5,"loans/{loan_id}/repayment":1.5,auto_repay:1.5,"cross/loans":1.5,"cross/loans/repayments":1.5,"cross/repayments":1.5},patch:{"loans/{loan_id}":1.5,"loan_records/{loan_record_id}":1.5},delete:{"loans/{loan_id}":1.5}},futures:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/dual_comp/positions/{contract}":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/dual_mode":1.5,"{settle}/dual_comp/positions/{contract}":1.5,"{settle}/dual_comp/positions/{contract}/margin":1.5,"{settle}/dual_comp/positions/{contract}/leverage":1.5,"{settle}/dual_comp/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},delivery:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/settlements":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},options:{get:{accounts:1.5,account_book:1.5,positions:1.5,"positions/{contract}":1.5,position_close:1.5,orders:1.5,"orders/{order_id}":1.5,my_trades:1.5},post:{orders:1.5},delete:{orders:1.5,"orders/{order_id}":1.5}}}},timeframes:{"10s":"10s","1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","8h":"8h","1d":"1d","7d":"7d","1w":"7d"},commonCurrencies:{"88MPH":"MPH",AXIS:"Axis DeFi",BIFI:"Bitcoin File",BOX:"DefiBox",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",EGG:"Goose Finance",GTC:"Game.com",GTC_HT:"Game.com HT",GTC_BSC:"Game.com BSC",HIT:"HitChain",MM:"Million",MPH:"Morpher",POINT:"GatePoint",RAI:"Rai Reflex Index",SBTC:"Super Bitcoin",TNC:"Trinity Network Credit",TON:"TONToken",VAI:"VAIOT"},requiredCredentials:{apiKey:!0,secret:!0},headers:{"X-Gate-Channel-Id":"ccxt"},options:{createOrder:{expiration:86400},networks:{TRC20:"TRX",ERC20:"ETH",BEP20:"BSC"},timeInForce:{GTC:"gtc",IOC:"ioc",PO:"poc",POC:"poc"},accountsByType:{funding:"spot",spot:"spot",margin:"margin",cross_margin:"cross_margin",cross:"cross_margin",isolated:"margin",swap:"futures",future:"delivery",futures:"futures",delivery:"delivery"},defaultType:"spot",swap:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}},future:{fetchMarkets:{settlementCurrencies:["usdt"]}}},precisionMode:m4,fees:{trading:{tierBased:!0,feeSide:"get",percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00185")],[this.parseNumber("3"),this.parseNumber("0.00175")],[this.parseNumber("6"),this.parseNumber("0.00165")],[this.parseNumber("12.5"),this.parseNumber("0.00155")],[this.parseNumber("25"),this.parseNumber("0.00145")],[this.parseNumber("75"),this.parseNumber("0.00135")],[this.parseNumber("200"),this.parseNumber("0.00125")],[this.parseNumber("500"),this.parseNumber("0.00115")],[this.parseNumber("1250"),this.parseNumber("0.00105")],[this.parseNumber("2500"),this.parseNumber("0.00095")],[this.parseNumber("3000"),this.parseNumber("0.00085")],[this.parseNumber("6000"),this.parseNumber("0.00075")],[this.parseNumber("11000"),this.parseNumber("0.00065")],[this.parseNumber("20000"),this.parseNumber("0.00055")],[this.parseNumber("40000"),this.parseNumber("0.00055")],[this.parseNumber("75000"),this.parseNumber("0.00055")]],taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00195")],[this.parseNumber("3"),this.parseNumber("0.00185")],[this.parseNumber("6"),this.parseNumber("0.00175")],[this.parseNumber("12.5"),this.parseNumber("0.00165")],[this.parseNumber("25"),this.parseNumber("0.00155")],[this.parseNumber("75"),this.parseNumber("0.00145")],[this.parseNumber("200"),this.parseNumber("0.00135")],[this.parseNumber("500"),this.parseNumber("0.00125")],[this.parseNumber("1250"),this.parseNumber("0.00115")],[this.parseNumber("2500"),this.parseNumber("0.00105")],[this.parseNumber("3000"),this.parseNumber("0.00095")],[this.parseNumber("6000"),this.parseNumber("0.00085")],[this.parseNumber("11000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")],[this.parseNumber("40000"),this.parseNumber("0.00065")],[this.parseNumber("75000"),this.parseNumber("0.00065")]]}},swap:{tierBased:!0,feeSide:"base",percentage:!0,maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0005"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0000")],[this.parseNumber("1.5"),this.parseNumber("-0.00005")],[this.parseNumber("3"),this.parseNumber("-0.00005")],[this.parseNumber("6"),this.parseNumber("-0.00005")],[this.parseNumber("12.5"),this.parseNumber("-0.00005")],[this.parseNumber("25"),this.parseNumber("-0.00005")],[this.parseNumber("75"),this.parseNumber("-0.00005")],[this.parseNumber("200"),this.parseNumber("-0.00005")],[this.parseNumber("500"),this.parseNumber("-0.00005")],[this.parseNumber("1250"),this.parseNumber("-0.00005")],[this.parseNumber("2500"),this.parseNumber("-0.00005")],[this.parseNumber("3000"),this.parseNumber("-0.00008")],[this.parseNumber("6000"),this.parseNumber("-0.01000")],[this.parseNumber("11000"),this.parseNumber("-0.01002")],[this.parseNumber("20000"),this.parseNumber("-0.01005")],[this.parseNumber("40000"),this.parseNumber("-0.02000")],[this.parseNumber("75000"),this.parseNumber("-0.02005")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00050")],[this.parseNumber("1.5"),this.parseNumber("0.00048")],[this.parseNumber("3"),this.parseNumber("0.00046")],[this.parseNumber("6"),this.parseNumber("0.00044")],[this.parseNumber("12.5"),this.parseNumber("0.00042")],[this.parseNumber("25"),this.parseNumber("0.00040")],[this.parseNumber("75"),this.parseNumber("0.00038")],[this.parseNumber("200"),this.parseNumber("0.00036")],[this.parseNumber("500"),this.parseNumber("0.00034")],[this.parseNumber("1250"),this.parseNumber("0.00032")],[this.parseNumber("2500"),this.parseNumber("0.00030")],[this.parseNumber("3000"),this.parseNumber("0.00030")],[this.parseNumber("6000"),this.parseNumber("0.00030")],[this.parseNumber("11000"),this.parseNumber("0.00030")],[this.parseNumber("20000"),this.parseNumber("0.00030")],[this.parseNumber("40000"),this.parseNumber("0.00030")],[this.parseNumber("75000"),this.parseNumber("0.00030")]]}}},exceptions:{exact:{INVALID_PARAM_VALUE:Ws,INVALID_PROTOCOL:Ws,INVALID_ARGUMENT:Ws,INVALID_REQUEST_BODY:Ws,MISSING_REQUIRED_PARAM:Mn,BAD_REQUEST:Ws,INVALID_CONTENT_TYPE:Ws,NOT_ACCEPTABLE:Ws,METHOD_NOT_ALLOWED:Ws,NOT_FOUND:ze,INVALID_CREDENTIALS:Ca,INVALID_KEY:Ca,IP_FORBIDDEN:Ca,READ_ONLY:fb,INVALID_SIGNATURE:Ca,MISSING_REQUIRED_HEADER:Ca,REQUEST_EXPIRED:Ca,ACCOUNT_LOCKED:lb,FORBIDDEN:fb,SUB_ACCOUNT_NOT_FOUND:ze,SUB_ACCOUNT_LOCKED:lb,MARGIN_BALANCE_EXCEPTION:ze,MARGIN_TRANSFER_FAILED:ze,TOO_MUCH_FUTURES_AVAILABLE:ze,FUTURES_BALANCE_NOT_ENOUGH:rd,ACCOUNT_EXCEPTION:ze,SUB_ACCOUNT_TRANSFER_FAILED:ze,ADDRESS_NOT_USED:ze,TOO_FAST:g4,WITHDRAWAL_OVER_LIMIT:ze,API_WITHDRAW_DISABLED:zc,INVALID_WITHDRAW_ID:ze,INVALID_WITHDRAW_CANCEL_STATUS:ze,INVALID_PRECISION:Tt,INVALID_CURRENCY:ad,INVALID_CURRENCY_PAIR:ad,POC_FILL_IMMEDIATELY:pb,ORDER_NOT_FOUND:jc,CLIENT_ID_NOT_FOUND:jc,ORDER_CLOSED:Tt,ORDER_CANCELLED:Tt,QUANTITY_NOT_ENOUGH:Tt,BALANCE_NOT_ENOUGH:rd,MARGIN_NOT_SUPPORTED:Tt,MARGIN_BALANCE_NOT_ENOUGH:rd,AMOUNT_TOO_LITTLE:Tt,AMOUNT_TOO_MUCH:Tt,REPEATED_CREATION:Tt,LOAN_NOT_FOUND:jc,LOAN_RECORD_NOT_FOUND:jc,NO_MATCHED_LOAN:ze,NOT_MERGEABLE:ze,NO_CHANGE:ze,REPAY_TOO_MUCH:ze,TOO_MANY_CURRENCY_PAIRS:Tt,TOO_MANY_ORDERS:Tt,MIXED_ACCOUNT_TYPE:Tt,AUTO_BORROW_TOO_MUCH:ze,TRADE_RESTRICTED:rd,USER_NOT_FOUND:w4,CONTRACT_NO_COUNTER:ze,CONTRACT_NOT_FOUND:ad,RISK_LIMIT_EXCEEDED:ze,INSUFFICIENT_AVAILABLE:rd,LIQUIDATE_IMMEDIATELY:Tt,LEVERAGE_TOO_HIGH:Tt,LEVERAGE_TOO_LOW:Tt,ORDER_NOT_OWNED:ze,ORDER_FINISHED:ze,POSITION_CROSS_MARGIN:ze,POSITION_IN_LIQUIDATION:ze,POSITION_IN_CLOSE:ze,POSITION_EMPTY:Tt,REMOVE_TOO_MUCH:ze,RISK_LIMIT_NOT_MULTIPLE:ze,RISK_LIMIT_TOO_HIGH:ze,RISK_LIMIT_TOO_lOW:ze,PRICE_TOO_DEVIATED:Tt,SIZE_TOO_LARGE:Tt,SIZE_TOO_SMALL:Tt,PRICE_OVER_LIQUIDATION:Tt,PRICE_OVER_BANKRUPT:Tt,ORDER_POC_IMMEDIATE:pb,INCREASE_POSITION:Tt,CONTRACT_IN_DELISTING:ze,INTERNAL:zc,SERVER_ERROR:zc,TOO_BUSY:zc,CROSS_ACCOUNT_NOT_FOUND:ze,RISK_LIMIT_TOO_LOW:Ws}},broad:{}})}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchContractMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1];return this.arrayConcat(s,i)}async fetchSpotMarkets(e={}){const t=await this.publicMarginGetCurrencyPairs(e),s=await this.publicSpotGetCurrencyPairs(e),i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeValue(i,o),c=this.deepExtend(d,a),[u,h]=o.split("_"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h),m=this.safeString(c,"fee"),g=this.safeString(c,"maker_fee_rate",m),y=this.parseNumber(this.parsePrecision(this.safeString(c,"amount_precision"))),w=this.safeString(c,"trade_status"),S=this.safeNumber(c,"leverage")!==void 0;n.push({id:o,symbol:f+"/"+l,base:f,quote:l,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:S,swap:!1,future:!1,option:!1,active:w==="tradable",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(_e.stringDiv(m,"100")),maker:this.parseNumber(_e.stringDiv(g,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.parseNumber(this.parsePrecision(this.safeString(c,"precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(c,"leverage",1)},amount:{min:this.safeNumber(a,"min_base_amount",y),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(c,"min_quote_amount"),max:S?this.safeNumber(c,"max_quote_amount"):void 0}},info:c})}return n}async fetchContractMarkets(e={}){const t=[],s=this.getSettlementCurrencies("swap","fetchMarkets"),i=this.getSettlementCurrencies("future","fetchMarkets");for(let n=0;n<s.length;n++){const r=s[n],a={settle:r},o=await this.publicFuturesGetSettleContracts(this.extend(a,e));for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}for(let n=0;n<i.length;n++){const r=i[n],a={settle:r},o=await this.publicDeliveryGetSettleContracts(this.extend(a,e));for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}return t}parseContractMarket(e,t){const s=this.safeString(e,"name"),i=s.split("_"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeString(i,2),o=this.safeCurrencyCode(n),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(t),u=this.safeTimestamp(e,"expire_time");let h="",f="swap";a!==void 0?(h=o+"/"+d+":"+c+"-"+this.yymmdd(u,""),f="future"):h=o+"/"+d+":"+c;const l=this.safeString(e,"order_price_deviate"),m=this.safeString(e,"mark_price"),g=_e.stringSub("1",l),y=_e.stringAdd("1",l),w=_e.stringMul(g,m),b=_e.stringMul(y,m),S=this.safeString(e,"taker_fee_rate"),v=this.safeString(e,"maker_fee_rate",S),T=d===c;return{id:s,symbol:h,base:o,quote:d,settle:c,baseId:n,quoteId:r,settleId:t,type:f,spot:!1,margin:!1,swap:f==="swap",future:f==="future",option:f==="option",active:!0,contract:!0,linear:T,inverse:!T,taker:this.parseNumber(_e.stringDiv(S,"100")),maker:this.parseNumber(_e.stringDiv(v,"100")),contractSize:this.safeNumber(e,"quanto_multiplier"),expiry:u,expiryDatetime:this.iso8601(u),strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1"),price:this.safeNumber(e,"order_price_round")},limits:{leverage:{min:this.safeNumber(e,"leverage_min"),max:this.safeNumber(e,"leverage_max")},amount:{min:this.safeNumber(e,"order_size_min"),max:this.safeNumber(e,"order_size_max")},price:{min:this.parseNumber(w),max:this.parseNumber(b)},cost:{min:void 0,max:void 0}},info:e}}async fetchOptionMarkets(e={}){const t=[],s=await this.fetchOptionUnderlyings();for(let i=0;i<s.length;i++){const n=s[i],r=e;r.underlying=n;const a=await this.publicOptionsGetContracts(r);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"name"),u=n.split("_"),h=this.safeString(u,0),f=this.safeString(u,1),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f);let g=l+"/"+m;const y=this.safeTimestamp(d,"expiration_time"),w=this.safeString(d,"strike_price"),b=this.safeValue(d,"is_call"),S=b?"C":"P",v=b?"call":"put";g=g+":"+m+"-"+this.yymmdd(y)+"-"+w+"-"+S;const T=this.safeString(d,"order_price_deviate"),I=this.safeString(d,"mark_price"),A=_e.stringSub("1",T),N=_e.stringAdd("1",T),B=_e.stringMul(A,I),x=_e.stringMul(N,I),k=this.safeString(d,"taker_fee_rate"),O=this.safeString(d,"maker_fee_rate",k);t.push({id:c,symbol:g,base:l,quote:m,settle:m,baseId:h,quoteId:f,settleId:f,type:"option",spot:!1,margin:!1,swap:!1,future:!1,option:!0,active:!0,contract:!0,linear:!0,inverse:!1,taker:this.parseNumber(_e.stringDiv(k,"100")),maker:this.parseNumber(_e.stringDiv(O,"100")),contractSize:this.parseNumber("1"),expiry:y,expiryDatetime:this.iso8601(y),strike:w,optionType:v,precision:{amount:this.parseNumber("1"),price:this.safeNumber(d,"order_price_round")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(d,"order_size_min"),max:this.safeNumber(d,"order_size_max")},price:{min:this.parseNumber(B),max:this.parseNumber(x)},cost:{min:void 0,max:void 0}},info:d})}}return t}async fetchOptionUnderlyings(){const e=await this.publicOptionsGetUnderlyings(),t=[];for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"name");n!==void 0&&t.push(n)}return t}prepareRequest(e=void 0,t=void 0,s={}){const i={};if(e!==void 0)e.contract?(i.contract=e.id,i.settle=e.settleId):i.currency_pair=e.id;else{const n=t==="swap";if(n||t==="future"){const a=n?"usdt":"btc",o=this.safeStringLower(s,"settle",a);s=this.omit(s,"settle"),i.settle=o}}return[i,s]}spotOrderPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={};if(!t){if(e===void 0)throw new Mn(this.id+" spotOrderPrepareRequest() requires a market argument for non-stop orders");r.account=i,r.currency_pair=e.id}return[r,n]}multiOrderSpotPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={account:i};return e!==void 0&&(t?r.market=e.id:r.currency_pair=e.id),[r,n]}getMarginMode(e,t){const s=this.safeStringLower2(this.options,"defaultMarginMode","marginMode","spot");let i=this.safeStringLower2(t,"marginMode","account",s);if(t=this.omit(t,["marginMode","account"]),i==="cross"?i="cross_margin":i==="isolated"?i="margin":i===""&&(i="spot"),e&&(i==="spot"&&(i="normal"),i==="cross_margin"))throw new Ws(this.id+" getMarginMode() does not support stop orders for cross margin");return[i,t]}getSettlementCurrencies(e,t){const s=this.safeValue(this.options,e,{}),i=this.safeValue(s,t,{}),n=e==="swap"?["usdt"]:["btc"];return this.safeValue(i,"settlementCurrencies",n)}async fetchCurrencies(e={}){if(this.safeValue(this.urls,"apiBackup")!==void 0)return;const s=await this.publicSpotGetCurrencies(e),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeStringLower(r,"currency"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"delisted"),u=this.safeValue(r,"withdraw_disabled",!1),h=this.safeValue(r,"deposit_disabled",!1),f=this.safeValue(r,"trade_disabled",!1),l=!u,m=!h,w=!c&&!f&&l&&m;i[d]={id:a,lowerCaseId:o,name:void 0,code:d,precision:this.parseNumber("1e-4"),info:r,active:w,deposit:m,withdraw:l,fee:void 0,fees:[],limits:this.limits}}return i}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new ad(this.id+" fetchFundingRate() supports swap contracts only");const[i,n]=this.prepareRequest(s,void 0,t),r=await this.publicFuturesGetSettleContractsContract(this.extend(i,n));return this.parseFundingRate(r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const[s,i]=this.prepareRequest(void 0,"swap",t),n=await this.publicFuturesGetSettleContracts(this.extend(s,i)),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"name"),i=this.safeSymbol(s,t,"_","swap"),n=this.safeNumber(e,"mark_price"),r=this.safeNumber(e,"index_price"),a=this.safeNumber(e,"interest_rate"),o=this.safeNumber(e,"funding_rate"),d=this.safeTimestamp(e,"funding_next_apply"),c=this.safeNumber(e,"funding_rate_indicative");return{info:e,symbol:i,markPrice:n,indexPrice:r,interestRate:a,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:o,fundingTimestamp:d,fundingDatetime:this.iso8601(d),nextFundingRate:c,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchNetworkDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"multichain_addresses"),a=this.safeString(n,"currency");e=this.safeCurrencyCode(a);const o={};for(let d=0;d<r.length;d++){const c=r[d];if(this.safeInteger(c,"obtain_failed"))continue;const h=this.safeString(c,"chain"),f=this.safeString(c,"address"),l=this.safeString(c,"payment_id");o[h]={info:c,code:e,currency:e,address:f,tag:l}}return o}async createDepositAddress(e,t={}){return await this.fetchDepositAddress(e,t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeString(n,"currency");e=this.safeCurrencyCode(r);const a=this.safeString(n,"address");let o,d;if(a!==void 0){if(a.indexOf("New address is being generated for you, please wait")>=0)throw new b4(this.id+" New address is being generated for you, please wait a few seconds and try again to get the address.");if(a.indexOf(" ")>=0){const c=a.split(" ");d=c[0],o=c[1]}else d=a}return this.checkAddress(d),{info:n,code:e,currency:e,address:d,tag:o,network:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency_pair:s.id},n=await this.privateWalletGetFee(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateWalletGetFee(e);return this.parseTradingFees(t)}parseTradingFees(e){const t={};for(let s=0;s<this.symbols.length;s++){const i=this.symbols[s],n=this.market(i);t[i]=this.parseTradingFee(e,n)}return t}parseTradingFee(e,t=void 0){const s=this.safeValue(t,"contract"),i=s?"futures_taker_fee":"taker_fee",n=s?"futures_maker_fee":"maker_fee";return{info:e,symbol:this.safeString(t,"symbol"),maker:this.safeNumber(e,n),taker:this.safeNumber(e,i)}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t),i={};let n={};for(let r=0;r<s.length;r++){n={};const a=s[r],o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o);if(e!==void 0&&!this.inArray(d,e))continue;const c=this.safeValue(a,"withdraw_fix_on_chains");if(c===void 0)n=this.safeNumber(a,"withdraw_fix");else{const u=Object.keys(c);for(let h=0;h<u.length;h++){const f=u[h];n[f]=this.parseNumber(c[f])}}i[d]={withdraw:n,deposit:void 0,info:a}}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t);return this.parseDepositWithdrawFees(s,e,"currency")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"withdraw_fix_on_chains"),i={info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fix"),percentage:!1},deposit:{fee:this.safeNumber(e,"deposit"),percentage:!1},networks:{}};if(s!==void 0){const n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r];i.networks[a]={withdraw:{fee:this.parseNumber(s[a]),percentage:!1},deposit:{fee:void 0,percentage:void 0}}}}return i}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i),[o,d]=this.prepareRequest(n,r,a);o.type="fund",t!==void 0&&(o.from=t/1e3),s!==void 0&&(o.limit=s);const c=this.getSupportedMapping(r,{swap:"privateFuturesGetSettleAccountBook",future:"privateDeliveryGetSettleAccountBook"}),u=await this[c](this.extend(o,d));return this.parseFundingHistories(u,e,t,s)}parseFundingHistories(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseFundingHistory(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySymbolSinceLimit(r,t,s,i)}parseFundingHistory(e,t=void 0){const s=this.safeTimestamp(e,"time"),i=this.safeString(e,"text");return t=this.safeMarket(i,t,"_","swap"),{info:e,symbol:this.safeString(t,"symbol"),code:this.safeString(t,"settle"),timestamp:s,datetime:this.iso8601(s),id:void 0,amount:this.safeNumber(e,"change")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.prepareRequest(i,void 0,s),a=this.getSupportedMapping(i.type,{spot:"publicSpotGetOrderBook",margin:"publicSpotGetOrderBook",swap:"publicFuturesGetSettleOrderBook",future:"publicDeliveryGetSettleOrderBook"});t!==void 0&&(n.limit=t),n.with_id=!0;const o=await this[a](this.extend(n,r));let d=this.safeInteger(o,"current");i.spot||(d=d*1e3);const c=i.spot?0:"p",u=i.spot?1:"s",h=this.safeInteger(o,"id"),f=this.parseOrderBook(o,e,d,"bids","asks",c,u);return f.nonce=h,f}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.prepareRequest(s,void 0,t),r=this.getSupportedMapping(s.type,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),a=await this[r](this.extend(i,n)),o=this.safeValue(a,0);return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeString2(e,"currency_pair","contract"),i="contract"in e?"contract":"spot",n=this.safeSymbol(s,t,"_",i),r=this.safeString(e,"last"),a=this.safeString2(e,"lowest_ask","a"),o=this.safeString2(e,"highest_bid","b"),d=this.safeString(e,"high_24h"),c=this.safeString(e,"low_24h"),u=this.safeString(e,"B"),h=this.safeString(e,"A"),f=this.safeInteger(e,"t");let l=this.safeString2(e,"base_volume","volume_24h_base");l==="nan"&&(l="0");let m=this.safeString2(e,"quote_volume","volume_24h_quote");m==="nan"&&(m="0");const g=this.safeString(e,"change_percentage");return this.safeTicker({symbol:n,timestamp:f,datetime:this.iso8601(f),high:d,low:c,bid:o,bidVolume:u,ask:a,askVolume:h,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:g,average:void 0,baseVolume:l,quoteVolume:m,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),[a,o]=this.prepareRequest(void 0,n,r),d=this.getSupportedMapping(n,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),c=await this[d](this.extend(a,o));return this.parseTickers(c,e)}parseBalanceHelper(e){const t=this.account();return t.used=this.safeString2(e,"freeze","locked"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total"),"borrowed"in e&&(t.debt=this.safeString(e,"borrowed")),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");e=this.omit(e,"symbol");const[s,i]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[n,r]=this.prepareRequest(void 0,s,i),[a,o]=this.getMarginMode(!1,r);if(t!==void 0){const m=this.market(t);n.currency_pair=m.id}const d=this.getSupportedMapping(s,{spot:this.getSupportedMapping(a,{spot:"privateSpotGetAccounts",margin:"privateMarginGetAccounts",cross_margin:"privateMarginGetCrossAccounts"}),funding:"privateMarginGetFundingAccounts",swap:"privateFuturesGetSettleAccounts",future:"privateDeliveryGetSettleAccounts"});let c=await this[d](this.extend(n,o));(s==="swap"||s==="future")&&(c=[c]);const h={info:c},f=a==="margin";let l=c;if("balances"in l){const m=[],g=this.safeValue(l,"balances",[]),y=Object.keys(g);for(let w=0;w<y.length;w++){const b=y[w],S=g[b];S.currency=b,m.push(S)}l=m}for(let m=0;m<l.length;m++){const g=l[m];if(f){const y=this.safeString(g,"currency_pair"),w=this.safeSymbol(y,void 0,"_","margin"),b=this.safeValue(g,"base",{}),S=this.safeValue(g,"quote",{}),v=this.safeCurrencyCode(this.safeString(b,"currency")),T=this.safeCurrencyCode(this.safeString(S,"currency")),I={};I[v]=this.parseBalanceHelper(b),I[T]=this.parseBalanceHelper(S),h[w]=this.safeBalance(I)}else{const y=this.safeCurrencyCode(this.safeString(g,"currency"));h[y]=this.parseBalanceHelper(g)}}return f?h:this.safeBalance(h)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");let o={};[o,n]=this.prepareRequest(r,void 0,n),o.interval=this.timeframes[t];let d="publicSpotGetCandlesticks",c=1e3;r.contract&&(c=1999,i=i===void 0?c:Math.min(i,c),r.future?d="publicDeliveryGetSettleCandlesticks":r.swap&&(d="publicFuturesGetSettleCandlesticks"),(a==="mark"||a==="index")&&(o.contract=a+"_"+r.id,n=this.omit(n,"price"))),i=i===void 0?c:Math.min(i,c);let u=this.safeInteger(n,"until");if(u!==void 0&&(u=parseInt(u/1e3),n=this.omit(n,"until")),s!==void 0){const f=this.parseTimeframe(t);o.from=parseInt(s/1e3);const l=this.sum(o.from,i*f-1),m=this.seconds(),g=Math.min(l,m);u!==void 0?o.to=Math.min(g,u):o.to=g}else u!==void 0&&(o.to=u),o.limit=i;const h=await this[d](this.extend(o,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Mn(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new ad(this.id+" fetchFundingRateHistory() supports swap contracts only");const[r,a]=this.prepareRequest(n,void 0,i);s!==void 0&&(r.limit=s);const d=await this["publicFuturesGetSettleFundingRate"](this.extend(r,a)),c=[];for(let h=0;h<d.length;h++){const f=d[h],l=this.safeTimestamp(f,"t");c.push({info:f,symbol:e,fundingRate:this.safeNumber(f,"r"),timestamp:l,datetime:this.iso8601(l)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,6)]:[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.prepareRequest(n,void 0,i),o=this.getSupportedMapping(n.type,{spot:"publicSpotGetTrades",margin:"publicSpotGetTrades",swap:"publicFuturesGetSettleTrades",future:"publicDeliveryGetSettleTrades"});s!==void 0&&(r.limit=s),t!==void 0&&n.contract&&(r.from=parseInt(t/1e3));const d=await this[o](this.extend(r,a));return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(await this.loadMarkets(),t===void 0)throw new Mn(this.id+" fetchOrderTrades requires a symbol argument");return await this.fetchMyTrades(t,s,i,{order_id:e})}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a={};const o=e!==void 0?this.market(e):void 0,d=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",o,i),n==="swap"||n==="future"?[a,i]=this.prepareRequest(o,n,i):(o!==void 0&&(a.currency_pair=o.id),[r,i]=this.getMarginMode(!1,i),a.account=r),s!==void 0&&(a.limit=s),t!==void 0&&(a.from=parseInt(t/1e3)),d!==void 0&&(a.to=parseInt(d/1e3));const u=this.getSupportedMapping(n,{spot:"privateSpotGetMyTrades",margin:"privateSpotGetMyTrades",swap:"privateFuturesGetSettleMyTrades",future:"privateDeliveryGetSettleMyTrades"}),h=await this[u](this.extend(a,i));return this.parseTrades(h,o,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeTimestamp2(e,"time","create_time");i=this.safeInteger(e,"create_time_ms",i);const n=this.safeString2(e,"currency_pair","contract"),r="contract"in e?"contract":"spot";t=this.safeMarket(n,t,"_",r);let a=this.safeString2(e,"amount","size");const o=this.safeString(e,"price"),d=_e.stringLt(a,"0")?"sell":"buy";a=_e.stringAbs(a);const c=this.safeString2(e,"side","type",d),u=this.safeString(e,"order_id"),h=this.safeString(e,"fee"),f=this.safeString(e,"gt_fee"),l=this.safeString(e,"point_fee"),m=[];if(h!==void 0){const y=this.safeString(e,"fee_currency");let w=this.safeCurrencyCode(y);w===void 0&&(w=this.safeString(t,"settle")),m.push({cost:h,currency:w})}f!==void 0&&m.push({cost:f,currency:"GT"}),l!==void 0&&m.push({cost:l,currency:"GatePoint"});const g=this.safeString(e,"role");return this.safeTrade({info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:u,type:void 0,side:c,takerOrMaker:g,price:o,amount:a,cost:void 0,fee:void 0,fees:m},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetDeposits(this.extend(n,i));return this.parseTransactions(a,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(a.chain=d,n=this.omit(n,"network"));const c=await this.privateWithdrawalsPostWithdrawals(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={PEND:"pending",REQUEST:"pending",DMOVE:"pending",CANCEL:"failed",DONE:"ok",BCODE:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={d:"deposit",w:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"amount");s!==void 0&&(s[0]==="b"?(i=_e.stringGt(n,"0")?"deposit":"withdrawal",n=_e.stringAbs(n)):i=this.parseTransactionType(s[0]));const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(e,"txid"),d=this.safeString(e,"status"),c=this.parseTransactionStatus(d),u=this.safeString(e,"address"),h=this.safeNumber(e,"fee"),f=this.safeString(e,"memo"),l=this.safeTimestamp(e,"timestamp");return{info:e,id:s,txid:o,currency:a,amount:this.parseNumber(n),network:void 0,address:u,addressTo:void 0,addressFrom:void 0,tag:f,tagTo:void 0,tagFrom:void 0,status:c,type:i,timestamp:l,datetime:this.iso8601(l),updated:void 0,fee:h}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.contract,d=this.safeValue(r,"trigger"),c=this.safeValue2(r,"triggerPrice","stopPrice"),u=this.safeValue(r,"stopLossPrice",c),h=this.safeValue(r,"takeProfitPrice"),f=u!==void 0,l=h!==void 0,m=f||l;if(f&&l)throw new ze(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");let g="Orders";const y=this.safeValue(r,"reduceOnly"),w=this.safeStringLower2(r,"time_in_force","tif"),b=this.isPostOnly(t==="market",w==="poc",r);let S=this.handleTimeInForce(r);r=this.omit(r,["stopPrice","triggerPrice","stopLossPrice","takeProfitPrice","reduceOnly","timeInForce","postOnly"]),b&&(S="poc");const v=t==="limit",T=t==="market";if(v&&n===void 0)throw new Mn(this.id+" createOrder () requires a price argument for "+t+" orders");if(o){const B=this.amountToPrecision(e,i),x=s==="sell"?_e.stringNeg(B):B;if(i=parseInt(x),T){if(S==="poc"||S==="gtc")throw new ze(this.id+' createOrder () timeInForce for market orders must be "IOC"');S="ioc",n=0}}let I;if(!m&&d===void 0){if(o)I={contract:a.id,size:i,settle:a.settleId},T?I.price=n:I.price=this.priceToPrecision(e,n),y!==void 0&&(I.reduce_only=y),S!==void 0&&(I.tif=S);else{let x;[x,r]=this.getMarginMode(!1,r),I={currency_pair:a.id,type:t,account:x,side:s};const k=this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0);if(T&&s==="buy")if(k){if(n===void 0)throw new Tt(this.id+" createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const O=this.numberToString(i),P=this.numberToString(n),q=this.parseNumber(_e.stringMul(O,P));I.amount=this.costToPrecision(e,q)}}else{const O=this.safeNumber(r,"cost",i);r=this.omit(r,"cost"),I.amount=this.costToPrecision(e,O)}else I.amount=this.amountToPrecision(e,i);v?I.price=this.priceToPrecision(e,n):S="ioc",S!==void 0&&(I.time_in_force=S)}let B=this.safeString2(r,"text","clientOrderId");if(B!==void 0){if(B.length>28)throw new Ws(this.id+" createOrder () clientOrderId or text param must be up to 28 characters");r=this.omit(r,["text","clientOrderId"]),B[0]!=="t"&&(B="t-"+B),I.text=B}}else{if(o){if(I={initial:{contract:a.id,size:i,price:this.priceToPrecision(e,n)},settle:a.settleId},d===void 0){let B,x;f?(B=s==="buy"?1:2,x=this.priceToPrecision(e,u)):l&&(B=s==="buy"?2:1,x=this.priceToPrecision(e,h)),I.trigger={price_type:0,price:this.priceToPrecision(e,x),rule:B}}y!==void 0&&(I.initial.reduce_only=y),S!==void 0&&(I.initial.tif=S)}else{const B=this.safeValue(this.options,"createOrder",{});let x;if([x,r]=this.getMarginMode(!0,r),I={put:{type:t,side:s,price:this.priceToPrecision(e,n),amount:this.amountToPrecision(e,i),account:x,time_in_force:"gtc"},market:a.id},d===void 0){const k=this.safeInteger(B,"expiration"),O=this.safeInteger(r,"expiration",k);let P,q;f?(P=s==="buy"?">=":"<=",q=this.priceToPrecision(e,u)):l&&(P=s==="buy"?"<=":">=",q=this.priceToPrecision(e,h)),I.trigger={price:this.priceToPrecision(e,q),rule:P,expiration:O}}S!==void 0&&(I.put.time_in_force=S)}g="PriceOrders"}const A=this.getSupportedMapping(a.type,{spot:"privateSpotPost"+g,margin:"privateSpotPost"+g,swap:"privateFuturesPostSettle"+g,future:"privateDeliveryPostSettle"+g}),N=await this[A](this.deepExtend(I,r));return this.parseOrder(N,a)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);if(!o.spot)throw new Ws(this.id+" editOrder() supports only spot markets");const[d,c]=this.handleMarketTypeAndParams("editOrder",o,a),u=this.convertTypeToAccount(d);if(u==="spot"&&!(s==="limit"))throw new Tt(this.id+" editOrder() does not support "+s+" orders for "+d+" markets");const f={order_id:e,currency_pair:o.id,account:u};n!==void 0&&(f.amount=this.amountToPrecision(t,n)),r!==void 0&&(f.price=this.priceToPrecision(t,r));const l=await this.privateSpotPatchOrdersOrderId(this.extend(f,c));return this.parseOrder(l,o)}parseOrderStatus(e){const t={open:"open",_new:"open",filled:"closed",cancelled:"canceled",liquidated:"closed",ioc:"canceled",failed:"canceled",expired:"canceled",finished:"closed",succeeded:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue2(e,"put","initial"),i=this.safeValue(e,"trigger");let n=this.safeString(s,"contract"),r=this.safeString(s,"type"),a=this.safeStringUpper2(s,"time_in_force","tif"),o=this.safeString2(s,"amount","size"),d=this.safeString(s,"side"),c=this.safeString(s,"price");n=this.safeString(e,"contract",n),r=this.safeString(e,"type",r),a=this.safeStringUpper2(e,"time_in_force","tif",a),a==="POC"&&(a="PO");const u=a==="PO";o=this.safeString2(e,"amount","size",o),d=this.safeString(e,"side",d),c=this.safeString(e,"price",c);let h=this.safeString(e,"left"),f=_e.stringSub(o,h),l=this.safeString(e,"filled_total"),m,g=this.safeNumber(e,"fill_price");s&&(h=o,f="0",l="0"),n?(r=_e.stringEquals(c,"0")&&a==="IOC"?"market":"limit",d=_e.stringGt(o,"0")?"buy":"sell",m=this.safeString(e,"finish_as","open")):m=this.safeString(e,"status");let y=this.safeInteger(e,"create_time_ms");y===void 0&&(y=this.safeTimestamp2(e,"create_time","ctime"));let w=this.safeInteger(e,"update_time_ms");w===void 0&&(w=this.safeTimestamp2(e,"update_time","finish_time"));const b="currency_pair"in e?"spot":"contract",S=this.safeString2(e,"currency_pair","market",n),v=this.safeSymbol(S,t,"_",b),T=[],I=this.safeString(e,"gt_fee");I&&T.push({currency:"GT",cost:I});const A=this.safeString(e,"fee");A&&T.push({currency:this.safeCurrencyCode(this.safeString(e,"fee_currency")),cost:A});const N=this.safeString(e,"rebated_fee");N&&T.push({currency:this.safeCurrencyCode(this.safeString(e,"rebated_fee_currency")),cost:_e.stringNeg(N)});const x=T.length>1,k=this.parseOrderStatus(m);let O=this.parseNumber(_e.stringAbs(f)),P=this.parseNumber(_e.stringAbs(h));if(this.safeString(e,"account")==="spot"&&r==="market"&&d==="buy"){const L=this.safeString(e,"avg_deal_price");g=this.parseNumber(L),O=_e.stringDiv(f,L),P=_e.stringDiv(h,L),c=void 0,l=o,o=_e.stringDiv(o,L)}return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"text"),timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:w,status:k,symbol:v,type:r,timeInForce:a,postOnly:u,reduceOnly:this.safeValue(e,"is_reduce_only"),side:d,price:this.parseNumber(c),stopPrice:this.safeNumber(i,"price"),triggerPrice:this.safeNumber(i,"price"),average:g,amount:this.parseNumber(_e.stringAbs(o)),cost:_e.stringAbs(l),filled:O,remaining:P,fee:x?void 0:this.safeValue(T,0),fees:x?T:[],trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);let n=this.safeString2(s,"text","clientOrderId"),r=e;n!==void 0&&(s=this.omit(s,["text","clientOrderId"]),n[0]!=="t"&&(n="t-"+n),r=n);const a=t===void 0?void 0:this.market(t),[o,d]=this.handleMarketTypeAndParams("fetchOrder",a,s),c=o==="swap"||o==="future",[u,h]=c?this.prepareRequest(a,o,d):this.spotOrderPrepareRequest(a,i,d);u.order_id=r;const f=i?"PriceOrders":"Orders",l=this.getSupportedMapping(o,{spot:"privateSpotGet"+f+"OrderId",margin:"privateSpotGet"+f+"OrderId",swap:"privateFuturesGetSettle"+f+"OrderId",future:"privateDeliveryGetSettle"+f+"OrderId"}),m=await this[l](this.extend(u,h));return this.parseOrder(m,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),t=r.symbol);const a=this.safeValue(n,"stop");n=this.omit(n,"stop");const[o,d]=this.handleMarketTypeAndParams("fetchOrdersByStatus",r,n),c=o==="spot"||o==="margin",[u,h]=c?this.multiOrderSpotPrepareRequest(r,a,d):this.prepareRequest(r,o,d);e==="closed"&&(e="finished"),u.status=e,i!==void 0&&(u.limit=i),s!==void 0&&c&&(u.from=parseInt(s/1e3));let f=a?"PriceOrders":"Orders";const l=c&&e==="open"&&!a;l&&(f="OpenOrders");const m=this.getSupportedMapping(o,{spot:"privateSpotGet"+f,margin:"privateSpotGet"+f,swap:"privateFuturesGetSettle"+f,future:"privateDeliveryGetSettle"+f}),g=await this[m](this.extend(u,h));let y=g;if(l){y=[];for(let b=0;b<g.length;b++){const S=this.safeValue(g[b],"orders");y=this.arrayConcat(y,S)}}const w=this.parseOrders(y,r,s,i);return this.filterBySymbolSinceLimit(w,t,s,i)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t===void 0?void 0:this.market(t),n=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);const[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=r==="spot"||r==="margin"?this.spotOrderPrepareRequest(i,n,a):this.prepareRequest(i,r,a);o.order_id=e;const c=n?"Price":"",u=this.getSupportedMapping(r,{spot:"privateSpotDelete"+c+"OrdersOrderId",margin:"privateSpotDelete"+c+"OrdersOrderId",swap:"privateFuturesDeleteSettle"+c+"OrdersOrderId",future:"privateDeliveryDeleteSettle"+c+"OrdersOrderId"}),h=await this[u](this.extend(o,d));return this.parseOrder(h,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e===void 0?void 0:this.market(e),i=this.safeValue(t,"stop");t=this.omit(t,"stop");const[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=n==="spot"?this.multiOrderSpotPrepareRequest(s,i,r):this.prepareRequest(s,n,r),d=i?"PriceOrders":"Orders",c=this.getSupportedMapping(n,{spot:"privateSpotDelete"+d,margin:"privateSpotDelete"+d,swap:"privateFuturesDeleteSettle"+d,future:"privateDeliveryDeleteSettle"+d}),u=await this[c](this.extend(a,o));return this.parseOrders(u,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.convertTypeToAccount(s),o=this.convertTypeToAccount(i),d=this.currencyToPrecision(e,t),c={currency:r.id,amount:d};if(a in this.options.accountsByType?c.from=a:(c.from="margin",c.currency_pair=a),o in this.options.accountsByType?c.to=o:(c.to="margin",c.currency_pair=o),a==="margin"||o==="margin"){const f=this.safeString2(n,"symbol","currency_pair");if(f===void 0)throw new Mn(this.id+' transfer requires params["symbol"] for isolated margin transfers');const l=this.market(f);c.currency_pair=l.id,n=this.omit(n,"symbol")}(o==="futures"||o==="delivery"||a==="futures"||a==="delivery")&&(c.settle=r.lowerCaseId);const u=await this.privateWalletPostTransfers(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{fromAccount:s,toAccount:i,amount:this.parseNumber(d)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Mn(this.id+" setLeverage() requires a symbol argument");if(e<0||e>100)throw new Ws(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const i=this.market(t),n=this.getSupportedMapping(i.type,{swap:"privateFuturesPostSettlePositionsContractLeverage",future:"privateDeliveryPostSettlePositionsContractLeverage"}),[r,a]=this.prepareRequest(i,void 0,s),o=this.safeString2(this.options,"marginMode","defaultMarginMode"),d=this.safeString(a,"cross_leverage_limit");let c=this.safeString(a,"marginMode",o);return d!==void 0&&(c="cross",e=d),c==="cross"||c==="cross_margin"?(r.cross_leverage_limit=e.toString(),r.leverage="0"):r.leverage=e.toString(),await this[n](this.extend(r,a))}parsePosition(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t,"_","contract");const i=this.safeString(e,"size");let n;_e.stringGt(i,"0")?n="long":_e.stringLt(i,"0")&&(n="short");const r=this.safeString(e,"maintenance_rate"),a=this.safeString(e,"value"),o=this.safeString(e,"leverage");let d;o==="0"?d="cross":d="isolated";const c=this.safeString(e,"unrealised_pnl"),u="0.00075",h=_e.stringMul(u,a),f=_e.stringAdd(_e.stringDiv(a,o),h),l=_e.stringMul(_e.stringDiv(c,f),"100");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(f),initialMarginPercentage:this.parseNumber(_e.stringDiv(f,a)),maintenanceMargin:this.parseNumber(_e.stringMul(r,a)),maintenanceMarginPercentage:this.parseNumber(r),entryPrice:this.safeNumber(e,"entry_price"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(_e.stringAbs(i)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liq_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:this.safeNumber(e,"margin"),marginMode:d,side:n,percentage:this.parseNumber(l)}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e!==void 0&&(e=this.marketSymbols(e),e.length>0)){s=this.market(e[0]);for(let u=1;u<e.length;u++)if(this.market(e[u]).type!==s.type)throw new Ws(this.id+" fetchPositions() does not support multiple types of positions at the same time")}const[i,n]=this.handleMarketTypeAndParams("fetchPositions",s,t);if(i!=="swap"&&i!=="future")throw new Mn(this.id+' fetchPositions requires a type parameter, "swap" or "future"');const[r,a]=this.prepareRequest(void 0,i,n),o=this.getSupportedMapping(i,{swap:"privateFuturesGetSettlePositions",future:"privateDeliveryGetSettlePositions"}),d=await this[o](this.extend(r,a));return this.parsePositions(d,e)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t),[n,r]=this.prepareRequest(void 0,s,i);if(s!=="future"&&s!=="swap")throw new Ws(this.id+" fetchLeverageTiers only supports swap and future");const a=this.getSupportedMapping(s,{swap:"publicFuturesGetSettleContracts",future:"publicDeliveryGetSettleContracts"}),o=await this[a](this.extend(n,r));return this.parseLeverageTiers(o,e,"name")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeString(e,"maintenance_rate"),i=this.safeString(e,"leverage_max"),n=this.safeString(e,"risk_limit_step"),r=this.safeString(e,"risk_limit_max"),a=_e.stringDiv("1",i);let o=s,d=a,c="0";const u=[];for(;_e.stringLt(c,r);){const h=_e.stringAdd(c,n);u.push({tier:this.parseNumber(_e.stringDiv(h,n)),currency:this.safeString(t,"settle"),minNotional:this.parseNumber(c),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(o),maxLeverage:this.parseNumber(_e.stringDiv("1",d)),info:e}),o=_e.stringAdd(o,s),d=_e.stringAdd(d,a),c=h}return u}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossRepayments";else{o="privateMarginPostLoansLoanIdRepayment";const c=this.market(s);a.currency_pair=c.id,a.mode="partial";const u=this.safeString2(i,"loan_id","id");if(u===void 0)throw new Mn(this.id+" repayMargin() requires loan_id param for isolated margin");a.loan_id=u}i=this.omit(i,["marginMode","loan_id","id"]);let d=await this[o](this.extend(a,i));return n==="cross"&&(d=d[0]),this.parseMarginLoan(d,r)}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossLoans";else{const c=this.market(s);a.currency_pair=c.id,a.side="borrow",a.rate=this.safeString(i,"rate","0.0001"),a.auto_renew=!0,o="privateMarginPostLoans"}i=this.omit(i,["marginMode","rate"]);const d=await this[o](this.extend(a,i));return this.parseMarginLoan(d,r)}parseMarginLoan(e,t=void 0){const s=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let i=this.safeInteger(e,"create_time");s==="isolated"&&(i=this.safeTimestamp(e,"create_time"));const n=this.safeString(e,"currency"),r=this.safeString(e,"currency_pair");return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),symbol:this.safeSymbol(r,void 0,"_","margin"),timestamp:i,datetime:this.iso8601(i),info:e}}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1];let d=this.omit(i,this.extractParams(e));e=this.implodeParams(e,i);const c=e===""?"":"/"+e;let u="/"+o+c;(o==="subAccounts"||o==="withdrawals")&&(u=c);let h=this.urls.api[a][o];if(h===void 0)throw new y4(this.id+" does not have a testnet for the "+o+" market type.");if(h+=u,a==="public")Object.keys(d).length&&(h+="?"+this.urlencode(d));else{this.checkRequiredCredentials();let f="",l=!1;if((o==="futures"||o==="delivery")&&s==="POST"){const I=e.split("/"),A=this.safeString(I,1,"");l=A.indexOf("dual")>=0||A.indexOf("positions")>=0}if(s==="GET"||s==="DELETE"||l||s==="PATCH")Object.keys(d).length&&(f=this.urlencode(d),h+="?"+f),s==="PATCH"&&(r=this.json(d));else{const I=this.safeValue(d,"query",{});Object.keys(I).length&&(f=this.urlencode(I),h+="?"+f),d=this.omit(d,"query"),r=this.json(d)}const m=r===void 0?"":r,g=this.hash(this.encode(m),"sha512"),w=this.seconds().toString(),b="/api/"+this.version+u,v=[s.toUpperCase(),b,f,g,w].join(`
`),T=this.hmac(this.encode(v),this.encode(this.secret),"sha512");n={KEY:this.apiKey,Timestamp:w,SIGN:T,"Content-Type":"application/json"}}return{url:h,method:s,body:r,headers:n}}async modifyMarginHelper(e,t,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.prepareRequest(i,void 0,s);n.change=this.numberToString(t);const a=this.getSupportedMapping(i.type,{swap:"privateFuturesPostSettlePositionsContractMargin",future:"privateDeliveryPostSettlePositionsContractMargin"}),o=await this[a](this.extend(n,r));return this.parseMarginModification(o,i)}parseMarginModification(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t,"_","contract");const i=this.safeNumber(e,"margin");return{info:e,amount:void 0,code:this.safeValue(t,"quote"),symbol:t.symbol,total:i,status:"ok"}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,-t,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,s)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"label");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new ze(u)}}};const k4=lg;var S4=class extends k4{describe(){return this.deepExtend(super.describe(),{id:"gateio",alias:!0})}};const v4=re,{ExchangeError:od,ArgumentsRequired:Hl,BadRequest:di,OrderNotFound:mb,InvalidOrder:Ma,InvalidNonce:T4,InsufficientFunds:gb,AuthenticationError:Vr,PermissionDenied:O4,NotSupported:Kc,OnMaintenance:Gl,RateLimitExceeded:yb,ExchangeNotAvailable:wb}=Q,{TICK_SIZE:I4}=ne,bb=ae;var _T=class extends v4{describe(){return this.deepExtend(super.describe(),{id:"gemini",name:"Gemini",countries:["US"],rateLimit:100,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddress:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,postOnly:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg",api:{public:"https://api.gemini.com",private:"https://api.gemini.com",web:"https://docs.gemini.com"},www:"https://gemini.com/",doc:["https://docs.gemini.com/rest-api","https://docs.sandbox.gemini.com"],test:{public:"https://api.sandbox.gemini.com",private:"https://api.sandbox.gemini.com",web:"https://docs.gemini.com"},fees:["https://gemini.com/api-fee-schedule","https://gemini.com/trading-fees","https://gemini.com/transfer-fees"]},api:{web:{get:["rest-api"]},public:{get:{"v1/symbols":5,"v1/symbols/details/{symbol}":5,"v1/staking/rates":5,"v1/pubticker/{symbol}":5,"v2/ticker/{symbol}":5,"v2/candles/{symbol}/{timeframe}":5,"v1/trades/{symbol}":5,"v1/auction/{symbol}":5,"v1/auction/{symbol}/history":5,"v1/pricefeed":5,"v1/book/{symbol}":5,"v1/earn/rates":5}},private:{post:{"v1/staking/unstake":1,"v1/staking/stake":1,"v1/staking/rewards":1,"v1/staking/history":1,"v1/order/new":1,"v1/order/cancel":1,"v1/wrap/{symbol}":1,"v1/order/cancel/session":1,"v1/order/cancel/all":1,"v1/order/status":1,"v1/orders":1,"v1/mytrades":1,"v1/notionalvolume":1,"v1/tradevolume":1,"v1/clearing/new":1,"v1/clearing/status":1,"v1/clearing/cancel":1,"v1/clearing/confirm":1,"v1/balances":1,"v1/balances/staking":1,"v1/notionalbalances/{currency}":1,"v1/transfers":1,"v1/addresses/{network}":1,"v1/deposit/{network}/newAddress":1,"v1/deposit/{currency}/newAddress":1,"v1/withdraw/{currency}":1,"v1/account/transfer/{currency}":1,"v1/payments/addbank":1,"v1/payments/methods":1,"v1/payments/sen/withdraw":1,"v1/balances/earn":1,"v1/earn/interest":1,"v1/earn/history":1,"v1/approvedAddresses/{network}/request":1,"v1/approvedAddresses/account/{network}":1,"v1/approvedAddresses/{network}/remove":1,"v1/account":1,"v1/account/create":1,"v1/account/list":1,"v1/heartbeat":1}}},precisionMode:I4,fees:{trading:{taker:.004,maker:.002}},httpExceptions:{400:di,403:O4,404:mb,406:gb,429:yb,500:od,502:wb,503:Gl},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1hr","6h":"6hr","1d":"1day"},exceptions:{exact:{AuctionNotOpen:di,ClientOrderIdTooLong:di,ClientOrderIdMustBeString:di,ConflictingOptions:di,EndpointMismatch:di,EndpointNotFound:di,IneligibleTiming:di,InsufficientFunds:gb,InvalidJson:di,InvalidNonce:T4,InvalidOrderType:Ma,InvalidPrice:Ma,InvalidQuantity:Ma,InvalidSide:Ma,InvalidSignature:Vr,InvalidSymbol:di,InvalidTimestampInPayload:di,Maintenance:Gl,MarketNotOpen:Ma,MissingApikeyHeader:Vr,MissingOrderField:Ma,MissingRole:Vr,MissingPayloadHeader:Vr,MissingSignatureHeader:Vr,NoSSL:Vr,OptionsMustBeArray:di,OrderNotFound:mb,RateLimit:yb,System:od,UnsupportedOption:di},broad:{"The Gemini Exchange is currently undergoing maintenance.":Gl,"We are investigating technical issues with the Gemini Exchange.":wb}},options:{fetchMarketsMethod:"fetch_markets_from_web",fetchMarketFromWebRetries:10,fetchMarketsFromAPI:{fetchDetailsForAllSymbols:!1,fetchDetailsForMarketIds:[]},fetchUsdtMarkets:["btcusdt","ethusdt"],fetchTickerMethod:"fetchTickerV1",networkIds:{bitcoin:"BTC",ethereum:"ERC20",bitcoincash:"BCH",litecoin:"LTC",zcash:"ZEC",filecoin:"FIL",dogecoin:"DOGE",tezos:"XTZ"},networks:{BTC:"bitcoin",ERC20:"ethereum",BCH:"bitcoincash",LTC:"litecoin",ZEC:"zcash",FIL:"filecoin",DOGE:"dogecoin",XTZ:"tezos"},nonce:"milliseconds"}})}async fetchMarkets(e={}){if(this.safeValue(this.options,"fetchMarketsMethod","fetch_markets_from_api")==="fetch_markets_from_web"){const s=await this.fetchMarketsFromWeb(e),i=await this.fetchUSDTMarkets(e);return this.arrayConcat(s,i)}return await this.fetchMarketsFromAPI(e)}async fetchMarketsFromWeb(e={}){const t=this.safeInteger(this.options,"fetchMarketFromWebRetries",10);let s,i=0;for(;i<t;)try{s=await this.webGetRestApi(e);break}catch(f){if(i=i+1,i===t)throw f}const n=s.split('<h1 id="symbols-and-minimums">Symbols and minimums</h1>'),r=n.length,a=this.id+" fetchMarketsFromWeb() the "+this.name+" API doc HTML markup has changed, breaking the parser of order limits and precision info for "+this.name+" markets.";if(r!==2)throw new Kc(a);const o=n[1].split("tbody>");if(o.length<2)throw new Kc(a);const c=o[1].split(`
<tr>
`),u=c.length;if(u<2)throw new Kc(a);const h=[];for(let f=1;f<u;f++){const l=c[f],m=l.split(`</td>
`);if(m.length<5)throw new Kc(a);const y=m[0].replace("<td>",""),b=m[1].replace("<td>","").split(" "),S=this.safeNumber(b,0),T=m[2].replace("<td>","").split(" "),I=y.length-0,A=I-3,B=m[3].replace("<td>","").split(" "),x=this.safeStringLower(B,1,y.slice(A,I)),k=this.safeStringLower(T,1,y.replace(x,"")),O=this.safeCurrencyCode(k),P=this.safeCurrencyCode(x);h.push({id:y,symbol:O+"/"+P,base:O,quote:P,settle:void 0,baseId:k,quoteId:x,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(T,0),price:this.safeNumber(B,0)},limits:{leverage:{min:void 0,max:void 0},amount:{min:S,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:l})}return h}parseMarketActive(e){const t={open:!0,closed:!1,cancel_only:!0,post_only:!0,limit_only:!0};return this.safeValue(t,e,!0)}async fetchUSDTMarkets(e={}){const t=this.safeValue(this.options,"fetchUsdtMarkets",[]),s=[];for(let i=0;i<t.length;i++){const r={symbol:t[i]},a=await this.publicGetV1SymbolsDetailsSymbol(this.extend(r,e));s.push(this.parseMarket(a))}return s}async fetchMarketsFromAPI(e={}){const t=await this.publicGetV1Symbols(e),s={};for(let d=0;d<t.length;d++){const c=t[d],u={symbol:c};s[c]=this.parseMarket(u)}const i=this.safeValue(this.options,"fetchMarketsFromAPI",{}),n=this.safeValue(i,"fetchDetailsForAllSymbols",!1),r=this.safeValue(i,"fetchDetailsForMarketIds",[]);let a=[],o=[];n?o=t:o=r;for(let d=0;d<o.length;d++){const c=o[d],u="publicGetV1SymbolsDetailsSymbol",h={symbol:c};a.push(this[u](this.extend(h,e)))}a=await Promise.all(a);for(let d=0;d<a.length;d++){const c=a[d],u=this.safeStringLower(c,"symbol");s[u]=this.parseMarket(c)}return this.toArray(s)}parseMarket(e){const t=this.safeStringLower(e,"symbol");let s=this.safeString(e,"base_currency"),i=this.safeString(e,"quote_currency");if(s===void 0){const o=t.length-0,c=t.indexOf("usdt")!==-1?4:3;s=t.slice(0,o-c),i=t.slice(o-c,o)}const n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i),a=this.safeString(e,"status");return{id:t,symbol:n+"/"+r,base:n,quote:r,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.parseMarketActive(a),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.safeNumber(e,"quote_increment"),amount:this.safeNumber(e,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"min_order_size"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetV1BookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickerV1(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV1PubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2TickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV1AndV2(e,t={}){const s=await this.fetchTickerV1(e,t),i=await this.fetchTickerV2(e,t);return this.deepExtend(s,{open:i.open,high:i.high,low:i.low,change:i.change,percentage:i.percentage,average:i.average,info:i.info})}async fetchTicker(e,t={}){const s=this.safeValue(this.options,"fetchTickerMethod","fetchTickerV1");return await this[s](e,t)}parseTicker(e,t=void 0){const s=this.safeValue(e,"volume",{}),i=this.safeInteger(s,"timestamp");let n;const r=this.safeStringLower(e,"pair");t=this.safeMarket(r,t);let a,o,d,c;r!==void 0&&t===void 0&&(r.length-0===7?(a=r.slice(0,4),o=r.slice(4,7)):(a=r.slice(0,3),o=r.slice(3,6)),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),n=d+"/"+c),n===void 0&&t!==void 0&&(n=t.symbol,a=this.safeStringUpper(t,"baseId"),o=this.safeStringUpper(t,"quoteId"));const u=this.safeString(e,"price"),h=this.safeString2(e,"last","close",u),f=this.safeString(e,"percentChange24h"),l=this.safeString(e,"open"),m=this.safeString(s,a),g=this.safeString(s,o);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:l,close:h,last:h,previousClose:void 0,change:void 0,percentage:f,average:void 0,baseVolume:m,quoteVolume:g,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV1Pricefeed(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"tid"),n=this.safeString(e,"order_id"),r=this.safeString(e,"fee_currency"),a=this.safeCurrencyCode(r),o={cost:this.safeString(e,"fee_amount"),currency:a},d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeStringLower(e,"type"),h=this.safeSymbol(void 0,t);return this.safeTrade({id:i,order:n,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,side:u,takerOrMaker:void 0,price:d,cost:void 0,amount:c,fee:o},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=t);const a=await this.publicGetV1TradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"amount"),t[r]=a}return this.safeBalance(t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostV1Notionalvolume(e),s=this.safeString(t,"api_maker_fee_bps"),i=this.safeString(t,"api_taker_fee_bps"),n=bb.stringDiv(s,"10000"),r=bb.stringDiv(i,"10000"),a=this.parseNumber(n),o=this.parseNumber(r),d={};for(let c=0;c<this.symbols.length;c++){const u=this.symbols[c];d[u]={info:t,symbol:u,maker:a,taker:o,percentage:!0,tierBased:!0}}return d}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV1Balances(e);return this.parseBalance(t)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"original_amount"),n=this.safeString(e,"remaining_amount"),r=this.safeString(e,"executed_amount");let a="closed";e.is_live&&(a="open"),e.is_cancelled&&(a="canceled");const o=this.safeString(e,"price"),d=this.safeString(e,"avg_execution_price");let c=this.safeString(e,"type");c==="exchange limit"?c="limit":c==="market buy"||c==="market sell"?c="market":c=e.type;const u=void 0,h=this.safeString(e,"symbol"),f=this.safeSymbol(h,t),l=this.safeString(e,"order_id"),m=this.safeStringLower(e,"side"),g=this.safeString(e,"client_order_id"),y=this.safeValue(e,"options",[]),w=this.safeString(y,0);let b="GTC",S=!1;return w!==void 0&&(w==="immediate-or-cancel"?b="IOC":w==="fill-or-kill"?b="FOK":w==="maker-or-cancel"&&(b="PO",S=!0)),this.safeOrder({id:l,clientOrderId:g,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:a,symbol:f,type:c,timeInForce:b,postOnly:S,side:m,price:o,stopPrice:void 0,triggerPrice:void 0,average:d,cost:void 0,amount:i,filled:r,remaining:n,fee:u,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderStatus(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.privatePostV1Orders(i);let r;return e!==void 0&&(r=this.market(e)),this.parseOrders(n,r,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new od(this.id+" createOrder() allows limit orders only");let a=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),a===void 0&&(a=this.milliseconds().toString());const o=this.market(e),d=this.amountToPrecision(e,i),c=this.priceToPrecision(e,n),u={client_order_id:a.toString(),symbol:o.id,amount:d,price:c,side:s,type:"exchange limit"};t=this.safeString(r,"type",t),r=this.omit(r,"type");const h=this.safeString2(r,"stop_price","stopPrice");if(r=this.omit(r,["stop_price","stopPrice","type"]),t==="stopLimit")throw new Hl(this.id+" createOrder() requires a stopPrice parameter or a stop_price parameter for "+t+" orders");if(h!==void 0)u.stop_price=this.priceToPrecision(e,h),u.type="exchange stop limit";else{const l=this.safeString(r,"timeInForce");r=this.omit(r,"timeInForce"),l!==void 0&&(l==="IOC"||l==="immediate-or-cancel"?u.options=["immediate-or-cancel"]:l==="FOK"||l==="fill-or-kill"?u.options=["fill-or-kill"]:l==="PO"&&(u.options=["maker-or-cancel"]));const m=this.safeValue(r,"postOnly",!1);r=this.omit(r,"postOnly"),m&&(u.options=["maker-or-cancel"]);const g=this.safeString(r,"options");g!==void 0&&(u.options=[g])}const f=await this.privatePostV1OrderNew(this.extend(u,r));return this.parseOrder(f)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderCancel(this.extend(i,s));return this.parseOrder(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hl(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostV1Mytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s},o=await this.privatePostV1WithdrawCurrency(this.extend(a,n));if(this.safeString(o,"result")==="error")throw new od(this.id+" withdraw() failed: "+this.json(o));return this.parseTransaction(o,r)}nonce(){return this.safeString(this.options,"nonce","milliseconds")==="milliseconds"?this.milliseconds():this.seconds()}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit_transfers=s),t!==void 0&&(n.timestamp=t);const r=await this.privatePostV1Transfers(this.extend(n,i));return this.parseTransactions(r)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeString(e,"destination"),a=this.safeStringLower(e,"type"),o=this.safeString(e,"status");let d;const c=this.safeNumber(e,"feeAmount");return c!==void 0&&(d={cost:c,currency:n}),{info:e,id:this.safeString2(e,"eid","withdrawalId"),txid:this.safeString(e,"txHash"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:r,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(o),updated:void 0,fee:d}}parseTransactionStatus(e){const t={Advanced:"ok",Complete:"ok"};return this.safeString(t,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.safeString(t,"network");if(s===void 0)throw new Hl(this.id+" fetchDepositAddressesByNetwork() requires a network parameter");t=this.omit(t,"network");const i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s),r=this.safeValue(this.options,"networkIds",{}),a=this.safeString(r,n,s),o={network:n},d=await this.privatePostV1AddressesNetwork(this.extend(o,t)),c=this.parseDepositAddresses(d,[e],!1,{network:a,currency:e});return this.groupBy(c,"network")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"){if(this.checkRequiredCredentials(),this.apiKey.indexOf("account")<0)throw new Vr(this.id+" sign() requires an account-key, master-keys are not-supported");const c=this.nonce(),u=this.extend({request:a,nonce:c},o);let h=this.json(u);h=this.stringToBase64(h);const f=this.hmac(h,this.encode(this.secret),"sha384");n={"Content-Type":"text/plain","X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":this.decode(h),"X-GEMINI-SIGNATURE":f}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api[t]+a,(s==="POST"||s==="DELETE")&&(r=this.json(o)),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0){if(typeof r=="string"){const u=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,u)}return}if(this.safeString(a,"result")==="error"){const u=this.safeString(a,"reason"),h=this.safeString(a,"message"),f=this.id+" "+h;throw this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwExactlyMatchedException(this.exceptions.exact,h,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f),new od(f)}}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostV1DepositCurrencyNewAddress(this.extend(i,t)),r=this.safeString(n,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:n}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={timeframe:this.safeString(this.timeframes,t,t),symbol:r.id},d=await this.publicGetV2CandlesSymbolTimeframe(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}};const x4=re,{TICK_SIZE:_4}=ne,C4=ae,{BadSymbol:Ul,BadRequest:ti,OnMaintenance:M4,AccountSuspended:$l,PermissionDenied:Wl,ExchangeError:rt,RateLimitExceeded:P4,ExchangeNotAvailable:kb,OrderNotFound:A4,InsufficientFunds:B4,InvalidOrder:Xc,AuthenticationError:zl,ArgumentsRequired:Yc,NotSupported:N4}=Q;var V4=class extends x4{describe(){return this.deepExtend(super.describe(),{id:"hitbtc3",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"3",pro:!1,has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!1,option:void 0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:!0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},precisionMode:_4,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com/api/3",private:"https://api.demo.hitbtc.com/api/3"},api:{public:"https://api.hitbtc.com/api/3",private:"https://api.hitbtc.com/api/3"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{"public/currency":10,"public/symbol":10,"public/ticker":10,"public/price/rate":10,"public/trades":10,"public/orderbook":10,"public/candles":10,"public/futures/info":10,"public/futures/history/funding":10,"public/futures/candles/index_price":10,"public/futures/candles/mark_price":10,"public/futures/candles/premium_index":10,"public/futures/candles/open_interest":10}},private:{get:{"spot/balance":15,"spot/order":15,"spot/order/{client_order_id}":15,"spot/fee":15,"spot/fee/{symbol}":15,"spot/history/order":15,"spot/history/trade":15,"margin/account":15,"margin/account/isolated/{symbol}":15,"margin/order":15,"margin/order/{client_order_id}":15,"margin/history/clearing":15,"margin/history/order":15,"margin/history/positions":15,"margin/history/trade":15,"futures/balance":15,"futures/account":15,"futures/account/isolated/{symbol}":15,"futures/order":15,"futures/order/{client_order_id}":15,"futures/fee":15,"futures/fee/{symbol}":15,"futures/history/clearing":15,"futures/history/order":15,"futures/history/positions":15,"futures/history/trade":15,"wallet/balance":15,"wallet/crypto/address":15,"wallet/crypto/address/recent-deposit":15,"wallet/crypto/address/recent-withdraw":15,"wallet/crypto/address/check-mine":15,"wallet/transactions":15,"wallet/crypto/check-offchain-available":15,"wallet/crypto/fee/estimate":15,"sub-account":15,"sub-account/acl":15,"sub-account/balance/{subAccID}":15,"sub-account/crypto/address/{subAccID}/{currency}":15},post:{"spot/order":1,"margin/order":1,"futures/order":1,"wallet/convert":15,"wallet/crypto/address":15,"wallet/crypto/withdraw":15,"wallet/transfer":15,"sub-account/freeze":15,"sub-account/activate":15,"sub-account/transfer":15,"sub-account/acl":15},patch:{"spot/order/{client_order_id}":1,"margin/order/{client_order_id}":1,"futures/order/{client_order_id}":1},delete:{"spot/order":1,"spot/order/{client_order_id}":1,"margin/position":1,"margin/position/isolated/{symbol}":1,"margin/order":1,"margin/order/{client_order_id}":1,"futures/position":1,"futures/position/isolated/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"wallet/crypto/withdraw/{id}":1},put:{"margin/account/isolated/{symbol}":1,"futures/account/isolated/{symbol}":1,"wallet/crypto/withdraw/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0009"),maker:this.parseNumber("0.0009"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0007")],[this.parseNumber("100"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("5000"),this.parseNumber("0.0002")],[this.parseNumber("10000"),this.parseNumber("0.0001")],[this.parseNumber("20000"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.0001")],[this.parseNumber("100000"),this.parseNumber("-0.0001")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0008")],[this.parseNumber("100"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")],[this.parseNumber("100000"),this.parseNumber("0.0002")]]}}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},exceptions:{exact:{429:P4,500:rt,503:kb,504:kb,600:Wl,800:rt,1002:zl,1003:Wl,1004:zl,1005:zl,2001:Ul,2002:ti,2003:ti,2010:ti,2011:ti,2012:ti,2020:ti,2022:ti,10001:ti,10021:$l,10022:ti,20001:B4,20002:A4,20003:rt,20004:rt,20005:rt,20006:rt,20007:rt,20008:Xc,20009:Xc,20010:M4,20011:rt,20012:rt,20014:rt,20016:rt,20031:rt,20032:rt,20033:rt,20034:rt,20040:rt,20041:rt,20042:rt,20043:rt,20044:Wl,20045:Xc,20080:rt,21001:rt,21003:$l,21004:$l},broad:{}},options:{networks:{ETH:"USDT20",ERC20:"USDT20",TRX:"USDTRX",TRC20:"USDTRX",OMNI:"USDT"},accountsByType:{spot:"spot",funding:"wallet",future:"derivatives"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetPublicSymbol(e),s=[],i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(t,r),o=this.safeString(a,"type"),d=this.safeInteger(a,"expiry"),c=o==="futures",u=o==="spot",h=this.safeValue(a,"margin_trading",!1),f=u&&h,l=d!==void 0,m=c&&!l,g=!1,y=this.safeString2(a,"base_currency","underlying"),w=this.safeString(a,"quote_currency"),b=this.safeString(a,"fee_currency"),S=this.safeCurrencyCode(y),v=this.safeCurrencyCode(w),T=this.safeCurrencyCode(b);let I,A,N=S+"/"+v,B="spot",x,k,O;c&&(x=this.parseNumber("1"),I=b,A=this.safeCurrencyCode(I),k=v!==void 0&&v===A,O=!k,N=N+":"+A,l?(N=N+"-"+d,B="future"):B="swap");const P=this.safeString(a,"quantity_increment"),q=this.safeString(a,"tick_size"),L=this.parseNumber(P),D=this.parseNumber(q);s.push({id:r,symbol:N,base:S,quote:v,settle:A,baseId:y,quoteId:w,settleId:I,type:B,spot:u,margin:f,swap:m,future:l,option:g,active:!0,contract:c,linear:k,inverse:O,taker:this.safeNumber(a,"take_rate"),maker:this.safeNumber(a,"make_rate"),contractSize:x,expiry:d,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:T,precision:{amount:L,price:D},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_initial_leverage",1)},amount:{min:L,max:void 0},price:{min:D,max:void 0},cost:{min:this.parseNumber(C4.stringMul(P,q)),max:void 0}},info:a})}return s}async fetchCurrencies(e={}){const t=await this.publicGetPublicCurrency(e),s={},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=t[r],d=this.safeString(o,"full_name"),c=this.safeNumber(o,"precision_transfer"),u=this.safeValue(o,"payin_enabled",!1),h=this.safeValue(o,"payout_enabled",!1),f=this.safeValue(o,"transfer_enabled",!1),l=u&&h&&f,m=this.safeValue(o,"networks",[]),g={};let y,w,b;for(let T=0;T<m.length;T++){const I=m[T],A=this.safeString2(I,"protocol","network"),N=this.safeNetwork(A);y=this.safeNumber(I,"payout_fee");const B=this.safeNumber(I,"precision_payout"),x=this.safeValue(o,"payin_enabled",!1),k=this.safeValue(o,"payout_enabled",!1),O=x&&k;x&&!w?w=!0:x||(w=!1),k&&!b?b=!0:k||(b=!1),g[N]={info:I,id:A,network:N,fee:y,active:O,deposit:x,withdraw:k,precision:B,limits:{withdraw:{min:void 0,max:void 0}}}}const v=Object.keys(g).length;s[a]={info:o,code:a,id:r,precision:c,name:d,active:l,deposit:w,withdraw:b,networks:g,fee:v<=1?y:void 0,limits:{amount:{min:void 0,max:void 0}}}}return s}safeNetwork(e){if(e!==void 0)return e.toUpperCase()}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const o=this.safeValue(this.options,"networks"),d=this.safeString(o,n);d!==void 0&&(i.currency=d),t=this.omit(t,"network")}const r=await this.privatePostWalletCryptoAddress(this.extend(i,t)),a=this.safeString(r,"currency");return{currency:this.safeCurrencyCode(a),address:this.safeString(r,"address"),tag:this.safeString(r,"payment_id"),network:void 0,info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const h=this.safeValue(this.options,"networks"),f=this.safeString(h,n);f!==void 0&&(i.currency=f),t=this.omit(t,"network")}const r=await this.privateGetWalletCryptoAddress(this.extend(i,t)),a=this.safeValue(r,0),o=this.safeString(a,"address"),d=this.safeString(a,"currency"),c=this.safeString(a,"payment_id"),u=this.safeCurrencyCode(d);return{info:r,address:o,tag:c,code:u,currency:u,network:void 0}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeStringLower(e,"type","spot");e=this.omit(e,["type"]);const s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);let n;if(i==="wallet")n=await this.privateGetWalletBalance(e);else if(i==="spot")n=await this.privateGetSpotBalance(e);else if(i==="derivatives")n=await this.privateGetFuturesBalance(e);else{const r=Object.keys(s);throw new ti(this.id+" fetchBalance() type parameter must be one of "+r.join(", "))}return this.parseBalance(n)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const o=this.marketIds(e).join(",");s.symbols=o}const i=await this.publicGetPublicTicker(this.extend(s,t)),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=d.symbol,u=i[o];n[c]=this.parseTicker(u,d)}return this.filterByArray(n,"symbol",e)}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volume_quote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbols=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);const a=await this.publicGetPublicTrades(this.extend(r,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.market(u),f=a[u],l=this.parseTrades(f,h);d=this.arrayConcat(d,l)}return d}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);let a;[a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[d,c]=this.handleMarginModeAndParams("fetchMyTrades",i);d!==void 0&&(o="privateGetMarginHistoryTrade");const u=await this[o](this.extend(r,c));return this.parseTrades(u,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee"),o=this.safeValue(e,"taker");let d;if(o!==void 0&&(d=o?"taker":"maker"),a!==void 0){const m=this.safeValue(t,"info",{}),g=this.safeString(m,"fee_currency"),y=this.safeCurrencyCode(g);r={cost:a,currency:y}}const c=this.safeString2(e,"clientOrderId","client_order_id"),u=this.safeString(e,"price"),h=this.safeString2(e,"quantity","qty"),f=this.safeString(e,"side"),l=this.safeString(e,"id");return this.safeTrade({info:e,id:l,order:c,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:f,takerOrMaker:d,price:u,amount:h,cost:void 0,fee:r},t)}async fetchTransactionsHelper(e,t,s,i,n){await this.loadMarkets();const r={types:e};let a;t!==void 0&&(a=this.currency(t),r.currencies=a.id),s!==void 0&&(r.from=this.iso8601(s)),i!==void 0&&(r.limit=i);const o=await this.privateGetWalletTransactions(this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransactionStatus(e){const t={PENDING:"pending",FAILED:"failed",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={DEPOSIT:"deposit",WITHDRAW:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.parse8601(this.safeString(e,"updated_at")),r=this.parseTransactionType(this.safeString(e,"type")),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeValue(e,"native",{}),d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.safeString(o,"hash"),h=this.safeString(o,"address"),f=h,l=this.safeString(o,"payment_id"),m=l,g=this.safeValue(o,"senders"),y=this.safeString(g,0),w=this.safeNumber(o,"amount"),b={currency:void 0,cost:void 0,rate:void 0},S=this.safeNumber(o,"fee");return S!==void 0&&(b.currency=c,b.cost=S),{info:e,id:s,txid:u,type:r,code:c,currency:c,network:void 0,amount:w,status:a,timestamp:i,datetime:this.iso8601(i),address:h,addressFrom:y,addressTo:f,tag:l,tagFrom:void 0,tagTo:m,updated:n,comment:void 0,fee:b}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("WITHDRAW",e,t,s,i)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};if(e!==void 0){const o=this.marketIds(e);i.symbols=o.join(",")}t!==void 0&&(i.depth=t);const n=await this.publicGetPublicOrderbook(this.extend(i,s)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeSymbol(d),h=this.parse8601(this.safeString(c,"timestamp"));r[u]=this.parseOrderBook(n[d],u,h,"bid","ask")}return r}async fetchOrderBook(e,t=void 0,s={}){return(await this.fetchOrderBooks([e],t,s))[e]}parseTradingFee(e,t=void 0){const s=this.safeNumber(e,"take_rate"),i=this.safeNumber(e,"make_rate"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t);return{info:e,symbol:r,taker:s,maker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.getSupportedMapping(s.type,{spot:"privateGetSpotFeeSymbol",swap:"privateGetFuturesFeeSymbol"}),r=await this[n](this.extend(i,t));return this.parseTradingFee(r,s)}async fetchTradingFees(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,t),n=this.getSupportedMapping(s,{spot:"privateGetSpotFee",swap:"privateGetFuturesFee"}),r=await this[n](i),a={};for(let o=0;o<r.length;o++){const d=this.parseTradingFee(r[o]),c=d.symbol;a[c]=d}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=this.safeString(n,"price");n=this.omit(n,"price");let d="publicGetPublicCandles";o==="mark"?d="publicGetPublicFuturesCandlesMarkPrice":o==="index"?d="publicGetPublicFuturesCandlesIndexPrice":o==="premiumIndex"&&(d="publicGetPublicFuturesCandlesPremiumIndex");const c=await this[d](this.extend(a,n)),u=this.safeValue(c,r.id);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.from=this.iso8601(t)),s!==void 0&&(r.limit=s);let a;[a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[d,c]=this.handleMarginModeAndParams("fetchClosedOrders",i);d!==void 0&&(o="privateGetMarginHistoryOrder");const u=await this[o](this.extend(r,c)),h=this.parseOrders(u,n,t,s);return this.filterByArray(h,"status",["closed","canceled"],!1)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateGetMarginHistoryOrder");const d={client_order_id:e},c=await this[r](this.extend(d,o)),u=this.safeValue(c,0);return this.parseOrder(u,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e};let o;[o,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);let d=this.getSupportedMapping(o,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[c,u]=this.handleMarginModeAndParams("fetchOrderTrades",n);c!==void 0&&(d="privateGetMarginHistoryTrade");const h=await this[d](this.extend(a,u));return this.parseTrades(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);let a;[a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotOrder",swap:"privateGetFuturesOrder",margin:"privateGetMarginOrder"});const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);d!==void 0&&(o="privateGetMarginOrder");const u=await this[o](this.extend(r,c));return this.parseOrders(u,n,t,s)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOpenOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotOrderClientOrderId",swap:"privateGetFuturesOrderClientOrderId",margin:"privateGetMarginOrderClientOrderId"});const[a,o]=this.handleMarginModeAndParams("fetchOpenOrder",s);a!==void 0&&(r="privateGetMarginOrderClientOrderId");const d={client_order_id:e},c=await this[r](this.extend(d,o));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};e!==void 0&&(s=this.market(e),i.symbol=s.id);let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);let r=this.getSupportedMapping(n,{spot:"privateDeleteSpotOrder",swap:"privateDeleteFuturesOrder",margin:"privateDeleteMarginOrder"});const[a,o]=this.handleMarginModeAndParams("cancelAllOrders",t);a!==void 0&&(r="privateDeleteMarginOrder");const d=await this[r](this.extend(i,o));return this.parseOrders(d,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const n={client_order_id:e};t!==void 0&&(i=this.market(t));let r;[r,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(r,{spot:"privateDeleteSpotOrderClientOrderId",swap:"privateDeleteFuturesOrderClientOrderId",margin:"privateDeleteMarginOrderClientOrderId"});const[o,d]=this.handleMarginModeAndParams("cancelOrder",s);o!==void 0&&(a="privateDeleteMarginOrderClientOrderId");const c=await this[a](this.extend(n,d));return this.parseOrder(c,i)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();let o;const d={client_order_id:e,quantity:this.amountToPrecision(t,n)};if(s==="limit"||s==="stopLimit"){if(r===void 0)throw new rt(this.id+" editOrder() limit order requires price");d.price=this.priceToPrecision(t,r)}t!==void 0&&(o=this.market(t));let c;[c,a]=this.handleMarketTypeAndParams("editOrder",o,a);let u=this.getSupportedMapping(c,{spot:"privatePatchSpotOrderClientOrderId",swap:"privatePatchFuturesOrderClientOrderId",margin:"privatePatchMarginOrderClientOrderId"});const[h,f]=this.handleMarginModeAndParams("editOrder",a);h!==void 0&&(u="privatePatchMarginOrderClientOrderId");const l=await this[u](this.extend(d,f));return this.parseOrder(l,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,quantity:this.amountToPrecision(e,i),symbol:a.id},d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="margin")throw new Xc(this.id+" createOrder() does not support reduce_only for "+a.type+" orders, reduce_only orders are supported for swap and margin markets only");d===!0&&(o.reduce_only=d);const c=this.safeString2(r,"timeInForce","time_in_force"),u=this.safeString(r,"expire_time"),h=this.safeNumber2(r,"stopPrice","stop_price");if(t==="limit"||t==="stopLimit"||t==="takeProfitLimit"){if(n===void 0)throw new rt(this.id+" createOrder() requires a price argument for limit orders");o.price=this.priceToPrecision(e,n)}if(c==="GTD"){if(u===void 0)throw new rt(this.id+" createOrder() requires an expire_time parameter for a GTD order");o.expire_time=u}if(t==="stopLimit"||t==="stopMarket"||t==="takeProfitLimit"||t==="takeProfitMarket"){if(h===void 0)throw new rt(this.id+" createOrder() requires a stopPrice parameter for stop-loss and take-profit orders");o.stop_price=this.priceToPrecision(e,h)}let f;[f,r]=this.handleMarketTypeAndParams("createOrder",a,r);let l=this.getSupportedMapping(f,{spot:"privatePostSpotOrder",swap:"privatePostFuturesOrder",margin:"privatePostMarginOrder"});const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(l="privatePostMarginOrder");const y=await this[l](this.extend(o,g));return this.parseOrder(y,a)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"client_order_id"),i=this.safeString(e,"side"),n=this.safeString(e,"type"),r=this.safeString(e,"quantity"),a=this.safeString(e,"price"),o=this.safeString(e,"price_average"),d=this.safeString(e,"created_at"),c=this.parse8601(d),u=this.safeString(e,"updated_at");let h;u!==d&&(h=this.parse8601(u));const f=this.safeString(e,"quantity_cumulative"),l=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeString(e,"symbol");t=this.safeMarket(m,t);const g=t.symbol,y=this.safeValue(e,"post_only"),w=this.safeString(e,"time_in_force"),b=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:h,symbol:g,price:a,amount:r,type:n,side:i,timeInForce:w,postOnly:y,reduceOnly:this.safeValue(e,"reduce_only"),filled:f,remaining:void 0,cost:void 0,status:l,average:o,trades:b,fee:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const d=this.safeString(o,s,s),c=this.safeString(o,i,i);if(d===c)throw new ti(this.id+" transfer() fromAccount and toAccount arguments cannot be the same account");const u={currency:r.id,amount:a,source:d,destination:c},h=await this.privatePostWalletTransfer(this.extend(u,n)),f=this.parseTransfer(h,r);return this.extend(f,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,0),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async convertCurrencyNetwork(e,t,s,i,n){if(await this.loadMarkets(),e!=="USDT")throw new rt(this.id+" convertCurrencyNetwork() only supports USDT currently");const r=this.safeValue(this.options,"networks",{});if(s=s.toUpperCase(),i=i.toUpperCase(),s=this.safeString(r,s),i=this.safeString(r,i),s===i)throw new ti(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");if(s===void 0||i===void 0){const d=Object.keys(r);throw new Yc(this.id+" convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "+d.join(", "))}const a={from_currency:s,to_currency:i,amount:this.currencyToPrecision(e,t)};return{info:await this.privatePostWalletConvert(this.extend(a,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.payment_id=i);const o=this.safeValue(this.options,"networks",{}),d=this.safeStringUpper(n,"network");if(d!==void 0&&e==="USDT"){const u=this.safeString(o,d);u!==void 0&&(a.currency=u),n=this.omit(n,"network")}const c=await this.privatePostWalletCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),e=n.symbol,r.symbols=n.id),t!==void 0&&(r.from=t),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFuturesHistoryFunding(this.extend(r,i)),o=Object.keys(a),d=[];for(let u=0;u<o.length;u++){const h=o[u],f=this.safeMarket(h),l=a[h];for(let m=0;m<l.length;m++){const g=l[m],y=this.safeSymbol(f.symbol),w=this.safeNumber(g,"funding_rate"),b=this.safeString(g,"timestamp");d.push({info:g,symbol:y,fundingRate:w,timestamp:this.parse8601(b),datetime:b})}}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;[i,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);let n=this.getSupportedMapping(i,{swap:"privateGetFuturesAccount",margin:"privateGetMarginAccount"});const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);r!==void 0&&(n="privateGetMarginAccount");const o=await this[n](this.extend(s,a)),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return d}async fetchPosition(e,t={}){await this.loadMarkets();let s;[s,t]=this.handleMarketTypeAndParams("fetchPosition",void 0,t);let i=this.getSupportedMapping(s,{swap:"privateGetFuturesAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol"});const[n,r]=this.handleMarginModeAndParams("fetchPosition",t);n!==void 0&&(i="privateGetMarginAccountIsolatedSymbol");const a=this.market(e),o={symbol:a.id},d=await this[i](this.extend(o,r));return this.parsePosition(d,a)}parsePosition(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeNumber(e,"leverage"),n=this.safeString(e,"updated_at"),r=this.safeValue(e,"positions",[]);let a,o,d;for(let l=0;l<r.length;l++){const m=r[l];a=this.safeNumber(m,"price_liquidation"),o=this.safeNumber(m,"price_entry"),d=this.safeNumber(m,"quantity")}const c=this.safeValue(e,"currencies",[]);let u;for(let l=0;l<c.length;l++){const m=c[l];u=this.safeNumber(m,"margin_balance")}const h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const f=t.symbol;return{info:e,id:void 0,symbol:f,notional:void 0,marginMode:s,marginType:s,liquidationPrice:a,entryPrice:o,unrealizedPnl:void 0,percentage:void 0,contracts:d,contractSize:void 0,markPrice:void 0,side:void 0,hedged:void 0,timestamp:this.parse8601(n),datetime:n,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:u,initialMargin:void 0,initialMarginPercentage:void 0,leverage:i,marginRatio:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ul(this.id+" fetchFundingRate() supports swap contracts only");const i={};e!==void 0&&(e=s.symbol,i.symbols=s.id);const n=await this.publicGetPublicFuturesInfo(this.extend(i,t)),r=this.safeValue(n,s.id,{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"next_funding_time"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:this.safeNumber(e,"interest_rate"),estimatedSettlePrice:void 0,timestamp:this.parse8601(i),datetime:i,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(s),fundingDatetime:s,nextFundingRate:this.safeNumber(e,"indicative_funding_rate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"leverage");if(n.type==="swap"&&r===void 0)throw new Yc(this.id+" modifyMarginHelper() requires a leverage parameter for swap markets");t=this.amountToPrecision(e,t);const a={symbol:n.id,margin_balance:t};r!==void 0&&(a.leverage=r);let o;[o,i]=this.handleMarketTypeAndParams("modifyMarginHelper",void 0,i);let d=this.getSupportedMapping(o,{swap:"privatePutFuturesAccountIsolatedSymbol",margin:"privatePutMarginAccountIsolatedSymbol"});const[c,u]=this.handleMarginModeAndParams("modifyMarginHelper",i);c!==void 0&&(d="privatePutMarginAccountIsolatedSymbol");const h=await this[d](this.extend(a,u));return this.extend(this.parseMarginModification(h,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"currencies",[]),i=this.safeValue(s,0);return{info:e,type:void 0,amount:void 0,code:this.safeString(i,"code"),symbol:t.symbol,status:void 0}}async reduceMargin(e,t,s={}){if(t!==0)throw new ti(this.id+" reduceMargin() on hitbtc3 requires the amount to be 0 and that will remove the entire margin amount");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"privateGetMarginAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol",swap:"privateGetFuturesAccountIsolatedSymbol"});const[r,a]=this.handleMarginModeAndParams("modifyMarginHelper",t);r!==void 0&&(n="privateGetMarginAccountIsolatedSymbol");const o=await this[n](this.extend(i,a));return this.safeNumber(o,"leverage")}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Yc(this.id+" setLeverage() requires a symbol argument");if(s.margin_balance===void 0)throw new Yc(this.id+" setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair");const i=this.market(t),n=this.safeNumber(s,"margin_balance"),r=this.safeInteger(i.limits.leverage,"max",50);if(i.type!=="swap")throw new Ul(this.id+" setLeverage() supports swap contracts only");if(e<1||e>r)throw new ti(this.id+" setLeverage() leverage should be between 1 and "+r.toString()+" for "+t);const a={symbol:i.id,leverage:e.toString(),margin_balance:this.amountToPrecision(t,n)};return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(a,s))}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPublicCurrency(t);return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networks",[]),i=this.depositWithdrawFee(e);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.networkIdToCode(a),d=this.safeNumber(r,"payout_fee"),c=this.safeValue(r,"default"),u={fee:d,percentage:d!==void 0?!1:void 0};c===!0&&(i.withdraw=u),i.networks[o]={withdraw:u,deposit:{fee:void 0,percentage:void 0}}}return i}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="isolated")throw new N4(this.id+" only isolated margin is supported")}else(i==="margin"||n===!0)&&(r="isolated");return[r,t]}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeValue(a,"error"),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r,f=this.safeString2(c,"message","description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,f,h),new rt(h)}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+o,c;const h=Object.keys(a).length;if(n={"Content-Type":"application/json"},s==="GET"?h&&(c="?"+this.urlencode(a),d=d+c):r=this.json(i),t==="private"){this.checkRequiredCredentials();const f=this.nonce().toString(),l=[s,"/api/3/"+o];s==="GET"?c!==void 0&&l.push(c):l.push(r),l.push(f);const m=l.join(""),g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","hex"),y=this.apiKey+":"+g+":"+f,w=this.decode(this.stringToBase64(y));n.Authorization="HS256 "+w}return{url:d,method:s,body:r,headers:n}}};const E4=re,{BadRequest:dd,AuthenticationError:Sb,NetworkError:vb,ArgumentsRequired:Tb,OrderImmediatelyFillable:q4,OrderNotFound:Ob,InsufficientFunds:L4}=Q,{TICK_SIZE:R4}=ne,Ib=ae;var CT=class extends E4{describe(){return this.deepExtend(super.describe(),{id:"hollaex",name:"HollaEx",countries:["KR"],rateLimit:250,version:"v2",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketSellOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:"emulated",fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg",test:{rest:"https://api.sandbox.hollaex.com"},api:{rest:"https://api.hollaex.com"},www:"https://hollaex.com",doc:"https://apidocs.hollaex.com",referral:"https://pro.hollaex.com/signup?affiliation_code=QSWA6G"},precisionMode:R4,requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{health:1,constants:1,kit:1,tiers:1,ticker:1,tickers:1,orderbook:1,orderbooks:1,trades:1,chart:1,charts:1,"udf/config":1,"udf/history":1,"udf/symbols":1}},private:{get:{user:1,"user/balance":1,"user/deposits":1,"user/withdrawals":1,"user/withdrawal/fee":1,"user/trades":1,orders:1,order:1},post:{"user/withdrawal":1,order:1},delete:{"order/all":1,order:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:.001}},exceptions:{broad:{"Invalid token":Sb,"Order not found":Ob,"Insufficient balance":L4,"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.":q4},exact:{400:dd,403:Sb,404:dd,405:dd,410:dd,429:dd,500:vb,503:vb}},options:{"api-expires":parseInt(this.timeout/1e3),networks:{BTC:"btc",ETH:"eth",ERC20:"eth",TRX:"trx",TRC20:"trx",XRP:"xrp",XLM:"xlm"}}})}async fetchMarkets(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"pair_base"),c=this.safeString(o,"pair_2"),u=this.commonCurrencyCode(d.toUpperCase()),h=this.commonCurrencyCode(c.toUpperCase());n.push({id:this.safeString(o,"name"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(o,"active"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(o,"increment_size"),price:this.safeNumber(o,"increment_price")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_size"),max:this.safeNumber(o,"max_size")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:void 0,max:void 0}},info:o})}return n}async fetchCurrencies(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"coins",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"symbol"),c=this.safeInteger(o,"id"),u=this.safeCurrencyCode(d),h=this.safeString(o,"fullname"),f=this.safeValue(o,"allow_deposit"),l=this.safeValue(o,"allow_withdrawal"),g=this.safeValue(o,"active")&&f&&l,y=this.safeNumber(o,"withdrawal_fee"),w=this.safeValue(o,"withdrawal_limits",[]);n[u]={id:d,numericId:c,code:u,info:o,name:h,active:g,deposit:f,withdraw:l,fee:y,precision:this.safeNumber(o,"increment_unit"),limits:{amount:{min:this.safeNumber(o,"min"),max:this.safeNumber(o,"max")},withdraw:{min:void 0,max:this.safeValue(w,0)}}}}return n}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i=await this.publicGetOrderbooks(s),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=i[o],c=this.safeSymbol(o,void 0,"-"),u=this.parse8601(this.safeString(d,"timestamp"));n[c]=this.parseOrderBook(i[o],c,u)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,i.id),o=this.parse8601(this.safeString(a,"timestamp"));return this.parseOrderBook(a,i.symbol,o)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(this.extend(t));return this.parseTickers(s,e)}parseTickers(e,t=void 0,s={}){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=e[a],d=this.safeString(o,"symbol",a),c=this.safeMarket(d,void 0,"-"),u=c.symbol;i[u]=this.extend(this.parseTicker(o,c),s)}return this.filterByArray(i,"symbol",t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"time","timestamp")),r=this.safeString(e,"close");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:this.safeString(e,"last",r),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"timestamp"),r=this.parse8601(n),a=this.safeString(e,"side"),o=this.safeString(e,"order_id"),d=this.safeString(e,"price"),c=this.safeString(e,"size"),u=this.safeString(e,"fee");let h;return u!==void 0&&(h={cost:u,currency:t.quote}),this.safeTrade({info:e,id:void 0,timestamp:r,datetime:n,symbol:i,order:o,type:void 0,side:a,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTiers(e),s=this.safeValue(t,"1",{}),i=this.safeValue(s,"fees",{}),n=this.safeValue(i,"maker",{}),r=this.safeValue(i,"taker",{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o],c=this.market(d),u=this.safeString(n,c.id),h=this.safeString(r,c.id);a[d]={info:i,symbol:d,maker:this.parseNumber(Ib.stringDiv(u,"100")),taker:this.parseNumber(Ib.stringDiv(h,"100")),percentage:!0,tierBased:!0}}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(s===void 0){i===void 0&&(i=1e3);const c=this.seconds(),u=c-o*i;a.to=c,a.from=u}else if(i===void 0)a.from=parseInt(s/1e3),a.to=this.seconds();else{const c=parseInt(s/1e3);a.from=c,a.to=this.sum(c,o*i)}const d=await this.publicGetChart(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1h",i=void 0,n=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseBalance(e){const t=this.parse8601(this.safeString(e,"updated_at")),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=Object.keys(this.currencies_by_id);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(e,r+"_available"),o.total=this.safeString(e,r+"_balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e);return this.parseBalance(t)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!0};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetOrder(this.extend(i,s));if(r===void 0)throw new Ob(this.id+" fetchOrder() could not find order id "+e);return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.start_date=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={new:"open",pfilled:"open",filled:"closed",canceled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"stop"),u=this.safeString(e,"size"),h=this.safeString(e,"filled"),f=this.parseOrderStatus(this.safeString(e,"status")),l=this.safeValue(e,"meta",{}),m=this.safeValue(l,"post_only",!1);return this.safeOrder({id:n,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:f,symbol:i,type:a,timeInForce:void 0,postOnly:m,side:o,price:d,stopPrice:c,triggerPrice:c,amount:u,filled:h,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=parseFloat(this.amountToPrecision(e,i)),d={symbol:a.id,side:s,size:this.normalizeNumberIfNeeded(o),type:t},c=this.safeNumberN(r,["triggerPrice","stopPrice","stop"]),u=this.safeValue(r,"meta",{}),h=this.safeValue(u,"post_only",!1),f=t==="market",l=this.isPostOnly(f,h,r);if(!f){const g=parseFloat(this.priceToPrecision(e,n));d.price=this.normalizeNumberIfNeeded(g)}c!==void 0&&(d.stop=this.normalizeNumberIfNeeded(parseFloat(this.priceToPrecision(e,c)))),l&&(d.meta={post_only:!0}),r=this.omit(r,["postOnly","timeInForce","stopPrice","triggerPrice","stop"]);const m=await this.privatePostOrder(this.extend(d,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Tb(this.id+" cancelAllOrders() requires a 'symbol' argument");await this.loadMarkets();const s={};let i;i=this.market(e),s.symbol=i.id;const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserTrades(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}parseDepositAddress(e,t=void 0){let s=this.safeString(e,"address"),i;if(s!==void 0){const a=s.split(":");s=this.safeString(a,0),i=this.safeString(a,1)}this.checkAddress(s);const n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeString(e,"network");return{currency:t.code,address:s,tag:i,network:r,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(t,"network");t=this.omit(t,"network");const i=await this.privateGetUser(t),n=this.safeValue(i,"wallet",[]),r=s===void 0?n:this.filterBy(n,"network",s);return this.parseDepositAddresses(r,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={transaction_id:e};let n;t!==void 0&&(n=this.currency(t),i.currency=n.id);const r=await this.privateGetUserWithdrawals(this.extend(i,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"transaction_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.parse8601(this.safeString(e,"updated_at")),a=this.safeString(e,"type"),o=this.safeNumber(e,"amount");let d=this.safeString(e,"address"),c;const u=void 0;let h,f;const l=void 0;if(d!==void 0){const I=d.split(":");d=this.safeString(I,0),h=this.safeString(I,1),c=d,f=h}const m=this.safeString(e,"currency");t=this.safeCurrency(m,t);let g=this.safeValue(e,"status");const y=this.safeValue(e,"dismissed"),w=this.safeValue(e,"rejected");g?g="ok":y?g="canceled":w?g="failed":g="pending";const b=this.safeString(e,"fee_coin"),S=this.safeCurrencyCode(b,t),v=this.safeNumber(e,"fee");let T;return v!==void 0&&(T={currency:S,cost:v}),{info:e,id:s,txid:i,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:u,address:d,addressTo:c,tagFrom:l,tag:h,tagTo:f,type:a,amount:o,currency:t.code,status:g,updated:r,fee:T}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&(s+=":"+i);const a=this.safeString(n,"network");if(a===void 0)throw new Tb(this.id+" withdraw() requires a network parameter");n=this.omit(n,"network");const o=this.safeValue(this.options,"networks",{}),d=this.safeStringLower2(o,a,e,a),c={currency:r.id,amount:t,address:s,network:d},u=await this.privatePostUserWithdrawal(this.extend(c,n));return this.parseTransaction(u,r)}normalizeNumberIfNeeded(e){return e%1===0&&(e=parseInt(e)),e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));e="/"+this.version+"/"+this.implodeParams(e,i),(s==="GET"||s==="DELETE")&&Object.keys(a).length&&(e+="?"+this.urlencode(a));const o=this.urls.api.rest+e;if(t==="private"){this.checkRequiredCredentials();const d=this.safeInteger2(this.options,"api-expires","expires",parseInt(this.timeout/1e3)),u=this.sum(this.seconds(),d).toString();let h=s+e+u;n={"api-key":this.apiKey,"api-expires":u},s==="POST"&&(n["Content-type"]="application/json",Object.keys(a).length&&(r=this.json(a),h+=r));const f=this.hmac(this.encode(h),this.encode(this.secret));n["api-signature"]=f}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400&&e<=503){const c=this.id+" "+r,u=this.safeString(a,"message");this.throwBroadlyMatchedException(this.exceptions.broad,u,c);const h=e.toString();this.throwExactlyMatchedException(this.exceptions.exact,h,c)}}};const D4=re,{AccountNotEnabled:xb,ArgumentsRequired:hs,AuthenticationError:Zc,ExchangeError:Qc,PermissionDenied:F4,ExchangeNotAvailable:_b,OnMaintenance:jl,InvalidOrder:zt,OrderNotFound:Jc,InsufficientFunds:eu,BadSymbol:Yn,BadRequest:As,RateLimitExceeded:H4,RequestTimeout:G4,NetworkError:U4,NotSupported:si}=Q,{TICK_SIZE:$4,TRUNCATE:W4}=ne,Bs=ae;var pg=class extends D4{describe(){return this.deepExtend(super.describe(),{id:"huobi",name:"Huobi",countries:["CN"],rateLimit:100,userAgent:this.userAgents.chrome100,certified:!0,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api.huobi.pro",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:void 0,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawAddresses:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,signIn:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",hostnames:{contract:"api.hbdm.com",spot:"api.huobi.pro",status:{spot:"status.huobigroup.com",future:{inverse:"status-dm.huobigroup.com",linear:"status-linear-swap.huobigroup.com"},swap:{inverse:"status-swap.huobigroup.com",linear:"status-linear-swap.huobigroup.com"}}},api:{status:"https://{hostname}",contract:"https://{hostname}",spot:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.com",referral:{url:"https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223",discount:.15},doc:["https://huobiapi.github.io/docs/spot/v1/cn/","https://huobiapi.github.io/docs/dm/v1/cn/","https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/","https://huobiapi.github.io/docs/usdt_swap/v1/cn/","https://huobiapi.github.io/docs/option/v1/cn/"],fees:"https://www.huobi.com/about/fee/"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}},status:{public:{spot:{get:{"api/v2/summary.json":1}},future:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}},swap:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}}}},spot:{public:{get:{"v2/market-status":1,"v1/common/symbols":1,"v1/common/currencys":1,"v2/settings/common/currencies":1,"v2/reference/currencies":1,"v1/common/timestamp":1,"v1/common/exchange":1,"v1/settings/common/chains":1,"v1/settings/common/currencys":1,"v1/settings/common/symbols":1,"v2/settings/common/symbols":1,"v1/settings/common/market-symbols":1,"market/history/candles":1,"market/history/kline":1,"market/detail/merged":1,"market/tickers":1,"market/detail":1,"market/depth":1,"market/trade":1,"market/history/trade":1,"market/detail/":1,"market/etp":1,"v2/etp/reference":1,"v2/etp/rebalance":1}},private:{get:{"v1/account/accounts":.2,"v1/account/accounts/{account-id}/balance":.2,"v2/account/valuation":1,"v2/account/asset-valuation":.2,"v1/account/history":4,"v2/account/ledger":1,"v2/point/account":5,"v2/account/deposit/address":1,"v2/account/withdraw/quota":1,"v2/account/withdraw/address":1,"v2/reference/currencies":1,"v1/query/deposit-withdraw":1,"v1/query/withdraw/client-order-id":1,"v2/user/api-key":1,"v2/user/uid":1,"v2/sub-user/user-list":1,"v2/sub-user/user-state":1,"v2/sub-user/account-list":1,"v2/sub-user/deposit-address":1,"v2/sub-user/query-deposit":1,"v1/subuser/aggregate-balance":10,"v1/account/accounts/{sub-uid}":1,"v1/order/openOrders":.4,"v1/order/orders/{order-id}":.4,"v1/order/orders/getClientOrder":.4,"v1/order/orders/{order-id}/matchresult":.4,"v1/order/orders/{order-id}/matchresults":.4,"v1/order/orders":.4,"v1/order/history":1,"v1/order/matchresults":1,"v2/reference/transact-fee-rate":1,"v2/algo-orders/opening":1,"v2/algo-orders/history":1,"v2/algo-orders/specific":1,"v1/margin/loan-info":1,"v1/margin/loan-orders":.2,"v1/margin/accounts/balance":.2,"v1/cross-margin/loan-info":1,"v1/cross-margin/loan-orders":1,"v1/cross-margin/accounts/balance":1,"v2/account/repayment":5,"v1/stable-coin/quote":1,"v1/stable_coin/exchange_rate":1,"v2/etp/transactions":5,"v2/etp/transaction":5,"v2/etp/limit":1},post:{"v1/account/transfer":1,"v1/futures/transfer":1,"v2/point/transfer":5,"v2/account/transfer":1,"v1/dw/withdraw/api/create":1,"v1/dw/withdraw-virtual/{withdraw-id}/cancel":1,"v2/sub-user/deduct-mode":1,"v2/sub-user/creation":1,"v2/sub-user/management":1,"v2/sub-user/tradable-market":1,"v2/sub-user/transferability":1,"v2/sub-user/api-key-generation":1,"v2/sub-user/api-key-modification":1,"v2/sub-user/api-key-deletion":1,"v1/subuser/transfer":10,"v1/order/orders/place":.2,"v1/order/batch-orders":.4,"v1/order/orders/{order-id}/submitcancel":.2,"v1/order/orders/submitCancelClientOrder":.2,"v1/order/orders/batchCancelOpenOrders":.4,"v1/order/orders/batchcancel":.4,"v2/algo-orders/cancel-all-after":1,"v2/algo-orders":1,"v2/algo-orders/cancellation":1,"v2/account/repayment":5,"v1/dw/transfer-in/margin":10,"v1/dw/transfer-out/margin":10,"v1/margin/orders":10,"v1/margin/orders/{order-id}/repay":10,"v1/cross-margin/transfer-in":1,"v1/cross-margin/transfer-out":1,"v1/cross-margin/orders":1,"v1/cross-margin/orders/{order-id}/repay":1,"v1/stable-coin/exchange":1,"v2/etp/creation":5,"v2/etp/redemption":5,"v2/etp/{transactId}/cancel":10,"v2/etp/batch-cancel":50}}},contract:{public:{get:{"api/v1/timestamp":1,"heartbeat/":1,"api/v1/contract_contract_info":1,"api/v1/contract_index":1,"api/v1/contract_price_limit":1,"api/v1/contract_open_interest":1,"api/v1/contract_delivery_price":1,"market/depth":1,"market/bbo":1,"market/history/kline":1,"index/market/history/mark_price_kline":1,"market/detail/merged":1,"market/detail/batch_merged":1,"v2/market/detail/batch_merged":1,"market/trade":1,"market/history/trade":1,"api/v1/contract_risk_info":1,"api/v1/contract_insurance_fund":1,"api/v1/contract_adjustfactor":1,"api/v1/contract_his_open_interest":1,"api/v1/contract_ladder_margin":1,"api/v1/contract_api_state":1,"api/v1/contract_elite_account_ratio":1,"api/v1/contract_elite_position_ratio":1,"api/v1/contract_liquidation_orders":1,"api/v1/contract_settlement_records":1,"index/market/history/index":1,"index/market/history/basis":1,"api/v1/contract_estimated_settlement_price":1,"api/v3/contract_liquidation_orders":1,"swap-api/v1/swap_contract_info":1,"swap-api/v1/swap_index":1,"swap-api/v1/swap_price_limit":1,"swap-api/v1/swap_open_interest":1,"swap-ex/market/depth":1,"swap-ex/market/bbo":1,"swap-ex/market/history/kline":1,"index/market/history/swap_mark_price_kline":1,"swap-ex/market/detail/merged":1,"v2/swap-ex/market/detail/batch_merged":1,"index/market/history/swap_premium_index_kline":1,"swap-ex/market/detail/batch_merged":1,"swap-ex/market/trade":1,"swap-ex/market/history/trade":1,"swap-api/v1/swap_risk_info":1,"swap-api/v1/swap_insurance_fund":1,"swap-api/v1/swap_adjustfactor":1,"swap-api/v1/swap_his_open_interest":1,"swap-api/v1/swap_ladder_margin":1,"swap-api/v1/swap_api_state":1,"swap-api/v1/swap_elite_account_ratio":1,"swap-api/v1/swap_elite_position_ratio":1,"swap-api/v1/swap_estimated_settlement_price":1,"swap-api/v1/swap_liquidation_orders":1,"swap-api/v1/swap_settlement_records":1,"swap-api/v1/swap_funding_rate":1,"swap-api/v1/swap_batch_funding_rate":1,"swap-api/v1/swap_historical_funding_rate":1,"swap-api/v3/swap_liquidation_orders":1,"index/market/history/swap_estimated_rate_kline":1,"index/market/history/swap_basis":1,"linear-swap-api/v1/swap_contract_info":1,"linear-swap-api/v1/swap_index":1,"linear-swap-api/v1/swap_price_limit":1,"linear-swap-api/v1/swap_open_interest":1,"linear-swap-ex/market/depth":1,"linear-swap-ex/market/bbo":1,"linear-swap-ex/market/history/kline":1,"index/market/history/linear_swap_mark_price_kline":1,"linear-swap-ex/market/detail/merged":1,"linear-swap-ex/market/detail/batch_merged":1,"v2/linear-swap-ex/market/detail/batch_merged":1,"linear-swap-ex/market/trade":1,"linear-swap-ex/market/history/trade":1,"linear-swap-api/v1/swap_risk_info":1,"swap-api/v1/linear-swap-api/v1/swap_insurance_fund":1,"linear-swap-api/v1/swap_adjustfactor":1,"linear-swap-api/v1/swap_cross_adjustfactor":1,"linear-swap-api/v1/swap_his_open_interest":1,"linear-swap-api/v1/swap_ladder_margin":1,"linear-swap-api/v1/swap_cross_ladder_margin":1,"linear-swap-api/v1/swap_api_state":1,"linear-swap-api/v1/swap_cross_transfer_state":1,"linear-swap-api/v1/swap_cross_trade_state":1,"linear-swap-api/v1/swap_elite_account_ratio":1,"linear-swap-api/v1/swap_elite_position_ratio":1,"linear-swap-api/v1/swap_liquidation_orders":1,"linear-swap-api/v1/swap_settlement_records":1,"linear-swap-api/v1/swap_funding_rate":1,"linear-swap-api/v1/swap_batch_funding_rate":1,"linear-swap-api/v1/swap_historical_funding_rate":1,"linear-swap-api/v3/swap_liquidation_orders":1,"index/market/history/linear_swap_premium_index_kline":1,"index/market/history/linear_swap_estimated_rate_kline":1,"index/market/history/linear_swap_basis":1,"linear-swap-api/v1/swap_estimated_settlement_price":1}},private:{get:{"api/v1/contract_api_trading_status":1,"swap-api/v1/swap_api_trading_status":1,"linear-swap-api/v1/swap_api_trading_status":1},post:{"api/v1/contract_balance_valuation":1,"api/v1/contract_account_info":1,"api/v1/contract_position_info":1,"api/v1/contract_sub_auth":1,"api/v1/contract_sub_account_list":1,"api/v1/contract_sub_account_info_list":1,"api/v1/contract_sub_account_info":1,"api/v1/contract_sub_position_info":1,"api/v1/contract_financial_record":1,"api/v1/contract_financial_record_exact":1,"api/v1/contract_user_settlement_records":1,"api/v1/contract_order_limit":1,"api/v1/contract_fee":1,"api/v1/contract_transfer_limit":1,"api/v1/contract_position_limit":1,"api/v1/contract_account_position_info":1,"api/v1/contract_master_sub_transfer":1,"api/v1/contract_master_sub_transfer_record":1,"api/v1/contract_available_level_rate":1,"api/v3/contract_financial_record":1,"api/v3/contract_financial_record_exact":1,"api/v1/contract_order":1,"v1/contract_batchorder":1,"api/v1/contract_cancel":1,"api/v1/contract_cancelall":1,"api/v1/contract_switch_lever_rate":1,"api/v1/lightning_close_position":1,"api/v1/contract_order_info":1,"api/v1/contract_order_detail":1,"api/v1/contract_openorders":1,"api/v1/contract_hisorders":1,"api/v1/contract_hisorders_exact":1,"api/v1/contract_matchresults":1,"api/v1/contract_matchresults_exact":1,"api/v3/contract_hisorders":1,"api/v3/contract_hisorders_exact":1,"api/v3/contract_matchresults":1,"api/v3/contract_matchresults_exact":1,"api/v1/contract_trigger_order":1,"api/v1/contract_trigger_cancel":1,"api/v1/contract_trigger_cancelall":1,"api/v1/contract_trigger_openorders":1,"api/v1/contract_trigger_hisorders":1,"api/v1/contract_tpsl_order":1,"api/v1/contract_tpsl_cancel":1,"api/v1/contract_tpsl_cancelall":1,"api/v1/contract_tpsl_openorders":1,"api/v1/contract_tpsl_hisorders":1,"api/v1/contract_relation_tpsl_order":1,"api/v1/contract_track_order":1,"api/v1/contract_track_cancel":1,"api/v1/contract_track_cancelall":1,"api/v1/contract_track_openorders":1,"api/v1/contract_track_hisorders":1,"swap-api/v1/swap_balance_valuation":1,"swap-api/v1/swap_account_info":1,"swap-api/v1/swap_position_info":1,"swap-api/v1/swap_account_position_info":1,"swap-api/v1/swap_sub_auth":1,"swap-api/v1/swap_sub_account_list":1,"swap-api/v1/swap_sub_account_info_list":1,"swap-api/v1/swap_sub_account_info":1,"swap-api/v1/swap_sub_position_info":1,"swap-api/v1/swap_financial_record":1,"swap-api/v1/swap_financial_record_exact":1,"swap-api/v1/swap_user_settlement_records":1,"swap-api/v1/swap_available_level_rate":1,"swap-api/v1/swap_order_limit":1,"swap-api/v1/swap_fee":1,"swap-api/v1/swap_transfer_limit":1,"swap-api/v1/swap_position_limit":1,"swap-api/v1/swap_master_sub_transfer":1,"swap-api/v1/swap_master_sub_transfer_record":1,"swap-api/v3/swap_financial_record":1,"swap-api/v3/swap_financial_record_exact":1,"swap-api/v1/swap_order":1,"swap-api/v1/swap_batchorder":1,"swap-api/v1/swap_cancel":1,"swap-api/v1/swap_cancelall":1,"swap-api/v1/swap_lightning_close_position":1,"swap-api/v1/swap_switch_lever_rate":1,"swap-api/v1/swap_order_info":1,"swap-api/v1/swap_order_detail":1,"swap-api/v1/swap_openorders":1,"swap-api/v1/swap_hisorders":1,"swap-api/v1/swap_hisorders_exact":1,"swap-api/v1/swap_matchresults":1,"swap-api/v1/swap_matchresults_exact":1,"swap-api/v3/swap_matchresults":1,"swap-api/v3/swap_matchresults_exact":1,"swap-api/v3/swap_hisorders":1,"swap-api/v3/swap_hisorders_exact":1,"swap-api/v1/swap_trigger_order":1,"swap-api/v1/swap_trigger_cancel":1,"swap-api/v1/swap_trigger_cancelall":1,"swap-api/v1/swap_trigger_openorders":1,"swap-api/v1/swap_trigger_hisorders":1,"swap-api/v1/swap_tpsl_order":1,"swap-api/v1/swap_tpsl_cancel":1,"swap-api/v1/swap_tpsl_cancelall":1,"swap-api/v1/swap_tpsl_openorders":1,"swap-api/v1/swap_tpsl_hisorders":1,"swap-api/v1/swap_relation_tpsl_order":1,"swap-api/v1/swap_track_order":1,"swap-api/v1/swap_track_cancel":1,"swap-api/v1/swap_track_cancelall":1,"swap-api/v1/swap_track_openorders":1,"swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_lever_position_limit":1,"linear-swap-api/v1/swap_cross_lever_position_limit":1,"linear-swap-api/v1/swap_balance_valuation":1,"linear-swap-api/v1/swap_account_info":1,"linear-swap-api/v1/swap_cross_account_info":1,"linear-swap-api/v1/swap_position_info":1,"linear-swap-api/v1/swap_cross_position_info":1,"linear-swap-api/v1/swap_account_position_info":1,"linear-swap-api/v1/swap_cross_account_position_info":1,"linear-swap-api/v1/swap_sub_auth":1,"linear-swap-api/v1/swap_sub_account_list":1,"linear-swap-api/v1/swap_cross_sub_account_list":1,"linear-swap-api/v1/swap_sub_account_info_list":1,"linear-swap-api/v1/swap_cross_sub_account_info_list":1,"linear-swap-api/v1/swap_sub_account_info":1,"linear-swap-api/v1/swap_cross_sub_account_info":1,"linear-swap-api/v1/swap_sub_position_info":1,"linear-swap-api/v1/swap_cross_sub_position_info":1,"linear-swap-api/v1/swap_financial_record":1,"linear-swap-api/v1/swap_financial_record_exact":1,"linear-swap-api/v1/swap_user_settlement_records":1,"linear-swap-api/v1/swap_cross_user_settlement_records":1,"linear-swap-api/v1/swap_available_level_rate":1,"linear-swap-api/v1/swap_cross_available_level_rate":1,"linear-swap-api/v1/swap_order_limit":1,"linear-swap-api/v1/swap_fee":1,"linear-swap-api/v1/swap_transfer_limit":1,"linear-swap-api/v1/swap_cross_transfer_limit":1,"linear-swap-api/v1/swap_position_limit":1,"linear-swap-api/v1/swap_cross_position_limit":1,"linear-swap-api/v1/swap_master_sub_transfer":1,"linear-swap-api/v1/swap_master_sub_transfer_record":1,"linear-swap-api/v1/swap_transfer_inner":1,"linear-swap-api/v3/swap_financial_record":1,"linear-swap-api/v3/swap_financial_record_exact":1,"linear-swap-api/v1/swap_order":1,"linear-swap-api/v1/swap_cross_order":1,"linear-swap-api/v1/swap_batchorder":1,"linear-swap-api/v1/swap_cross_batchorder":1,"linear-swap-api/v1/swap_cancel":1,"linear-swap-api/v1/swap_cross_cancel":1,"linear-swap-api/v1/swap_cancelall":1,"linear-swap-api/v1/swap_cross_cancelall":1,"linear-swap-api/v1/swap_switch_lever_rate":1,"linear-swap-api/v1/swap_cross_switch_lever_rate":1,"linear-swap-api/v1/swap_lightning_close_position":1,"linear-swap-api/v1/swap_cross_lightning_close_position":1,"linear-swap-api/v1/swap_order_info":1,"linear-swap-api/v1/swap_cross_order_info":1,"linear-swap-api/v1/swap_order_detail":1,"linear-swap-api/v1/swap_cross_order_detail":1,"linear-swap-api/v1/swap_openorders":1,"linear-swap-api/v1/swap_cross_openorders":1,"linear-swap-api/v1/swap_hisorders":1,"linear-swap-api/v1/swap_cross_hisorders":1,"linear-swap-api/v1/swap_hisorders_exact":1,"linear-swap-api/v1/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_matchresults":1,"linear-swap-api/v1/swap_cross_matchresults":1,"linear-swap-api/v1/swap_matchresults_exact":1,"linear-swap-api/v1/swap_cross_matchresults_exact":1,"linear-swap-api/v1/swap_switch_position_mode":1,"linear-swap-api/v1/swap_cross_switch_position_mode":1,"linear-swap-api/v3/swap_matchresults":1,"linear-swap-api/v3/swap_cross_matchresults":1,"linear-swap-api/v3/swap_matchresults_exact":1,"linear-swap-api/v3/swap_cross_matchresults_exact":1,"linear-swap-api/v3/swap_hisorders":1,"linear-swap-api/v3/swap_cross_hisorders":1,"linear-swap-api/v3/swap_hisorders_exact":1,"linear-swap-api/v3/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_trigger_order":1,"linear-swap-api/v1/swap_cross_trigger_order":1,"linear-swap-api/v1/swap_trigger_cancel":1,"linear-swap-api/v1/swap_cross_trigger_cancel":1,"linear-swap-api/v1/swap_trigger_cancelall":1,"linear-swap-api/v1/swap_cross_trigger_cancelall":1,"linear-swap-api/v1/swap_trigger_openorders":1,"linear-swap-api/v1/swap_cross_trigger_openorders":1,"linear-swap-api/v1/swap_trigger_hisorders":1,"linear-swap-api/v1/swap_cross_trigger_hisorders":1,"linear-swap-api/v1/swap_tpsl_order":1,"linear-swap-api/v1/swap_cross_tpsl_order":1,"linear-swap-api/v1/swap_tpsl_cancel":1,"linear-swap-api/v1/swap_cross_tpsl_cancel":1,"linear-swap-api/v1/swap_tpsl_cancelall":1,"linear-swap-api/v1/swap_cross_tpsl_cancelall":1,"linear-swap-api/v1/swap_tpsl_openorders":1,"linear-swap-api/v1/swap_cross_tpsl_openorders":1,"linear-swap-api/v1/swap_tpsl_hisorders":1,"linear-swap-api/v1/swap_cross_tpsl_hisorders":1,"linear-swap-api/v1/swap_relation_tpsl_order":1,"linear-swap-api/v1/swap_cross_relation_tpsl_order":1,"linear-swap-api/v1/swap_track_order":1,"linear-swap-api/v1/swap_cross_track_order":1,"linear-swap-api/v1/swap_track_cancel":1,"linear-swap-api/v1/swap_cross_track_cancel":1,"linear-swap-api/v1/swap_track_cancelall":1,"linear-swap-api/v1/swap_cross_track_cancelall":1,"linear-swap-api/v1/swap_track_openorders":1,"linear-swap-api/v1/swap_cross_track_openorders":1,"linear-swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_cross_track_hisorders":1}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":jl,maintain:jl},exact:{403:Zc,1010:xb,1003:Zc,1013:Yn,1017:Jc,1034:zt,1036:zt,1039:zt,1041:zt,1047:eu,1048:eu,1051:zt,1066:Yn,1067:zt,1094:zt,1220:xb,1461:zt,"bad-request":As,"validation-format-error":As,"validation-constraints-required":As,"base-date-limit-error":As,"api-not-support-temp-addr":F4,timeout:G4,"gateway-internal-error":_b,"account-frozen-balance-insufficient-error":eu,"invalid-amount":zt,"order-limitorder-amount-min-error":zt,"order-limitorder-amount-max-error":zt,"order-marketorder-amount-min-error":zt,"order-limitorder-price-min-error":zt,"order-limitorder-price-max-error":zt,"order-stop-order-hit-trigger":zt,"order-value-min-error":zt,"order-invalid-price":zt,"order-holding-limit-failed":zt,"order-orderprice-precision-error":zt,"order-etp-nav-price-max-error":zt,"order-orderstate-error":Jc,"order-queryorder-invalid":Jc,"order-update-error":_b,"api-signature-check-failed":Zc,"api-signature-not-valid":Zc,"base-record-invalid":Jc,"base-symbol-trade-disabled":Yn,"base-symbol-error":Yn,"system-maintenance":jl,"base-request-exceed-frequency-limit":H4,"invalid symbol":Yn,"symbol trade not open now":Yn,"require-symbol":Yn,"invalid-address":As,"base-currency-chain-error":As,"dw-insufficient-balance":eu,"base-withdraw-fee-error":As,"dw-withdraw-min-limit":As}},precisionMode:$4,options:{fetchMarkets:{types:{spot:!0,future:{linear:!0,inverse:!0},swap:{linear:!0,inverse:!0}}},withdraw:{includeFee:!1},defaultType:"spot",defaultSubType:"linear",defaultNetwork:"ERC20",defaultNetworks:{ETH:"ERC20",BTC:"BTC",USDT:"TRC20"},networks:{ALGO:"ALGO",ALGORAND:"ALGO",BEP20:"BEP20",BSC:"BEP20",ERC20:"ERC20",ETH:"ERC20",AVALANCHE:"AVAXCCHAIN",AVAX:"AVAXCCHAIN",HRC20:"HECO",HECO:"HECO",TRC20:"TRC20",TRX:"TRC20",BTC:"BTC",BITCOIN:"BTC",ARBITRUM:"ARB",ARB:"ARB",SOLANA:"SOL",SOL:"SOL",SPL:"SOL",PRC20:"PRC20",POLYGON:"PRC20",MATIC:"PRC20"},networksById:{ALGO:"ALGO",BEP20:"BEP20",ERC20:"ERC20",AVAXCCHAIN:"AVALANCHE",HECO:"HRC20",TRC20:"TRC20",BTC:"BTC",ARB:"ARBITRUM",SOL:"SOLANA",PRC20:"POLYGON"},fetchOrdersByStatesMethod:"spot_private_get_v1_order_orders",createMarketBuyOrderRequiresPrice:!0,language:"en-US",broker:{id:"AA03022abc"},accountsByType:{spot:"pro",funding:"pro",future:"futures"},accountsById:{spot:"spot",margin:"margin",otc:"otc",point:"point","super-margin":"super-margin",investment:"investment",borrow:"borrow","grid-trading":"grid-trading","deposit-earning":"deposit-earning","otc-options":"otc-options"},marginAccounts:{cross:"super-margin",isolated:"margin"},typesByAccount:{pro:"spot",futures:"future"},spot:{stopOrderTypes:{"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0},limitOrderTypes:{limit:!0,"buy-limit":!0,"sell-limit":!0,ioc:!0,"buy-ioc":!0,"sell-ioc":!0,"limit-maker":!0,"buy-limit-maker":!0,"sell-limit-maker":!0,"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"limit-fok":!0,"buy-limit-fok":!0,"sell-limit-fok":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0}}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",SOUL:"Soulsaver",BIFI:"Bitcoin File"}})}async fetchStatus(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchMyTrades",void 0,e);let s="statusPublicSpotGetApiV2SummaryJson";if(t!=="spot"){const o=this.safeString(e,"subType",this.options.defaultSubType);t==="swap"?o==="linear"?s="statusPublicSwapLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicSwapInverseGetApiV2SummaryJson"):t==="future"?o==="linear"?s="statusPublicFutureLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicFutureInverseGetApiV2SummaryJson"):t==="contract"&&(s="contractPublicGetHeartbeat")}const i=await this[s]();let n,r,a;if(s==="contractPublicGetHeartbeat")n=this.safeString(i,"status")==="ok"?"ok":"maintenance",r=this.safeString(i,"ts");else{const o=this.safeValue(i,"status",{});n=this.safeString(o,"indicator")==="none"?"ok":"maintenance";const c=this.safeValue(i,"page",{}),u=this.safeString(c,"updated_at");r=this.parse8601(u),a=this.safeString(c,"url")}return{status:n,updated:r,eta:void 0,url:a,info:i}}async fetchTime(e={}){const t=this.safeValue(this.options,"fetchTime",{}),s=this.safeString(this.options,"defaultType","spot");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i);let n="spotPublicGetV1CommonTimestamp";(i==="future"||i==="swap")&&(n="contractPublicGetApiV1Timestamp");const r=await this[n](e);return this.safeInteger2(r,"data","ts")}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"actualMakerRate"),taker:this.safeNumber(e,"actualTakerRate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.spotPublicGetV1CommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,W4,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeValue(t,"types",{});let i=[],n=[];const r=Object.keys(s);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeValue(s,o);if(d===!0)n.push(this.fetchMarketsByTypeAndSubType(o,void 0,e));else{const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u];this.safeValue(d,h)&&n.push(this.fetchMarketsByTypeAndSubType(o,h,e))}}}n=await Promise.all(n);for(let a=0;a<n.length;a++)i=this.arrayConcat(i,n[a]);return i}async fetchMarketsByTypeAndSubType(e,t,s={}){let i="spotPublicGetV1CommonSymbols";const n=this.omit(s,["type","subType"]),r=e==="spot",a=e!=="spot",o=e==="future",d=e==="swap";let c,u;const h={};a&&(c=t==="linear",u=t==="inverse",c?(i="contractPublicGetLinearSwapApiV1SwapContractInfo",o&&(h.business_type="futures")):u&&(o?i="contractPublicGetApiV1ContractContractInfo":d&&(i="contractPublicGetSwapApiV1SwapContractInfo")));const f=await this[i](this.extend(h,n)),l=this.safeValue(f,"data",[]);if(l.length<1)throw new U4(this.id+" fetchMarkets() returned an empty response: "+this.json(l));const g=[];for(let y=0;y<l.length;y++){const w=l[y];let b,S,v,T,I,A;if(a){if(T=this.safeString(w,"contract_code"),I=T.toLowerCase(),d){const me=T.split("-");b=this.safeString(w,"symbol"),A=b.toLowerCase(),S=this.safeStringLower(me,1),v=u?b:S}else if(o)if(b=this.safeString(w,"symbol"),A=b.toLowerCase(),u)S="USD",v=b;else{const ye=this.safeString(w,"pair").split("-");S=this.safeString(ye,1),v=S}}else b=this.safeString(w,"base-currency"),A=b.toLowerCase(),S=this.safeString(w,"quote-currency"),T=b+S,I=T.toLowerCase();const N=this.safeCurrencyCode(b),B=this.safeCurrencyCode(S),x=this.safeCurrencyCode(v);let k=N+"/"+B,O;a&&(u?k+=":"+N:c&&(k+=":"+B),o&&(O=this.safeInteger(w,"delivery_time"),k+="-"+this.yymmdd(O)));const P=this.safeNumber(w,"contract_size");let q=this.safeNumber(w,"min-order-value");const L=this.safeNumber(w,"max-order-amt");let D=this.safeNumber(w,"min-order-amt");a&&(c?D=P:u&&(q=P));let H,R,_;r?(H=this.parseNumber(this.parsePrecision(this.safeString(w,"price-precision"))),R=this.parseNumber(this.parsePrecision(this.safeString(w,"amount-precision"))),_=this.parseNumber(this.parsePrecision(this.safeString(w,"value-precision")))):(H=this.safeNumber(w,"price_tick"),R=this.parseNumber("1"));let E,U;r&&(E=N==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"),U=N==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"));let G;r?G=this.safeString(w,"state")==="online":a&&(G=this.safeInteger(w,"contract_status")===1);const $=this.safeString(w,"leverage-ratio","1"),Z=this.safeString(w,"super-margin-leverage-ratio","1"),he=Bs.stringGt($,"1")||Bs.stringGt(Z,"1");g.push({id:T,lowercaseId:I,symbol:k,base:N,quote:B,settle:x,baseId:b,lowercaseBaseId:A,quoteId:S,settleId:v,type:e,spot:r,margin:r&&he,swap:d,future:o,option:!1,active:G,contract:a,linear:c,inverse:u,taker:U,maker:E,contractSize:P,expiry:O,expiryDatetime:this.iso8601(O),strike:void 0,optionType:void 0,precision:{amount:R,price:H,cost:_},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber($),superMax:this.parseNumber(Z)},amount:{min:D,max:L},price:{min:void 0,max:void 0},cost:{min:q,max:void 0}},info:w})}return g}parseTicker(e,t=void 0){const s=this.safeString2(e,"symbol","contract_code"),i=this.safeSymbol(s,t),n=this.safeInteger2(e,"ts","quoteTime");let r,a,o,d;"bid"in e&&(Array.isArray(e.bid)?(r=this.safeString(e.bid,0),a=this.safeString(e.bid,1)):(r=this.safeString(e,"bid"),a=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(o=this.safeString(e.ask,0),d=this.safeString(e.ask,1)):(o=this.safeString(e,"ask"),d=this.safeString(e,"askSize")));const c=this.safeString(e,"open"),u=this.safeString(e,"close"),h=this.safeString(e,"amount"),f=this.safeString(e,"vol");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:r,bidVolume:a,ask:o,askVolume:d,vwap:void 0,open:c,close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:f,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n="symbol",r="spotPublicGetMarketDetailMerged";s.linear?(r="contractPublicGetLinearSwapExMarketDetailMerged",n="contract_code"):s.inverse&&(s.future?r="contractPublicGetMarketDetailMerged":s.swap&&(r="contractPublicGetSwapExMarketDetailMerged",n="contract_code")),i[n]=s.id;const a=await this[r](this.extend(i,t)),o=this.safeValue(a,"tick",{}),d=this.parseTicker(o,s),c=this.safeInteger(a,"ts");return d.timestamp=c,d.datetime=this.iso8601(c),d}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n,r,a="spotPublicGetMarketTickers";[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),[r,t]=this.handleSubTypeAndParams("fetchTickers",i,t);const o={},d=n==="future",c=n==="swap",u=r==="linear";(d||c)&&(u?(a="contractPublicGetLinearSwapExMarketDetailBatchMerged",d&&(o.business_type="futures")):r==="inverse"&&(d?a="contractPublicGetMarketDetailBatchMerged":c&&(a="contractPublicGetSwapExMarketDetailBatchMerged"))),t=this.omit(t,["type","subType"]);const f=await this[a](this.extend(o,t)),l=this.safeValue2(f,"data","ticks",[]),m=this.safeInteger(f,"ts"),g={};for(let y=0;y<l.length;y++){const w=this.parseTicker(l[y]);if(d&&u)for(let S=0;S<this.symbols.length;S++){const v=this.symbols[S],T=this.market(v),I=this.safeString(T.info,"contract_type");if(I==="this_week"&&w.symbol===T.baseId+"-"+T.quoteId+"-CW"){w.symbol=T.symbol;break}else if(I==="next_week"&&w.symbol===T.baseId+"-"+T.quoteId+"-NW"){w.symbol=T.symbol;break}else if(I==="this_quarter"&&w.symbol===T.baseId+"-"+T.quoteId+"-CQ"){w.symbol=T.symbol;break}else if(I==="next_quarter"&&w.symbol===T.baseId+"-"+T.quoteId+"-NQ"){w.symbol=T.symbol;break}}const b=w.symbol;w.timestamp=m,w.datetime=this.iso8601(m),g[b]=w}return this.filterByArray(g,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={type:"step0"};let r="symbol",a="spotPublicGetMarketDepth";if(i.linear)a="contractPublicGetLinearSwapExMarketDepth",r="contract_code";else if(i.inverse)i.future?a="contractPublicGetMarketDepth":i.swap&&(a="contractPublicGetSwapExMarketDepth",r="contract_code");else if(t!==void 0){if(t!==5&&t!==10&&t!==20&&t!==150)throw new As(this.id+" fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150");t!==150&&(n.depth=t)}n[r]=i.id;const o=await this[a](this.extend(n,s));if("tick"in o){if(!o.tick)throw new Yn(this.id+" fetchOrderBook() returned empty response: "+this.json(o));const d=this.safeValue(o,"tick"),c=this.safeInteger(d,"ts",this.safeInteger(o,"ts")),u=this.parseOrderBook(d,e,c);return u.nonce=this.safeInteger(d,"version"),u}throw new Qc(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(o))}parseTrade(e,t=void 0){const s=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeInteger2(e,"ts","created-at");n=this.safeInteger2(e,"created_at","create_date",n);const r=this.safeString2(e,"order-id","order_id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const S=o.split("-");a=S[0],o=S[1]}const d=this.safeStringLower(e,"role"),c=this.safeString2(e,"price","trade_price");let u=this.safeString2(e,"filled-amount","amount");u=this.safeString(e,"trade_volume",u);const h=this.safeString(e,"trade_turnover");let f,l=this.safeString2(e,"filled-fees","trade_fee");const m=this.safeString2(e,"fee-currency","fee_asset");let g=this.safeCurrencyCode(m);const y=this.safeString(e,"filled-points");if(y!==void 0&&(l===void 0||Bs.stringEquals(l,"0"))){const S=this.safeString(e,"fee-deduct-currency");S!==void 0&&(l=y,g=this.safeCurrencyCode(S))}l!==void 0&&(f={cost:l,currency:g});const w=this.safeString2(e,"trade-id","tradeId"),b=this.safeString2(e,"trade_id","id",w);return this.safeTrade({id:b,info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:c,amount:u,cost:h,fee:f},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));let a;[a,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);const o=this.getSupportedMapping(a,{spot:"fetchSpotOrderTrades"});return await this[o](e,t,s,i,n)}async fetchSpotOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={"order-id":e},a=await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);const a={};let o;if(r==="spot")e!==void 0&&(n=this.market(e),a.symbol=n.id),s!==void 0&&(a.size=s),t!==void 0&&(a["start-time"]=t),o="spotPrivateGetV1OrderMatchresults";else{if(e===void 0)throw new hs(this.id+" fetchMyTrades() requires a symbol for "+r+" orders");if(a.contract=n.id,a.trade_type=0,t!==void 0&&(a.start_time=t),s!==void 0&&(a.page_size=s),n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchMyTrades",i),u=u===void 0?"cross":u,u==="isolated"?o="contractPrivatePostLinearSwapApiV3SwapMatchresultsExact":u==="cross"&&(o="contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact")}else if(n.inverse)if(r==="future")o="contractPrivatePostApiV3ContractMatchresultsExact",a.symbol=n.settleId;else if(r==="swap")o="contractPrivatePostSwapApiV3SwapMatchresultsExact";else throw new si(this.id+" fetchMyTrades() does not support "+r+" markets")}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"trades")),this.parseTrades(c,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={};let a="symbol",o="spotPublicGetMarketHistoryTrade";n.future?n.inverse?o="contractPublicGetMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade",a="contract_code"):n.swap&&(n.inverse?o="contractPublicGetSwapExMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade"),a="contract_code"),r[a]=n.id,s!==void 0&&(r.size=s);const d=await this[o](this.extend(r,i)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const f=this.safeValue(c[h],"data",[]);for(let l=0;l<f.length;l++){const m=this.parseTrade(f[l],n);u.push(m)}}return u=this.sortBy(u,"timestamp"),this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};let o="symbol";const d=this.safeString(n,"price");n=this.omit(n,"price");let c="spotPublicGetMarketHistoryCandles";if(r.spot)s!==void 0&&(a.from=parseInt(s/1e3)),i!==void 0&&(a.size=i);else if(r.future){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistoryMarkPriceKline";else if(d==="index")c="contractPublicGetIndexMarketHistoryIndex";else{if(d==="premiumIndex")throw new As(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");c="contractPublicGetMarketHistoryKline"}else if(r.linear){if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new As(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}}else if(r.swap){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistorySwapMarkPriceKline";else{if(d==="index")throw new As(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistorySwapPremiumIndexKline":c="contractPublicGetSwapExMarketHistoryKline"}else if(r.linear)if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new As(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}if(r.contract&&(i===void 0&&(i=2e3),a.size=i,d===void 0)){const f=this.parseTimeframe(t);if(s===void 0){const l=this.seconds();a.from=l-f*(i-1),a.to=l}else{const l=parseInt(s/1e3);a.from=l,a.to=this.sum(l,f*(i-1))}}a[o]=r.id;const u=await this[c](this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1AccountAccounts(e),s=this.safeValue(t,"data");return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"type"),s=this.safeValue(this.options,"accountsById",{}),i=this.safeValue(s,t,t);return{info:e,id:this.safeString(e,"id"),type:i,code:void 0}}async fetchAccountIdByType(e,t={}){const s=await this.loadAccounts(),i=this.safeValue(t,"account-id");if(i!==void 0)return i;const n=this.indexBy(s,"type"),r=this.safeValue(s,0,{}),a=this.safeValue(n,e,r);return this.safeString(a,"id")}async fetchCurrencies(e={}){const t=await this.spotPublicGetV2ReferenceCurrencies(e),s=this.safeValue(t,"data",[]),i={};this.options.networkChainIdsByNames={},this.options.networkNamesByChainIds={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a);this.options.networkChainIdsByNames[o]={};const d=this.safeValue(r,"chains",[]),c={},h=this.safeString(r,"instStatus")==="normal";let f,l,m,g,y;for(let w=0;w<d.length;w++){const b=d[w],S=this.safeString(b,"chain"),v=this.safeString(b,"displayName");this.options.networkChainIdsByNames[o][v]=S,this.options.networkNamesByChainIds[S]=v;const T=this.networkIdToCode(v,o);l=this.safeNumber(b,"minWithdrawAmt"),m=this.safeNumber(b,"maxWithdrawAmt");const I=this.safeString(b,"withdrawStatus"),A=this.safeString(b,"depositStatus"),N=I==="allowed",B=A==="allowed",x=N&&B,k=this.parsePrecision(this.safeString(b,"withdrawPrecision"));k!==void 0&&(f=f===void 0?k:Bs.stringMin(k,f)),N&&!y?y=!0:N||(y=!1),B&&!g?g=!0:B||(g=!1);const O=this.safeNumber(b,"transactFeeWithdraw");c[T]={info:b,id:S,network:T,limits:{withdraw:{min:l,max:m}},active:x,deposit:B,withdraw:N,fee:O,precision:this.parseNumber(k)}}i[o]={info:r,code:o,id:a,active:h,deposit:g,withdraw:y,fee:void 0,name:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:l,max:m}},precision:this.parseNumber(f),networks:c}}return i}networkIdToCode(e,t=void 0){if(Object.keys(this.options.networkNamesByChainIds).length===0)throw new Qc(this.id+" networkIdToCode() - markets need to be loaded at first");const n=this.safeValue(this.options.networkNamesByChainIds,e,e);return super.networkIdToCode(n)}networkCodeToId(e,t=void 0){if(t===void 0)throw new hs(this.id+" networkCodeToId() requires a currencyCode argument");if(Object.keys(this.options.networkChainIdsByNames).length===0)throw new Qc(this.id+" networkCodeToId() - markets need to be loaded at first");const n=this.safeValue(this.options.networkChainIdsByNames,t,{}),r=super.networkCodeToId(e);return this.safeValue(n,r,r)}async fetchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeValue(this.options,"fetchBalance",{}),i={};let n;const r=t==="margin",a=t==="spot",o=t==="future",d=t==="swap",c=this.safeString2(this.options,"defaultSubType","subType","linear");let u=this.safeString2(s,"defaultSubType","subType",c);u=this.safeString2(e,"defaultSubType","subType",u);const h=u==="inverse",f=u==="linear";let l;[l,e]=this.handleMarginModeAndParams("fetchBalance",e),e=this.omit(e,["defaultSubType","subType"]);const m=l==="isolated",g=l==="cross";if(a)if(m)n="spotPrivateGetV1MarginAccountsBalance";else if(g)n="spotPrivateGetV1CrossMarginAccountsBalance";else{await this.loadAccounts();const v=await this.fetchAccountIdByType(t,e);i["account-id"]=v,n="spotPrivateGetV1AccountAccountsAccountIdBalance"}else r?m?n="spotPrivateGetV1MarginAccountsBalance":n="spotPrivateGetV1CrossMarginAccountsBalance":f?m?n="contractPrivatePostLinearSwapApiV1SwapAccountInfo":n="contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo":h&&(o?n="contractPrivatePostApiV1ContractAccountInfo":d&&(n="contractPrivatePostSwapApiV1SwapAccountInfo"));const y=await this[n](this.extend(i,e)),w={info:y},b=this.safeValue(y,"data");if(a||r)if(m)for(let v=0;v<b.length;v++){const T=b[v],I=this.safeSymbol(this.safeString(T,"symbol")),A=this.safeValue(T,"list"),N={};for(let B=0;B<A.length;B++){const x=A[B],k=this.safeString(x,"currency"),O=this.safeCurrencyCode(k);N[O]=this.parseMarginBalanceHelper(x,O,N)}w[I]=this.safeBalance(N)}else{const v=this.safeValue(b,"list",[]);for(let T=0;T<v.length;T++){const I=v[T],A=this.safeString(I,"currency"),N=this.safeCurrencyCode(A);w[N]=this.parseMarginBalanceHelper(I,N,w)}}else if(f){const v=this.safeValue(b,0,{});if(g){const T=this.account();T.free=this.safeString(v,"margin_balance","margin_available"),T.used=this.safeString(v,"margin_frozen");const I=this.safeString2(v,"margin_asset","symbol"),A=this.safeCurrencyCode(I);w[A]=T}else if(m){for(let T=0;T<b.length;T++){const I=b[T],A=this.safeString2(I,"contract_code","margin_account"),N=this.safeMarket(A),B=this.safeString(I,"margin_asset"),x=this.safeCurrency(B),k=this.safeString(N,"settle",x.code);if(k!==void 0){const O=this.account();O.free=this.safeString(I,"margin_balance"),O.used=this.safeString(I,"margin_frozen");const P={};P[k]=O;const q=N.symbol;w[q]=this.safeBalance(P)}}return w}}else if(h)for(let v=0;v<b.length;v++){const T=b[v],I=this.safeString(T,"symbol"),A=this.safeCurrencyCode(I),N=this.account();N.free=this.safeString(T,"margin_available"),N.used=this.safeString(T,"margin_frozen"),w[A]=N}return m&&(a||r)?w:this.safeBalance(w)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);const r={};let a;if(n==="spot"){const c=this.safeString(s,"clientOrderId");a="spotPrivateGetV1OrderOrdersOrderId",c!==void 0?a="spotPrivateGetV1OrderOrdersGetClientOrder":r["order-id"]=e}else{if(t===void 0)throw new hs(this.id+" fetchOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let u;[u,s]=this.handleMarginModeAndParams("fetchOrder",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapOrderInfo":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo")}else if(i.inverse)if(n==="future")a="contractPrivatePostApiV1ContractOrderInfo",r.symbol=i.settleId;else if(n==="swap")a="contractPrivatePostSwapApiV1SwapOrderInfo";else throw new si(this.id+" fetchOrder() does not support "+n+" markets");const c=this.safeString2(s,"client_order_id","clientOrderId");c===void 0?r.order_id=e:(r.client_order_id=c,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));let d=this.safeValue(o,"data");return Array.isArray(d)&&(d=this.safeValue(d,0)),this.parseOrder(d)}parseMarginBalanceHelper(e,t,s){let i;return t in s?i=s[t]:i=this.account(),e.type==="trade"&&(i.free=this.safeString(e,"balance")),e.type==="frozen"&&(i.used=this.safeString(e,"balance")),i}async fetchSpotOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeString(this.options,"fetchOrdersByStatesMethod","spot_private_get_v1_order_orders");if(r==="spot_private_get_v1_order_orders"&&t===void 0)throw new hs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();let a;const o={states:e};t!==void 0&&(a=this.market(t),o.symbol=a.id),s!==void 0&&(o["start-time"]=s,o["end-time"]=this.sum(s,48*60*60*1e3)),i!==void 0&&(o.size=i);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,a,s,i)}async fetchSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchClosedSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchContractOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hs(this.id+" fetchContractOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a={contract:n.id,trade_type:0,type:1,status:"0"};t!==void 0&&(a.start_time=t);let o;if(n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchContractOrders",i),u=u===void 0?"cross":u,o=this.getSupportedMapping(u,{isolated:"contractPrivatePostLinearSwapApiV3SwapHisorders",cross:"contractPrivatePostLinearSwapApiV3SwapCrossHisorders"})}else n.inverse&&(o=this.getSupportedMapping(r,{future:"contractPrivatePostApiV3ContractHisorders",swap:"contractPrivatePostSwapApiV3SwapHisorders"}),r==="future"&&(a.symbol=n.settleId));s!==void 0&&(a.page_size=s);const d=await this[o](this.extend(a,i)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,n,t,s)}async fetchClosedContractOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"5,6,7"};return await this.fetchContractOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchSpotOrders",swap:"fetchContractOrders",future:"fetchContractOrders"});if(a===void 0)throw new si(this.id+" fetchOrders() does not support "+r+" markets yet");if((r==="swap"||r==="future")&&e===void 0)throw new hs(this.id+" fetchOrders() requires a symbol argument for "+r+" orders");return await this[a](e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchClosedSpotOrders",swap:"fetchClosedContractOrders",future:"fetchClosedContractOrders"});if(a===void 0)throw new si(this.id+" fetchClosedOrders() does not support "+r+" markets yet");return await this[a](e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);const a={};let o;if(r==="spot"){o="spotPrivateGetV1OrderOpenOrders",e!==void 0&&(n=this.market(e),a.symbol=n.id);let u=this.safeString(i,"account-id");if(u===void 0){await this.loadAccounts();for(let h=0;h<this.accounts.length;h++){const f=this.accounts[h];if(f.type==="spot"&&(u=this.safeString(f,"id"),u!==void 0))break}}a["account-id"]=u,s!==void 0&&(a.size=s),i=this.omit(i,"account-id")}else{if(e===void 0)throw new hs(this.id+" fetchOpenOrders() requires a symbol for "+r+" orders");const u=this.market(e);if(a.contract_code=u.id,u.linear){let h;[h,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),h=h===void 0?"cross":h,h==="isolated"?o="contractPrivatePostLinearSwapApiV1SwapOpenorders":h==="cross"&&(o="contractPrivatePostLinearSwapApiV1SwapCrossOpenorders")}else u.inverse&&(u.future?(o="contractPrivatePostApiV1ContractOpenorders",a.symbol=u.settleId):u.swap&&(o="contractPrivatePostSwapApiV1SwapOpenorders"));s!==void 0&&(a.page_size=s)}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"orders",[])),this.parseOrders(c,n,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open",created:"open",1:"open",2:"open",3:"open",4:"open",5:"canceled",6:"closed",7:"canceled",11:"canceling"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","order_id_str");let i=this.safeString(e,"direction"),n=this.safeString(e,"order_price_type");if("type"in e){const b=e.type.split("-");i=b[0],n=b[1]}const r=this.parseOrderStatus(this.safeString2(e,"state","status")),a=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(a,t);const o=this.safeIntegerN(e,["created_at","created-at","create_date"]),d=this.safeString2(e,"client_order_id","client-order-id");let c,u;n!==void 0&&n.indexOf("market")>=0?i==="sell"?c=this.safeString(e,"field-cash-amount"):c=this.safeString(e,"amount"):(u=this.safeString2(e,"volume","amount"),c=this.safeStringN(e,["filled-cash-amount","field-cash-amount","trade_turnover"]));const h=this.safeStringN(e,["filled-amount","field-amount","trade_volume"]),f=this.safeString(e,"price");let l=this.safeString2(e,"filled-fees","field-fees");l=this.safeString(e,"fee",l);let m;if(l!==void 0){let b;const S=this.safeString(e,"fee_asset");S!==void 0?b=this.safeCurrencyCode(S):b=i==="sell"?t.quote:t.base,m={cost:l,currency:b}}const g=this.safeString(e,"stop-price"),y=this.safeString(e,"trade_avg_price"),w=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:f,stopPrice:g,triggerPrice:g,average:y,cost:c,amount:u,filled:h,remaining:void 0,status:r,fee:m,trades:w},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c=this.getSupportedMapping(o,{spot:"createSpotOrder",swap:"createContractOrder",future:"createContractOrder"});if(c===void 0)throw new si(this.id+" createOrder() does not support "+o+" markets yet");return await this[c](e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),d={"account-id":await this.fetchAccountIdByType(a.type),symbol:a.id};let c=t.replace("buy-","");c=c.replace("sell-","");const u=this.safeValue(this.options,a.type,{}),h=this.safeString2(r,"stopPrice","stop-price");if(h===void 0){const w=this.safeValue(u,"stopOrderTypes",{});if(c in w)throw new hs(this.id+" createOrder() requires a stopPrice or a stop-price parameter for a stop order")}else{const w=this.safeString(r,"operator");if(w===void 0)throw new hs(this.id+' createOrder() requires an operator parameter "gte" or "lte" for a stop order');if(r=this.omit(r,["stopPrice","stop-price"]),d["stop-price"]=this.priceToPrecision(e,h),d.operator=w,c==="limit"||c==="limit-fok")c="stop-"+c;else if(c!=="stop-limit"&&c!=="stop-limit-fok")throw new si(this.id+" createOrder() does not support "+t+" orders")}this.safeValue(r,"postOnly",!1)&&(c="limit-maker"),d.type=s+"-"+c;const l=this.safeString2(r,"clientOrderId","client-order-id");if(l===void 0){const w=this.safeValue(this.options,"broker",{}),b=this.safeString(w,"id");d["client-order-id"]=b+this.uuid()}else d["client-order-id"]=l;if(r=this.omit(r,["clientOrderId","client-order-id","postOnly"]),c==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new zt(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");{const w=this.numberToString(i),b=this.numberToString(n);d.amount=this.costToPrecision(e,Bs.stringMul(w,b))}}else d.amount=this.costToPrecision(e,i);else d.amount=this.amountToPrecision(e,i);const m=this.safeValue(u,"limitOrderTypes",{});c in m&&(d.price=this.priceToPrecision(e,n));const g=await this.spotPrivatePostV1OrderOrdersPlace(this.extend(d,r)),y=this.safeString(g,"data");return{info:g,id:y,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async createContractOrder(e,t,s,i,n=void 0,r={}){const a=this.safeString(r,"offset");if(this.safeString(r,"stopPrice")!==void 0)throw new si(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");const d=this.market(e),c={contract_code:d.id,volume:this.amountToPrecision(e,i),direction:s,lever_rate:1},u=this.safeString(r,"sl_order_price"),h=this.safeString(r,"sl_trigger_price"),f=this.safeString(r,"tp_order_price"),l=this.safeString(r,"tp_trigger_price"),m=a==="open";let g=!1;if(h!==void 0&&(c.sl_trigger_price=this.priceToPrecision(e,h),g=!0,n!==void 0&&(c.sl_order_price=this.priceToPrecision(e,n))),u!==void 0&&(c.sl_order_price=this.priceToPrecision(e,u),g=!0),l!==void 0&&(c.tp_trigger_price=this.priceToPrecision(e,l),g=!0,n!==void 0&&(c.tp_order_price=this.priceToPrecision(e,n))),f!==void 0&&(c.tp_order_price=this.priceToPrecision(e,f),g=!0),g&&!m)throw new si(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");r=this.omit(r,["sl_order_price","sl_trigger_price","tp_order_price","tp_trigger_price"]),this.safeValue(r,"postOnly",!1)&&(t="post_only"),(t==="limit"||t==="ioc"||t==="fok"||t==="post_only")&&(c.price=this.priceToPrecision(e,n)),c.order_price_type=t;const w=this.safeValue(this.options,"broker",{}),b=this.safeString(w,"id");c.channel_code=b;const S=this.safeString2(r,"client_order_id","clientOrderId");S!==void 0&&(c.client_order_id=S,r=this.omit(r,["client_order_id","clientOrderId"]));let v;if(d.linear){let A;[A,r]=this.handleMarginModeAndParams("createOrder",r),A=A===void 0?"cross":A,A==="isolated"?v="contractPrivatePostLinearSwapApiV1SwapOrder":A==="cross"&&(v="contractPrivatePostLinearSwapApiV1SwapCrossOrder")}else d.inverse&&(d.swap?v="contractPrivatePostSwapApiV1SwapOrder":d.future&&(v="contractPrivatePostApiV1ContractOrder"));const T=await this[v](this.extend(c,r)),I=this.safeValue(T,"data",{});return this.parseOrder(I,d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const r={};let a;if(n==="spot"){const d=this.safeString2(s,"client-order-id","clientOrderId");a="spotPrivatePostV1OrderOrdersOrderIdSubmitcancel",d===void 0?r["order-id"]=e:(r["client-order-id"]=d,a="spotPrivatePostV1OrderOrdersSubmitCancelClientOrder",s=this.omit(s,["client-order-id","clientOrderId"]))}else{if(t===void 0)throw new hs(this.id+" cancelOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let c;[c,s]=this.handleMarginModeAndParams("cancelOrder",s),c=c===void 0?"cross":c,c==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":c==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(i.inverse)i.future?(a="contractPrivatePostApiV1ContractCancel",r.symbol=i.settleId):i.swap&&(a="contractPrivatePostSwapApiV1SwapCancel");else throw new si(this.id+" cancelOrder() does not support "+n+" markets");const d=this.safeString2(s,"client_order_id","clientOrderId");d===void 0?r.order_id=e:(r.client_order_id=d,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));return this.extend(this.parseOrder(o,i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrders",i,s);const r={};let a;if(n==="spot"){let d=this.safeValue2(s,"client-order-id","clientOrderId");d=this.safeValue2(s,"client-order-ids","clientOrderIds",d),d===void 0?typeof d=="string"?r["order-ids"]=e:r["order-ids"]=e.join(","):(typeof d=="string"?r["client-order-ids"]=d:r["client-order-ids"]=d.join(","),s=this.omit(s,["client-order-id","client-order-ids","clientOrderId","clientOrderIds"])),a="spotPrivatePostV1OrderOrdersBatchcancel"}else{if(t===void 0)throw new hs(this.id+" cancelOrders() requires a symbol for "+n+" orders");const d=this.market(t);if(r.contract_code=d.id,d.linear){let u;[u,s]=this.handleMarginModeAndParams("cancelOrders",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(d.inverse)if(d.future)a="contractPrivatePostApiV1ContractCancel",r.symbol=d.settleId;else if(d.swap)a="contractPrivatePostSwapApiV1SwapCancel";else throw new si(this.id+" cancelOrders() does not support "+n+" markets");let c=this.safeString2(s,"client_order_id","clientOrderId");c=this.safeString2(s,"client_order_ids","clientOrderIds",c),c===void 0?r.order_id=e.join(","):(r.client_order_id=c,s=this.omit(s,["client_order_id","client_order_ids","clientOrderId","clientOrderIds"]))}return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));let i;[i,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const n={};let r;if(i==="spot")e!==void 0&&(s=this.market(e),n.symbol=s.id),r="spotPrivatePostV1OrderOrdersBatchCancelOpenOrders";else{if(e===void 0)throw new hs(this.id+" cancelAllOrders() requires a symbol for "+i+" orders");const o=this.market(e);if(n.contract_code=o.id,o.linear){let d;[d,t]=this.handleMarginModeAndParams("cancelAllOrders",t),d=d===void 0?"cross":d,d==="isolated"?r="contractPrivatePostLinearSwapApiV1SwapCancelallall":d==="cross"&&(r="contractPrivatePostLinearSwapApiV1SwapCrossCancelall")}else if(o.inverse)if(i==="future")r="contractPrivatePostApiV1ContractCancelall",n.symbol=o.settleId;else if(i==="swap")r="contractPrivatePostSwapApiV1SwapCancelall";else throw new si(this.id+" cancelAllOrders() does not support "+i+" markets")}return await this[r](this.extend(n,t))}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"note"),o=this.safeString(e,"chain");return this.checkAddress(s),{currency:r,address:s,tag:i,network:this.networkIdToCode(o,r),note:a,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivateGetV2AccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r,[e],!1);return this.indexBy(a,"network")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const[s,i]=this.handleNetworkCodeAndParams(t),n=await this.fetchDepositAddressesByNetwork(e,i),r=this.selectNetworkCodeFromUnifiedNetworks(e,s,n);return n[r]}async fetchWithdrawAddresses(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={currency:this.currency(e).id},a=await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.parseDepositAddresses(o,[e],!1),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=t===void 0||h.note===t,l=s===void 0||h.network===s;f&&l&&c.push(h)}return c}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",direct:"next",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",direct:"next",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let n=this.safeString(e,"type");n==="withdraw"&&(n="withdrawal");let r=this.safeString(e,"fee");r!==void 0&&(r=Bs.stringAbs(r));const a=this.safeString(e,"chain");return{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:this.networkIdToCode(a,i),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:n,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),fee:{currency:i,cost:this.parseNumber(r),rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);let o;[o,n]=this.handleNetworkCodeAndParams(n),o!==void 0&&(a.chain=this.networkCodeToId(o,e)),t=parseFloat(this.currencyToPrecision(e,t,o));const d=this.safeValue(this.options,"withdraw",{});if(this.safeValue(d,"includeFee",!1)){let u=this.safeNumber(n,"fee");if(u===void 0){const g=await this.fetchCurrencies();this.currencies=this.deepExtend(this.currencies,g);const y=this.safeValue(r.networks,o,{});if(u=this.safeNumber(y,"fee"),u===void 0)throw new hs(this.id+' withdraw() function can not find withdraw fee for chosen network. You need to re-load markets with "exchange.loadMarkets(true)", or provide the "fee" parameter')}const h=this.currencyToPrecision(e,u,o);n=this.omit(n,"fee");const f=this.numberToString(t),l=Bs.stringSub(f,h),m=parseFloat(l);a.fee=parseFloat(h),t=parseFloat(this.currencyToPrecision(e,m,o))}a.amount=t;const c=await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeCurrencyCode(void 0,t);return{info:e,id:s,timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"type");if(a===void 0){const u=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const h=this.safeString(u,s,s),f=this.safeString(u,i,i);a=h+"-to-"+f}const o={currency:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),type:a},d=await this.spotPrivatePostFuturesTransfer(this.extend(o,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchBorrowRatesPerSymbol(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={info:t};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]),d={};for(let h=0;h<o.length;h++){const f=o[h],l=this.safeString(f,"currency"),m=this.safeCurrencyCode(l,"currency");d[m]={currency:m,rate:this.safeNumber(f,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s)}}const c=this.safeString(a,"symbol"),u=this.safeSymbol(c);n[u]=d}return n}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u,"currency");n[h]={currency:h,rate:this.safeNumber(c,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s),info:void 0}}}return n}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hs(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={contract_code:n.id};let a;if(n.inverse)a="contractPublicGetSwapApiV1SwapHistoricalFundingRate";else if(n.linear)a="contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate";else throw new si(this.id+" fetchFundingRateHistory() supports inverse and linear swaps only");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data"),c=this.safeValue(d,"data",[]),u=[];for(let f=0;f<c.length;f++){const l=c[f],m=this.safeString(l,"contract_code"),g=this.safeSymbol(m),y=this.safeInteger(l,"funding_time");u.push({info:l,symbol:g,fundingRate:this.safeNumber(l,"funding_rate"),timestamp:y,datetime:this.iso8601(y)})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,n.symbol,t,s)}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"estimated_rate"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"contract_code"),a=this.safeSymbol(r,t);return{info:e,symbol:a,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:s,nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.inverse)i="contractPublicGetSwapApiV1SwapFundingRate";else if(s.linear)i="contractPublicGetLinearSwapApiV1SwapFundingRate";else throw new si(this.id+" fetchFundingRate() supports inverse and linear swaps only");const n={contract_code:s.id},r=await this[i](this.extend(n,t)),a=this.safeValue(r,"data",{});return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchFundingRates",{}),i=this.safeString(this.options,"defaultSubType","inverse");let n=this.safeString(s,"subType",i);n=this.safeString(t,"subType",n);const r={},a=this.getSupportedMapping(n,{linear:"contractPublicGetLinearSwapApiV1SwapBatchFundingRate",inverse:"contractPublicGetSwapApiV1SwapBatchFundingRate"});t=this.omit(t,"subType");const o=await this[a](this.extend(r,t)),d=this.safeValue(o,"data",[]),c=this.parseFundingRates(d);return this.filterByArray(c,"symbol",e)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r=r===void 0?"cross":r;const a={};s!==void 0&&(a["start-date"]=this.yyyymmdd(s)),i!==void 0&&(a.size=i);let o,d;if(r==="isolated")d="privateGetMarginLoanOrders",t!==void 0&&(o=this.market(t),a.symbol=o.id);else if(d="privateGetCrossMarginLoanOrders",e!==void 0){const f=this.currency(e);a.currency=f.id}const c=await this[d](this.extend(a,n)),u=this.safeValue(c,"data"),h=this.parseBorrowInterests(u,o);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s);const n=this.safeString(t,"symbol"),r=this.safeNumber(e,"accrued-at");return{account:i==="isolated"?n:"cross",symbol:n,marginMode:i,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest-amount"),interestRate:this.safeNumber(e,"interest-rate"),amountBorrowed:this.safeNumber(e,"loan-amount"),timestamp:r,datetime:this.iso8601(r),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";const o=this.omit(i,this.extractParams(e));if(typeof t=="string"){if(t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i),t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),f=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:f}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a}else{const d=this.safeString(t,0),c=this.safeString(t,1),u=this.safeString(t,2),h=this.safeString(t,3);let f,l=this.safeValue(this.urls.hostnames,d);if(typeof l!="string"&&(l=this.safeValue(l,u),typeof f!="string"&&h!==void 0&&(l=this.safeValue(l,h))),f=l,a+=this.implodeParams(e,i),c==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(c==="private"){this.checkRequiredCredentials();const m=this.ymdhms(this.milliseconds(),"T");let g={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:m};s!=="POST"&&(g=this.extend(g,o)),g=this.keysort(g);let y=this.urlencode(g);const w=[s,f,a,y].join(`
`),b=this.hmac(this.encode(w),this.encode(this.secret),"sha256","base64");y+="&"+this.urlencode({Signature:b}),a+="?"+y,s==="POST"?(r=this.json(o),r.length===2&&(r="{}"),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}a=this.implodeParams(this.urls.api[d],{hostname:f})+a}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString2(a,"err-code","err_code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const f=this.safeString2(a,"err-msg","err_msg");throw this.throwExactlyMatchedException(this.exceptions.exact,f,h),new Qc(h)}if("code"in a){const c=this.id+" "+r,u=this.safeString(a,"code");this.throwExactlyMatchedException(this.exceptions.exact,u,c)}}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i);let o;const d={type:"30,31"};if(t!==void 0&&(d.start_date=t),n.linear){o="contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact";let h;[h,i]=this.handleMarginModeAndParams("fetchFundingHistory",i),h=h===void 0?"cross":h,h==="isolated"?d.mar_acct=n.id:d.mar_acct=n.quoteId}else r==="swap"?(o="contractPrivatePostSwapApiV3SwapFinancialRecordExact",d.contract=n.id):(o="contractPrivatePostApiV3ContractFinancialRecordExact",d.symbol=n.id);const c=await this[o](this.extend(d,a)),u=this.safeValue(c,"data",[]);return this.parseIncomes(u,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new hs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("setLeverage",i,s);let a;if(i.linear){let c;[c,s]=this.handleMarginModeAndParams("setLeverage",s),c=c===void 0?"cross":c,a=this.getSupportedMapping(c,{isolated:"contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate",cross:"contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate"})}else a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractSwitchLeverRate",swap:"contractPrivatePostSwapApiV1SwapSwitchLeverRate"});const o={lever_rate:e};return n==="future"&&i.inverse?o.symbol=i.settleId:o.contract_code=i.id,await this[a](this.extend(o,r))}parseIncome(e,t=void 0){const s=this.safeString(e,"contract_code"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"ts"),a=this.safeString(e,"id"),o=this.safeString2(e,"symbol","asset"),d=this.safeCurrencyCode(o);return{info:e,symbol:i,code:d,timestamp:r,datetime:this.iso8601(r),id:a,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"contract_code"));const s=t.symbol,i=this.safeString(e,"volume"),n=this.safeValue(t,"contractSize"),r=this.numberToString(n),a=this.safeNumber(e,"cost_open"),o=this.safeString(e,"position_margin"),c=this.safeString(e,"direction")==="buy"?"long":"short",u=this.safeNumber(e,"profit_unreal");let h=this.safeString(e,"margin_mode");const f=this.safeString(e,"lever_rate"),l=Bs.stringMul(this.safeString(e,"profit_rate"),"100"),m=this.safeString(e,"last_price"),g=Bs.stringMul(i,r);let y;t.linear?y=Bs.stringMul(g,m):(y=Bs.stringDiv(g,m),h="cross");const w=Bs.stringDiv(o,y),b=this.safeString(e,"margin_balance"),S=this.safeNumber(e,"liquidation_price"),v=this.safeString(e,"adjust_factor"),T=Bs.stringDiv(v,f),I=Bs.stringMul(T,y),A=Bs.stringDiv(I,b);return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:n,entryPrice:a,collateral:this.parseNumber(b),side:c,unrealizedProfit:u,leverage:this.parseNumber(f),percentage:this.parseNumber(l),marginMode:h,notional:this.parseNumber(y),markPrice:void 0,liquidationPrice:S,initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(w),maintenanceMargin:this.parseNumber(I),maintenanceMarginPercentage:this.parseNumber(T),marginRatio:this.parseNumber(A),timestamp:void 0,datetime:void 0}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;[s,t]=this.handleMarginModeAndParams("fetchPositions",t),s=s===void 0?"cross":s;const i=this.safeString(this.options,"defaultSubType","inverse");let n;[n,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t),n==="spot"&&(n="future");let r;i==="linear"?r=this.getSupportedMapping(s,{isolated:"contractPrivatePostLinearSwapApiV1SwapPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo"}):r=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractPositionInfo",swap:"contractPrivatePostSwapApiV1SwapPositionInfo"});const a=await this[r](t),o=this.safeValue(a,"data",[]),d=this.safeInteger(a,"ts"),c=[];for(let u=0;u<o.length;u++){const h=o[u],f=this.parsePosition(h);c.push(this.extend(f,{timestamp:d,datetime:this.iso8601(d)}))}return this.filterByArray(c,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarginModeAndParams("fetchPosition",t),i=i===void 0?"cross":i;const[n,r]=this.handleMarketTypeAndParams("fetchPosition",s,t);let a;s.linear?a=this.getSupportedMapping(i,{isolated:"contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo"}):a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractAccountPositionInfo",swap:"contractPrivatePostSwapApiV1SwapAccountPositionInfo"});const o={};s.future&&s.inverse?o.symbol=s.settleId:(i==="cross"&&(o.margin_account="USDT"),o.contract_code=s.id);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data");let u;i==="cross"?u=c:u=this.safeValue(c,0);const h=this.omit(u,["positions"]),f=this.safeValue(u,"positions");let l;if(s.future&&s.inverse)for(let y=0;y<f.length;y++){const w=f[y];if(w.contract_code===s.id){l=w;break}}else l=this.safeValue(f,0);const m=this.safeInteger(d,"ts"),g=this.parsePosition(this.extend(l,h));return this.extend(g,{timestamp:m,datetime:this.iso8601(m)})}parseLedgerEntryType(e){const t={trade:"trade",etf:"trade","transact-fee":"fee","fee-deduction":"fee",transfer:"transfer",credit:"credit",liquidation:"trade",interest:"credit",deposit:"deposit",withdraw:"withdrawal","withdraw-fee":"fee",exchange:"exchange","other-types":"transfer",rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactId"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"transactAmt"),a=this.safeString(e,"transferType"),o=this.parseLedgerEntryType(a),d=this.safeString(e,"direction"),c=this.safeInteger(e,"transactTime"),u=this.iso8601(c),h=this.safeString(e,"accountId");return{id:s,direction:d,account:h,referenceId:s,referenceAccount:h,type:o,currency:n,amount:r,timestamp:c,datetime:u,before:void 0,after:void 0,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={accountId:await this.fetchAccountIdByType("spot",i)};let a;e!==void 0&&(a=this.currency(e),r.currency=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this.spotPrivateGetV2AccountLedger(this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseLedger(d,a,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"contract_code")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=this.market(e);if(!a.contract)throw new As(this.id+" fetchMarketLeverageTiers() symbol supports contract markets only");s.contract_code=a.id}const i=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(this.extend(s,t)),n=this.safeValue(i,"data"),r=this.parseLeverageTiers(n,[e],"contract_code");return this.safeValue(r,e)}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"list",[]),o=[],d=this.safeString(r,"trade_partition"),c=this.safeString(r,s),u=this.safeSymbol(c);if(this.inArray(u,t)){for(let h=0;h<a.length;h++){const f=a[h],l=this.safeString(f,"lever_rate"),m=this.safeValue(f,"ladders",[]);for(let g=0;g<m.length;g++){const y=m[g],w=this.safeString(y,"adjust_factor");o.push({tier:this.safeInteger(y,"ladder"),currency:this.safeCurrencyCode(d),minNotional:this.safeNumber(y,"min_size"),maxNotional:this.safeNumber(y,"max_size"),maintenanceMarginRate:this.parseNumber(Bs.stringDiv(w,l)),maxLeverage:this.parseNumber(l),info:y})}}i[u]=o}}return i}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t!=="1h"&&t!=="4h"&&t!=="12h"&&t!=="1d")throw new As(this.id+" fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe");await this.loadMarkets();const r={"1h":"60min","4h":"4hour","12h":"12hour","1d":"1day"},a=this.market(e),o=this.safeNumber2(n,"amount_type","amountType");if(o===void 0)throw new hs(this.id+" fetchOpenInterestHistory requires parameter params.amountType to be either 1 (cont), or 2 (cryptocurrency)");const d={period:r[t],amount_type:o};let c;a.future?(d.contract_type=this.safeString(a.info,"contract_type"),d.symbol=a.baseId,c="contractPublicGetApiV1ContractHisOpenInterest"):a.linear?(d.contract_type="swap",d.contract_code=a.id,d.contract_code=a.id,c="contractPublicGetLinearSwapApiV1SwapHisOpenInterest"):(d.contract_code=a.id,c="contractPublicGetSwapApiV1SwapHisOpenInterest"),i!==void 0&&(d.size=i);const u=await this[c](this.extend(d,n)),h=this.safeValue(u,"data"),f=this.safeValue(h,"tick");return this.parseOpenInterests(f,a,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new As(this.id+" fetchOpenInterest() supports contract markets only");if(s.option)throw new si(this.id+" fetchOpenInterest() does not currently support option markets");const i={contract_code:s.id};let n;s.future?(i.contract_type=this.safeString(s.info,"contract_type"),i.symbol=s.baseId,n="contractPublicGetApiV1ContractOpenInterest"):s.linear?(i.contract_type="swap",n="contractPublicGetLinearSwapApiV1SwapOpenInterest"):n="contractPublicGetSwapApiV1SwapOpenInterest";const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.parseOpenInterest(a[0],s),d=this.safeInteger(r,"ts");return this.extend(o,{timestamp:d,datetime:this.iso8601(d)})}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeNumber(e,"volume"),n=this.safeNumber(e,"value");return{symbol:this.safeString(t,"symbol"),baseVolume:i,quoteVolume:n,openInterestAmount:i,openInterestValue:n,timestamp:s,datetime:this.iso8601(s),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)};let a;[a,i]=this.handleMarginModeAndParams("borrowMargin",i),a=a===void 0?"cross":a;let o;if(a==="isolated"){if(s===void 0)throw new hs(this.id+" borrowMargin() requires a symbol argument for isolated margin");const u=this.market(s);r.symbol=u.id,o="privatePostMarginOrders"}else a==="cross"&&(o="privatePostCrossMarginOrders");const d=await this[o](this.extend(r,i)),c=this.parseMarginLoan(d,n);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e);let r;[r,i]=this.handleMarginModeAndParams("repayMargin",i),r=r===void 0?"cross":r;const a=this.safeValue(this.options,"marginAccounts",{}),o=this.getSupportedMapping(r,a),d=await this.fetchAccountIdByType(o,i),c={currency:n.id,amount:this.currencyToPrecision(e,t),accountId:d},u=await this.v2PrivatePostAccountRepayment(this.extend(c,i)),h=this.safeValue(u,"Data",[]),f=this.safeValue(h,0),l=this.parseMarginLoan(f,n);return this.extend(l,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeInteger(e,"repayTime");return{id:this.safeInteger2(e,"repayId","data"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"code"),r=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]);const a=e===void 0?void 0:this.market(e),[o,d]=this.handleMarketTypeAndParams("fetchSettlementHistory",a,i);if(o==="future"){if(e===void 0&&n===void 0)throw new hs(this.id+' requires a symbol argument or params["code"] for fetchSettlementHistory future')}else if(e===void 0)throw new hs(this.id+" requires a symbol argument for fetchSettlementHistory swap");const c={};a.future?c.symbol=a.baseId:c.contract_code=a.id,t!==void 0&&(c.start_at=t),s!==void 0&&(c.page_size=s),r!==void 0&&(c.end_at=r);let u="contractPublicGetApiV1ContractSettlementRecords";a.swap&&(a.linear?u="contractPublicGetLinearSwapApiV1SwapSettlementRecords":u="contractPublicGetSwapApiV1SwapSettlementRecords");const h=await this[u](this.extend(c,d)),f=this.safeValue(h,"data"),l=this.safeValue(f,"settlement_record"),m=this.parseSettlements(l,a);return this.sortBy(m,"timestamp")}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPublicGetV2ReferenceCurrencies(t),i=this.safeValue(s,"data");return this.parseDepositWithdrawFees(i,e,"currency")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"chains",[]);let i=this.depositWithdrawFee(e);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"chain"),o=this.safeString(r,"withdrawFeeType"),d=this.networkIdToCode(a);let c,u;o==="fixed"?(c=this.safeNumber(r,"transactFeeWithdraw"),u={fee:c,percentage:!1}):(c=this.safeNumber(r,"transactFeeRateWithdraw"),u={fee:c,percentage:!0}),i.networks[d]={withdraw:u,deposit:{fee:void 0,percentage:void 0}},i=this.assignDefaultDepositWithdrawFees(i,t)}return i}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i],r=this.safeValue(n,"list");if(r!==void 0){const a=this.safeInteger(n,"settlement_time"),o={timestamp:a,datetime:this.iso8601(a)};for(let d=0;d<r.length;d++){const c=r[d],u=this.parseSettlement(c,t);s.push(this.extend(u,o))}}else s.push(this.parseSettlement(e[i],t))}return s}parseSettlement(e,t){const s=this.safeInteger(e,"settlement_time"),i=this.safeString(e,"contract_code");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settlement_price"),timestamp:s,datetime:this.iso8601(s)}}};const z4=re,{AuthenticationError:Cb,ExchangeError:Mb,PermissionDenied:j4,ExchangeNotAvailable:Pb,OnMaintenance:Kl,InvalidOrder:un,OrderNotFound:Xl,InsufficientFunds:Ab,ArgumentsRequired:K4,BadSymbol:cd,BadRequest:tu,RequestTimeout:X4,NetworkError:Y4}=Q,{TRUNCATE:Z4,TICK_SIZE:Q4}=ne,ud=ae;var MT=class extends z4{describe(){return this.deepExtend(super.describe(),{id:"huobijp",name:"Huobi Japan",countries:["JP"],rateLimit:100,userAgent:this.userAgents.chrome39,certified:!1,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api-cloud.huobi.co.jp",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingLimits:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg",api:{market:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.co.jp",referral:"https://www.huobi.co.jp/register/?invite_code=znnq3",doc:"https://api-doc.huobi.co.jp",fees:"https://www.huobi.co.jp/support/fee"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},market:{get:{"history/kline":1,"detail/merged":1,depth:1,trade:1,"history/trade":1,detail:1,tickers:1,etp:1}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:Q4,exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":Kl,maintain:Kl},exact:{"bad-request":tu,"base-date-limit-error":tu,"api-not-support-temp-addr":j4,timeout:X4,"gateway-internal-error":Pb,"account-frozen-balance-insufficient-error":Ab,"invalid-amount":un,"order-limitorder-amount-min-error":un,"order-limitorder-amount-max-error":un,"order-marketorder-amount-min-error":un,"order-limitorder-price-min-error":un,"order-limitorder-price-max-error":un,"order-holding-limit-failed":un,"order-orderprice-precision-error":un,"order-etp-nav-price-max-error":un,"order-orderstate-error":Xl,"order-queryorder-invalid":Xl,"order-update-error":Pb,"api-signature-check-failed":Cb,"api-signature-not-valid":Cb,"base-record-invalid":Xl,"base-symbol-trade-disabled":cd,"base-symbol-error":cd,"system-maintenance":Kl,"invalid symbol":cd,"symbol trade not open now":cd,"invalid-address":tu,"base-currency-chain-error":tu,"dw-insufficient-balance":Ab}},options:{defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"private_get_order_orders",fetchOpenOrdersMethod:"fetch_open_orders_v1",createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US",broker:{id:"AA03022abc"}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",BIFI:"Bitcoin File"}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.publicGetCommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,Z4,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.options.fetchMarketsMethod,s=await this[t](e),i=this.safeValue(s,"data",[]);if(i.length<1)throw new Y4(this.id+" fetchMarkets() returned empty response: "+this.json(i));const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"base-currency"),c=this.safeString(o,"quote-currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeString(o,"state"),l=this.safeString(o,"leverage-ratio","1"),m=this.safeString(o,"super-margin-leverage-ratio","1"),g=ud.stringGt(l,"1")||ud.stringGt(m,"1"),y=u==="OMG"?this.parseNumber("0"):this.parseNumber("0.002");r.push({id:d+c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:g,swap:!1,future:!1,option:!1,active:f==="online",contract:!1,linear:void 0,inverse:void 0,taker:y,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(o,"price-precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(o,"amount-precision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(o,"value-precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(l),superMax:this.parseNumber(m)},amount:{min:this.safeNumber(o,"min-order-amt"),max:this.safeNumber(o,"max-order-amt")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(o,"min-order-value"),max:void 0}},info:o})}return r}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"ts");let n,r,a,o;"bid"in e&&(Array.isArray(e.bid)?(n=this.safeString(e.bid,0),r=this.safeString(e.bid,1)):(n=this.safeString(e,"bid"),r=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(a=this.safeString(e.ask,0),o=this.safeString(e.ask,1)):(a=this.safeString(e,"ask"),o=this.safeString(e,"askSize")));const d=this.safeString(e,"open"),c=this.safeString(e,"close"),u=this.safeString(e,"amount"),h=this.safeString(e,"vol");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:n,bidVolume:r,ask:a,askVolume:o,vwap:void 0,open:d,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:u,quoteVolume:h,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id,type:"step0"},r=await this.marketGetDepth(this.extend(n,s));if("tick"in r){if(!r.tick)throw new cd(this.id+" fetchOrderBook() returned empty response: "+this.json(r));const a=this.safeValue(r,"tick"),o=this.safeInteger(a,"ts",this.safeInteger(r,"ts")),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"version"),d}throw new Mb(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(r))}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.marketGetDetailMerged(this.extend(i,t)),r=this.parseTicker(n.tick,s),a=this.safeInteger(n,"ts");return r.timestamp=a,r.datetime=this.iso8601(a),r}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.marketGetTickers(t),i=this.safeValue(s,"data",[]),n=this.safeInteger(s,"ts"),r={};for(let a=0;a<i.length;a++){const o=this.safeString(i[a],"symbol"),d=this.safeMarket(o),c=d.symbol,u=this.parseTicker(i[a],d);u.timestamp=n,u.datetime=this.iso8601(n),r[c]=u}return this.filterByArray(r,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger2(e,"ts","created-at"),r=this.safeString(e,"order-id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const v=o.split("-");a=v[0],o=v[1]}const d=this.safeString(e,"role"),c=this.safeString(e,"price"),u=this.safeString2(e,"filled-amount","amount"),h=this.parseNumber(c),f=this.parseNumber(u),l=this.parseNumber(ud.stringMul(c,u));let m,g=this.safeNumber(e,"filled-fees"),y=this.safeCurrencyCode(this.safeString(e,"fee-currency"));const w=this.safeNumber(e,"filled-points");w!==void 0&&(g===void 0||g===0)&&(g=w,y=this.safeCurrencyCode(this.safeString(e,"fee-deduct-currency"))),g!==void 0&&(m={cost:g,currency:y});const b=this.safeString2(e,"trade-id","tradeId");return{id:this.safeString(e,"id",b),info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:h,amount:f,cost:l,fee:m}}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrderOrdersIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.size=s),t!==void 0&&(r["start-time"]=t);const a=await this.privateGetOrderMatchresults(this.extend(r,i));return this.parseTrades(a.data,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.marketGetHistoryTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);let d=[];for(let c=0;c<o.length;c++){const u=this.safeValue(o[c],"data",[]);for(let h=0;h<u.length;h++){const f=this.parseTrade(u[h],n);d.push(f)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.marketGetHistoryKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchAccounts(e={}){return await this.loadMarkets(),(await this.privateGetAccountAccounts(e)).data}async fetchCurrencies(e={}){const t={language:this.options.language},s=await this.publicGetSettingsCurrencys(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"name"),d=this.safeCurrencyCode(o),c=this.safeValue(a,"deposit-enabled"),u=this.safeValue(a,"withdraw-enabled"),h=this.safeValue(a,"country-disabled"),f=this.safeValue(a,"visible",!1),l=this.safeString(a,"state"),m=f&&c&&u&&l==="online"&&!h,g=this.safeString(a,"display-name"),y=this.parseNumber(this.parsePrecision(this.safeString(a,"withdraw-precision")));n[d]={id:o,code:d,type:"crypto",name:g,active:m,deposit:c,withdraw:u,fee:void 0,precision:y,limits:{amount:{min:y,max:void 0},deposit:{min:this.safeNumber(a,"deposit-min-amount"),max:void 0},withdraw:{min:this.safeNumber(a,"withdraw-min-amount"),max:void 0}},info:a}}return n}parseBalance(e){const t=this.safeValue(e.data,"list",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r);let o;a in s?o=s[a]:o=this.account(),n.type==="trade"&&(o.free=this.safeString(n,"balance")),n.type==="frozen"&&(o.used=this.safeString(n,"balance")),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.options.fetchBalanceMethod,s={id:this.accounts[0].id},i=await this[t](this.extend(s,e));return this.parseBalance(i)}async fetchOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={states:e};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=this.safeString(this.options,"fetchOrdersByStatesMethod","private_get_order_orders"),d=await this[o](this.extend(r,n));return this.parseOrders(d.data,a,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderOrdersId(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchOpenOrdersMethod","fetch_open_orders_v1");return await this[n](e,t,s,i)}async fetchOpenOrdersV1(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new K4(this.id+" fetchOpenOrdersV1() requires a symbol argument");return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrdersV2(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a=this.safeString(i,"account-id");if(a===void 0){await this.loadAccounts();for(let u=0;u<this.accounts.length;u++){const h=this.accounts[u];if(h.type==="spot"&&(a=this.safeString(h,"id"),a!==void 0))break}}n["account-id"]=a,s!==void 0&&(n.size=s);const o=this.omit(i,"account-id"),d=await this.privateGetOrderOpenOrders(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,r,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id");let i,n,r;if("type"in e){const g=e.type.split("-");i=g[0],n=g[1],r=this.parseOrderStatus(this.safeString(e,"state"))}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t);const o=this.safeInteger(e,"created-at"),d=this.safeString(e,"client-order-id"),c=this.safeString(e,"amount"),u=this.safeString2(e,"filled-amount","field-amount"),h=this.safeString(e,"price"),f=this.safeString2(e,"filled-cash-amount","field-cash-amount"),l=this.safeString2(e,"filled-fees","field-fees");let m;if(l!==void 0){const g=i==="sell"?t.quote:t.base;m={cost:l,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:h,stopPrice:void 0,triggerPrice:void 0,average:void 0,cost:f,amount:c,filled:u,remaining:void 0,status:r,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),o={"account-id":this.accounts[0].id,symbol:a.id,type:s+"-"+t},d=this.safeString2(r,"clientOrderId","client-order-id");if(d===void 0){const l=this.safeValue(this.options,"broker",{}),m=this.safeString(l,"id");o["client-order-id"]=m+this.uuid()}else o["client-order-id"]=d;if(r=this.omit(r,["clientOrderId","client-order-id"]),t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new un(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");{const l=this.numberToString(i),m=this.numberToString(n),g=ud.stringMul(l,m);o.amount=this.costToPrecision(e,g)}}else o.amount=this.costToPrecision(e,i);else o.amount=this.amountToPrecision(e,i);(t==="limit"||t==="ioc"||t==="limit-maker"||t==="stop-limit"||t==="stop-limit-fok")&&(o.price=this.priceToPrecision(e,n));const c=this.options.createOrderMethod,u=await this[c](this.extend(o,r)),h=this.milliseconds(),f=this.safeString(u,"data");return{info:u,id:f,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:s,price:n,amount:i,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async cancelOrder(e,t=void 0,s={}){const i=await this.privatePostOrderOrdersIdSubmitcancel({id:e});return this.extend(this.parseOrder(i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clientOrderIds","client-order-ids");s=this.omit(s,["clientOrderIds","client-order-ids"]);const n={};return i===void 0?n["order-ids"]=e:n["client-order-ids"]=i,await this.privatePostOrderOrdersBatchcancel(this.extend(n,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbol=i.id),await this.privatePostOrderOrdersBatchCancelOpenOrders(this.extend(s,t))}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,this.precisionMode)}safeNetwork(e){const t=e.length-1;e[t]==="1"&&(e=e.slice(0,t));const i={};return this.safeString(i,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id"),c=this.safeValue(d,a,a),u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let n=this.safeString(e,"type");n==="withdraw"&&(n="withdrawal");let r=this.safeString(e,"fee");return r!==void 0&&(r=ud.stringAbs(r)),{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:this.safeStringUpper(e,"chain"),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:n,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),fee:{currency:i,cost:this.parseNumber(r),rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,amount:t,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d==="erc20"?a.chain=r.id+d:a.chain=d+r.id,n=this.omit(n,"network"));const c=await this.privatePostDwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";t==="market"?a+=t:t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),f=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:f}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString(a,"err-code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const f=this.safeString(a,"err-msg");throw this.throwExactlyMatchedException(this.exceptions.exact,f,h),new Mb(h)}}};const J4=pg;var e5=class extends J4{describe(){return this.deepExtend(super.describe(),{id:"huobipro",alias:!0,name:"Huobi Pro"})}};const t5=re,{TICK_SIZE:s5,PAD_WITH_ZERO:Bb,ROUND:i5,TRUNCATE:n5,DECIMAL_PLACES:r5}=ne,{InvalidOrder:a5,InsufficientFunds:o5,ExchangeError:d5,ExchangeNotAvailable:c5,DDoSProtection:u5,BadRequest:Er,NotSupported:h5,InvalidAddress:Yl,AuthenticationError:f5}=Q,l5=ae;var PT=class extends t5{describe(){return this.deepExtend(super.describe(),{id:"idex",name:"IDEX",countries:["US"],rateLimit:200,version:"v3",pro:!0,certified:!0,requiresWeb3:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","6h":"6h","1d":"1d"},urls:{test:{MATIC:"https://api-sandbox-matic.idex.io"},logo:"https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg",api:{MATIC:"https://api-matic.idex.io"},www:"https://idex.io",doc:["https://docs.idex.io/"]},api:{public:{get:{ping:1,time:1,exchange:1,assets:1,markets:1,tickers:1,candles:1,trades:1,orderbook:1}},private:{get:{user:1,wallets:1,balances:1,orders:1,fills:1,deposits:1,withdrawals:1,wsToken:1},post:{wallets:1,orders:1,"orders/test":1,withdrawals:1},delete:{orders:1}}},options:{defaultTimeInForce:"gtc",defaultSelfTradePrevention:"cn",network:"MATIC"},exceptions:{INVALID_ORDER_QUANTITY:a5,INSUFFICIENT_FUNDS:o5,SERVICE_UNAVAILABLE:c5,EXCEEDED_RATE_LIMIT:u5,INVALID_PARAMETER:Er,WALLET_NOT_ASSOCIATED:Yl,INVALID_WALLET_SIGNATURE:f5},requiredCredentials:{walletAddress:!0,privateKey:!0,apiKey:!0,secret:!0},precisionMode:s5,paddingMode:Bb,commonCurrencies:{}})}priceToPrecision(e,t){const s=this.market(e),i=this.safeValue(s,"info",{}),n=this.safeInteger(i,"quoteAssetPrecision");return t=this.decimalToPrecision(t,i5,s.precision.price,this.precisionMode),this.decimalToPrecision(t,n5,n,r5,Bb)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.publicGetExchange(),i=this.safeNumber(s,"makerFeeRate"),n=this.safeNumber(s,"takerFeeRate"),r=this.safeString(s,"makerTradeMinimum"),a=this.safeString(s,"takerTradeMinimum"),o=this.parseNumber(l5.stringMin(r,a)),d=[];for(let c=0;c<t.length;c++){const u=t[c],h=this.safeString(u,"market"),f=this.safeString(u,"baseAsset"),l=this.safeString(u,"quoteAsset"),m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l),y=this.parseNumber(this.parsePrecision(this.safeString(u,"baseAssetPrecision"))),w=this.parseNumber(this.parsePrecision(this.safeString(u,"quoteAssetPrecision"))),b=this.safeString(u,"status");let S;g==="ETH"&&(S=o),d.push({id:h,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:f,quoteId:l,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:b!=="inactive",contract:!1,linear:void 0,inverse:void 0,taker:n,maker:i,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:y,max:void 0},price:{min:w,max:void 0},cost:{min:S,max:void 0}},info:u})}return d}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,0);return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeInteger(e,"time"),r=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:t};s!==void 0&&(a.start=s),i!==void 0&&(a.limit=i);const o=await this.publicGetCandles(this.extend(a,n));return Array.isArray(o)?this.parseOHLCVs(o,r,t,s,i):[]}parseOHLCV(e,t=void 0){const s=this.safeInteger(e,"start"),i=this.safeNumber(e,"open"),n=this.safeNumber(e,"high"),r=this.safeNumber(e,"low"),a=this.safeNumber(e,"close"),o=this.safeNumber(e,"volume");return[s,i,n,r,a,o]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fillId"),i=this.safeString(e,"price"),n=this.safeString(e,"quantity"),r=this.safeString(e,"quoteQuantity"),a=this.safeInteger(e,"time"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),u=this.safeString(e,"makerSide")==="buy"?"sell":"buy",h=this.safeString(e,"side",u),f=this.safeString(e,"liquidity","taker"),l=this.safeString(e,"fee");let m;if(l!==void 0){const y=this.safeString(e,"feeAsset");m={cost:l,currency:this.safeCurrencyCode(y)}}const g=this.safeString(e,"orderId");return this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:d,id:s,order:g,type:"limit",side:h,takerOrMaker:f,price:i,amount:n,cost:r,fee:m},t)}async fetchTradingFees(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1()};let i;i=await this.privateGetUser(this.extend(s,e));const n=this.safeNumber(i,"makerFeeRate"),r=this.safeNumber(i,"takerFeeRate"),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:i,symbol:d,maker:n,taker:r,percentage:!0,tierBased:!1}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id,level:2};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeInteger(r,"sequence");return{symbol:e,timestamp:void 0,datetime:void 0,nonce:a,bids:this.parseSide(r,"bids"),asks:this.parseSide(r,"asks")}}parseSide(e,t){const s=this.safeValue(e,t,[]),i=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeNumber(a,0),d=this.safeNumber(a,1),c=this.safeInteger(a,2);i.push([o,d,c])}const n=t==="bids";return this.sortBy(i,0,n)}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"symbol"),o=this.safeCurrencyCode(a),d=this.parseNumber(this.parsePrecision(this.safeString(n,"exchangeDecimals")));s[o]={id:a,code:o,info:n,type:void 0,name:r,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:d,limits:{amount:{min:d,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"quantity"),a.free=this.safeString(i,"availableForTrade"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1(),wallet:this.walletAddress},i=this.extend(s,e);if(i.wallet===void 0)throw new Er(this.id+' fetchBalance() wallet is undefined, set this.walletAddress or "address" in params');let n;try{n=await this.privateGetBalances(i)}catch(r){if(r instanceof Yl){const a=i.wallet;await this.associateWallet(a),n=await this.privateGetBalances(i)}else throw r}return this.parseBalance(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials(),await this.loadMarkets();let n;const r={nonce:this.uuidv1(),wallet:this.walletAddress};e!==void 0&&(n=this.market(e),r.market=n.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=this.extend(r,i);if(a.wallet===void 0)throw new Er(this.id+' fetchMyTrades() walletAddress is undefined, set this.walletAddress or "address" in params');let o;try{o=await this.privateGetFills(a)}catch(d){if(d instanceof Yl){const c=a.wallet;await this.associateWallet(c),o=await this.privateGetFills(a)}else throw d}return this.parseTrades(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e};return await this.fetchOrdersHelper(t,void 0,void 0,this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!1};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!0};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchOrdersHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return Array.isArray(a)?this.parseOrders(a,r,t,s):this.parseOrder(a,r)}parseOrderStatus(e){const t={active:"open",partiallyFilled:"open",rejected:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"fills",[]),n=this.safeString(e,"orderId"),r=this.safeString(e,"clientOrderId"),a=this.safeString(e,"market"),o=this.safeString(e,"side"),d=this.safeSymbol(a,t,"-"),c=this.safeString(e,"type"),u=this.safeString(e,"originalQuantity"),h=this.safeString(e,"executedQuantity"),f=this.safeString(e,"avgExecutionPrice"),l=this.safeString(e,"price"),m=this.safeString(e,"status"),g=this.safeStringUpper(e,"timeInForce"),y=this.parseOrderStatus(m);return this.safeOrder({info:e,id:n,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:d,type:c,timeInForce:g,postOnly:void 0,side:o,price:l,stopPrice:void 0,triggerPrice:void 0,amount:u,cost:void 0,average:f,filled:h,remaining:void 0,status:y,fee:void 0,trades:i},t)}async associateWallet(e,t={}){const s=this.uuidv1(),i=this.remove0xPrefix(e),n=[this.base16ToBinary(s),this.base16ToBinary(i)],r=this.binaryConcatArray(n),a=this.hash(r,"keccak","hex"),o=this.signMessageString(a,this.privateKey),d={parameters:{nonce:s,wallet:e},signature:o};return await this.privatePostWallets(d)}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredCredentials(),await this.loadMarkets();const a=this.market(e),o=this.uuidv1();let d;const c={stopLoss:3,stopLossLimit:4,takeProfit:5,takeProfitLimit:6};let u;if(t==="stopLossLimit"||t==="takeProfitLimit"||"stopPrice"in r){if(!("stopPrice"in r))throw new Er(this.id+" createOrder() stopPrice is a required parameter for "+t+"orders");u=this.priceToPrecision(e,r.stopPrice)}const h={limit:1,limitMaker:2};let f;const m=t.toLowerCase().indexOf("limit")>=0;if(t in h)d=h[t],f=this.priceToPrecision(e,n);else if(t in c)d=c[t],f=this.priceToPrecision(e,n);else if(t==="market")d=0;else throw new Er(this.id+" "+t+" is not a valid order type");let g=0;if("quoteOrderQuantity"in r){if(t!=="market")throw new h5(this.id+" createOrder() quoteOrderQuantity is not supported for "+t+" orders, only supported for market orders");g=1,i=this.safeNumber(r,"quoteOrderQuantity")}const y=s==="buy"?0:1,w=this.remove0xPrefix(this.walletAddress),b=this.safeString(this.options,"network","ETH"),S=this.getSupportedMapping(b,{ETH:1,BSC:2,MATIC:4}),v=this.amountToPrecision(e,i),T={gtc:0,ioc:2,fok:3},I=this.safeString(this.options,"defaultTimeInForce","gtc"),A=this.safeString(r,"timeInForce",I);let N;if(A in T)N=T[A];else{const $=Object.keys(T).join(", ");throw new Er(this.id+" "+A+" is not a valid timeInForce, please choose one of "+$)}const B={dc:0,co:1,cn:2,cb:3},x=this.safeString(this.options,"defaultSelfTradePrevention","cn"),k=this.safeString(r,"selfTradePrevention",x);let O;if(k in B)O=B[k];else{const $=Object.keys(B).join(", ");throw new Er(this.id+" "+k+" is not a valid selfTradePrevention, please choose one of "+$)}const P=[this.numberToBE(S,1),this.base16ToBinary(o),this.base16ToBinary(w),this.stringToBinary(this.encode(a.id)),this.numberToBE(d,1),this.numberToBE(y,1),this.stringToBinary(this.encode(v)),this.numberToBE(g,1)];if(m){const G=this.stringToBinary(this.encode(f));P.push(G)}if(t in c){const G=this.stringToBinary(this.encode(u||f));P.push(G)}const q=this.safeString(r,"clientOrderId");q!==void 0&&P.push(this.stringToBinary(this.encode(q)));const L=[this.numberToBE(N,1),this.numberToBE(O,1),this.numberToBE(0,8)],D=this.arrayConcat(P,L),H=this.binaryConcatArray(D),R=this.hash(H,"keccak","hex"),_=this.signMessageString(R,this.privateKey),E={parameters:{nonce:o,market:a.id,side:s,type:t,wallet:this.walletAddress,selfTradePrevention:k},signature:_};t!=="market"&&(E.parameters.timeInForce=A),m&&(E.parameters.price=f),t in c&&(E.parameters.stopPrice=u||f),g===0?E.parameters.quantity=v:E.parameters.quoteOrderQuantity=v,q!==void 0&&(E.parameters.clientOrderId=q);const U=await this.privatePostOrders(E);return this.parseOrder(U,a)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkRequiredCredentials(),await this.loadMarkets();const r=this.uuidv1(),a=this.currencyToPrecision(e,t),o=this.currency(e),d=this.remove0xPrefix(this.walletAddress),c=[this.base16ToBinary(r),this.base16ToBinary(d),this.stringToBinary(this.encode(o.id)),this.stringToBinary(this.encode(a)),this.numberToBE(1,1)],u=this.binaryConcatArray(c),h=this.hash(u,"keccak","hex"),f=this.signMessageString(h,this.privateKey),l={parameters:{nonce:r,wallet:s,asset:o.id,quantity:a},signature:f},m=await this.privatePostWithdrawals(l);return this.parseTransaction(m,o)}async cancelAllOrders(e=void 0,t={}){this.checkRequiredCredentials(),await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i=this.uuidv1(),n={parameters:{nonce:i,wallet:this.walletAddress}},r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(i),this.base16ToBinary(r)];s!==void 0&&(a.push(this.stringToBinary(this.encode(s.id))),n.parameters.market=s.id);const o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey);n.signature=c;const u=await this.privateDeleteOrders(this.extend(n,t));return this.parseOrders(u,s)}async cancelOrder(e,t=void 0,s={}){this.checkRequiredCredentials(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.uuidv1(),r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(n),this.base16ToBinary(r),this.stringToBinary(this.encode(e))],o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey),u={parameters:{nonce:n,wallet:this.walletAddress,orderId:e},signature:c},h=await this.privateDeleteOrders(this.extend(u,s)),f=this.safeValue(h,0);return this.parseOrder(f,i)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c in this.exceptions){const h=this.exceptions[c];throw new h(this.id+" "+u)}if(c!==void 0)throw new d5(this.id+" "+u)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,depositId:e},r=await this.privateGetDeposits(this.extend(n,s));return this.parseTransaction(r,t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetDeposits"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeNumber(t,"serverTime")}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,withdrawalId:e},r=await this.privateGetWithdrawals(this.extend(n,s));return this.parseTransaction(r,t)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetWithdrawals"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={nonce:this.uuidv1(),wallet:this.walletAddress};let a;e!==void 0&&(a=this.currency(e),r.asset=a.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=i.method;i=this.omit(i,"method");const d=await this[o](this.extend(r,i));return this.parseTransactions(d,a,t,s)}parseTransactionStatus(e){const t={mined:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;"depositId"in e?s="deposit":("withdrawId"in e||"withdrawalId"in e)&&(s="withdrawal");let i=this.safeString2(e,"depositId","withdrawId");i=this.safeString(e,"withdrawalId",i);const n=this.safeCurrencyCode(this.safeString(e,"asset"),t),r=this.safeNumber(e,"quantity"),a=this.safeString(e,"txId"),o=this.safeInteger2(e,"txTime","time");let d;"fee"in e&&(d={cost:this.safeNumber(e,"fee"),currency:"ETH"});const c=this.safeString(e,"txStatus"),u=this.parseTransactionStatus(c),h=this.safeInteger(e,"confirmationTime");return{info:e,id:i,txid:a,timestamp:o,datetime:this.iso8601(o),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:s,amount:r,currency:n,status:u,updated:h,fee:d}}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.apiKey!==void 0,o=this.secret!==void 0,d=this.walletAddress!==void 0,c=this.privateKey!==void 0,u=this.safeValue(n,"cost",1);return a&&o&&d&&c?u/2:u}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeString(this.options,"network","ETH"),o=this.safeString(this.options,"version","v1");let d=this.urls.api[a]+"/"+o+"/"+e;const u=Object.keys(i).length;let h;if(u>0&&(s==="GET"?(h=this.urlencode(i),d=d+"?"+h):r=this.json(i)),n={"Content-Type":"application/json"},this.apiKey!==void 0&&(n["IDEX-API-Key"]=this.apiKey),t==="private"){let f;s==="GET"?f=h:f=r,n["IDEX-HMAC-Signature"]=this.hmac(this.encode(f),this.encode(this.secret),"sha256","hex")}return{url:d,method:s,body:r,headers:n}}};const p5=re,{TICK_SIZE:m5}=ne,Nb=ae;var g5=class extends p5{describe(){return this.deepExtend(super.describe(),{id:"independentreserve",name:"Independent Reserve",countries:["AU","NZ"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg",api:{public:"https://api.independentreserve.com/Public",private:"https://api.independentreserve.com/Private"},www:"https://www.independentreserve.com",doc:"https://www.independentreserve.com/API"},api:{public:{get:["GetValidPrimaryCurrencyCodes","GetValidSecondaryCurrencyCodes","GetValidLimitOrderTypes","GetValidMarketOrderTypes","GetValidOrderTypes","GetValidTransactionTypes","GetMarketSummary","GetOrderBook","GetAllOrders","GetTradeHistorySummary","GetRecentTrades","GetFxRates","GetOrderMinimumVolumes","GetCryptoWithdrawalFees"]},private:{post:["GetOpenOrders","GetClosedOrders","GetClosedFilledOrders","GetOrderDetails","GetAccounts","GetTransactions","GetFiatBankAccounts","GetDigitalCurrencyDepositAddress","GetDigitalCurrencyDepositAddresses","GetTrades","GetBrokerageFees","GetDigitalCurrencyWithdrawal","PlaceLimitOrder","PlaceMarketOrder","CancelOrder","SynchDigitalCurrencyDepositAddressWithBlockchain","RequestFiatWithdrawal","WithdrawFiatCurrency","WithdrawDigitalCurrency"]}},fees:{trading:{taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),percentage:!0,tierBased:!1}},commonCurrencies:{PLA:"PlayChip"},precisionMode:m5})}async fetchMarkets(e={}){const t=await this.publicGetGetValidPrimaryCurrencyCodes(e),s=await this.publicGetGetValidSecondaryCurrencyCodes(e),i=await this.publicGetGetOrderMinimumVolumes(e),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeCurrencyCode(a),d=this.safeNumber(i,a);for(let c=0;c<s.length;c++){const u=s[c],h=this.safeCurrencyCode(u),f=a+"/"+u;n.push({id:f,symbol:o+"/"+h,base:o,quote:h,settle:void 0,baseId:a,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:f})}}return n}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"CurrencyCode"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"AvailableBalance"),a.total=this.safeString(i,"TotalBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={primaryCurrencyCode:i.baseId,secondaryCurrencyCode:i.quoteId},r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"CreatedTimestampUtc"));return this.parseOrderBook(r,i.symbol,a,"BuyOrders","SellOrders","Price","Volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r;i!==void 0&&n!==void 0&&(r=i+"/"+n),t=this.safeMarket(r,t,"/");const a=t.symbol,o=this.safeString(e,"LastPrice");return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"DayHighestPrice"),low:this.safeString(e,"DayLowestPrice"),bid:this.safeString(e,"CurrentHighestBidPrice"),bidVolume:void 0,ask:this.safeString(e,"CurrentLowestOfferPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"DayAvgPrice"),baseVolume:this.safeString(e,"DayVolumeXbtInSecondaryCurrrency"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={primaryCurrencyCode:s.baseId,secondaryCurrencyCode:s.quoteId},n=await this.publicGetGetMarketSummary(this.extend(i,t));return this.parseTicker(n,s)}parseOrder(e,t=void 0){let s;const i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r,a;i!==void 0&&n!==void 0?(r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),s=r+"/"+a):t!==void 0&&(s=t.symbol,r=t.base,a=t.quote);let o=this.safeString2(e,"Type","OrderType"),d;o!==void 0&&(o.indexOf("Bid")>=0?d="buy":o.indexOf("Offer")>=0&&(d="sell"),o.indexOf("Market")>=0?o="market":o.indexOf("Limit")>=0&&(o="limit"));const c=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),u=this.safeString(e,"VolumeFilled"),h=this.safeString(e,"FeePercent");let f;return h!==void 0&&u!==void 0&&(f=Nb.stringMul(h,u)),this.safeOrder({info:e,id:this.safeString(e,"OrderGuid"),clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:s,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:this.safeString(e,"Price"),stopPrice:void 0,triggerPrice:void 0,cost:this.safeString(e,"Value"),average:this.safeString(e,"AvgPrice"),amount:this.safeString2(e,"VolumeOrdered","Volume"),filled:u,remaining:this.safeString(e,"Outstanding"),status:this.parseOrderStatus(this.safeString(e,"Status")),fee:{rate:h,cost:f,currency:r},trades:void 0},t)}parseOrderStatus(e){const t={Open:"open",PartiallyFilled:"open",Filled:"closed",PartiallyFilledAndCancelled:"canceled",Cancelled:"canceled",PartiallyFilledAndExpired:"canceled",Expired:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostGetOrderDetails(this.extend({orderGuid:e},s));let n;return t!==void 0&&(n=this.market(t)),this.parseOrder(i,n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetClosedOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.safeInteger(i,"pageIndex",1);s===void 0&&(s=50);const r=this.ordered({pageIndex:n,pageSize:s}),a=await this.privatePostGetTrades(this.extend(r,i));let o;return e!==void 0&&(o=this.market(e)),this.parseTrades(a.Data,o,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.TradeTimestampUtc),i=this.safeString(e,"TradeGuid"),n=this.safeString(e,"OrderGuid"),r=this.safeString2(e,"Price","SecondaryCurrencyTradePrice"),a=this.safeString2(e,"VolumeTraded","PrimaryCurrencyAmount"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(Nb.stringMul(r,a)),u=this.safeString(e,"PrimaryCurrencyCode"),h=this.safeString(e,"SecondaryCurrencyCode");let f;u!==void 0&&h!==void 0&&(f=u+"/"+h);const l=this.safeSymbol(f,t,"/");let m=this.safeString(e,"OrderType");return m!==void 0&&(m.indexOf("Bid")>=0?m="buy":m.indexOf("Offer")>=0&&(m="sell")),{id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:l,order:n,type:void 0,side:m,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={primaryCurrencyCode:n.baseId,secondaryCurrencyCode:n.quoteId,numberOfRecentTradesToRetrieve:50},a=await this.publicGetGetRecentTrades(this.extend(r,i));return this.parseTrades(a.Trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetBrokerageFees(e),s={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"CurrencyCode"),o=this.safeCurrencyCode(a),d=this.safeNumber(r,"Fee");s[o]={info:r,fee:d}}const i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.base,{});i[r]={info:this.safeValue(o,"info"),symbol:r,maker:this.safeNumber(o,"fee"),taker:this.safeNumber(o,"fee"),percentage:!0,tierBased:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d="privatePostPlace"+o+"Order";let c=o;c+=s==="sell"?"Offer":"Bid";const u=this.ordered({primaryCurrencyCode:a.baseId,secondaryCurrencyCode:a.quoteId,orderType:c});t==="limit"&&(u.price=n),u.volume=i;const h=await this[d](this.extend(u,r));return{info:h,id:h.OrderGuid}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderGuid:e};return await this.privatePostCancelOrder(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce(),d=[a,"apiKey="+this.apiKey,"nonce="+o.toString()],c=Object.keys(i);for(let l=0;l<c.length;l++){const m=c[l],g=i[m].toString();d.push(m+"="+g)}const u=d.join(","),h=this.hmac(this.encode(u),this.encode(this.secret)),f=this.ordered({});f.apiKey=this.apiKey,f.nonce=o,f.signature=h.toUpperCase();for(let l=0;l<c.length;l++){const m=c[l];f[m]=i[m]}r=this.json(f),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}};const y5=re,{ExchangeError:Zl,ArgumentsRequired:su,InsufficientFunds:w5,InvalidOrder:Vb,OrderNotFound:b5,AuthenticationError:Eb,BadSymbol:k5}=Q,{TICK_SIZE:S5}=ne;var v5=class extends y5{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:["ID"],rateLimit:100,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},version:"2.0",urls:{logo:"https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg",api:{public:"https://indodax.com/api",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://github.com/btcid/indodax-official-api-docs",referral:"https://indodax.com/ref/testbitcoincoid/1"},api:{public:{get:{server_time:5,pairs:5,price_increments:5,summaries:5,ticker_all:5,"{pair}/ticker":5,"{pair}/trades":5,"{pair}/depth":5}},private:{post:{getInfo:4,transHistory:4,trade:1,tradeHistory:4,openOrders:4,orderHistory:4,getOrder:4,cancelOrder:4,withdrawFee:4,withdrawCoin:4,listDownline:4,checkDownline:4,createVoucher:4}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}},exceptions:{exact:{invalid_pair:k5,"Insufficient balance.":w5,"invalid order.":b5,"Invalid credentials. API not found or session has expired.":Eb,"Invalid credentials. Bad sign.":Eb},broad:{"Minimum price":Vb,"Minimum order":Vb}},options:{recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1},commonCurrencies:{STR:"XLM",BCHABC:"BCH",BCHSV:"BSV",DRK:"DASH",NEM:"XEM"},precisionMode:S5})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetServerTime(e);return this.safeInteger(t,"server_time")}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"ticker_id"),a=this.safeString(n,"traded_currency"),o=this.safeString(n,"base_currency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeInteger(n,"is_maintenance");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!u,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"trade_fee_percent"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,percentage:!0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"price_round"))),cost:this.parseNumber(this.parsePrecision(this.safeString(n,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"trade_min_traded_currency"),max:void 0},price:{min:this.safeNumber(n,"trade_min_base_currency"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"balance",{}),i=this.safeValue(t,"balance_hold",{}),n=this.safeTimestamp(t,"server_time"),r={info:e,timestamp:n,datetime:this.iso8601(n)},a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(s,d),u.used=this.safeString(i,d),r[c]=u}return this.safeBalance(r)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"server_time"),n="vol_"+t.baseId.toLowerCase(),r="vol_"+t.quoteId.toLowerCase(),a=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,n),quoteVolume:this.safeString(e,r),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickerAll(t),i=this.safeValue(s,"tickers");return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");return this.safeTrade({id:this.safeString(e,"tid"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),type:void 0,side:this.safeString(e,"type"),order:void 0,takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrderStatus(e){const t={open:"open",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;"type"in e&&(s=e.type);const i=this.parseOrderStatus(this.safeString(e,"status","open"));let n,r;const a=this.safeString(e,"price");let o,d;if(t!==void 0){n=t.symbol;let f=t.quoteId,l=t.baseId;t.quoteId==="idr"&&"order_rp"in e&&(f="rp"),t.baseId==="idr"&&"remain_rp"in e&&(l="rp"),r=this.safeString(e,"order_"+f),r||(o=this.safeString(e,"order_"+l),d=this.safeString(e,"remain_"+l))}const c=this.safeInteger(e,"submit_time"),u=void 0,h=this.safeString(e,"order_id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:n,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,triggerPrice:void 0,cost:r,average:void 0,amount:o,filled:void 0,remaining:d,status:i,fee:u,trades:void 0})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new su(this.id+" fetchOrder() requires a symbol");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostGetOrder(this.extend(n,s)),a=r.return,o=this.parseOrder(this.extend({id:e},a.order),i);return this.extend({info:r},o)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id);const o=(await this.privatePostOpenOrders(this.extend(r,i))).return.orders;if(!o)return[];if(e!==void 0)return this.parseOrders(o,n,t,s);const d=Object.keys(o);let c=[];for(let u=0;u<d.length;u++){const h=d[u],f=o[h];n=this.safeMarket(h);const l=this.parseOrders(f,n,t,s);c=this.arrayConcat(c,l)}return c}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new su(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.pair=r.id);const a=await this.privatePostOrderHistory(this.extend(n,i));let o=this.parseOrders(a.return.orders,r);return o=this.filterBy(o,"status","closed"),this.filterBySymbolSinceLimit(o,e,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new Zl(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,price:n},d=a.baseId;s==="buy"?o[a.quoteId]=i*n:o[a.baseId]=i,o[d]=i;const c=await this.privatePostTrade(this.extend(o,r)),u=this.safeValue(c,"return",{}),h=this.safeString(u,"order_id");return{info:c,id:h}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new su(this.id+" cancelOrder() requires a symbol argument");const i=this.safeValue(s,"side");if(i===void 0)throw new su(this.id+' cancelOrder() requires an extra "side" param');await this.loadMarkets();const n=this.market(t),r={order_id:e,pair:n.id,type:i};return await this.privatePostCancelOrder(this.extend(r,s))}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostWithdrawFee(this.extend(i,t)),r=this.safeValue(n,"return",{}),a=this.safeString(r,"currency");return{info:n,rate:this.safeNumber(r,"withdraw_fee"),currency:this.safeCurrencyCode(a,s)}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(t!==void 0){const h=this.iso8601(t).slice(0,10);n.start=h,n.end=this.iso8601(this.milliseconds()).slice(0,10)}const r=await this.privatePostTransHistory(this.extend(n,i)),a=this.safeValue(r,"return",{}),o=this.safeValue(a,"withdraw",{}),d=this.safeValue(a,"deposit",{});let c=[],u;if(e===void 0){let h=Object.keys(o);for(let f=0;f<h.length;f++){const l=h[f];c=this.arrayConcat(c,o[l])}h=Object.keys(d);for(let f=0;f<h.length;f++){const l=h[f];c=this.arrayConcat(c,d[l])}}else{u=this.currency(e);const h=this.safeValue(o,u.id,[]),f=this.safeValue(d,u.id,[]);c=this.arrayConcat(h,f)}return this.parseTransactions(c,u,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.milliseconds(),o={currency:r.id,withdraw_amount:t,withdraw_address:s,request_id:a.toString()};i&&(o.withdraw_memo=i);const d=await this.privatePostWithdrawCoin(this.extend(o,n));return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeTimestamp2(e,"success_time","submit_time"),n=this.safeString(e,"deposit_id"),r=this.safeNumber(e,"fee");let a;return r!==void 0&&(a={currency:this.safeCurrencyCode(void 0,t),cost:r,rate:void 0}),{id:this.safeString2(e,"withdraw_id","deposit_id"),txid:this.safeString2(e,"txid","tx"),timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:this.safeString(e,"withdraw_address"),addressTo:void 0,amount:this.safeNumberN(e,["amount","withdraw_amount","deposit_amount"]),type:n===void 0?"withdraw":"deposit",currency:this.safeCurrencyCode(void 0,t),status:this.parseTransactionStatus(s),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"withdraw_memo"),fee:a,info:e}}parseTransactionStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];return t==="public"?a+="/"+this.implodeParams(e,i):(this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,timestamp:this.nonce(),recvWindow:this.options.recvWindow},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||Array.isArray(a))return;const c=this.safeValue(a,"error","");if(!("success"in a)&&c==="")return;if(this.safeInteger(a,"success",0)===1){if("return"in a)return;throw new Zl(this.id+": malformed response: "+this.json(a))}const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Zl(u)}};const T5=re,{ExchangeError:Zn,AuthenticationError:O5,ArgumentsRequired:I5}=Q,{TICK_SIZE:x5}=ne,qb=ae;var _5=class extends T5{describe(){return this.deepExtend(super.describe(),{id:"itbit",name:"itBit",countries:["US"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg",api:{rest:"https://api.itbit.com"},www:"https://www.itbit.com",doc:["https://api.itbit.com/docs","https://www.itbit.com/api"]},api:{public:{get:["markets/{symbol}/ticker","markets/{symbol}/order_book","markets/{symbol}/trades"]},private:{get:["wallets","wallets/{walletId}","wallets/{walletId}/balances/{currencyCode}","wallets/{walletId}/funding_history","wallets/{walletId}/trades","wallets/{walletId}/orders","wallets/{walletId}/orders/{id}"],post:["wallet_transfers","wallets","wallets/{walletId}/cryptocurrency_deposits","wallets/{walletId}/cryptocurrency_withdrawals","wallets/{walletId}/orders","wire_withdrawal"],delete:["wallets/{walletId}/orders/{id}"]}},markets:{"BTC/USD":{id:"XBTUSD",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"XBT",quoteId:"USD",type:"spot",spot:!0},"BTC/SGD":{id:"XBTSGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD",baseId:"XBT",quoteId:"SGD",type:"spot",spot:!0},"BTC/EUR":{id:"XBTEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"XBT",quoteId:"EUR",type:"spot",spot:!0},"ETH/USD":{id:"ETHUSD",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"ETH",quoteId:"USD",type:"spot",spot:!0},"ETH/EUR":{id:"ETHEUR",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"ETH",quoteId:"EUR",type:"spot",spot:!0},"ETH/SGD":{id:"ETHSGD",symbol:"ETH/SGD",base:"ETH",quote:"SGD",baseId:"ETH",quoteId:"SGD",type:"spot",spot:!0},PAXGUSD:{id:"PAXGUSD",symbol:"PAXG/USD",base:"PAXG",quote:"USD",baseId:"PAXG",quoteId:"USD",type:"spot",spot:!0},BCHUSD:{id:"BCHUSD",symbol:"BCH/USD",base:"BCH",quote:"USD",baseId:"BCH",quoteId:"USD",type:"spot",spot:!0},LTCUSD:{id:"LTCUSD",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"LTC",quoteId:"USD",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.0003"),taker:this.parseNumber("0.0035")}},commonCurrencies:{XBT:"BTC"},precisionMode:x5})}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"serverTimeUTC");if(!i)throw new Zn(this.id+" fetchTicker() returned a bad response: "+this.json(e));const n=this.parse8601(i),r=this.safeString(e,"vwap24h"),a=this.safeString(e,"volume24h"),o=qb.stringMul(a,r),d=this.safeString(e,"lastPrice");return this.safeTicker({symbol:s,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:r,open:this.safeString(e,"openToday"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"executionId","matchNumber"),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"direction"),r=this.safeString(e,"orderId");let a=this.safeNumber(e,"commissionPaid");const o=this.safeString(e,"commissionCurrency"),d=this.safeCurrencyCode(o);let c=this.safeNumber(e,"rebatesApplied");c!==void 0&&(c=-c);const u=this.safeString(e,"rebateCurrency"),h=this.safeCurrencyCode(u),f=this.safeString2(e,"price","rate"),l=this.safeString2(e,"currency1Amount","amount"),m=this.parseNumber(f),g=this.parseNumber(l),y=this.parseNumber(qb.stringMul(f,l));let w;if(this.safeString(e,"instrument")!==void 0){const v=this.safeString(e,"currency1"),T=this.safeString(e,"currency2"),I=this.safeCurrencyCode(v),A=this.safeCurrencyCode(T);w=I+"/"+A}const S={info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:w,order:r,type:void 0,side:n,takerOrMaker:void 0,price:m,amount:g,cost:y,fee:void 0};return a!==void 0&&(c!==void 0?d===h?(a=this.sum(a,c),S.fee={cost:a,currency:d}):S.fees=[{cost:a,currency:d},{cost:c,currency:h}]:S.fee={cost:a,currency:d}),"fee"in S||"fees"in S||(S.fee=void 0),S}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new I5(this.id+" fetchTransactions() requires a walletId parameter");const r={walletId:n};s!==void 0&&(r.perPage=s);const o=(await this.privateGetWalletsWalletIdFundingHistory(this.extend(r,i))).fundingHistory,d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeString(u,"time"),f=this.parse8601(h),l=this.safeString(u,"currency"),m=this.safeString(u,"destinationAddress"),g=this.safeString(u,"txnHash"),y=this.safeStringLower(u,"transactionType"),w=this.safeString(u,"status"),b=this.parseTransferStatus(w);d.push({id:this.safeString(u,"withdrawalId"),timestamp:f,datetime:this.iso8601(f),currency:this.safeCurrencyCode(l),address:m,tag:void 0,txid:g,type:y,status:b,amount:this.safeNumber(u,"amount"),fee:void 0,info:u})}return d}parseTransferStatus(e){const t={cancelled:"canceled",completed:"ok"};return this.safeString(t,e,"pending")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new Zn(this.id+" fetchMyTrades() requires a walletId parameter");const r={walletId:n};t!==void 0&&(r.rangeStart=this.ymdhms(t,"T")),s!==void 0&&(r.perPage=s);const a=await this.privateGetWalletsWalletIdTrades(this.extend(r,i)),o=this.safeValue(a,"tradingHistory",[]);let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(o,d,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketsSymbolTrades(this.extend(r,i)),o=this.safeValue(a,"recentTrades",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t=e[0].balances,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"availableBalance"),o.total=this.safeString(n,"totalBalance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.fetchWallets(e);return this.parseBalance(t)}async fetchWallets(e={}){if(await this.loadMarkets(),!this.uid)throw new O5(this.id+" fetchWallets() requires uid API credential");const t={userId:this.uid};return await this.privateGetWallets(this.extend(t,e))}async fetchWallet(e,t={}){await this.loadMarkets();const s={walletId:e};return await this.privateGetWalletsWalletId(this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"filled"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;if(e!==void 0&&(n=this.market(e)),!("walletId"in i))throw new Zn(this.id+" fetchOrders() requires a walletId parameter");const o={walletId:i.walletId},d=await this.privateGetWalletsWalletIdOrders(this.extend(o,i));return this.parseOrders(d,n,t,s)}parseOrderStatus(e){const t={submitted:"open",open:"open",filled:"closed",cancelled:"canceled",rejected:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeString(e,"type"),n=this.safeString(e,"instrument"),r=this.safeSymbol(n,t),a=this.safeString(e,"createdTime"),o=this.parse8601(a),d=this.safeString(e,"amount"),c=this.safeString(e,"amountFilled"),u=void 0,h=this.safeString(e,"price"),f=this.safeString(e,"volumeWeightedAveragePrice"),l=this.safeString(e,"clientOrderIdentifier"),m=this.safeString(e,"id"),y=this.safeString(e,"postOnly")==="True";return this.safeOrder({id:m,clientOrderId:l,info:e,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),symbol:r,type:i,timeInForce:void 0,postOnly:y,side:s,price:h,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:f,amount:d,filled:c,remaining:void 0,fee:u,trades:void 0},t)}nonce(){return this.milliseconds()}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t==="market")throw new Zn(this.id+" createOrder() allows limit orders only");if(!("walletId"in r))throw new Zn(this.id+" createOrder() requires a walletId parameter");i=i.toString(),n=n.toString();const o=this.market(e),d={side:s,type:t,currency:o.id.replace(o.quote,""),amount:i,display:i,price:n,instrument:o.id},c=await this.privatePostWalletsWalletIdOrders(this.extend(d,r));return{info:c,id:c.id}}async fetchOrder(e,t=void 0,s={}){if(await this.loadMarkets(),!("walletId"in s))throw new Zn(this.id+" fetchOrder() requires a walletId parameter");const n={id:e},r=await this.privateGetWalletsWalletIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async cancelOrder(e,t=void 0,s={}){if(!("walletId"in s))throw new Zn(this.id+" cancelOrder() requires a walletId parameter");const n={id:e};return await this.privateDeleteWalletsWalletIdOrdersId(this.extend(n,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),s==="POST"&&Object.keys(o).length&&(r=this.json(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=d,h=[s,a,s==="POST"?r:"",d,c],f=d+this.json(h).replace("\\/","/"),l=this.hash(this.encode(f),"sha256","binary"),m=this.stringToBinary(this.encode(a)),g=this.binaryConcat(m,l),y=this.hmac(g,this.encode(this.secret),"sha512","base64");n={Authorization:this.apiKey+":"+y,"Content-Type":"application/json","X-Auth-Timestamp":c,"X-Auth-Nonce":d}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"code")!==void 0)throw new Zn(this.id+" "+this.json(a))}};const C5=re,{BadSymbol:Ql,BadRequest:Lb,ExchangeNotAvailable:hd,ArgumentsRequired:fd,NotSupported:M5,PermissionDenied:P5,AuthenticationError:Rb,ExchangeError:ld,OrderNotFound:Db,DDoSProtection:iu,InvalidNonce:Fb,InsufficientFunds:Hb,CancelPending:A5,InvalidOrder:nu,InvalidAddress:Gb,RateLimitExceeded:B5,OnMaintenance:N5,AccountSuspended:V5}=Q,{TRUNCATE:E5,TICK_SIZE:q5}=ne,qr=ae;var AT=class extends C5{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:["US"],version:"0",rateLimit:1e3,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLedgerEntry:!0,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:"emulated",fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,withdraw:!0},marketsByAltname:{},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"4h":240,"1d":1440,"1w":10080,"2w":21600},urls:{logo:"https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://kraken.zendesk.com/api/v2/help_center/en-us/articles"},www:"https://www.kraken.com",doc:"https://www.kraken.com/features/api",fees:"https://www.kraken.com/en-us/features/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0026"),maker:this.parseNumber("0.0016"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0026")],[this.parseNumber("50000"),this.parseNumber("0.0024")],[this.parseNumber("100000"),this.parseNumber("0.0022")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("2500000"),this.parseNumber("0.0014")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.0001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0016")],[this.parseNumber("50000"),this.parseNumber("0.0014")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("250000"),this.parseNumber("0.0010")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("10000000"),this.parseNumber("0.0")]]}}},handleContentTypeApplicationZip:!0,api:{zendesk:{get:["360000292886","201893608"]},public:{get:{Assets:1,AssetPairs:1,Depth:1,OHLC:1,Spread:1,Ticker:1,Time:1,Trades:1}},private:{post:{AddOrder:0,AddOrderBatch:0,AddExport:3,Balance:3,CancelAll:3,CancelOrder:0,CancelOrderBatch:0,ClosedOrders:6,DepositAddresses:3,DepositMethods:3,DepositStatus:3,EditOrder:0,ExportStatus:3,GetWebSocketsToken:3,Ledgers:6,OpenOrders:3,OpenPositions:3,QueryLedgers:3,QueryOrders:3,QueryTrades:3,RetrieveExport:3,RemoveExport:3,TradeBalance:3,TradesHistory:6,TradeVolume:3,Withdraw:3,WithdrawCancel:3,WithdrawInfo:3,WithdrawStatus:3,Stake:3,Unstake:3,"Staking/Assets":3,"Staking/Pending":3,"Staking/Transactions":3}}},commonCurrencies:{LUNA:"LUNC",LUNA2:"LUNA",REPV2:"REP",REP:"REPV1",UST:"USTC",XBT:"BTC","XBT.M":"BTC.M",XDG:"DOGE"},options:{delistedMarketsById:{},inactiveCurrencies:["CAD","USD","JPY","GBP"],networks:{ETH:"ERC20",TRX:"TRC20"},depositMethods:{"1INCH":"1inch (1INCH)",AAVE:"Aave",ADA:"ADA",ALGO:"Algorand",ANKR:"ANKR (ANKR)",ANT:"Aragon (ANT)",ATOM:"Cosmos",AXS:"Axie Infinity Shards (AXS)",BADGER:"Bager DAO (BADGER)",BAL:"Balancer (BAL)",BAND:"Band Protocol (BAND)",BAT:"BAT",BCH:"Bitcoin Cash",BNC:"Bifrost (BNC)",BNT:"Bancor (BNT)",BTC:"Bitcoin",CHZ:"Chiliz (CHZ)",COMP:"Compound (COMP)",CQT:"	Covalent Query Token (CQT)",CRV:"Curve DAO Token (CRV)",CTSI:"Cartesi (CTSI)",DAI:"Dai",DASH:"Dash",DOGE:"Dogecoin",DOT:"Polkadot",DYDX:"dYdX (DYDX)",ENJ:"Enjin Coin (ENJ)",EOS:"EOS",ETC:"Ether Classic (Hex)",ETH:"Ether (Hex)",EWT:"Energy Web Token",FEE:"Kraken Fee Credit",FIL:"Filecoin",FLOW:"Flow",GHST:"Aavegotchi (GHST)",GNO:"GNO",GRT:"GRT",ICX:"Icon",INJ:"Injective Protocol (INJ)",KAR:"Karura (KAR)",KAVA:"Kava",KEEP:"Keep Token (KEEP)",KNC:"Kyber Network (KNC)",KSM:"Kusama",LINK:"Link",LPT:"Livepeer Token (LPT)",LRC:"Loopring (LRC)",LSK:"Lisk",LTC:"Litecoin",MANA:"MANA",MATIC:"Polygon (MATIC)",MINA:"Mina",MIR:"Mirror Protocol (MIR)",MKR:"Maker (MKR)",MLN:"MLN",MOVR:"Moonriver (MOVR)",NANO:"NANO",OCEAN:"OCEAN",OGN:"Origin Protocol (OGN)",OMG:"OMG",OXT:"Orchid (OXT)",OXY:"Oxygen (OXY)",PAXG:"PAX (Gold)",PERP:"Perpetual Protocol (PERP)",PHA:"Phala (PHA)",QTUM:"QTUM",RARI:"Rarible (RARI)",RAY:"Raydium (RAY)",REN:"Ren Protocol (REN)",REP:"REPv2",REPV1:"REP",SAND:"The Sandbox (SAND)",SC:"Siacoin",SDN:"Shiden (SDN)",SOL:"Solana",SNX:"Synthetix  Network (SNX)",SRM:"Serum",STORJ:"Storj (STORJ)",SUSHI:"Sushiswap (SUSHI)",TBTC:"tBTC",TRX:"Tron",UNI:"UNI",USDC:"USDC",USDT:"Tether USD (ERC20)","USDT-TRC20":"Tether USD (TRC20)",WAVES:"Waves",WBTC:"Wrapped Bitcoin (WBTC)",XLM:"Stellar XLM",XMR:"Monero",XRP:"Ripple XRP",XTZ:"XTZ",YFI:"YFI",ZEC:"Zcash (Transparent)",ZRX:"0x (ZRX)"}},precisionMode:q5,exceptions:{"EQuery:Invalid asset pair":Ql,"EAPI:Invalid key":Rb,"EFunding:Unknown withdraw key":Gb,"EFunding:Invalid amount":Hb,"EService:Unavailable":hd,"EDatabase:Internal error":hd,"EService:Busy":hd,"EQuery:Unknown asset":Ql,"EAPI:Rate limit exceeded":iu,"EOrder:Rate limit exceeded":iu,"EGeneral:Internal error":hd,"EGeneral:Temporary lockout":iu,"EGeneral:Permission denied":P5,"EOrder:Unknown order":nu,"EOrder:Order minimum not met":nu,"EGeneral:Invalid arguments":Lb,"ESession:Invalid session":Rb,"EAPI:Invalid nonce":Fb,"EFunding:No funding method":Lb,"EFunding:Unknown asset":Ql,"EService:Market in post_only mode":N5,"EGeneral:Too many requests":iu,"ETrade:User Locked":V5}})}feeToPrecision(e,t){return this.decimalToPrecision(t,E5,this.markets[e].precision.amount,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"result",{}),i=Object.keys(s);let n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"base"),c=this.safeString(o,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=a.indexOf(".d")>=0,l=this.safeString(o,"altname"),m=this.safeValue(o,"fees_maker",[]),g=this.safeValue(m,0,[]),y=this.safeString(g,1);let w;y!==void 0&&(w=this.parseNumber(qr.stringDiv(y,"100")));const b=this.safeValue(o,"fees",[]),S=this.safeValue(b,0,[]),v=this.safeString(S,1);let T;v!==void 0&&(T=this.parseNumber(qr.stringDiv(v,"100")));const I=this.safeValue(o,"leverage_buy",[]),A=I.length,N=this.parseNumber(this.parsePrecision(this.safeString(o,"pair_decimals")));n.push({id:a,symbol:f?l:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,darkpool:f,altname:o.altname,type:"spot",spot:!0,margin:A>0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:T,maker:w,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"lot_decimals"))),price:N},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(I,A-1,1)},amount:{min:this.safeNumber(o,"ordermin"),max:void 0},price:{min:N,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return n=this.appendInactiveMarkets(n),this.marketsByAltname=this.indexBy(n,"altname"),n}safeCurrency(e,t=void 0){if(e!==void 0&&e.length>3&&(e.indexOf("X")===0||e.indexOf("Z")===0)){if(e.indexOf(".")>0)return super.safeCurrency(e,t);e=e.slice(1)}return super.safeCurrency(e,t)}appendInactiveMarkets(e){const t={amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-8")},s={min:void 0,max:void 0},i={min:t.price,max:void 0},r={amount:{min:t.amount,max:void 0},price:i,cost:s},a={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:r},o=[];for(let d=0;d<o.length;d++)e.push(this.extend(a,o[d]));return e}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(this.safeString(o,"altname")),c=this.parseNumber(this.parsePrecision(this.safeString(o,"decimals"))),u=!this.inArray(d,this.options.inactiveCurrencies);n[d]={id:a,code:d,info:o,name:d,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id,"fee-info":!0},n=await this.privatePostTradeVolume(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t){const s=this.safeValue(e,"fees_maker",{}),i=this.safeValue(e,"fees",{}),n=this.safeValue(s,t.id,{}),r=this.safeValue(i,t.id,{});return{info:e,symbol:t.symbol,maker:this.safeNumber(n,"fee"),taker:this.safeNumber(r,"fee"),percentage:!0,tierBased:!0}}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s),r=this.safeInteger(e,2);return[i,n,r]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(i.darkpool)throw new ld(this.id+" fetchOrderBook() does not provide an order book for darkpool symbol "+e);const n={pair:i.id};t!==void 0&&(n.count=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeValue(r,"result",{});let o=this.safeValue(a,i.id);const d=this.safeValue(i,"info",{}),c=this.safeValue(d,"wsname");return c!==void 0&&(o=this.safeValue(a,c,o)),this.parseOrderBook(o,e)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeValue(e,"v",[]),r=this.safeString(n,1),a=this.safeValue(e,"p",[]),o=this.safeString(a,1),d=qr.stringMul(r,o),c=this.safeValue(e,"c",[]),u=this.safeString(c,0),h=this.safeValue(e,"h",[]),f=this.safeValue(e,"l",[]),l=this.safeValue(e,"b",[]),m=this.safeValue(e,"a",[]);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(h,1),low:this.safeString(f,1),bid:this.safeString(l,0),bidVolume:void 0,ask:this.safeString(m,0),askVolume:void 0,vwap:o,open:this.safeString(e,"o"),close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){e=this.marketSymbols(e);const o=[];for(let d=0;d<e.length;d++){const c=e[d],u=this.markets[c];u.active&&!u.darkpool&&o.push(u.id)}s.pair=o.join(",")}const n=(await this.publicGetTicker(this.extend(s,t))).result,r=Object.keys(n),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=n[d];a[u]=this.parseTicker(h,c)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){if(await this.loadMarkets(),e.indexOf(".d")>=0)throw new ld(this.id+" fetchTicker() does not provide a ticker for darkpool symbol "+e);const i=this.market(e),n={pair:i.id},a=(await this.publicGetTicker(this.extend(n,t))).result[i.id];return this.parseTicker(a,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,interval:this.timeframes[t]};s!==void 0&&(a.since=parseInt((s-1)/1e3));const o=await this.publicGetOHLC(this.extend(a,n)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,r.id,[]);return this.parseOHLCVs(c,r,t,s,i)}parseLedgerEntryType(e){const t={trade:"trade",withdrawal:"transaction",deposit:"transaction",transfer:"transfer",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i;const n=void 0,r=this.safeString(e,"refid"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"asset"),t);let c=this.safeString(e,"amount");qr.stringLt(c,"0")?(i="out",c=qr.stringAbs(c)):i="in";const u=this.safeNumber(e,"time");let h;return u!==void 0&&(h=parseInt(u*1e3)),{info:e,id:s,direction:i,account:n,referenceId:r,referenceAccount:a,type:o,currency:d,amount:this.parseNumber(c),before:void 0,after:this.safeNumber(e,"balance"),status:"ok",timestamp:h,datetime:this.iso8601(h),fee:{cost:this.safeNumber(e,"fee"),currency:d}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.start=parseInt(t/1e3));const a=await this.privatePostLedgers(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"ledger",{}),c=Object.keys(d),u=[];for(let h=0;h<c.length;h++){const f=c[h],l=d[f];l.id=f,u.push(l)}return this.parseLedger(u,r,t,s)}async fetchLedgerEntriesByIds(e,t=void 0,s={}){await this.loadMarkets(),e=e.join(",");const i=this.extend({id:e},s),r=(await this.privatePostQueryLedgers(i)).result,a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];u.id=c,o.push(u)}return this.parseLedger(o)}async fetchLedgerEntry(e,t=void 0,s={}){return(await this.fetchLedgerEntriesByIds([e],t,s))[0]}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u;if(Array.isArray(e))s=this.safeTimestamp(e,2),i=e[3]==="s"?"sell":"buy",n=e[4]==="l"?"limit":"market",r=this.safeString(e,0),a=this.safeString(e,1),e.length>6&&(o=this.safeString(e,6));else if(typeof e=="string")o=e;else if("ordertxid"in e){const f=this.safeString(e,"pair"),l=this.findMarketByAltnameOrId(f);if(l!==void 0?t=l:f!==void 0&&(t=this.getDelistedMarketById(f)),d=this.safeString(e,"ordertxid"),o=this.safeString2(e,"id","postxid"),s=this.safeTimestamp(e,"time"),i=this.safeString(e,"type"),n=this.safeString(e,"ordertype"),r=this.safeString(e,"price"),a=this.safeString(e,"vol"),"fee"in e){let m;t!==void 0&&(m=t.quote),c={cost:this.safeString(e,"fee"),currency:m}}}t!==void 0&&(u=t.symbol);const h=this.safeString(e,"cost");return this.safeTrade({id:o,order:d,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:n,side:i,takerOrMaker:void 0,price:r,amount:a,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.id,a={pair:r};if(t!==void 0&&(a.since=t*1e6,a.since=t.toString()+"000000"),s!==void 0&&s!==1e3&&this.safeValue(this.options,"fetchTradesWarning",!0))throw new ld(this.id+" fetchTrades() cannot serve "+s.toString()+" trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options['fetchTradesWarning'] to acknowledge this warning and silence it.");const d=(await this.publicGetTrades(this.extend(a,i))).result,c=d[r],u=c.length;if(u<=0)return[];const h=c[u-1],f=this.safeString(d,"last");return h.push(f),this.parseTrades(c,n,t,s)}parseBalance(e){const t=this.safeValue(e,"result",{}),s={info:e,timestamp:void 0,datetime:void 0},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(t,r),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id,type:s,ordertype:t,volume:this.amountToPrecision(e,i)},d=this.orderRequest("createOrder()",e,t,o,n,r),c=await this.privatePostAddOrder(this.extend(d[0],d[1])),u=this.safeValue(c,"result");return this.parseOrder(u)}findMarketByAltnameOrId(e){return e in this.marketsByAltname?this.marketsByAltname[e]:this.safeMarket(e)}getDelistedMarketById(e){if(e===void 0)return e;let t=this.safeValue(this.options.delistedMarketsById,e);if(t!==void 0)return t;const s=0;let i=3,n=3,r=6;e.length===8?(i=4,n=4,r=8):e.length===7&&(i=4,n=4,r=7);const a=e.slice(s,i),o=e.slice(n,r),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);return t={symbol:d+"/"+c,base:d,quote:c,baseId:a,quoteId:o},this.options.delistedMarketsById[e]=t,t}parseOrderStatus(e){const t={pending:"open",open:"open",closed:"closed",canceled:"canceled",expired:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d,c;if(i!==void 0){const v=i.split(" ");n=this.safeString(v,0),d=this.safeString(v,1),a=this.safeString(v,2),r=this.safeString(v,4),r==="stop"?(c=this.safeString(v,6),o=this.safeString(v,9)):r==="limit"&&(o=this.safeString(v,5))}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a);const u=this.findMarketByAltnameOrId(a);let h;u!==void 0?t=u:a!==void 0&&(t=this.getDelistedMarketById(a));const f=this.safeTimestamp(e,"opentm");d=this.safeString(e,"vol",d);const l=this.safeString(e,"vol_exec");let m;o=this.safeString(s,"price",o),(o===void 0||qr.stringEquals(o,"0"))&&(o=this.safeString(s,"price2")),(o===void 0||qr.stringEquals(o,"0"))&&(o=this.safeString(e,"price",o));const g=this.safeNumber(e,"price");if(t!==void 0&&(h=t.symbol,"fee"in e)){const v=e.oflags;m={cost:this.safeString(e,"fee"),rate:void 0},v.indexOf("fciq")>=0?m.currency=t.quote:v.indexOf("fcib")>=0&&(m.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));let w=this.safeString2(e,"id","txid");if(w===void 0||w.slice(0,1)==="["){const v=this.safeValue(e,"txid");w=this.safeString(v,0)}const b=this.safeString(e,"userref"),S=this.safeValue(e,"trades");return c=this.safeNumber(e,"stopprice",c),this.safeOrder({id:w,clientOrderId:b,info:e,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,status:y,symbol:h,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:c,triggerPrice:c,cost:void 0,amount:d,filled:l,average:g,remaining:void 0,fee:m,trades:S},t)}orderRequest(e,t,s,i,n=void 0,r={}){const a=this.safeString2(r,"userref","clientOrderId");if(r=this.omit(r,["userref","clientOrderId"]),a!==void 0&&(i.userref=a),s==="limit")i.price=this.priceToPrecision(t,n);else if(s==="stop-loss"||s==="take-profit"){const d=this.safeNumber2(r,"price","stopPrice",n);if(d===void 0)throw new fd(this.id+e+" requires a price argument or a price/stopPrice parameter for a "+s+" order");i.price=this.priceToPrecision(t,d)}else if(s==="stop-loss-limit"||s==="take-profit-limit"){const d=this.safeNumber2(r,"price","stopPrice"),c=this.safeNumber(r,"price2"),u=d!==void 0,h=c!==void 0;if(u&&h)i.price=this.priceToPrecision(t,d),i.price2=this.priceToPrecision(t,c);else{if(n===void 0||!(u||h))throw new fd(this.id+e+" requires a price argument and/or price/stopPrice/price2 parameters for a "+s+" order");u?(i.price=this.priceToPrecision(t,d),i.price2=this.priceToPrecision(t,n)):h&&(i.price=this.priceToPrecision(t,n),i.price2=this.priceToPrecision(t,c))}}let o=this.safeValue(r,"close");if(o!==void 0){o=this.extend({},o);const d=this.safeValue(o,"price");d!==void 0&&(o.price=this.priceToPrecision(t,d));const c=this.safeValue(o,"price2");c!==void 0&&(o.price2=this.priceToPrecision(t,c)),i.close=o}return r=this.omit(r,["price","stopPrice","price2","close"]),[i,r]}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);if(!o.spot)throw new M5(this.id+" editOrder() does not support "+o.type+" orders, only spot orders are accepted");const d={txid:e,pair:o.id};n!==void 0&&(d.volume=this.amountToPrecision(t,n));const c=this.orderRequest("editOrder()",t,s,d,r,a),u=await this.privatePostEditOrder(this.extend(c[0],c[1])),h=this.safeValue(u,"result",{});return this.parseOrder(h,o)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"userref","clientOrderId"),n={trades:!0};let r=s;i!==void 0?(n.userref=i,r=this.omit(s,["userref","clientOrderId"])):n.txid=e;const a=await this.privatePostQueryOrders(this.extend(n,r)),o=this.safeValue(a,"result",[]);if(!(e in o))throw new Db(this.id+" fetchOrder() could not find order id "+e);const d=this.parseOrder(this.extend({id:e},o[e]));return this.extend({info:a},d)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeValue(n,"trades"),a=[];if(r===void 0)throw new fd(this.id+" fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)");for(let f=0;f<r.length;f++){const l=r[f];typeof l=="string"?a.push(l):a.push(l.id)}await this.loadMarkets(),t!==void 0&&(t=this.symbol(t));const o=this.safeValue(this.options,"fetchOrderTrades",{}),d=this.safeInteger(o,"batchSize",20),c=a.length;let u=parseInt(c/d);u=this.sum(u,1);let h=[];for(let f=0;f<u;f++){const l=[];for(let v=0;v<d;v++){const T=this.sum(f*d,v);T<c&&l.push(a[T])}const m={txid:l.join(",")},g=await this.privatePostQueryTrades(m),y=this.safeValue(g,"result"),w=Object.keys(y);for(let v=0;v<w.length;v++)y[w[v]].id=w[v];const b=this.parseTrades(y,void 0,s,i),S=this.filterBySymbol(b,t);h=this.arrayConcat(h,S)}return h}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e.join(",")},s)),n=this.safeValue(i,"result",{}),r=[],a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.parseOrder(this.extend({id:d},c));r.push(u)}return r}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));const a=(await this.privatePostTradesHistory(this.extend(n,i))).result.trades,o=Object.keys(a);for(let c=0;c<o.length;c++)a[o[c]].id=o[c];let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(a,d,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const r={txid:this.safeValue2(s,"userref","clientOrderId",e)};s=this.omit(s,["userref","clientOrderId"]);try{i=await this.privatePostCancelOrder(this.extend(r,s))}catch(a){throw this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0?new Db(this.id+" cancelOrder() error "+this.last_http_response):a}return i}async cancelOrders(e,t=void 0,s={}){const i={orders:e};return await this.privatePostCancelOrderBatch(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostCancelAll(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostOpenOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"open",[]);return this.parseOrders(u,d,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostClosedOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"closed",[]);return this.parseOrders(u,d,t,s)}parseTransactionStatus(e){const t={Initial:"pending",Pending:"pending",Success:"ok",Settled:"pending",Failure:"failed",Partial:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"refid"),i=this.safeString(e,"txid"),n=this.safeTimestamp(e,"time"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"info"),d=this.safeNumber(e,"amount");let c=this.parseTransactionStatus(this.safeString(e,"status"));const u=this.safeString(e,"status-prop");(u==="on-hold"||u==="cancel-pending"||u==="onhold")&&(c="pending");const m=this.safeString(e,"type");let g=this.safeNumber(e,"fee");return g===void 0&&m==="deposit"&&(g=0),{info:e,id:s,currency:a,amount:d,network:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:c,type:m,updated:void 0,txid:i,timestamp:n,datetime:this.iso8601(n),fee:{currency:a,cost:g}}}parseTransactionsByType(e,t,s=void 0,i=void 0,n=void 0){const r=[];for(let a=0;a<t.length;a++){const o=this.parseTransaction(this.extend({type:e},t[a]));r.push(o)}return this.filterByCurrencySinceLimit(r,s,i,n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fd(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostDepositStatus(this.extend(r,i));return this.parseTransactionsByType("deposit",a.result,e,t,s)}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"result",{});return this.safeTimestamp(s,"unixtime")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fd(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostWithdrawStatus(this.extend(r,i));return this.parseTransactionsByType("withdrawal",a.result,e,t,s)}async createDepositAddress(e,t={}){const s={new:"true"};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositMethods(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.privatePostDepositMethods(this.extend(i,t));return this.safeValue(n,"result")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeStringUpper(t,"network");const n=this.safeValue(this.options,"networks",{});i=this.safeString(n,i,i),t=this.omit(t,"network"),e==="USDT"&&i==="TRC20"&&(e=e+"-"+i);const r=this.safeValue(this.options,"depositMethods",{}),a=this.safeString(r,e);let o=this.safeString(t,"method",a);if(o===void 0){const f=await this.fetchDepositMethods(e);if(i!==void 0)for(let l=0;l<f.length;l++){const m=this.safeString(f[l],"method");if(m.indexOf(i)>=0){o=m;break}}if(o===void 0){const l=this.safeValue(f,0,{});o=this.safeString(l,"method")}}const d={asset:s.id,method:o},c=await this.privatePostDepositAddresses(this.extend(d,t)),u=this.safeValue(c,"result",[]),h=this.safeValue(u,0,{});if(h===void 0)throw new Gb(this.id+" privatePostDepositAddresses() returned no addresses for "+e);return this.parseDepositAddress(h,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");t=this.safeCurrency(void 0,t);const n=t.code;return this.checkAddress(s),{currency:n,address:s,tag:i,network:void 0,info:e}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),"key"in n){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"result",{});return this.parseTransaction(d,r)}throw new ld(this.id+" withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)")}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostOpenPositions(this.extend(s,t));return this.safeValue(i,"result")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+t+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencodeNested(i));else if(t==="private"){const o=e==="CancelOrderBatch";this.checkRequiredCredentials();const d=this.nonce().toString();o?r=this.json(this.extend({nonce:d},i)):r=this.urlencodeNested(this.extend({nonce:d},i));const c=this.encode(d+r),u=this.hash(c,"sha256","binary"),h=this.stringToBinary(this.encode(a)),f=this.binaryConcat(h,u),l=this.base64ToBinary(this.secret),m=this.hmac(f,l,"sha512","base64");n={"API-Key":this.apiKey,"API-Sign":m},o?n["Content-Type"]="application/json":n["Content-Type"]="application/x-www-form-urlencoded"}else a="/"+e;return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(e===520)throw new hd(this.id+" "+e.toString()+" "+t);if(r.indexOf("Invalid order")>=0)throw new nu(this.id+" "+r);if(r.indexOf("Invalid nonce")>=0)throw new Fb(this.id+" "+r);if(r.indexOf("Insufficient funds")>=0)throw new Hb(this.id+" "+r);if(r.indexOf("Cancel pending")>=0)throw new A5(this.id+" "+r);if(r.indexOf("Invalid arguments:volume")>=0)throw new nu(this.id+" "+r);if(r.indexOf("Rate limit exceeded")>=0)throw new B5(this.id+" "+r);if(a!==void 0&&r[0]==="{"&&typeof a!="string"&&"error"in a&&a.error.length){const u=this.id+" "+r;for(let h=0;h<a.error.length;h++){const f=a.error[h];this.throwExactlyMatchedException(this.exceptions,f,u)}throw new ld(u)}}};const L5=re,{ExchangeError:Pa,ExchangeNotAvailable:Jl,InsufficientFunds:pd,OrderNotFound:ep,InvalidOrder:$i,AccountSuspended:R5,InvalidNonce:D5,NotSupported:ru,BadRequest:md,AuthenticationError:Lr,BadSymbol:Ub,RateLimitExceeded:$b,PermissionDenied:Wb,InvalidAddress:zb}=Q,{TICK_SIZE:F5}=ne,Aa=ae;var mg=class extends L5{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"KuCoin",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchWithdrawals:!0,repayMargin:!0,setMarginMode:!1,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",referral:"https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",api:{public:"https://api.kucoin.com",private:"https://api.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"},www:"https://www.kucoin.com",doc:["https://docs.kucoin.com"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:{timestamp:1,status:1,symbols:1,markets:1,"market/allTickers":1,"market/orderbook/level{level}_{limit}":1,"market/orderbook/level2_20":1,"market/orderbook/level2_100":1,"market/histories":1,"market/candles":1,"market/stats":1,currencies:1,"currencies/{currency}":1,prices:1,"mark-price/{symbol}/current":1,"margin/config":1,"margin/trade/last":1},post:{"bullet-public":1}},private:{get:{"market/orderbook/level{level}":1,"market/orderbook/level2":{v3:2},"market/orderbook/level3":1,accounts:1,"accounts/{accountId}":1,"accounts/ledgers":3.333,"accounts/{accountId}/holds":1,"accounts/transferable":1,"base-fee":1,"sub/user":1,"user-info":1,"sub/api-key":1,"sub-accounts":1,"sub-accounts/{subUserId}":1,"deposit-addresses":1,deposits:10,"hist-deposits":10,"hist-withdrawals":10,withdrawals:10,"withdrawals/quotas":1,orders:2,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"limit/orders":1,fills:6.66667,"limit/fills":1,"isolated/accounts":2,"isolated/account/{symbol}":2,"isolated/borrow/outstanding":2,"isolated/borrow/repaid":2,"isolated/symbols":2,"margin/account":1,"margin/borrow":1,"margin/borrow/outstanding":1,"margin/borrow/repaid":1,"margin/lend/active":1,"margin/lend/done":1,"margin/lend/trade/unsettled":1,"margin/lend/trade/settled":1,"margin/lend/assets":1,"margin/market":1,"stop-order/{orderId}":1,"stop-order":1,"stop-order/queryOrderByClientOid":1,"trade-fees":1.3333},post:{accounts:1,"accounts/inner-transfer":{v2:1},"accounts/sub-transfer":{v2:25},"deposit-addresses":1,withdrawals:1,orders:4,"orders/multi":20,"isolated/borrow":2,"isolated/repay/all":2,"isolated/repay/single":2,"margin/borrow":1,"margin/order":1,"margin/repay/all":1,"margin/repay/single":1,"margin/lend":1,"margin/toggle-auto-lend":1,"bullet-private":1,"stop-order":1,"sub/user":1,"sub/api-key":1,"sub/api-key/update":1},delete:{"withdrawals/{withdrawalId}":1,orders:20,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"margin/lend/{orderId}":1,"stop-order/cancelOrderByClientOid":1,"stop-order/{orderId}":1,"stop-order/cancel":1,"sub/api-key":1}},futuresPublic:{get:{"contracts/active":1.3953,"contracts/{symbol}":1.3953,ticker:1.3953,"level2/snapshot":2,"level2/depth20":1.3953,"level2/depth100":1.3953,"level2/message/query":1.3953,"level3/message/query":1.3953,"level3/snapshot":1.3953,"trade/history":1.3953,"interest/query":1.3953,"index/query":1.3953,"mark-price/{symbol}/current":1.3953,"premium/query":1.3953,"funding-rate/{symbol}/current":1.3953,timestamp:1.3953,status:1.3953,"kline/query":1.3953},post:{"bullet-public":1.3953}},futuresPrivate:{get:{"account-overview":2,"transaction-history":6.666,"deposit-address":1.3953,"deposit-list":1.3953,"withdrawals/quotas":1.3953,"withdrawal-list":1.3953,"transfer-list":1.3953,orders:1.3953,stopOrders:1.3953,recentDoneOrders:1.3953,"orders/{orderId}":1.3953,"orders/byClientOid":1.3953,fills:6.666,recentFills:6.666,openOrderStatistics:1.3953,position:1.3953,positions:6.666,"funding-history":6.666},post:{withdrawals:1.3953,"transfer-out":1.3953,orders:1.3953,"position/margin/auto-deposit-status":1.3953,"position/margin/deposit-margin":1.3953,"bullet-private":1.3953},delete:{"withdrawals/{withdrawalId}":1.3953,"cancel/transfer-out":1.3953,"orders/{orderId}":1.3953,orders:6.666,stopOrders:1.3953}}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},precisionMode:F5,exceptions:{exact:{"order not exist":ep,"order not exist.":ep,order_not_exist:ep,order_not_exist_or_not_allow_to_cancel:$i,"Order size below the minimum requirement.":$i,"The withdrawal amount is below the minimum requirement.":Pa,"Unsuccessful! Exceeded the max. funds out-transfer limit":pd,400:md,401:Lr,403:ru,404:ru,405:ru,429:$b,500:Jl,503:Jl,101030:Wb,103e3:$i,200004:pd,210014:$i,210021:pd,230003:pd,26e4:zb,260100:pd,3e5:$i,4e5:Ub,400001:Lr,400002:D5,400003:Lr,400004:Lr,400005:Lr,400006:Lr,400007:Lr,400008:ru,400100:md,400200:$i,400350:$i,400370:$i,400500:$i,400600:Ub,400760:$i,401e3:md,411100:R5,415e3:md,5e5:Jl,260220:zb,900014:md},broad:{"Exceeded the access frequency":$b,"require more permission":Wb}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.001")],[this.parseNumber("200"),this.parseNumber("0.0009")],[this.parseNumber("500"),this.parseNumber("0.0008")],[this.parseNumber("1000"),this.parseNumber("0.0007")],[this.parseNumber("2000"),this.parseNumber("0.0007")],[this.parseNumber("4000"),this.parseNumber("0.0006")],[this.parseNumber("8000"),this.parseNumber("0.0005")],[this.parseNumber("15000"),this.parseNumber("0.00045")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("40000"),this.parseNumber("0.00035")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.00025")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.0009")],[this.parseNumber("200"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.00005")],[this.parseNumber("25000"),this.parseNumber("-0.00005")],[this.parseNumber("40000"),this.parseNumber("-0.00005")],[this.parseNumber("60000"),this.parseNumber("-0.00005")],[this.parseNumber("80000"),this.parseNumber("-0.00005")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{BIFI:"BIFIF",EDGE:"DADI",HOT:"HOTNOW",TRY:"Trias",VAI:"VAIOT",WAX:"WAXP"},options:{version:"v1",symbolSeparator:"-",fetchMyTradesMethod:"private_get_fills",fetchMarkets:{fetchTickersFees:!0},versions:{public:{GET:{"currencies/{currency}":"v2",status:"v1","market/orderbook/level2_20":"v1","market/orderbook/level2_100":"v1","market/orderbook/level{level}_{limit}":"v1"}},private:{GET:{"market/orderbook/level2":"v3","market/orderbook/level3":"v3","market/orderbook/level{level}":"v3","deposit-addresses":"v1"},POST:{"accounts/inner-transfer":"v2","accounts/sub-transfer":"v2",accounts:"v2"}},futuresPrivate:{GET:{"account-overview":"v1",positions:"v1"},POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},partner:{spot:{id:"ccxt",key:"9e58cc35-5b5e-4133-92ec-166e3f077cb8"},future:{id:"ccxtfutures",key:"1b327198-f30c-4f14-a0ac-918871282f15"}},accountsByType:{spot:"trade",margin:"margin",cross:"margin",isolated:"isolated",main:"main",funding:"main",future:"contract",swap:"contract",mining:"pool"},networks:{Native:"bech32","BTC-Segwit":"btc",ERC20:"eth",BEP20:"bsc",TRC20:"trx",TERRA:"luna",BNB:"bsc",HRC20:"heco",HT:"heco"},networksById:{BEP20:"BSC"}}})}nonce(){return this.milliseconds()}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=this.safeValue(t,"data"),i=this.safeValue(this.options,"fetchMarkets",{}),n=this.safeValue(i,"fetchTickersFees",!0);let r={};n&&(r=await this.publicGetMarketAllTickers(e));const a=this.safeValue(r,"data",{}),o=this.safeValue(a,"ticker",[]),d=this.indexBy(o,"symbol"),c=[];for(let u=0;u<s.length;u++){const h=s[u],f=this.safeString(h,"symbol"),[l,m]=f.split("-"),g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(m),w=this.safeValue(d,f,{}),b=this.safeString(w,"makerFeeRate"),S=this.safeString(w,"takerFeeRate"),v=this.safeString(w,"makerCoefficient"),T=this.safeString(w,"takerCoefficient");c.push({id:f,symbol:g+"/"+y,base:g,quote:y,settle:void 0,baseId:l,quoteId:m,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(h,"isMarginEnabled"),swap:!1,future:!1,option:!1,active:this.safeValue(h,"enableTrading"),contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(Aa.stringMul(S,T)),maker:this.parseNumber(Aa.stringMul(b,v)),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(h,"baseIncrement"),price:this.safeNumber(h,"priceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(h,"baseMinSize"),max:this.safeNumber(h,"baseMaxSize")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"quoteMinSize"),max:this.safeNumber(h,"quoteMaxSize")}},info:h})}return c}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeString(r,"fullName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"isWithdrawEnabled",!1),u=this.safeValue(r,"isDepositEnabled",!1),h=this.safeNumber(r,"withdrawalMinFee"),f=c&&u;i[d]={id:a,name:o,code:d,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),info:r,active:f,deposit:u,withdraw:c,fee:h,limits:this.limits}}return i}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"currency"),d=this.safeCurrencyCode(o),c=this.safeString(r,"type");i.push({id:a,type:c,currency:d,info:r})}return i}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"network","chain");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r.toLowerCase(),t=this.omit(t,["network","chain"]));const a=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),o=a.data,d={};return d[e]=this.safeNumber(o,"withdrawMinFee"),{info:a,withdraw:d,deposit:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeStringUpper(t,"network"),r=this.networkCodeToId(n,e);r!==void 0&&(i.chain=r,t=this.omit(t,["network"]));const a=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),o=this.safeValue(a,"data");return this.parseDepositWithdrawFee(o,s)}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e);if(this.safeValue(e,"isWithdrawEnabled")){const n=this.safeString(e,"chain"),r=this.networkIdToCode(n,this.safeString(t,"code"));s.networks[r]={withdraw:{fee:this.safeNumber(e,"withdrawMinFee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return this.assignDefaultDepositWithdrawFees(s)}isFuturesMethod(e,t){const s=this.safeString2(this.options,e,"defaultType","trade"),i=this.safeString(t,"type",s),n=this.safeValue(this.options,"accountsByType"),r=this.safeString(n,i);if(r===void 0){const a=Object.keys(n);throw new Pa(this.id+" isFuturesMethod() type must be one of "+a.join(", "))}return t=this.omit(t,"type"),r==="contract"||r==="future"||r==="futures"}parseTicker(e,t=void 0){let s=this.safeString(e,"changeRate");s!==void 0&&(s=Aa.stringMul(s,"100"));let i=this.safeString2(e,"last","lastTradedPrice");i=this.safeString(e,"price",i);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.safeString(e,"vol"),o=this.safeString(e,"volValue"),d=this.safeInteger2(e,"time","datetime");return this.safeTicker({symbol:r,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString2(e,"buy","bestBid"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString2(e,"sell","bestAsk"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:this.safeString(e,"changePrice"),percentage:s,average:this.safeString(e,"averagePrice"),baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketAllTickers(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"ticker",[]),r=this.safeInteger(i,"time"),a={};for(let o=0;o<n.length;o++){n[o].time=r;const d=this.parseTicker(n[o]),c=this.safeString(d,"symbol");c!==void 0&&(a[c]=d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketStats(this.extend(i,t));return this.parseTicker(n.data,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,type:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.startAt=parseInt(Math.floor(s/1e3)),i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",1500)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.startAt=parseInt(Math.floor(s/1e3))),o.endAt=parseInt(Math.floor(c/1e3));const u=await this.publicGetMarketCandles(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=await this.privatePostDepositAddresses(this.extend(i,t)),o=this.safeValue(a,"data",{});let d=this.safeString(o,"address");d!==void 0&&(d=d.replace("bitcoincash:",""));const c=this.safeString(o,"memo");return e!=="NIM"&&this.checkAddress(d),{info:a,currency:e,network:this.safeString(o,"chain"),address:d,tag:c}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v1";const o=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=a;const d=this.safeValue(o,"data",{});return this.parseDepositAddress(d,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=t.id;return i!=="NIM"&&this.checkAddress(s),{info:e,currency:i,address:s,tag:this.safeString(e,"memo"),network:this.safeString(e,"chain")}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v2";const r=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=n;const a=this.safeValue(r,"data",[]);return this.parseDepositAddressesByNetwork(a,s)}parseDepositAddressesByNetwork(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({info:n,currency:this.safeCurrencyCode(t.id,t),network:this.safeString(n,"chain"),address:this.safeString(n,"address"),tag:this.safeString(n,"memo")})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.safeInteger(s,"level",2),r={symbol:i.id};let a="publicGetMarketOrderbookLevelLevelLimit";const o=this.checkRequiredCredentials(!1);let d;if(!o||t!==void 0){if(n===2){if(r.level=n,t!==void 0)if(t===20||t===100)r.limit=t;else throw new Pa(this.id+" fetchOrderBook() limit argument must be 20 or 100");r.limit=t||100}}else a="privateGetMarketOrderbookLevel2";d=await this[a](this.extend(r,s));const c=this.safeValue(d,"data",{}),u=this.safeInteger(c,"time"),h=this.parseOrderBook(c,i.symbol,u,"bids","asks",n-2,n-1);return h.nonce=this.safeInteger(c,"sequence"),h}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.marketId(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());r=this.omit(r,["clientOid","clientOrderId"]);const d={clientOid:o,side:s,symbol:a,type:t},c=this.safeNumber2(r,"cost","funds");let u,h,f;[f,r]=this.handleMarginModeAndParams("createOrder",r),t==="market"?c!==void 0?(r=this.omit(r,["cost","funds"]),h=this.amountToPrecision(e,c),d.funds=h):(u=this.amountToPrecision(e,i),d.size=this.amountToPrecision(e,i)):(u=this.amountToPrecision(e,i),d.size=u,d.price=this.priceToPrecision(e,n));const l=this.safeValue(r,"stopLossPrice"),m=this.safeValue2(r,"takeProfitPrice","stopPrice"),g=l!==void 0,y=m!==void 0;if(g&&y)throw new Pa(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");r=this.omit(r,["stopLossPrice","takeProfitPrice","stopPrice"]);const w=this.safeString(r,"tradeType");let b="privatePostOrders";if(g||y){d.stop=g?"entry":"loss";const N=g?l:m;d.stopPrice=this.priceToPrecision(e,N),b="privatePostStopOrder"}else(w==="MARGIN_TRADE"||f!==void 0)&&(b="privatePostMarginOrder",f==="isolated"&&(d.marginModel="isolated"));const S=await this[b](this.extend(d,r)),v=this.safeValue(S,"data",{}),T=this.milliseconds();return{id:this.safeString(v,"orderId"),clientOrderId:o,info:v,timestamp:T,datetime:this.iso8601(T),lastTradeTimestamp:void 0,symbol:e,type:t,side:s,price:n,amount:this.parseNumber(u),cost:this.parseNumber(h),average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a="privateDeleteOrdersOrderId";return n!==void 0?(i.clientOid=n,r?a="privateDeleteStopOrderCancelOrderByClientOid":a="privateDeleteOrderClientOrderClientOid"):(r&&(a="privateDeleteStopOrderOrderId"),i.orderId=e),s=this.omit(s,["clientOid","clientOrderId","stop"]),await this[a](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);let n="privateDeleteOrders";return this.safeValue(t,"stop")&&(n="privateDeleteStopOrderCancel"),await this[n](this.extend(s,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r=e.toLowerCase();r==="open"?r="active":r==="closed"&&(r="done");const a={status:r};let o;t!==void 0&&(o=this.market(t),a.symbol=o.id),s!==void 0&&(a.startAt=s),i!==void 0&&(a.pageSize=i);const d=this.safeInteger2(n,"until","till");d&&(a.endAt=d);const c=this.safeValue(n,"stop");n=this.omit(n,["stop","till","until"]);let u="privateGetOrders";c&&(u="privateGetStopOrder");const h=await this[u](this.extend(a,n)),f=this.safeValue(h,"data",{}),l=this.safeValue(f,"items",[]);return this.parseOrders(l,o,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("active",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a;t!==void 0&&(a=this.market(t)),s=this.omit(s,"stop");let o="privateGetOrdersOrderId";if(n!==void 0)i.clientOid=n,r?(o="privateGetStopOrderQueryOrderByClientOid",t!==void 0&&(i.symbol=a.id)):o="privateGetOrderClientOrderClientOid";else{if(e===void 0)throw new $i(this.id+" fetchOrder() requires an order id");r&&(o="privateGetStopOrderOrderId"),i.orderId=e}s=this.omit(s,["clientOid","clientOrderId"]);const d=await this[o](this.extend(i,s));let c=this.safeValue(d,"data");return o==="privateGetStopOrderQueryOrderByClientOid"&&(c=this.safeValue(c,0)),this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),f=this.safeNumber(e,"fee"),l=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString(e,"dealFunds"),y=this.safeValue(e,"isActive",!1),w=this.safeValue(e,"cancelExist",!1),b=this.safeString(e,"stop"),S=this.safeValue(e,"stopTriggered",!1);let v=y?"open":"closed";v=w||!y&&b&&!S?"canceled":v;const I={currency:h,cost:f},A=this.safeString(e,"clientOid"),N=this.safeString(e,"timeInForce"),B=this.safeNumber(e,"stopPrice"),x=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:A,symbol:i,type:r,timeInForce:N,postOnly:x,side:c,amount:l,price:d,stopPrice:B,triggerPrice:B,cost:g,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:I,status:v,info:e,lastTradeTimestamp:void 0,average:void 0,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.pageSize=s);const a=this.options.fetchMyTradesMethod;let o=!1;if(a==="private_get_fills")t!==void 0&&(n.startAt=t);else if(a==="private_get_limit_fills")o=!0;else if(a==="private_get_hist_orders")t!==void 0&&(n.startAt=parseInt(t/1e3));else throw new Pa(this.id+" fetchMyTradesMethod() invalid method");const d=await this[a](this.extend(n,i)),c=this.safeValue(d,"data",{});let u;return o?u=c:u=this.safeValue(c,"items",[]),this.parseTrades(u,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketHistories(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"time");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let f=this.safeString(e,"type");f==="match"&&(f=void 0);const l=this.safeString2(e,"funds","dealValue");return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:f,takerOrMaker:r,side:c,price:o,amount:d,cost:l,fee:u},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.privateGetTradeFees(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0),o=this.safeString(a,"symbol");return{info:n,symbol:this.safeSymbol(o,s),maker:this.safeNumber(a,"makerFeeRate"),taker:this.safeNumber(a,"takerFeeRate"),percentage:!0,tierBased:!0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,address:s,amount:t};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d=d.toLowerCase(),a.chain=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawals(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}parseTransactionStatus(e){const t={SUCCESS:"ok",PROCESSING:"ok",FAILURE:"failed"};return this.safeString(t,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t);let n=this.safeString(e,"address");const r=this.safeString(e,"amount");let a=this.safeString(e,"walletTxId");if(a!==void 0){const y=a.split("@");y.length>1&&n===void 0&&y[1].length>1&&(n=y[1]),a=y[0]}let o=a===void 0?"withdrawal":"deposit";const d=this.safeString(e,"status");let c;const u=this.safeString(e,"fee");if(u!==void 0){let y;r!==void 0&&(y=Aa.stringDiv(u,r)),c={cost:this.parseNumber(u),rate:this.parseNumber(y),currency:i}}let h=this.safeInteger2(e,"createdAt","createAt"),f=this.safeInteger(e,"updatedAt");!("createdAt"in e)&&(o="address"in e?"withdrawal":"deposit",h!==void 0&&(h=h*1e3),f!==void 0&&(f=f*1e3));const m=this.safeString(e,"memo"),g=this.safeString(e,"chain");return{info:e,id:this.safeString2(e,"id","withdrawalId"),timestamp:h,datetime:this.iso8601(h),network:g,address:n,addressTo:n,addressFrom:void 0,tag:m,tagTo:m,tagFrom:void 0,currency:i,amount:this.parseNumber(r),txid:a,type:o,status:this.parseTransactionStatus(d),comment:this.safeString(e,"remark"),fee:c,updated:f}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetDeposits";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistDeposits"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetWithdrawals";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistWithdrawals"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"withdrawal"})}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"holdBalance"),t.free=this.safeString(e,"availableBalance"),t.total=this.safeString(e,"totalBalance");const s=this.safeString(e,"liability"),i=this.safeString(e,"interest");return t.debt=Aa.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"code");let s;t!==void 0&&(s=this.currency(t));const i=this.safeString2(this.options,"fetchBalance","defaultType","spot"),n=this.safeString(e,"type",i),r=this.safeValue(this.options,"accountsByType"),a=this.safeString(r,n,n);e=this.omit(e,"type");const[o,d]=this.handleMarginModeAndParams("fetchBalance",e);let c="privateGetAccounts";const u={},h=o==="isolated"||a==="isolated",f=o==="cross"||a==="cross";h?(c="privateGetIsolatedAccounts",s!==void 0&&(u.balanceCurrency=s.id)):f?c="privateGetMarginAccount":(s!==void 0&&(u.currency=s.id),u.type=a);const l=await this[c](this.extend(u,d)),m=this.safeValue(l,"data",[]),g={info:l,timestamp:void 0,datetime:void 0};if(h){const y=this.safeValue(m,"assets",[]);for(let w=0;w<y.length;w++){const b=y[w],S=this.safeString(b,"symbol"),v=this.safeSymbol(S,void 0,"_"),T=this.safeValue(b,"baseAsset",{}),I=this.safeValue(b,"quoteAsset",{}),A=this.safeCurrencyCode(this.safeString(T,"currency")),N=this.safeCurrencyCode(this.safeString(I,"currency")),B={};B[A]=this.parseBalanceHelper(T),B[N]=this.parseBalanceHelper(I),g[v]=this.safeBalance(B)}}else if(f){const y=this.safeValue(m,"accounts",[]);for(let w=0;w<y.length;w++){const b=y[w],S=this.safeString(b,"currency"),v=this.safeCurrencyCode(S);g[v]=this.parseBalanceHelper(b)}}else for(let y=0;y<m.length;y++){const w=m[y];if(this.safeString(w,"type")===a){const S=this.safeString(w,"currency"),v=this.safeCurrencyCode(S),T=this.account();T.total=this.safeString(w,"balance"),T.free=this.safeString(w,"available"),T.used=this.safeString(w,"holds"),g[v]=T}}return h?g:this.safeBalance(g)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t);let o=this.convertTypeToAccount(s),d=this.convertTypeToAccount(i);const c=this.inArray(o,this.ids),u=this.inArray(d,this.ids);if(o==="contract"){if(d!=="main")throw new Pa(this.id+" transfer() only supports transferring from futures account to main account");const h={currency:r.id,amount:a};"bizNo"in n||(h.bizNo=this.uuid22());const f=await this.futuresPrivatePostTransferOut(this.extend(h,n)),l=this.safeValue(f,"data");return this.parseTransfer(l,r)}else{const h={currency:r.id,amount:a};(c||u)&&(this.inArray(o,this.ids)&&(h.fromTag=o,o="isolated"),this.inArray(d,this.ids)&&(h.toTag=d,d="isolated")),h.from=o,h.to=d,"clientOid"in n||(h.clientOid=this.uuid());const f=await this.privatePostAccountsInnerTransfer(this.extend(h,n)),l=this.safeValue(f,"data");return this.parseTransfer(l,r)}}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"createdAt"),i=this.safeString(e,"currency"),n=this.safeString(e,"status"),r=this.safeStringLower(e,"payAccountType"),a=this.safeStringLower(e,"recAccountType"),o=this.safeValue(this.options,"accountsByType"),d=this.safeString(o,r,r),c=this.safeString(o,a,a);return{id:this.safeString2(e,"applyId","orderId"),currency:this.safeCurrencyCode(i,t),timestamp:s,datetime:this.iso8601(s),amount:this.safeNumber(e,"amount"),fromAccount:d,toAccount:c,status:this.parseTransferStatus(n),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={"Assets Transferred in After Upgrading":"transfer",Deposit:"transaction",Withdrawal:"transaction",Transfer:"transfer",Trade_Exchange:"trade","KuCoin Bonus":"bonus","Referral Bonus":"referral",Rewards:"bonus","Airdrop/Fork":"airdrop","Other rewards":"bonus","Fee Rebate":"rebate","Buy Crypto":"trade","Sell Crypto":"sell","Public Offering Purchase":"trade","Refunded Fees":"fee","KCS Pay Fees":"fee","Margin Trade":"trade",Loans:"Loans","Instant Exchange":"trade","Sub-account transfer":"transfer","Liquidation Fees":"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=void 0,o=this.safeString(e,"bizType"),d=this.parseLedgerEntryType(o),c=this.safeString(e,"direction"),u=this.safeInteger(e,"createdAt"),h=this.iso8601(u),f=this.safeString(e,"accountType"),l=this.safeString(e,"context");let m;if(l!==void 0&&l!=="")try{const b=JSON.parse(l),S=this.safeString(b,"orderId"),v=this.safeString(b,"tradeId");v!==void 0?m=v:m=S}catch{m=l}let g;const y=this.safeNumber(e,"fee");let w;return y!==0&&(w=n,g={cost:y,currency:w}),{id:s,direction:c,account:f,referenceId:m,referenceAccount:f,type:d,currency:n,amount:r,timestamp:u,datetime:h,before:void 0,after:a,status:void 0,fee:g,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n={};t!==void 0&&(n.startAt=t);let r;e!==void 0&&(r=this.currency(e),n.currency=r.id);const a=await this.privateGetAccountsLedgers(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"items");return this.parseLedger(d,r,t,s)}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,e,{}),d=this.safeValue(o,t,{}),c=this.safeString(d,s,this.options.version),u=this.safeString(i,"version",c);return u==="v3"&&"v3"in n?n.v3:u==="v2"&&"v2"in n?n.v2:u==="v1"&&"v1"in n?n.v1:this.safeValue(n,"cost",1)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={currency:this.currency(e).id},a=await this.privateGetMarginTradeLast(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseBorrowRateHistory(o,e)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=Aa.stringMul(s,"0.000001"),n=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(n,t),rate:this.safeNumber(e,"dailyIntRate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r="cross");const a={};let o="privateGetMarginBorrowOutstanding";if(r==="isolated"){if(e!==void 0){const h=this.currency(e);a.balanceCurrency=h.id}o="privateGetIsolatedAccounts"}else if(e!==void 0){const h=this.currency(e);a.currency=h.id}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",{}),u=r==="isolated"?this.safeValue(c,"assets",[]):this.safeValue(c,"items",[]);return this.parseBorrowInterests(u,void 0)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s,t);const n=this.safeString(t,"symbol"),r=this.safeInteger(e,"createdAt"),a=this.safeValue(e,"baseAsset",{});let o,d,c;return i==="isolated"?(o=this.safeNumber(a,"liability"),d=this.safeNumber(a,"interest"),c=this.safeString(a,"currency")):(o=this.safeNumber(e,"principal"),d=this.safeNumber(e,"accruedInterest"),c=this.safeString(e,"currency")),{symbol:n,marginMode:i,currency:this.safeCurrencyCode(c),interest:d,interestRate:this.safeNumber(e,"dailyIntRate"),amountBorrowed:o,timestamp:r,datetime:this.iso8601(r),info:e}}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeStringN(i,["timeInForce","type","borrowStrategy"],"IOC");let c;if(s===void 0)o="privatePostMarginBorrow",c="type";else{const f=this.market(s);a.symbol=f.id,c="borrowStrategy",o="privatePostIsolatedBorrow"}a[c]=d,i=this.omit(i,["timeInForce","type","borrowStrategy"]);const u=await this[o](this.extend(a,i)),h=this.safeValue(u,"data",{});return this.parseMarginLoan(h,r)}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeString2(i,"sequence","seqStrategy","RECENTLY_EXPIRE_FIRST");let c;if(s===void 0)o="privatePostMarginRepayAll",c="sequence";else{const h=this.market(s);a.symbol=h.id,c="seqStrategy",o="privatePostIsolatedRepayAll"}a[c]=d,i=this.omit(i,["sequence","seqStrategy"]);const u=await this[o](this.extend(a,i));return this.parseMarginLoan(u,r)}parseMarginLoan(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{id:this.safeString(e,"orderId"),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"actualSize"),symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,t,{}),d=this.safeValue(o,s,{}),c=this.safeString(d,e,this.options.version),u=this.safeString(i,"version",c);i=this.omit(i,"version");let h="/api/"+u+"/"+this.implodeParams(e,i);const f=this.omit(i,this.extractParams(e));let l="";n=n!==void 0?n:{};let m=this.urls.api[t];const g=m.indexOf("sandbox")>=0;e==="symbols"&&!g&&(h="/api/v2/"+this.implodeParams(e,i)),Object.keys(f).length&&(s==="GET"||s==="DELETE"?h+="?"+this.rawencode(f):(r=this.json(f),l=r,n["Content-Type"]="application/json")),m=m+h;const y=t==="futuresPrivate";if(t==="private"||y){this.checkRequiredCredentials();const b=this.nonce().toString();if(n=this.extend({"KC-API-KEY-VERSION":"2","KC-API-KEY":this.apiKey,"KC-API-TIMESTAMP":b},n),this.safeString(n,"KC-API-KEY-VERSION")==="2"){const B=this.hmac(this.encode(this.password),this.encode(this.secret),"sha256","base64");n["KC-API-PASSPHRASE"]=B}else n["KC-API-PASSPHRASE"]=this.password;const v=b+s+h+l,T=this.hmac(this.encode(v),this.encode(this.secret),"sha256","base64");n["KC-API-SIGN"]=T;let I=this.safeValue(this.options,"partner",{});I=y?this.safeValue(I,"future",I):this.safeValue(I,"spot",I);const A=this.safeString(I,"id"),N=this.safeString2(I,"secret","key");if(A!==void 0&&N!==void 0){const B=b+A+this.apiKey,x=this.hmac(this.encode(B),this.encode(N),"sha256","base64");n["KC-API-PARTNER-SIGN"]=x,n["KC-API-PARTNER"]=A}}return{url:m,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a){this.throwBroadlyMatchedException(this.exceptions.broad,r,r);return}const c=this.safeString(a,"code"),u=this.safeString(a,"msg",""),h=this.id+" "+u;this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h)}};const{ArgumentsRequired:tp,ExchangeNotAvailable:sp,InvalidOrder:au,InsufficientFunds:ou,AccountSuspended:H5,InvalidNonce:G5,NotSupported:du,OrderNotFound:U5,BadRequest:Ns,AuthenticationError:Rr,RateLimitExceeded:$5,PermissionDenied:W5}=Q,Vs=ae,z5=mg,{TICK_SIZE:j5}=ne;var BT=class extends z5{describe(){return this.deepExtend(super.describe(),{id:"kucoinfutures",name:"KuCoin Futures",countries:["SC"],rateLimit:75,version:"v1",certified:!1,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTransactionFee:!1,fetchWithdrawals:!0,setMarginMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/147508995-9e35030a-d046-43a1-a006-6fabd981b554.jpg",doc:["https://docs.kucoin.com/futures","https://docs.kucoin.com"],www:"https://futures.kucoin.com/",referral:"https://futures.kucoin.com/?rcode=E5wkqe",api:{public:"https://openapi-v2.kucoin.com",private:"https://openapi-v2.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{futuresPublic:{get:{"contracts/active":1,"contracts/{symbol}":1,"contracts/risk-limit/{symbol}":1,ticker:1,"level2/snapshot":1.33,"level2/depth{limit}":1,"level2/message/query":1,"level3/message/query":1,"level3/snapshot":1,"trade/history":1,"interest/query":1,"index/query":1,"mark-price/{symbol}/current":1,"premium/query":1,"funding-rate/{symbol}/current":1,timestamp:1,status:1,"kline/query":1},post:{"bullet-public":1}},futuresPrivate:{get:{"account-overview":1.33,"transaction-history":4.44,"deposit-address":1,"deposit-list":1,"withdrawals/quotas":1,"withdrawal-list":1,"transfer-list":1,orders:1.33,stopOrders:1,recentDoneOrders:1,"orders/{orderId}":1,"orders/byClientOid":1,fills:4.44,recentFills:4.44,openOrderStatistics:1,position:1,positions:4.44,"funding-history":4.44},post:{withdrawals:1,"transfer-out":1,orders:1.33,"position/margin/auto-deposit-status":1,"position/margin/deposit-margin":1,"bullet-private":1},delete:{"withdrawals/{withdrawalId}":1,"cancel/transfer-out":1,"orders/{orderId}":1,orders:4.44,stopOrders:1}}},precisionMode:j5,exceptions:{exact:{400:Ns,401:Rr,403:du,404:du,405:du,415:Ns,429:$5,500:sp,503:sp,100001:au,100004:Ns,101030:W5,200004:ou,230003:ou,260100:ou,300003:ou,300012:au,400001:Rr,400002:G5,400003:Rr,400004:Rr,400005:Rr,400006:Rr,400007:Rr,404e3:du,400100:Ns,411100:H5,5e5:sp},broad:{"Position does not exist":U5}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0006")],[this.parseNumber("50"),this.parseNumber("0.0006")],[this.parseNumber("200"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0004")],[this.parseNumber("2000"),this.parseNumber("0.0004")],[this.parseNumber("4000"),this.parseNumber("0.00038")],[this.parseNumber("8000"),this.parseNumber("0.00035")],[this.parseNumber("15000"),this.parseNumber("0.00032")],[this.parseNumber("25000"),this.parseNumber("0.0003")],[this.parseNumber("40000"),this.parseNumber("0.0003")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.0003")]],maker:[[this.parseNumber("0"),this.parseNumber("0.02")],[this.parseNumber("50"),this.parseNumber("0.015")],[this.parseNumber("200"),this.parseNumber("0.01")],[this.parseNumber("500"),this.parseNumber("0.01")],[this.parseNumber("1000"),this.parseNumber("0.01")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.003")],[this.parseNumber("25000"),this.parseNumber("-0.006")],[this.parseNumber("40000"),this.parseNumber("-0.009")],[this.parseNumber("60000"),this.parseNumber("-0.012")],[this.parseNumber("80000"),this.parseNumber("-0.015")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT",XBT:"BTC"},timeframes:{"1m":1,"3m":void 0,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"6h":void 0,"8h":480,"12h":720,"1d":1440,"1w":10080},options:{version:"v1",symbolSeparator:"-",defaultType:"swap",code:"USDT",marginModes:{},marginTypes:{},versions:{futuresPrivate:{POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"}}})}async fetchAccounts(e={}){throw new Ns(this.id+" fetchAccounts() is not supported yet")}async fetchStatus(e={}){const t=await this.futuresPublicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.futuresPublicGetContractsActive(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"expireDate"),d=!!o,c=!d,u=this.safeString(r,"baseCurrency"),h=this.safeString(r,"quoteCurrency"),f=this.safeString(r,"settleCurrency"),l=this.safeCurrencyCode(u),m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(f);let y=l+"/"+m+":"+g,w="swap";d&&(y=y+"-"+this.yymmdd(o,""),w="future");const b=this.safeValue(r,"isInverse"),S=this.safeString(r,"status"),v=this.safeString(r,"multiplier"),T=this.safeNumber(r,"tickSize"),I=this.safeNumber(r,"lotSize");let A=I;A===void 0&&(A=this.safeNumber(r,"baseMinSize"));let N=this.safeNumber(r,"maxOrderQty");N===void 0&&(N=this.safeNumber(r,"baseMaxSize"));let B=this.safeNumber(r,"maxPrice");if(B===void 0){const x=this.safeString(r,"baseMinSize"),k=this.safeString(r,"quoteMaxSize");B=this.parseNumber(Vs.stringDiv(k,x))}s.push({id:a,symbol:y,base:l,quote:m,settle:g,baseId:u,quoteId:h,settleId:f,type:w,spot:!1,margin:!1,swap:c,future:d,option:!1,active:S==="Open",contract:!0,linear:!b,inverse:b,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.parseNumber(Vs.stringAbs(v)),expiry:o,expiryDatetime:this.iso8601(o),strike:void 0,optionType:void 0,precision:{amount:I,price:T},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(r,"maxLeverage")},amount:{min:A,max:N},price:{min:T,max:B},cost:{min:this.safeNumber(r,"quoteMinSize"),max:this.safeNumber(r,"quoteMaxSize")}},info:r})}return s}async fetchTime(e={}){const t=await this.futuresPublicGetTimestamp(e);return this.safeNumber(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,granularity:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.from=s,i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.from=s),o.to=c;const u=await this.futuresPublicGetKlineQuery(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async createDepositAddress(e,t={}){throw new Ns(this.id+" createDepositAddress() is not supported yet")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e).id,n={currency:i},r=await this.futuresPrivateGetDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"address");return i!=="NIM"&&this.checkAddress(o),{info:r,currency:i,address:o,tag:this.safeString(a,"memo"),network:this.safeString(a,"chain")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeNumber(s,"level");if(i!==2&&i!==void 0)throw new Ns(this.id+" fetchOrderBook() can only return level 2");const n=this.market(e),r={symbol:n.id};if(t!==void 0)if(t===20||t===100)r.limit=t;else throw new Ns(this.id+" fetchOrderBook() limit argument must be 20 or 100");else r.limit=20;const a=await this.futuresPublicGetLevel2DepthLimit(this.extend(r,s)),o=this.safeValue(a,"data",{}),d=parseInt(this.safeInteger(o,"ts")/1e6),c=this.parseOrderBook(o,n.symbol,d,"bids","asks",0,1);return c.nonce=this.safeInteger(o,"sequence"),c}async fetchL3OrderBook(e,t=void 0,s={}){throw new Ns(this.id+" fetchL3OrderBook() is not supported yet")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetTicker(this.extend(i,t));return this.parseTicker(n.data,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=this.safeIntegerProduct(e,"ts",1e-6);return this.safeTicker({symbol:t.symbol,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tp(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const r={symbol:this.market(e).id};t!==void 0&&(r.startAt=t),s!==void 0&&(r.maxCount=s);const a=await this.futuresPrivateGetFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"dataList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.safeInteger(h,"timePoint");c.push({info:h,symbol:e,code:this.safeCurrencyCode(this.safeString(h,"settleCurrency")),timestamp:f,datetime:this.iso8601(f),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding"),fundingRate:this.safeNumber(h,"fundingRate"),markPrice:this.safeNumber(h,"markPrice"),positionQty:this.safeNumber(h,"positionQty"),positionCost:this.safeNumber(h,"positionCost")})}return c}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.futuresPrivateGetPositions(t),i=this.safeValue(s,"data");return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeNumber(e,"currentTimestamp"),n=this.safeString(e,"currentQty");let r;Vs.stringGt(n,"0")?r="long":Vs.stringLt(n,"0")&&(r="short");const a=Vs.stringAbs(this.safeString(e,"posCost")),o=this.safeString(e,"posInit"),d=Vs.stringDiv(o,a),c=this.safeString(e,"unrealisedPnl"),h=this.safeValue(e,"crossMode")?"cross":"isolated";return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(d),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber(e,"avgEntryPrice"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"realLeverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(Vs.stringAbs(n)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),collateral:this.safeNumber(e,"maintMargin"),marginMode:h,side:r,percentage:this.parseNumber(Vs.stringDiv(c,o))}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());if(r=this.omit(r,["clientOid","clientOrderId"]),i<1)throw new au(this.id+" createOrder() minimum contract order amount is 1");const d=parseInt(this.amountToPrecision(e,i)),c={clientOid:o,side:s,symbol:a.id,type:t,size:d,leverage:1},u=this.safeValue2(r,"triggerPrice","stopPrice"),h=this.safeValue(r,"stopLossPrice"),f=this.safeValue(r,"takeProfitPrice"),l=h!==void 0,m=f!==void 0,g=this.safeString(r,"stop"),y=this.safeString(r,"stopPriceType","MP");u?(g===void 0&&(c.stop=s==="buy"?"down":"up"),c.stopPrice=this.priceToPrecision(e,u),c.stopPriceType=y):(l||m)&&(l?(g===void 0&&(c.stop=s==="buy"?"up":"down"),c.stopPrice=this.priceToPrecision(e,h)):(g===void 0&&(c.stop=s==="buy"?"down":"up"),c.stopPrice=this.priceToPrecision(e,f)),c.reduceOnly=!0,c.stopPriceType=y);const w=t.toUpperCase(),b=this.safeStringUpper(r,"timeInForce");if(w==="LIMIT"){if(n===void 0)throw new tp(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,n),b!==void 0&&(c.timeInForce=b)}const S=this.safeValue(r,"postOnly",!1),v=this.safeValue(r,"hidden");if(S&&v!==void 0)throw new Ns(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(r,"iceberg")&&this.safeValue(r,"visibleSize")===void 0)throw new tp(this.id+" createOrder() requires a visibleSize parameter for iceberg orders");r=this.omit(r,["timeInForce","stop","stopPrice","stopPriceType","triggerPrice","stopLossPrice","takeProfitPrice"]);const I=await this.futuresPrivatePostOrders(this.extend(c,r)),A=this.safeValue(I,"data",{});return{id:this.safeString(A,"orderId"),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,triggerPrice:void 0,info:I}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.futuresPrivateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"data")}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.symbol=this.marketId(e));const n=this.safeValue(t,"stop")?"futuresPrivateDeleteStopOrders":"futuresPrivateDeleteOrders",r=await this[n](this.extend(s,t));return this.safeValue(r,"data")}async addMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n=this.uuid(),r={symbol:i.id,margin:this.amountToPrecision(e,t),bizNo:n},a=await this.futuresPrivatePostPositionMarginDepositMargin(this.extend(r,s)),o=this.safeValue(a,"data");return this.extend(this.parseMarginModification(o,i),{amount:this.amountToPrecision(e,t),direction:"in"})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"id");t=this.safeMarket(s,t);const i=this.safeString(e,"settleCurrency"),r=this.safeValue(e,"crossMode")?"cross":"isolated",a=this.safeString(t,"symbol");return{info:e,direction:void 0,mode:r,amount:void 0,code:this.safeCurrencyCode(i),symbol:this.safeSymbol(a,t),status:void 0}}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.safeValue(n,"stop"),a=this.safeInteger2(n,"until","till");n=this.omit(n,["stop","until","till"]),e==="closed"?e="done":e==="open"&&(e="active");const o={};if(!r)o.status=e;else if(e!=="active")throw new Ns(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders");let d;t!==void 0&&(d=this.market(t),o.symbol=d.id),s!==void 0&&(o.startAt=s),a!==void 0&&(o.endAt=a);const u=await this[r?"futuresPrivateGetStopOrders":"futuresPrivateGetOrders"](this.extend(o,n)),h=this.safeValue(u,"data",{}),f=this.safeValue(h,"items",[]);return this.parseOrders(f,d,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};let n="futuresPrivateGetOrdersOrderId";if(e===void 0){const d=this.safeString2(s,"clientOid","clientOrderId");if(d===void 0)throw new au(this.id+" fetchOrder() requires parameter id or params.clientOid");i.clientOid=d,n="futuresPrivateGetOrdersByClientOid",s=this.omit(s,["clientOid","clientOrderId"])}else i.orderId=e;const r=await this[n](this.extend(i,s)),a=t!==void 0?this.market(t):void 0,o=this.safeValue(r,"data");return this.parseOrder(o,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),f=this.safeNumber(e,"fee"),l=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString2(e,"dealFunds","filledValue"),y=this.safeString(e,"leverage"),w=Vs.stringDiv(g,y);let b;if(Vs.stringGt(m,"0")){const k=this.safeString(t,"contractSize");t.linear?b=Vs.stringDiv(g,Vs.stringMul(k,m)):b=Vs.stringDiv(Vs.stringMul(k,m),g)}const S=this.safeValue(e,"isActive",!1),v=this.safeValue(e,"cancelExist",!1);let T=S?"open":"closed";T=v?"canceled":T;const I={currency:h,cost:f},A=this.safeString(e,"clientOid"),N=this.safeString(e,"timeInForce"),B=this.safeNumber(e,"stopPrice"),x=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:A,symbol:i,type:r,timeInForce:N,postOnly:x,side:c,amount:l,price:d,stopPrice:B,triggerPrice:B,cost:w,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:I,status:T,info:e,lastTradeTimestamp:void 0,average:b,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetFundingRateSymbolCurrent(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeNumber(r,"timePoint");return{info:r,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(r,"predictedValue"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(r,"value"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();return r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"accountEquity"),t[n]=r,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(this.options,"code");const s=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(s,"code",t);const i=this.safeString(e,"code",t),r={currency:this.currency(i).id},a=await this.futuresPrivateGetAccountOverview(this.extend(r,e));return this.parseBalance(a)}async transfer(e,t,s,i,n={}){if(i!=="main"&&i!=="funding"||s!=="futures"&&s!=="future"&&s!=="contract")throw new Ns(this.id+" transfer() only supports transfers from contract(future) account to main(funding) account");await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:this.safeString(r,"id"),amount:a},d=await this.futuresPrivatePostTransferOut(this.extend(o,n)),c=this.safeValue(d,"data");return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:"future",toAccount:"spot"})}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"updatedAt");return{id:this.safeString(e,"applyId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.safeString(e,"status"),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.startAt=t);const a=await this.futuresPrivateGetFills(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"items",{});return this.parseTrades(d,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.futuresPublicGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"ts");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let f=this.safeString2(e,"type","orderType");f==="match"&&(f=void 0);let l=this.safeString2(e,"funds","value");if(l===void 0){const m=this.safeString(t,"contractSize"),g=Vs.stringMul(o,d);l=Vs.stringMul(g,m)}return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:f,takerOrMaker:r,side:c,price:o,amount:d,cost:l,fee:u},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetDepositList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetWithdrawalList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async fetchTransactionFee(e,t={}){throw new Ns(this.id+" fetchTransactionFee() is not supported")}async fetchDepositWithdrawFee(e,t={}){throw new Ns(this.id+" fetchDepositWithdrawFee() is not supported")}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){throw new Ns(this.id+" fetchLedger() is not supported yet")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Ns(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i={symbol:s.id},n=await this.futuresPublicGetContractsRiskLimitSymbol(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseMarketLeverageTiers(r,s)}parseMarketLeverageTiers(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeNumber(n,"level"),currency:t.base,minNotional:this.safeNumber(n,"minRiskLimit"),maxNotional:this.safeNumber(n,"maxRiskLimit"),maintenanceMarginRate:this.safeNumber(n,"maintainMargin"),maxLeverage:this.safeNumber(n,"maxLeverage"),info:n})}return s}};const K5=re,{ArgumentsRequired:jb,InsufficientFunds:X5,OrderNotFound:Kb,NotSupported:Y5}=Q,{TICK_SIZE:Z5}=ne;var Q5=class extends K5{describe(){return this.deepExtend(super.describe(),{id:"kuna",name:"Kuna",countries:["UA"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setPositionMode:!1,withdraw:void 0},timeframes:void 0,urls:{extension:".json",referral:"https://kuna.io?r=kunaid-gvfihe8az7o4",logo:"https://user-images.githubusercontent.com/51840849/87153927-f0578b80-c2c0-11ea-84b6-74612568e9e1.jpg",api:{xreserve:"https://api.xreserve.fund",v3:"https://api.kuna.io",public:"https://kuna.io",private:"https://kuna.io"},www:"https://kuna.io",doc:"https://kuna.io/documents/api",fees:"https://kuna.io/documents/api"},api:{xreserve:{get:{nonce:1,fee:1,"delegated-transactions":1},post:{"delegate-transfer":1}},v3:{public:{get:{timestamp:1,currencies:1,markets:1,tickers:1,k:1,trades_history:1,fees:1,"exchange-rates":1,"exchange-rates/currency":1,"book/market":1,"kuna_codes/code/check":1,landing_page_statistic:1,"translations/locale":1,"trades/market/hist":1},post:{http_test:1,deposit_channels:1,withdraw_channels:1,subscription_plans:1,send_to:1,confirm_token:1,kunaid:1,"withdraw/prerequest":1,"deposit/prerequest":1,"deposit/exchange-rates":1}},sign:{get:{"reset_password/token":1},post:{"signup/google":1,"signup/resend_confirmation":1,signup:1,signin:1,"signin/two_factor":1,"signin/resend_confirm_device":1,"signin/confirm_device":1,reset_password:1,"cool-signin":1},put:{"reset_password/token":1,"signup/code/confirm":1}},private:{post:{"auth/w/order/submit":1,"auth/r/orders":1,"auth/r/orders/market":1,"auth/r/orders/markets":1,"auth/api_tokens/delete":1,"auth/api_tokens/create":1,"auth/api_tokens":1,"auth/signin_history/uniq":1,"auth/signin_history":1,"auth/disable_withdraw_confirmation":1,"auth/change_password":1,"auth/deposit_address":1,"auth/announcements/accept":1,"auth/announcements/unaccepted":1,"auth/otp/deactivate":1,"auth/otp/activate":1,"auth/otp/secret":1,"auth/r/order/market/:order_id/trades":1,"auth/r/orders/market/hist":1,"auth/r/orders/hist":1,"auth/r/orders/hist/markets":1,"auth/r/orders/details":1,"auth/assets-history":1,"auth/assets-history/withdraws":1,"auth/assets-history/deposits":1,"auth/r/wallets":1,"auth/markets/favorites":1,"auth/markets/favorites/list":1,"auth/me/update":1,"auth/me":1,"auth/fund_sources":1,"auth/fund_sources/list":1,"auth/withdraw/resend_confirmation":1,"auth/withdraw":1,"auth/withdraw/details":1,"auth/withdraw/info":1,"auth/payment_addresses":1,"auth/deposit/prerequest":1,"auth/deposit/exchange-rates":1,"auth/deposit":1,"auth/deposit/details":1,"auth/deposit/info":1,"auth/kuna_codes/count":1,"auth/kuna_codes/details":1,"auth/kuna_codes/edit":1,"auth/kuna_codes/send-pdf":1,"auth/kuna_codes":1,"auth/kuna_codes/redeemed-by-me":1,"auth/kuna_codes/issued-by-me":1,"auth/payment_requests/invoice":1,"auth/payment_requests/type":1,"auth/referral_program/weekly_earnings":1,"auth/referral_program/stats":1,"auth/merchant/payout_services":1,"auth/merchant/withdraw":1,"auth/merchant/payment_services":1,"auth/merchant/deposit":1,"auth/verification/auth_token":1,"auth/kunaid_purchase/create":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/subscriptions/reactivate":1,"auth/subscriptions/cancel":1,"auth/subscriptions/prolong":1,"auth/subscriptions/create":1,"auth/subscriptions/list":1,"auth/kuna_ids/list":1,"order/cancel/multi":1,"order/cancel":1},put:{"auth/fund_sources/id":1,"auth/kuna_codes/redeem":1},delete:{"auth/markets/favorites":1,"auth/fund_sources":1,"auth/devices":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/sessions":1}}},public:{get:["depth","k_with_pending_trades","k","markets","order_book","order_book/{market}","tickers","tickers/{market}","timestamp","trades","trades/{market}"]},private:{get:["members/me","deposits","deposit","deposit_address","orders","order","trades/my","withdraws","withdraw"],post:["orders","orders/multi","orders/clear","order/delete","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")},funding:{withdraw:{UAH:"1%",BTC:.001,BCH:.001,ETH:.01,WAVES:.01,GOL:0,GBG:0},deposit:{}}},commonCurrencies:{PLA:"Plair"},precisionMode:Z5,exceptions:{2002:X5,2003:Kb}})}async fetchTime(e={}){return await this.publicGetTimestamp(e)*1e3}async fetchMarkets(e={}){const t=["btc","rub","uah","usd","usdt","usdc"],s=[],i=await this.publicGetTickers(e),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r];for(let o=0;o<t.length;o++){const d=t[o],c=a.slice(1),u=c.indexOf(d),h=c.slice(u);if(u>0&&h===d){const f=a[0]+c.replace(d,""),l=this.safeCurrencyCode(f),m=this.safeCurrencyCode(d);s.push({id:a,symbol:l+"/"+m,base:l,quote:m,settle:void 0,baseId:f,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0})}}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"at");e=e.ticker;const i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=o.symbol;n[d]=this.parseTicker(s[a],o)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickersMarket(this.extend(i,t));return this.parseTicker(n,s)}async fetchL3OrderBook(e,t=void 0,s={}){return await this.fetchOrderBook(e,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at"));let i;t&&(i=t.symbol);let n=this.safeString2(e,"side","trend");if(n!==void 0){const u={ask:"sell",bid:"buy"};n=this.safeString(u,n,n)}const r=this.safeString(e,"price"),a=this.safeString(e,"volume"),o=this.safeNumber(e,"funds"),d=this.safeString(e,"order_id"),c=this.safeString(e,"id");return this.safeTrade({id:c,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,side:n,order:d,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++){const c=a[d];o.push([c[0],c[1],c[2],c[3],c[4],c[5]])}return o}parseBalance(e){const t=this.safeValue(e,"accounts",[]),s={info:t};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"balance"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,volume:i.toString(),ord_type:t};t==="limit"&&(o.price=n.toString());const d=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderDelete(this.extend(i,s)),r=this.parseOrder(n),a=r.status;if(a==="closed"||a==="canceled")throw new Kb(this.id+" "+this.json(r));return r}parseOrderStatus(e){const t={done:"closed",wait:"open",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"created_at")),r=this.parseOrderStatus(this.safeString(e,"state")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:r,symbol:i,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeString(e,"volume"),filled:this.safeString(e,"executed_volume"),remaining:this.safeString(e,"remaining_volume"),trades:void 0,fee:void 0,info:e,cost:void 0,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new jb(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new jb(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetTradesMy(this.extend(r,i));return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}encodeParams(e){if("orders"in e){const t=e.orders;let s=this.urlencode(this.keysort(this.omit(e,"orders")));for(let i=0;i<t.length;i++){const n=t[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o];s+="&orders%5B%5D%5B"+o+"%5D="+d.toString()}}return s}return this.urlencode(this.keysort(e))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a;if(Array.isArray(t)){const[o,d]=t;if(a=this.urls.api[o]+"/"+o+"/"+this.implodeParams(e,i),d==="public")s==="GET"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):(s==="POST"||s==="PUT")&&(n={"Content-Type":"application/json"},r=this.json(i));else if(d==="private")throw new Y5(this.id+" private v3 API is not supported yet")}else{let o="/api/"+this.version+"/"+this.implodeParams(e,i);"extension"in this.urls&&(o+=this.urls.extension);const d=this.omit(i,this.extractParams(e));if(a=this.urls.api[t]+o,t==="public")Object.keys(d).length&&(a+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.encodeParams(this.extend({access_key:this.apiKey,tonce:c},i)),h=s+"|"+o+"|"+u,f=this.hmac(this.encode(h),this.encode(this.secret)),l=u+"&signature="+f;s==="GET"?a+="?"+l:(r=l,n={"Content-Type":"application/x-www-form-urlencoded"})}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e===400){const c=this.safeValue(a,"error"),u=this.safeString(c,"code"),h=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions,u,h)}}};const J5=re,{ExchangeError:cu,AuthenticationError:Dr,ArgumentsRequired:eD,InvalidNonce:tD,BadRequest:Ba,ExchangeNotAvailable:sD,PermissionDenied:Xb,AccountSuspended:ip,RateLimitExceeded:iD,InsufficientFunds:nD,BadSymbol:np,InvalidOrder:Yb}=Q,{TICK_SIZE:rD}=ne;var aD=class extends J5{describe(){return this.deepExtend(super.describe(),{id:"latoken",name:"Latoken",countries:["KY"],version:"v2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!0,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",api:{rest:"https://api.latoken.com"},www:"https://latoken.com",doc:["https://api.latoken.com"],fees:"https://latoken.com/fees",referral:"https://latoken.com/invite?r=mvgp2djk"},api:{public:{get:{"book/{currency}/{quote}":1,"chart/week":1,"chart/week/{currency}/{quote}":1,currency:1,"currency/available":1,"currency/quotes":1,"currency/{currency}":1,pair:1,"pair/available":1,ticker:1,"ticker/{base}/{quote}":1,time:1,"trade/history/{currency}/{quote}":1,"trade/fee/{currency}/{quote}":1,"trade/feeLevels":1,"transaction/bindings":1}},private:{get:{"auth/account":1,"auth/account/currency/{currency}/{type}":1,"auth/order":1,"auth/order/getOrder/{id}":1,"auth/order/pair/{currency}/{quote}":1,"auth/order/pair/{currency}/{quote}/active":1,"auth/stopOrder":1,"auth/stopOrder/getOrder/{id}":1,"auth/stopOrder/pair/{currency}/{quote}":1,"auth/stopOrder/pair/{currency}/{quote}/active":1,"auth/trade":1,"auth/trade/pair/{currency}/{quote}":1,"auth/trade/fee/{currency}/{quote}":1,"auth/transaction":1,"auth/transaction/bindings":1,"auth/transaction/bindings/{currency}":1,"auth/transaction/{id}":1,"auth/transfer":1},post:{"auth/order/cancel":1,"auth/order/cancelAll":1,"auth/order/cancelAll/{currency}/{quote}":1,"auth/order/place":1,"auth/spot/deposit":1,"auth/spot/withdraw":1,"auth/stopOrder/cancel":1,"auth/stopOrder/cancelAll":1,"auth/stopOrder/cancelAll/{currency}/{quote}":1,"auth/stopOrder/place":1,"auth/transaction/depositAddress":1,"auth/transaction/withdraw":1,"auth/transaction/withdraw/cancel":1,"auth/transaction/withdraw/confirm":1,"auth/transaction/withdraw/resendCode":1,"auth/transfer/email":1,"auth/transfer/id":1,"auth/transfer/phone":1}}},precisionMode:rD,fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.0049"),taker:this.parseNumber("0.0049")}},commonCurrencies:{BUX:"Buxcoin",CBT:"Community Business Token",CTC:"CyberTronchain",DMD:"Diamond Coin",FREN:"Frenchie",GDX:"GoldenX",GEC:"Geco One",GEM:"NFTmall",GMT:"GMT Token",IMC:"IMCoin",MT:"Monarch",TPAY:"Tetra Pay",TRADE:"Smart Trade Coin",TSL:"Treasure SL",UNO:"Unobtanium",WAR:"Warrior Token"},exceptions:{exact:{INTERNAL_ERROR:cu,SERVICE_UNAVAILABLE:sD,NOT_AUTHORIZED:Dr,FORBIDDEN:Xb,BAD_REQUEST:Ba,NOT_FOUND:cu,ACCESS_DENIED:Xb,REQUEST_REJECTED:cu,HTTP_MEDIA_TYPE_NOT_SUPPORTED:Ba,MEDIA_TYPE_NOT_ACCEPTABLE:Ba,METHOD_ARGUMENT_NOT_VALID:Ba,VALIDATION_ERROR:Ba,ACCOUNT_EXPIRED:ip,BAD_CREDENTIALS:Dr,COOKIE_THEFT:Dr,CREDENTIALS_EXPIRED:ip,INSUFFICIENT_AUTHENTICATION:Dr,UNKNOWN_LOCATION:Dr,TOO_MANY_REQUESTS:iD,INSUFFICIENT_FUNDS:nD,ORDER_VALIDATION:Yb,BAD_TICKS:Yb},broad:{"invalid API key, signature or digest":Dr,"The API key was revoked":Dr,"request expired or bad":tD,"For input string":Ba,"Unable to resolve currency by tag":np,"Can't find currency with tag":np,"Unable to place order because pair is in inactive state":np,"API keys are not available for FROZEN user":ip}},options:{defaultType:"spot",types:{wallet:"ACCOUNT_TYPE_WALLET",spot:"ACCOUNT_TYPE_SPOT"},accounts:{ACCOUNT_TYPE_WALLET:"wallet",ACCOUNT_TYPE_SPOT:"spot"},fetchTradingFee:{method:"fetchPrivateTradingFee"}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=await this.publicGetPair(e);this.safeValue(this.options,"adjustForTimeDifference",!0)&&await this.loadTimeDifference();const i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeString(a,"baseCurrency"),c=this.safeString(a,"quoteCurrency"),u=this.safeValue(i,d),h=this.safeValue(i,c);if(u!==void 0&&h!==void 0){const f=this.safeCurrencyCode(this.safeString(u,"tag")),l=this.safeCurrencyCode(this.safeString(h,"tag")),m=l.toLowerCase(),g=this.capitalize(m),y=this.safeString(a,"status");n.push({id:o,symbol:f+"/"+l,base:f,quote:l,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y==="PAIR_STATUS_ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantityTick"),price:this.safeNumber(a,"priceTick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderCost"+g),max:this.safeNumber(a,"maxOrderCost"+g)}},info:a})}}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrency(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"tag"),o=this.safeCurrencyCode(a),d=this.safeNumber(n,"fee"),u=this.safeString(n,"type").split("_"),h=u.length,l=this.safeValue(u,h-1).toLowerCase(),g=this.safeString(n,"status")==="CURRENCY_STATUS_ACTIVE",y=this.safeString(n,"name");s[o]={id:r,code:o,info:n,name:y,type:l,active:g,deposit:void 0,withdraw:void 0,fee:d,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"decimals"))),limits:{amount:{min:this.safeNumber(n,"minTransferAmount"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAuthAccount(e),s={info:t,timestamp:void 0,datetime:void 0};let i;const n=this.safeString2(this.options,"fetchBalance","defaultType","spot"),r=this.safeString(e,"type",n),a=this.safeValue(this.options,"types",{}),o=this.safeString(a,r,r),d=this.groupBy(t,"type"),c=this.safeValue(d,o,[]);for(let u=0;u<c.length;u++){const h=c[u],f=this.safeString(h,"currency"),l=this.safeInteger(h,"timestamp");l!==void 0&&(i===void 0?i=l:i=Math.max(i,l));const m=this.safeCurrencyCode(f),g=this.account();g.free=this.safeString(h,"available"),g.used=this.safeString(h,"blocked"),s[m]=g}return s.timestamp=i,s.datetime=this.iso8601(i),this.safeBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.baseId,quote:i.quoteId};t!==void 0&&(n.limit=t);const r=await this.publicGetBookCurrencyQuote(this.extend(n,s));return this.parseOrderBook(r,e,void 0,"bid","ask","price","quantity")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString(e,"lastPrice"),r=this.safeString(e,"change24h"),a=this.nonce();return this.safeTicker({symbol:i,timestamp:a,datetime:this.iso8601(a),low:this.safeString(e,"low"),high:this.safeString(e,"high"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:r,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={base:s.baseId,quote:s.quoteId},n=await this.publicGetTickerBaseQuote(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeString(e,"cost"),o=this.safeValue(e,"makerBuyer");let d=this.safeString(e,"direction");d===void 0?d=o?"sell":"buy":d==="TRADE_DIRECTION_BUY"?d="buy":d==="TRADE_DIRECTION_SELL"&&(d="sell");const u=o&&d==="buy"?"maker":"taker",h=this.safeString(e,"baseCurrency"),f=this.safeString(e,"quoteCurrency"),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f),g=l+"/"+m;g in this.markets&&(t=this.market(g));const y=this.safeString(e,"id"),w=this.safeString(e,"order"),b=this.safeString(e,"fee");let S;return b!==void 0&&(S={cost:b,currency:m}),this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:g,id:y,order:w,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:S},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId};s!==void 0&&(r.limit=s);const a=await this.publicGetTradeHistoryCurrencyQuote(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchTradingFee",{});s=this.safeString(i,"method","fetchPrivateTradingFee")}return await this[s](e,t)}async fetchPublicTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.publicGetTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchPrivateTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.privateGetAuthTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthTrade",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthTradePairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseTrades(o,a,t,s)}parseOrderStatus(e){const t={ORDER_STATUS_PLACED:"open",ORDER_STATUS_CLOSED:"closed",ORDER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={ORDER_TYPE_MARKET:"market",ORDER_TYPE_LIMIT:"limit"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={ORDER_CONDITION_GOOD_TILL_CANCELLED:"GTC",ORDER_CONDITION_IMMEDIATE_OR_CANCEL:"IOC",ORDER_CONDITION_FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"baseCurrency"),r=this.safeString(e,"quoteCurrency"),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r);let d;a!==void 0&&o!==void 0&&(d=a+"/"+o,d in this.markets&&(t=this.market(d)));const c=this.safeString(e,"side");let u;if(c!==void 0){const v=c.split("_"),T=v.length;u=this.safeStringLower(v,T-1)}const h=this.parseOrderType(this.safeString(e,"type")),f=this.safeString(e,"price"),l=this.safeString(e,"quantity"),m=this.safeString(e,"filled"),g=this.safeString(e,"cost");let y=this.parseOrderStatus(this.safeString(e,"status"));const w=this.safeString(e,"message");w!==void 0&&(w.indexOf("cancel")>=0?y="canceled":w.indexOf("accept")>=0&&(y="open"));const b=this.safeString(e,"clientOrderId"),S=this.parseTimeInForce(this.safeString(e,"condition"));return this.safeOrder({id:s,clientOrderId:b,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:y,symbol:d,type:h,timeInForce:S,postOnly:void 0,side:u,price:f,stopPrice:void 0,triggerPrice:void 0,cost:g,amount:l,filled:m,average:void 0,remaining:void 0,fee:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new eD(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId},a=await this.privateGetAuthOrderPairCurrencyQuoteActive(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthOrder",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthOrderPairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseOrders(o,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAuthOrderGetOrderId(this.extend(i,s));return this.parseOrder(n)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={baseCurrency:a.baseId,quoteCurrency:a.quoteId,side:s.toUpperCase(),condition:"GTC",type:o,clientOrderId:this.uuid()};o==="LIMIT"&&(d.price=this.priceToPrecision(e,n)),d.quantity=this.amountToPrecision(e,i),d.timestamp=this.seconds();const c=await this.privatePostAuthOrderPlace(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostAuthOrderCancel(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="privatePostAuthOrderCancelAll",n;return e!==void 0&&(n=this.market(e),s.currency=n.baseId,s.quote=n.quoteId,i="privatePostAuthOrderCancelAllCurrencyQuote"),await this[i](this.extend(s,t))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.privateGetAuthTransaction(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.safeValue(r,"content",[]);return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"senderAddress"),c=this.safeString(e,"recipientAddress"),u=this.safeString(e,"transactionHash"),h=this.safeString(e,"memo");let f;const l=this.safeNumber(e,"transactionFee");l!==void 0&&(f={cost:l,currency:r});const m=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:d,addressTo:c,address:c,tagFrom:void 0,tagTo:h,tag:h,type:m,amount:o,currency:r,status:a,updated:void 0,fee:f}}parseTransactionStatus(e){const t={TRANSACTION_STATUS_CONFIRMED:"ok",TRANSACTION_STATUS_EXECUTED:"ok",TRANSACTION_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}parseTransactionType(e){const t={TRANSACTION_TYPE_DEPOSIT:"deposit",TRANSACTION_TYPE_WITHDRAWAL:"withdrawal"};return this.safeString(t,e,e)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r=await this.privateGetAuthTransfer(i),a=this.safeValue(r,"content",[]);return this.parseTransfers(a,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;i.indexOf("@")>=0?a="privatePostAuthTransferEmail":i.length===36?a="privatePostAuthTransferId":a="privatePostAuthTransferPhone";const o={currency:r.id,recipient:i,value:this.currencyToPrecision(e,t)},d=await this[a](this.extend(o,n));return this.parseTransfer(d)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{info:e,id:this.safeString(e,"id"),timestamp:this.safeInteger(e,"timestamp"),datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"transferringFunds"),fromAccount:this.safeString(e,"fromAccount"),toAccount:this.safeString(e,"toAccount"),status:this.parseTransferStatus(n)}}parseTransferStatus(e){const t={TRANSFER_STATUS_COMPLETED:"ok",TRANSFER_STATUS_PENDING:"pending",TRANSFER_STATUS_REJECTED:"failed",TRANSFER_STATUS_UNVERIFIED:"pending",TRANSFER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i=void 0,n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=a;const d=this.omit(i,this.extractParams(e)),c=this.urlencode(d);if(s==="GET"&&Object.keys(d).length&&(o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=s+a+c,f=this.hmac(this.encode(h),this.encode(this.secret),"sha512");n={"X-LA-APIKEY":this.apiKey,"X-LA-SIGNATURE":f,"X-LA-DIGEST":"HMAC-SHA512"},s==="POST"&&(n["Content-Type"]="application/json",r=this.json(d))}return{url:this.urls.api.rest+o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"message"),u=this.id+" "+r;c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u));const h=this.safeValue(a,"error"),f=this.safeString(h,"message");if(h!==void 0||f!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new cu(u)}};const oD=re,{ExchangeError:dD,DDoSProtection:cD,AuthenticationError:gd,InvalidOrder:Qn}=Q,{TICK_SIZE:uD}=ne,hD=ae;var fD=class extends oD{describe(){return this.deepExtend(super.describe(),{id:"lbank",name:"LBank",countries:["CN"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},www:"https://www.lbank.info",doc:"https://github.com/LBank-exchange/lbank-official-api-docs",fees:"https://www.lbank.info/fees.html",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:["currencyPairs","ticker","depth","trades","kline","accuracy"]},private:{post:["user_info","create_order","cancel_order","orders_info","orders_info_history","withdraw","withdrawCancel","withdraws","withdrawConfigs"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{GMT:"GMT Token",PNT:"Penta",SHINJA:"SHINJA(1M)",VET_ERC20:"VEN"},options:{cacheSecretAsPem:!0},precisionMode:uD})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=n.symbol,a=r.split("_");let o,d;a.length>2?(o=a[0]+"_"+a[1],d=a[2]):(o=a[0],d=a[1]);const u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d);s.push({id:r,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeFloat(n,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=e;e=r.ticker;const a=this.safeString(e,"latest"),o=this.safeString(e,"change");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"turnover"),info:r},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={symbol:"all"},i=await this.publicGetTicker(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=60,s={}){await this.loadMarkets();let i=60;t!==void 0&&(i=Math.min(t,i));const n=this.market(e),r={symbol:n.id,size:i},a=await this.publicGetDepth(this.extend(r,s));return this.parseOrderBook(a,n.symbol)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"date_ms"),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.parseNumber(i),a=this.parseNumber(n),o=this.parseNumber(hD.stringMul(i,n)),d=this.safeString(e,"tid"),c=void 0;let u=this.safeString(e,"type");return u=u.split("_")[0],{id:d,info:this.safeValue(e,"info",e),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:c,side:u,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,size:100};t!==void 0&&(r.time=parseInt(t)),s!==void 0&&(r.size=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*1e3*i}const a={symbol:r.id,type:this.timeframes[t],size:i,time:parseInt(s/1e3)},o=await this.publicGetKline(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=this.safeValue(s,"free",{}),n=this.safeValue(s,"freeze",{}),r=this.safeValue(s,"asset",{}),a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(i,d),u.used=this.safeString(n,d),u.total=this.safeString(r,d),t[c]=u}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}parseOrderStatus(e){const t={"-1":"cancelled",0:"open",1:"open",2:"closed",4:"closed"};return this.safeString(t,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"_"),n=this.safeInteger(e,"create_time"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"deal_amount"),d=this.safeString(e,"avg_price"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"order_id"),h=this.safeString(e,"order_type"),f=this.safeString(e,"type");return this.safeOrder({id:u,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:c,symbol:i,type:h,timeInForce:void 0,postOnly:void 0,side:f,price:r,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:this.safeValue(e,"info",e),average:d},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={symbol:a.id,type:s,amount:i};t==="market"?o.type+="_market":o.price=n;const d=await this.privatePostCreateOrder(this.extend(o,r));return o=this.omit(o,"type"),o.order_id=d.order_id,o.type=s,o.order_type=t,o.create_time=this.milliseconds(),o.info=d,this.parseOrder(o,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(t).id,order_id:e};return await this.privatePostCancelOrder(this.extend(n,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:i.id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,i);return o.length===1?o[0]:o}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=100);const r={symbol:this.market(e).id,current_page:1,page_length:s},a=await this.privatePostOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,void 0,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.fetchOrders(e,t,s,i),r=this.filterBy(n,"status","closed"),a=this.filterBy(n,"status","cancelled"),o=this.arrayConcat(r,a);return this.filterBySymbolSinceLimit(o,e,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={assetCode:r.id,amount:t,account:s};i!==void 0&&(a.memo=i);const o=this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString2(e,"id","withdrawId"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.keysort(this.extend({api_key:this.apiKey},i)),c=this.rawencode(d),u=this.hash(this.encode(c)).toUpperCase(),h=this.safeValue(this.options,"cacheSecretAsPem",!0);let f;h?(f=this.safeValue(this.options,"pem"),f===void 0&&(f=this.convertSecretToPem(this.secret),this.options.pem=f)):f=this.convertSecretToPem(this.secret);const l=this.binaryToBase64(this.rsa(u,this.encode(f),"RS256"));d.sign=l,r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"verification failed",10003:"Illegal parameters",10004:"User requests are too frequent",10005:"Key does not exist",10006:"user does not exist",10007:"Invalid signature",10008:"This currency pair is not supported",10009:"Limit orders can not be missing orders and the number of orders",10010:"Order price or order quantity must be greater than 0",10011:"Market orders can not be missing the amount of the order",10012:"market sell orders can not be missing orders",10013:"is less than the minimum trading position 0.001",10014:"Account number is not enough",10015:"The order type is wrong",10016:"Account balance is not enough",10017:"Abnormal server",10018:"order inquiry can not be more than 50 less than one",10019:"withdrawal orders can not be more than 3 less than one",10020:"less than the minimum amount of the transaction limit of 0.001",10022:"Insufficient key authority"},u,this.json(a)),f=this.safeValue({10002:gd,10004:cD,10005:gd,10006:gd,10007:gd,10009:Qn,10010:Qn,10011:Qn,10012:Qn,10013:Qn,10014:Qn,10015:Qn,10016:Qn,10022:gd},u,dD);throw new f(h)}}};const lD=re,{ExchangeError:Pn,InvalidAddress:pD,DuplicateOrderId:mD,ArgumentsRequired:Jn,InsufficientFunds:rp,InvalidOrder:Wi,InvalidNonce:gD,AuthenticationError:uu,RateLimitExceeded:yD,PermissionDenied:hu,BadRequest:zs,BadSymbol:Zb}=Q,{TICK_SIZE:wD}=ne,bD=ae;var kD=class extends lD{describe(){return this.deepExtend(super.describe(),{id:"lbank2",name:"LBank",countries:["CN"],version:"v2",rateLimit:20,has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFees:!0,fetchTransactionFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!1},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},api2:"https://api.lbkex.com",www:"https://www.lbank.info",doc:"https://www.lbank.info/en-US/docs/index.html",fees:"https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:{currencyPairs:2.5,accuracy:2.5,usdToCny:2.5,withdrawConfigs:2.5,timestamp:2.5,"ticker/24hr":2.5,ticker:2.5,depth:2.5,incrDepth:2.5,trades:2.5,kline:2.5,"supplement/system_ping":2.5,"supplement/incrDepth":2.5,"supplement/trades":2.5,"supplement/ticker/price":2.5,"supplement/ticker/bookTicker":2.5},post:{"supplement/system_status":2.5}},private:{post:{user_info:2.5,"subscribe/get_key":2.5,"subscribe/refresh_key":2.5,"subscribe/destroy_key":2.5,get_deposit_address:2.5,deposit_history:2.5,create_order:1,batch_create_order:1,cancel_order:1,cancel_clientOrders:1,orders_info:2.5,orders_info_history:2.5,order_transaction_detail:2.5,transaction_history:2.5,orders_info_no_deal:2.5,withdraw:2.5,withdrawCancel:2.5,withdraws:2.5,"supplement/user_info":2.5,"supplement/withdraw":2.5,"supplement/deposit_history":2.5,"supplement/withdraws":2.5,"supplement/get_deposit_address":2.5,"supplement/asset_detail":2.5,"supplement/customer_trade_fee":2.5,"supplement/api_Restrictions":2.5,"supplement/system_ping":2.5,"supplement/create_order_test":1,"supplement/create_order":1,"supplement/cancel_order":1,"supplement/cancel_order_by_symbol":1,"supplement/orders_info":2.5,"supplement/orders_info_no_deal":2.5,"supplement/orders_info_history":2.5,"supplement/user_info_account":2.5,"supplement/transaction_history":2.5}}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{VET_ERC20:"VEN",PNT:"Penta"},precisionMode:wD,options:{cacheSecretAsPem:!0,createMarketBuyOrderRequiresPrice:!0,fetchTrades:{method:"publicGetTrades"},fetchTransactionFees:{method:"fetchPrivateTransactionFees"},fetchDepositWithdrawFees:{method:"fetchPrivateDepositWithdrawFees"},fetchDepositAddress:{method:"fetchDepositAddressDefault"},createOrder:{method:"privatePostSupplementCreateOrder"},fetchOrder:{method:"fetchOrderSupplement"},fetchBalance:{method:"privatePostSupplementUserInfo"},networks:{ERC20:"erc20",ETH:"erc20",TRC20:"trc20",TRX:"trc20",OMNI:"omni",ASA:"asa",BEP20:"bep20(bsc)",BSC:"bep20(bsc)",HT:"heco",BNB:"bep2",BTC:"btc",DOGE:"dogecoin",MATIC:"matic",POLYGON:"matic",OEC:"oec",BTCTRON:"btctron",XRP:"xrp"},"inverse-networks":{erc20:"ERC20",trc20:"TRC20",omni:"OMNI",asa:"ASA","bep20(bsc)":"BSC",bep20:"BSC",heco:"HT",bep2:"BNB",btc:"BTC",dogecoin:"DOGE",matic:"MATIC",oec:"OEC",btctron:"BTCTRON",xrp:"XRP"},defaultNetworks:{USDT:"TRC20"}}})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(),s=this.safeValue(t,"data"),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("_"),d=o[0],c=o[1],u=d.toUpperCase(),h=c.toUpperCase();let f=u+"/"+h;const l={"3l":!0,"5l":!0,"3s":!0,"5s":!0},m=d.slice(-2),g=this.safeValue(l,m,!1);g&&(f+=":"+h);let y;g===!0&&(y=!0),i.push({id:a,symbol:f,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:g,future:!1,option:!1,active:!0,contract:g,linear:y,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"ticker");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:this.safeString(r,"latest"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"change"),average:void 0,baseVolume:this.safeString(r,"vol"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={symbol:"all"},i=await this.publicGetTicker24hr(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=60);const n={symbol:i.id,size:t},a=(await this.publicGetDepth(this.extend(n,s))).data,o=this.milliseconds();return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"date_ms","time");s===void 0&&(s=this.safeInteger(e,"dealTime"));let i=this.safeString2(e,"amount","qty");i===void 0&&(i=this.safeString(e,"dealQuantity"));let n=this.safeString(e,"price");n===void 0&&(n=this.safeString(e,"dealPrice"));let r=this.safeString(e,"quoteQty");r===void 0&&(r=this.safeString(e,"dealVolumePrice"));let a=this.safeString2(e,"tradeType","type"),o,d;if(a!==void 0){const m=a.split("_");a=this.safeString(m,0);const g=this.safeString(m,1);o="limit",d="taker",g!==void 0&&(g==="market"?o="market":g==="maker"&&(d="maker"))}let c=this.safeString2(e,"tid","id");c===void 0&&(c=this.safeString(e,"txUuid"));const u=this.safeString(e,"orderUuid"),h=this.safeSymbol(void 0,t);let f;const l=this.safeString(e,"tradeFee");return l!==void 0&&(f={cost:l,currency:void 0,rate:this.safeString(e,"tradeFeeRate")}),this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:h,id:c,order:u,type:o,takerOrMaker:d,side:a,price:n,amount:i,cost:r,fee:f,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.time=t),s!==void 0?r.size=s:r.size=600;let a=this.safeString(i,"method");if(i=this.omit(i,"method"),a===void 0){const c=this.safeValue(this.options,"fetchTrades",{});a=this.safeString(c,"method","publicGetTrades")}const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const c=this.parseTimeframe(t);s=this.milliseconds()-c*1e3*i}const a={symbol:r.id,type:this.timeframes[t],time:parseInt(s/1e3),size:i},o=await this.publicGetKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t=this.safeInteger(e,"ts"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data");if(this.safeValue(i,"toBtc")!==void 0){const o=this.safeValue(i,"freeze",{}),d=this.safeValue(i,"free",{}),c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],f=this.safeCurrencyCode(h),l=this.account();l.used=this.safeString(o,h),l.free=this.safeString(d,h),s[f]=l}return this.safeBalance(s)}const r=this.safeValue(i,"balances");if(r!==void 0){for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),s[u]=h}return this.safeBalance(s)}if(Array.isArray(i)===!0){for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"coin"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"usableAmt"),h.used=this.safeString(d,"freezeAmt"),s[u]=h}return this.safeBalance(s)}}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(e,"method");if(t===void 0){const i=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(i,"method","privatePostSupplementUserInfo")}const s=await this[t]();return this.parseBalance(s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){const s=this.market(e);return await this.fetchTradingFees(this.extend(t,{category:s.id}))}async fetchTradingFees(e={}){await this.loadMarkets();const t={},s=await this.privatePostSupplementCustomerTradeFee(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTradingFee(i[r]),o=a.symbol;n[o]=a}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"custom_id","clientOrderId"),d=this.safeValue(r,"postOnly",!1),c=this.safeStringUpper(r,"timeInForce");r=this.omit(r,["custom_id","clientOrderId","timeInForce","postOnly"]);const u={symbol:a.id},h=c==="IOC",f=c==="FOK",l=d||c==="PO";if(t==="market"&&(h||f||l))throw new Wi(this.id+" createOrder () does not allow market FOK, IOC, or postOnly orders. Only limit IOC, FOK, and postOnly orders are allowed");if(t==="limit")u.type=s,u.price=this.priceToPrecision(e,n),u.amount=this.amountToPrecision(e,i),h?u.type=s+"_ioc":f?u.type=s+"_fok":l&&(u.type=s+"_maker");else if(t==="market"){if(s==="sell")u.type=s+"_market",u.amount=this.amountToPrecision(e,i);else if(s==="buy")if(u.type=s+"_market",this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Wi(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply the price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const w=this.numberToString(i),b=this.numberToString(n),S=bD.stringMul(w,b),v=this.parseNumber(S);u.price=this.priceToPrecision(e,v)}}else u.price=i}o!==void 0&&(u.custom_id=o);let m;if(m=this.safeString(r,"method"),r=this.omit(r,"method"),m===void 0){const w=this.safeValue(this.options,"createOrder",{});m=this.safeString(w,"method","privatePostSupplementCreateOrder")}const g=await this[m](this.extend(u,r)),y=this.safeValue(g,"data",{});return{id:this.safeString(y,"order_id"),info:y}}parseOrderStatus(e){const t={"-1":"canceled",0:"open",1:"open",2:"closed",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"orderId","order_id"),i=this.safeString2(e,"clientOrderId","custom_id"),n=this.safeInteger2(e,"time","create_time"),r=this.safeString(e,"status"),a=this.safeString(e,"symbol");t=this.safeMarket(a,t);let o,d=!1,c="limit";const u=this.safeString(e,"type"),h=u.split("_"),f=this.safeString(h,0),l=this.safeString(h,1);l==="market"&&(c="market"),l==="maker"&&(d=!0,o="PO"),l==="ioc"&&(o="IOC"),l==="fok"&&(o="FOK");const m=this.safeString(e,"price"),g=this.safeString(e,"cummulativeQuoteQty");let y;u!=="buy_market"&&(y=this.safeString2(e,"origQty","amount"));const w=this.safeString2(e,"executedQty","deal_amount");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:this.parseOrderStatus(r),symbol:t.symbol,type:c,timeInForce:o,postOnly:d,side:f,price:m,stopPrice:void 0,triggerPrice:void 0,cost:g,amount:y,filled:w,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i=this.safeString(s,"method");if(i===void 0){const r=this.safeValue(this.options,"fetchOrder",{});i=this.safeString(r,"method","fetchOrderSupplement")}return await this[i](e,t,s)}async fetchOrderSupplement(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Jn(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,orderId:e},r=await this.privatePostSupplementOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a)}async fetchOrderDefault(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Jn(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=a.length;if(o===1)return this.parseOrder(a[0]);{const d=[];for(let c=0;c<o;c++){const u=this.parseOrder(a[c]);d.push(u)}return d}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jn(this.id+" fetchMyTrades () requires a symbol argument");await this.loadMarkets();const n=this.market(e);t=this.safeValue(i,"start_date",t),i=this.omit(i,"start_date");const r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.start_date=this.ymd(t,"-"));const a=await this.privatePostTransactionHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jn(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Jn(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoNoDeal(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Jn(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(s,"origClientOrderId","clientOrderId");s=this.omit(s,["origClientOrderId","clientOrderId"]);const r={symbol:this.market(t).id};i!==void 0&&(r.origClientOrderId=i),r.orderId=e;const a=await this.privatePostSupplementCancelOrder(this.extend(r,s));return this.safeValue(a,"data",{})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Jn(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privatePostSupplementCancelOrderBySymbol(this.extend(i,t));return this.safeValue(n,"data",[])}getNetworkCodeForCurrency(e,t){const s=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(s,e),n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network",i);return r=this.safeString(n,r,r),r}async fetchDepositAddress(e,t={}){await this.loadMarkets();let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchDepositAddress",{});s=this.safeString(i,"method","fetchPrivateTradingFees")}return await this[s](e,t)}async fetchDepositAddressDefault(e,t={}){await this.loadMarkets();const i={assetCode:this.currency(e).id},n=this.getNetworkCodeForCurrency(e,t);n!==void 0&&(i.netWork=n,t=this.omit(t,"network"));const r=await this.privatePostGetDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeString(a,"address"),d=this.safeString(a,"memo"),c=this.safeString(a,"netWork"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,c,c);return{currency:e,address:o,tag:d,network:h,info:r}}async fetchDepositAddressSupplement(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks");let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.networkName=r,t=this.omit(t,"network"));const a=await this.privatePostSupplementGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data"),d=this.safeString(o,"address"),c=this.safeString(o,"memo"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,r,r);return{currency:e,address:d,tag:c,network:h,info:a}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.safeString(n,"fee");if(n=this.omit(n,"fee"),r===void 0)throw new Jn(this.id+" withdraw () requires a fee argument to be supplied in params, the relevant coin network fee can be found by calling fetchDepositWithdrawFees (), note: if no network param is supplied then the default network will be used, this can also be found in fetchDepositWithdrawFees ()");const a=this.currency(e),o={address:s,coin:a.id,amount:t,fee:r};i!==void 0&&(o.memo=i);const d=this.safeStringUpper2(n,"network","networkName");n=this.omit(n,["network","networkName"]);const c=this.safeValue(this.options,"networks"),u=this.safeString(c,d,d);u!==void 0&&(o.networkName=u);const h=await this.privatePostSupplementWithdraw(this.extend(o,n)),f=this.safeValue(h,"data",{});return{info:f,id:this.safeString(f,"withdrawId")}}parseTransactionStatus(e,t){const s={deposit:{1:"pending",2:"ok",3:"failed",4:"canceled",5:"transfer"},withdrawal:{1:"pending",2:"canceled",3:"failed",4:"ok"}};return this.safeString(this.safeValue(s,t,{}),e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i;s===void 0?i="deposit":i="withdrawal";const n=this.safeString(e,"txId"),r=this.safeInteger2(e,"insertTime","applyTime"),a=this.safeValue(this.options,"inverse-networks",{}),o=this.safeString(e,"networkName"),d=this.safeString(a,o,o),c=this.safeString(e,"address");let u,h;i==="deposit"?u=c:h=c;const f=this.safeNumber(e,"amount"),l=this.safeString2(e,"coin","coid"),m=this.safeCurrencyCode(l,t),g=this.parseTransactionStatus(this.safeString(e,"status"),i);let y;const w=this.safeNumber(e,"fee");return w!==void 0&&(y={cost:w,currency:m}),{info:e,id:s,txid:n,timestamp:r,datetime:this.iso8601(r),network:d,address:c,addressTo:h,addressFrom:u,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:f,currency:m,status:g,updated:void 0,comment:void 0,internal:g==="transfer",fee:y}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"depositOrders",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementWithdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"withdraws",[]);return this.parseTransactions(d,r,t,s)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=this.checkRequiredCredentials(!1);let i;if(s===!0){let n=this.safeString(t,"method");if(t=this.omit(t,"method"),n===void 0){const r=this.safeValue(this.options,"fetchTransactionFees",{});n=this.safeString(r,"method","fetchPrivateTransactionFees")}i=await this[n](t)}else i=await this.fetchPublicTransactionFees(t);return i}async fetchPrivateTransactionFees(e={}){await this.loadMarkets();const t=await this.privatePostSupplementUserInfo(),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"name"),f=this.safeString(this.options["inverse-networks"],h,h),l=this.safeNumber(u,"withdrawFee");l!==void 0&&(i[o][f]=l)}}return{withdraw:i,deposit:{},info:t}}async fetchPublicTransactionFees(e={}){await this.loadMarkets();const t=this.safeString2(e,"coin","assetCode");e=this.omit(e,["coin","assetCode"]);const s={};if(t!==void 0){const a=this.currency(t);s.assetCode=a.id}const i=await this.publicGetWithdrawConfigs(this.extend(s,e)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=n[a];if(this.safeValue(o,"canWithDraw")==="true"){const c=this.safeString(o,"assetCode"),u=this.safeCurrencyCode(c),h=this.safeString(o,"chain");let f=this.safeString(this.options["inverse-networks"],h,h);f===void 0&&(f=u);const l=this.safeString(o,"fee");r[u]===void 0&&(r[u]={}),r[u][f]=this.parseNumber(l)}}return{withdraw:r,deposit:{},info:i}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=this.checkRequiredCredentials(!1);let i;if(s===!0){if(i=this.safeString(t,"method"),t=this.omit(t,"method"),i===void 0){const n=this.safeValue(this.options,"fetchDepositWithdrawFees",{});i=this.safeString(n,"method","fetchPrivateDepositWithdrawFees")}}else i="fetchPublicDepositWithdrawFees";return await this[i](e,t)}async fetchPrivateDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostSupplementUserInfo(t),i=this.safeValue(s,"data",[]);return this.parseDepositWithdrawFees(i,e,"coin")}async fetchPublicDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.publicGetWithdrawConfigs(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parsePublicDepositWithdrawFees(n,e)}parsePublicDepositWithdrawFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i];if(this.safeValue(n,"canWithDraw")===!0){const a=this.safeString(n,"assetCode"),o=this.safeCurrencyCode(a);if(t===void 0||this.inArray(o,t)){const d=this.safeNumber(n,"fee");if(d!==void 0){this.safeValue(s,o)===void 0?s[o]=this.depositWithdrawFee([n]):s[o].info.push(n);const u=this.safeString(n,"chain"),h=this.safeString(this.options["inverse-networks"],u,u);h!==void 0?s[o].networks[h]={withdraw:{fee:d,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}:s[o].withdraw={fee:d,percentage:void 0}}}}}return s}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e),i=this.safeValue(e,"networkList",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"name"),o=this.safeStringUpper(this.options["inverse-networks"],a,a),d=this.safeNumber(r,"withdrawFee"),c=this.safeValue(r,"isDefault");d!==void 0&&(c&&(s.withdraw={fee:d,percentage:void 0}),s.networks[o]={withdraw:{fee:d,percentage:void 0},deposit:{fee:void 0,percentage:void 0}})}return s}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(this.keysort(a)));else{this.checkRequiredCredentials();const d=this.milliseconds().toString(),c=this.uuid22()+this.uuid16();a=this.extend({api_key:this.apiKey},a);let u;this.secret.length>32?u="RSA":u="HmacSHA256";const h=this.rawencode(this.keysort(this.extend({echostr:c,signature_method:u,timestamp:d},a))),f=this.encode(h),m=this.hash(f).toUpperCase();let g;if(u==="RSA"){const y=this.safeValue(this.options,"cacheSecretAsPem",!0);let w;y?(w=this.safeValue(this.options,"pem"),w===void 0&&(w=this.convertSecretToPem(this.encode(this.secret)),this.options.pem=w)):w=this.convertSecretToPem(this.encode(this.secret));const b=this.encode(w);g=this.binaryToBase64(this.rsa(m,b,"RS256"))}else u==="HmacSHA256"&&(g=this.hmac(this.encode(m),this.encode(this.secret)));a.sign=g,r=this.urlencode(this.keysort(a)),n={"Content-Type":"application/x-www-form-urlencoded",timestamp:d,signature_method:u,echostr:c}}return{url:o,method:s,body:r,headers:n}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"Validation failed",10003:"Invalid parameter",10004:"Request too frequent",10005:"Secret key does not exist",10006:"User does not exist",10007:"Invalid signature",10008:"Invalid Trading Pair",10009:"Price and/or Amount are required for limit order",10010:"Price and/or Amount must be less than minimum requirement",10013:"The amount is too small",10014:"Insufficient amount of money in the account",10015:"Invalid order type",10016:"Insufficient account balance",10017:"Server Error",10018:"Page size should be between 1 and 50",10019:"Cancel NO more than 3 orders in one request",10020:"Volume < 0.001",10021:"Price < 0.01",10022:"Invalid authorization",10023:"Market Order is not supported yet",10024:"User cannot trade on this pair",10025:"Order has been filled",10026:"Order has been cancelld",10027:"Order is cancelling",10028:"Wrong query time",10029:"from is not in the query time",10030:"from do not match the transaction type of inqury",10031:"echostr length must be valid and length must be from 30 to 40",10033:"Failed to create order",10036:"customID duplicated",10100:"Has no privilege to withdraw",10101:"Invalid fee rate to withdraw",10102:"Too little to withdraw",10103:"Exceed daily limitation of withdraw",10104:"Cancel was rejected",10105:"Request has been cancelled",10106:"None trade time",10107:"Start price exception",10108:"can not create order",10109:"wallet address is not mapping",10110:"transfer fee is not mapping",10111:"mount > 0",10112:"fee is too lower",10113:"transfer fee is 0",10600:"intercepted by replay attacks filter, check timestamp",10601:"Interface closed unavailable",10701:"invalid asset code",10702:"not allowed deposit"},u,this.json(a)),f=this.safeValue({10001:zs,10002:uu,10003:zs,10004:yD,10005:uu,10006:uu,10007:uu,10008:Zb,10009:Wi,10010:Wi,10013:Wi,10014:rp,10015:Wi,10016:rp,10017:Pn,10018:zs,10019:zs,10020:zs,10021:Wi,10022:hu,10023:Wi,10024:hu,10025:Wi,10026:Wi,10027:Wi,10028:zs,10029:zs,10030:zs,10031:gD,10033:Pn,10036:mD,10100:hu,10101:zs,10102:rp,10103:Pn,10104:Pn,10105:Pn,10106:zs,10107:zs,10108:Pn,10109:pD,10110:Pn,10111:zs,10112:zs,10113:zs,10600:zs,10601:Pn,10701:Zb,10702:hu},u,Pn);throw new f(h)}}};const SD=re,{ExchangeError:fu,ArgumentsRequired:Qb}=Q,{TICK_SIZE:vD}=ne,Is=ae;var NT=class extends SD{describe(){return this.deepExtend(super.describe(),{id:"luno",name:"luno",countries:["GB","SG","ZA"],rateLimit:200,version:"1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{referral:"https://www.luno.com/invite/44893A",logo:"https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",api:{public:"https://api.luno.com/api",private:"https://api.luno.com/api",exchange:"https://api.luno.com/api/exchange"},www:"https://www.luno.com",doc:["https://www.luno.com/en/api","https://npmjs.org/package/bitx","https://github.com/bausmeier/node-bitx"]},api:{exchange:{get:{markets:1}},public:{get:{orderbook:1,orderbook_top:1,ticker:1,tickers:1,trades:1}},private:{get:{"accounts/{id}/pending":1,"accounts/{id}/transactions":1,balance:1,beneficiaries:1,fee_info:1,funding_address:1,listorders:1,listtrades:1,"orders/{id}":1,"quotes/{id}":1,withdrawals:1,"withdrawals/{id}":1,transfers:1},post:{accounts:1,"accounts/{id}/name":1,postorder:1,marketorder:1,stoporder:1,funding_address:1,withdrawals:1,send:1,quotes:1,"oauth2/grant":1},put:{"accounts/{id}/name":1,"quotes/{id}":1},delete:{"quotes/{id}":1,"withdrawals/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},precisionMode:vD})}async fetchMarkets(e={}){const t=await this.exchangeGetMarkets(e),s=[],i=this.safeValue(t,"markets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market_id"),o=this.safeString(r,"base_currency"),d=this.safeString(r,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"trading_status");s.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:this.safeNumber(r,"max_volume")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchAccounts(e={}){const t=await this.privateGetBalance(e),s=this.safeValue(t,"balance",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"account_id"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balance",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(n,"reserved"),d=this.safeString(n,"unconfirmed"),c=this.safeString(n,"balance"),u=Is.stringAdd(o,d),h=Is.stringAdd(c,d);if(a in s)s[a].used=Is.stringAdd(s[a].used,u),s[a].total=Is.stringAdd(s[a].total,h);else{const f=this.account();f.used=u,f.total=h,s[a]=f}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();let i="publicGetOrderbook";t!==void 0&&t<=100&&(i+="Top");const n=this.market(e),r={pair:n.id},a=await this[i](this.extend(r,s)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,n.symbol,o,"bids","asks","price","volume")}parseOrderStatus(e){const t={PENDING:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp");let i=this.parseOrderStatus(this.safeString(e,"state"));i=i;let n;const r=this.safeString(e,"type");r==="ASK"||r==="SELL"?n="sell":(r==="BID"||r==="BUY")&&(n="buy");const a=this.safeString(e,"pair");t=this.safeMarket(a,t);const o=this.safeString(e,"limit_price"),d=this.safeString(e,"limit_volume"),c=this.safeNumber(e,"fee_counter"),u=this.safeNumber(e,"fee_base"),h=this.safeString(e,"base"),f=this.safeString(e,"counter");let l;c!==void 0?l={cost:c,currency:t.quote}:u!==void 0&&(l={cost:u,currency:t.base});const m=this.safeString(e,"order_id");return this.safeOrder({id:m,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:i,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:void 0,triggerPrice:void 0,amount:d,filled:h,cost:f,remaining:void 0,trades:void 0,fee:l,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrdersByState(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;e!==void 0&&(r.state=e),t!==void 0&&(a=this.market(t),r.pair=a.id);const o=await this.privateGetListorders(this.extend(r,n)),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,a,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(void 0,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("PENDING",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("COMPLETE",e,t,s,i)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"pair"),n=this.safeSymbol(i,t),r=this.safeString(e,"last_trade");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"rolling_24_hour_volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.indexBy(s.tickers,"pair"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeString(e,"order_id"),i=this.safeString(e,"sequence");let n,r;if(s!==void 0){const h=this.safeString(e,"type");h==="ASK"||h==="SELL"?r="sell":(h==="BID"||h==="BUY")&&(r="buy"),r==="sell"&&e.is_buy||r==="buy"&&!e.is_buy?n="maker":n="taker"}else r=e.is_buy?"buy":"sell";const a=this.safeString(e,"fee_base"),o=this.safeString(e,"fee_counter");let d,c;a!==void 0?Is.stringEquals(a,"0.0")||(d=t.base,c=a):o!==void 0&&(Is.stringEquals(o,"0.0")||(d=t.quote,c=o));const u=this.safeInteger(e,"timestamp");return this.safeTrade({info:e,id:i,timestamp:u,datetime:this.iso8601(u),symbol:t.symbol,order:s,type:void 0,side:r,takerOrMaker:n,price:this.safeString(e,"price"),amount:this.safeString2(e,"volume","base"),cost:this.safeString(e,"counter"),fee:{cost:c,currency:d}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qb(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.privateGetListtrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetFeeInfo(this.extend(i,t));return{info:n,symbol:e,maker:this.safeNumber(n,"maker_fee"),taker:this.safeNumber(n,"taker_fee")}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost";const o=this.market(e),d={pair:o.id};t==="market"?(a+="Marketorder",d.type=s.toUpperCase(),s==="buy"?d.counter_volume=this.amountToPrecision(o.symbol,i):d.base_volume=this.amountToPrecision(o.symbol,i)):(a+="Postorder",d.volume=this.amountToPrecision(o.symbol,i),d.price=this.priceToPrecision(o.symbol,n),d.type=s==="buy"?"BID":"ASK");const c=await this[a](this.extend(d,r));return{info:c,id:c.order_id}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostStoporder(this.extend(i,s))}async fetchLedgerByEntries(e=void 0,t=-1,s=1,i={}){const r={min_row:t,max_row:this.sum(t,s)};return await this.fetchLedger(e,void 0,s,this.extend(r,i))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id"),a=this.safeValue(i,"min_row"),o=this.safeValue(i,"max_row");if(r===void 0){if(e===void 0)throw new Qb(this.id+" fetchLedger() requires a currency code argument if no account id specified in params");n=this.currency(e);const h=this.indexBy(this.accounts,"currency"),f=this.safeValue(h,e);if(f===void 0)throw new fu(this.id+" fetchLedger() could not find account id for "+e);r=f.id}if(a===void 0&&o===void 0)o=0,a=-1e3;else if(a===void 0||o===void 0)throw new fu(this.id+" fetchLedger() require both params 'max_row' and 'min_row' or neither to be defined");if(s!==void 0&&o-a>s&&(o<=0?a=o-s:a>0&&(o=a+s)),o-a>1e3)throw new fu(this.id+" fetchLedger() requires the params 'max_row' - 'min_row' <= 1000");const d={id:r,min_row:a,max_row:o},c=await this.privateGetAccountsIdTransactions(this.extend(i,d)),u=this.safeValue(c,"transactions",[]);return this.parseLedger(u,n,t,s)}parseLedgerComment(e){const t=e.split(" "),s={Withdrawal:"fee",Trading:"fee",Payment:"transaction",Sent:"transaction",Deposit:"transaction",Received:"transaction",Released:"released",Reserved:"reserved",Sold:"trade",Bought:"trade",Failure:"failed"};let i;const n=this.safeString(t,0),r=this.safeString(t,2),a=this.safeString(t,3);let o=this.safeString(s,n,void 0);return o===void 0&&r==="fee"&&(o="fee"),o==="reserved"&&a==="order"&&(i=this.safeString(t,4)),{type:o,referenceId:i}}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"row_index"),i=this.safeString(e,"account_id"),n=this.safeValue(e,"timestamp"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"available_delta"),d=this.safeString(e,"balance_delta"),c=this.safeString(e,"balance"),u=this.safeString(e,"description");let h=c,f="0.0";const l=this.parseLedgerComment(u),m=l.type,g=l.referenceId;let y,w;return Is.stringEquals(d,"0.0")?Is.stringLt(o,"0.0")?(w="pending",f=Is.stringAbs(o)):Is.stringGt(o,"0.0")&&(w="canceled",f=Is.stringAbs(o)):(h=Is.stringSub(c,d),w="ok",f=Is.stringAbs(d)),Is.stringGt(d,"0")||Is.stringGt(o,"0")?y="in":(Is.stringLt(d,"0")||Is.stringLt(o,"0"))&&(y="out"),{id:s,direction:y,account:i,referenceId:g,referenceAccount:void 0,type:m,currency:a,amount:this.parseNumber(f),timestamp:n,datetime:this.iso8601(n),before:h,after:c,status:w,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.stringToBase64(this.apiKey+":"+this.secret);n={Authorization:"Basic "+this.decode(d)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error")!==void 0)throw new fu(this.id+" "+this.json(a))}};const TD=re,{NotSupported:OD,ExchangeError:er,BadRequest:ID,InsufficientFunds:yd,InvalidOrder:Ti,DuplicateOrderId:xD}=Q,{TICK_SIZE:_D}=ne,CD=ae;var MD=class extends TD{describe(){return this.deepExtend(super.describe(),{id:"lykke",name:"Lykke",countries:["UK"],version:"2",rateLimit:200,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,withdraw:!0},requiredCredentials:{apiKey:!0,secret:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg",api:{public:"https://hft-apiv2.lykke.com/api",private:"https://hft-apiv2.lykke.com/api"},www:"https://www.lykke.com",doc:["https://hft-apiv2.lykke.com/swagger/ui/index.html","https://lykkecity.github.io/Trading-API"],fees:"https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-"},api:{public:{get:{assetpairs:2.5,"assetpairs/{id}":2.5,assets:2.5,"assets/{id}":2.5,isalive:2.5,orderbooks:2.5,tickers:2.5,prices:2.5,"trades/public/{assetPairId}":2.5}},private:{get:{balance:2.5,trades:2.5,"trades/order/{orderId}":2.5,"orders/active":1,"orders/closed":1,"orders/{orderId}":1,operations:2.5,"operations/deposits/addresses":2.5,"operations/deposits/addresses/{assetId}":2.5},post:{"orders/limit":1,"orders/market":1,"orders/bulk":1,"operations/withdrawals":2.5,"operations/deposits/addresses":2.5},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0}},precisionMode:_D,exceptions:{exact:{1001:er,1100:er,1101:er,2e3:ID,2001:yd,2202:xD,2003:er,2004:OD,2005:er,2006:yd,2007:yd,2008:yd,2009:er,2010:yd,2011:Ti,2012:Ti,2013:Ti,2014:Ti,2015:Ti,2016:Ti,2017:Ti,2018:Ti,2019:Ti,2020:Ti,2021:Ti,2022:Ti,2023:er},broad:{}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"payload",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetId"),o=this.safeString(r,"symbol"),d=this.safeString(r,"name"),c=this.safeString(r,"type"),u=this.safeValue(r,"blockchainDepositEnabled"),h=this.safeValue(r,"blockchainWithdrawal"),l=!this.safeValue(r,"isDisabled");i[o]={id:a,code:o,info:r,type:c,name:d,active:l,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"accuracy"))),limits:{withdraw:{min:this.safeValue(r,"cashoutMinimalAmount"),max:void 0},amount:{min:this.safeValue(r,"lowVolumeAmount"),max:void 0}}}}return i}async fetchMarkets(e={}){const t=await this.publicGetAssetpairs(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetPairId"),o=this.safeString(r,"name"),d=this.safeString(r,"baseAssetId"),c=this.safeString(r,"quoteAssetId"),[u,h]=o.split("/"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h),m=f+"/"+l;i.push({id:a,symbol:m,base:f,quote:l,baseId:d,quoteId:c,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,active:!0,info:r,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{amount:{min:this.safeNumber(r,"minVolume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOppositeVolume"),max:void 0},leverage:{min:void 0,max:void 0}}})}return i}parseTicker(e,t=void 0){const i=this.safeString(e,"assetPairId");t=this.safeMarket(i,t);const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:this.iso8601(void 0),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeBase"),quoteVolume:this.safeString(e,"volumeQuote"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={assetPairIds:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetTickers"),r=await this[n](this.extend(i,t)),a=this.safeValue(r,"payload",[]);return this.parseTicker(this.safeValue(a,0,{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeValue(s,"payload",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={assetPairId:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,"payload",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,d,"bids","asks","p","v")}parseTrade(e,t){const s=this.safeString(e,"assetPairId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString2(e,"id","id"),r=this.safeString(e,"orderId"),a=this.safeInteger(e,"timestamp"),o=this.safeString2(e,"price","price");let d=this.safeString2(e,"volume","amount");d===void 0&&(d=this.safeString2(e,"baseVolume","amount"));const c=this.safeStringLower(e,"side");return this.safeTrade({id:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:void 0,order:r,side:c,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={assetPairId:n.id};s!==void 0&&(r.take=s);const a=await this.publicGetTradesPublicAssetPairId(this.extend(r,i)),o=this.safeValue(a,"payload",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetId"),r=this.safeCurrencyCode(n),a=this.account(),o=this.safeString(i,"available"),d=this.safeString(i,"reserved");a.free=o,a.used=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),s=this.safeValue(t,"payload",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={Open:"open",Pending:"open",InOrderBook:"open",Processing:"open",Matched:"closed",Cancelled:"canceled",Rejected:"rejected",Replaced:"canceled",Placed:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString(e,"assetPairId"),r=this.safeSymbol(n,t),a=this.safeStringLower(e,"type"),o=this.safeInteger(e,"lastTradeTimestamp"),d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"price"),u=this.safeStringLower(e,"side"),h=this.safeString(e,"volume"),f=this.safeString(e,"remainingVolume"),l=this.safeString(e,"filledVolume"),m=this.safeString(e,"cost");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:o,symbol:r,type:a,timeInForce:void 0,postOnly:void 0,side:u,price:c,stopPrice:void 0,triggerPrice:void 0,amount:h,cost:m,average:void 0,filled:l,remaining:f,status:i,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={assetPairId:a.id,side:this.capitalize(s),volume:parseFloat(this.amountToPrecision(a.symbol,i))};t==="limit"&&(o.price=parseFloat(this.priceToPrecision(a.symbol,n)));const d="privatePostOrders"+this.capitalize(t),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"payload"),h=this.safeString(u,"orderId");return t==="market"&&(n=this.safeNumber(u,"price")),{id:h,info:c,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:a.symbol,type:t,side:s,price:n,amount:i,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return await this.privateDeleteOrdersOrderId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.assetPairId=i.id),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"payload");return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersActive(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersClosed(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;s!==void 0&&(n.take=s),e!==void 0&&(r=this.market(e),n.assetPairId=r.id),t!==void 0&&(n.from=t);const a=await this.privateGetTrades(this.extend(n,i)),o=this.safeValue(a,"payload");return this.parseTrades(o,r,t,s)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=CD.stringAbs(this.safeString(e,s));return[this.parseNumber(i),this.parseNumber(n)]}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={assetId:this.safeString(s,"id")},n=await this.privateGetOperationsDepositsAddressesAssetId(this.extend(i,t)),r=this.safeString(n,"baseAddress"),a=this.safeString(n,"addressExtension");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}parseTransaction(e,t=void 0){let s,i,n,r,a,o,d;if(typeof e=="string")s=e;else{s=this.safeString(e,"operationId"),i=this.safeString(e,"assetId"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"totalVolume"),o=this.safeString(e,"type"),d=this.safeInteger(e,"timestamp");const c=this.safeNumber(e,"fee");a={currency:n,cost:c}}return{info:e,id:s,txid:void 0,timestamp:d,datetime:this.iso8601(d),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:o,amount:r,currency:n,status:void 0,updated:void 0,fee:a}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.take=s);const r=await this.privateGetOperations(this.extend(n,i)),a=this.safeValue(r,"payload",[]);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={assetId:r.id,volume:parseFloat(this.currencyToPrecision(e,t)),destinationAddress:s};i!==void 0&&(a.destinationAddressExtension=i);const o=await this.privatePostOperationsWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return n={Accept:"application/json","Content-Type":"application/json"},t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&((s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),this.checkRequiredCredentials(),n.Authorization="Bearer "+this.apiKey,s==="POST"&&Object.keys(i).length&&(r=this.json(i)),e==="operations/withdrawals"&&(n["X-Request-ID"]=this.uuid())),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0&&u!=="0"){const h=this.id+" "+r,f=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,f,h),new er(h)}}};const PD=re,{ExchangeError:AD,ArgumentsRequired:tr,InvalidOrder:BD}=Q,{TICK_SIZE:ND}=ne;var VD=class extends PD{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:["BR"],rateLimit:1e3,version:"v3",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:"emulated",fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"15m":"15m","1h":"1h","3h":"3h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi",v4Public:"https://www.mercadobitcoin.com.br/v4",v4PublicNet:"https://api.mercadobitcoin.net/api/v4"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api","https://api.mercadobitcoin.net/api/v4/docs/"]},api:{public:{get:["coins","{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","place_market_buy_order","place_market_sell_order","withdraw_coin"]},v4Public:{get:["{coin}/candle/"]},v4PublicNet:{get:["candles"]}},fees:{trading:{maker:.003,taker:.007}},options:{limits:{BTC:.001,BCH:.001,ETH:.01,LTC:.01,XRP:.1}},precisionMode:ND})}async fetchMarkets(e={}){const t=await this.publicGetCoins(e),s=[],i=this.safeValue(this.options,"limits",{});for(let n=0;n<t.length;n++){const r=t[n],a=r,o="BRL",d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=c+d;s.push({id:u,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,a),max:void 0},price:{min:this.parseNumber("1e-5"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={coin:i.base},r=await this.publicGetCoinOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"date"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={coin:s.base},n=await this.publicGetCoinTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","executed_timestamp");t=this.safeMarket(void 0,t);const i=this.safeString2(e,"tid","operation_id"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString2(e,"amount","quantity"),d=this.safeString(e,"fee_rate");let c;return d!==void 0&&(c={cost:d,currency:void 0}),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="publicGetCoinTrades";const a={coin:n.base};t!==void 0&&(r+="From",a.from=parseInt(t/1e3)),this.safeInteger(i,"to")!==void 0&&(r+="To");const d=await this[r](this.extend(a,i));return this.parseTrades(d,n,t,s)}parseBalance(e){const t=this.safeValue(e,"response_data",{}),s=this.safeValue(t,"balance",{}),i={info:e},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a);if(a in s){const d=this.safeValue(s,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.total=this.safeString(d,"total"),i[o]=c}}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id};let d=this.capitalize(s)+"Order";if(t==="limit")d="privatePostPlace"+d,o.limit_price=this.priceToPrecision(a.symbol,n),o.quantity=this.amountToPrecision(a.symbol,i);else if(d="privatePostPlaceMarket"+d,s==="buy"){if(n===void 0)throw new BD(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount");o.cost=this.priceToPrecision(a.symbol,i*n)}else o.quantity=this.amountToPrecision(a.symbol,i);const c=await this[d](this.extend(o,r));return{info:c,id:c.response_data.order.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new tr(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order",{});return this.parseOrder(o,i)}parseOrderStatus(e){const t={2:"open",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"order_type");let n;"order_type"in e&&(n=i==="1"?"buy":"sell");const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"coin_pair");t=this.safeMarket(a,t);const o=this.safeTimestamp(e,"created_timestamp"),d={cost:this.safeString(e,"fee"),currency:t.quote},c=this.safeString(e,"limit_price"),u=this.safeString(e,"executed_price_avg"),h=this.safeString(e,"quantity"),f=this.safeString(e,"executed_quantity"),l=this.safeTimestamp(e,"updated_timestamp"),m=this.safeValue(e,"operations",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:l,symbol:t.symbol,type:"limit",timeInForce:void 0,postOnly:void 0,side:n,price:c,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:u,amount:h,filled:f,remaining:void 0,status:r,fee:d,trades:m},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new tr(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:parseInt(e)},r=await this.privatePostGetOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order");return this.parseOrder(o,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,quantity:t.toFixed(10),address:s};if(e==="BRL"){if(!("account_ref"in n))throw new tr(this.id+" withdraw() requires account_ref parameter to withdraw "+e)}else if(e!=="LTC"){if(!("tx_fee"in n))throw new tr(this.id+" withdraw() requires tx_fee parameter to withdraw "+e);if(e==="XRP")if(i===void 0){if(!("destination_tag"in n))throw new tr(this.id+" withdraw() requires a tag argument or destination_tag parameter to withdraw "+e)}else a.destination_tag=i}const o=await this.privatePostWithdrawCoin(this.extend(a,n)),d=this.safeValue(o,"response_data",{}),c=this.safeValue(d,"withdrawal");return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="15m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={resolution:this.timeframes[t],symbol:r.base+"-"+r.quote};i===void 0&&(i=100),s!==void 0?(a.from=parseInt(s/1e3),a.to=this.sum(a.from,i*this.parseTimeframe(t))):(a.to=this.seconds(),a.from=a.to-i*this.parseTimeframe(t));const o=await this.v4PublicNetGetCandles(this.extend(a,n)),d=this.convertTradingViewToOHLCV(o,"t","o","h","l","c","v");return this.parseOHLCVs(d,r,t,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tr(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tr(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,status_list:"[2]"},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tr(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,has_fills:!0},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]),c=this.parseOrders(d,n,t,s),u=this.ordersToTrades(c);return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}ordersToTrades(e){const t=[];for(let s=0;s<e.length;s++){const i=this.safeValue(e[s],"trades",[]);for(let n=0;n<i.length;n++)t.push(i[n])}return t}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="public"||t==="v4Public"||t==="v4PublicNet")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.version+"/";const d=this.nonce();r=this.urlencode(this.extend({tapi_method:e,tapi_nonce:d},i));const c="/tapi/"+this.version+"/?"+r;n={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(c),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error_message")!==void 0)throw new AD(this.id+" "+this.json(a))}};const ED=re,{AccountNotEnabled:qD,InvalidAddress:ap,ExchangeError:op,BadRequest:LD,AuthenticationError:lu,RateLimitExceeded:RD,BadSymbol:Fr,InvalidOrder:ci,InsufficientFunds:Jb,ArgumentsRequired:Oi,OrderNotFound:DD,PermissionDenied:dp,NotSupported:FD}=Q,{TICK_SIZE:HD}=ne,zi=ae;var VT=class extends ED{describe(){return this.deepExtend(super.describe(),{id:"mexc",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:HD,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1M":"1M"},contract:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},accountsByType:{spot:"MAIN",swap:"CONTRACT"},transfer:{accountsById:{MAIN:"spot",CONTRACT:"swap"},status:{SUCCESS:"ok",FAILED:"failed",WAIT:"pending"}},fetchOrdersByState:{method:"spotPrivateGetOrderList"},cancelOrder:{method:"spotPrivateDeleteOrderCancel"},broker:"CCXT"},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GAS:"GASDAO",GMT:"GMT Token",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap",STEPN:"GMT"},exceptions:{exact:{400:LD,401:lu,402:lu,403:dp,429:RD,703:dp,1e3:qD,1002:ci,10072:lu,10073:lu,10075:dp,10101:Jb,10216:ap,10232:Fr,3e4:Fr,30001:ci,30002:ci,30003:ci,30004:Jb,30005:ci,30010:ci,30014:Fr,30016:Fr,30019:ci,30020:Fr,30021:Fr,33333:Fr},broad:{"price and quantity must be positive":ci}}})}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPublicGetCommonTimestamp",swap:"contractPublicGetPing"}),n=await this[i](this.extend(s));return this.safeInteger(n,"data")}async fetchStatus(e={}){const t=await this.spotPublicGetCommonPing(e);return{status:this.safeInteger(t,"code")===200?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.spotPublicGetMarketCoinList(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"full_name");let c=!1,u,h,f,l;const m={},g=this.safeValue(r,"coins",[]);let y=!1,w=!1;for(let v=0;v<g.length;v++){const T=g[v],I=this.safeString(T,"chain"),A=this.safeNetwork(I),N=this.safeValue(T,"is_deposit_enabled",!1),B=this.safeValue(T,"is_withdraw_enabled",!1),x=N&&B;c=x||c;const k=this.safeString(T,"withdraw_limit_min"),O=this.safeString(T,"withdraw_limit_max");f=f===void 0?k:f,l=l===void 0?O:l,zi.stringGt(f,k)&&(f=k),zi.stringLt(l,O)&&(l=O),N&&(y=!0),B&&(w=!0);const P=this.parsePrecision(this.safeString(T,"precision"));P!==void 0&&(u=u===void 0?P:zi.stringMin(P,u)),m[A]={info:T,id:I,network:A,active:x,deposit:N,withdraw:B,fee:this.safeNumber(T,"fee"),precision:this.parseNumber(u),limits:{withdraw:{min:k,max:O}}}}const S=Object.keys(m).length;if(S===1||"NONE"in m){const v=this.safeValue2(m,"NONE",S-1);v!==void 0&&(h=v.fee)}i[o]={id:a,code:o,info:r,name:d,active:c,deposit:y,withdraw:w,fee:h,precision:this.parseNumber(u),limits:{amount:{min:void 0,max:void 0},withdraw:{min:f,max:l}},networks:m}}return i}async fetchMarkets(e={}){const t=this.safeString2(this.options,"fetchMarkets","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type"),n=s==="spot",r=s==="swap";if(!n&&!r)throw new op(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot' or 'swap''");if(n)return await this.fetchSpotMarkets(i);if(r)return await this.fetchContractMarkets(i)}async fetchContractMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),f=this.safeCurrencyCode(c),l=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+f,base:u,quote:h,settle:f,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:l==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i=await this.spotPublicGetMarketApiDefaultSymbols(e),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"symbol",[]),a=[];for(let o=0;o<s.length;o++){const d=s[o],c=this.safeString(d,"symbol"),[u,h]=c.split("_"),f=this.safeCurrencyCode(u),l=this.safeCurrencyCode(h),m=this.safeString(d,"state");let g=!1;for(let y=0;y<r.length;y++)if(r[y]===c){m==="ENABLED"&&(g=!0);break}a.push({id:c,symbol:f+"/"+l,base:f,quote:l,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(d,"taker_fee_rate"),maker:this.safeNumber(d,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(d,"quantity_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(d,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"min_amount"),max:this.safeNumber(d,"max_amount")}},info:d})}return a}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),a=this.getSupportedMapping(n,{spot:"spotPublicGetMarketTicker",swap:"contractPublicGetTicker"}),o=await this[a](this.extend(r)),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;s.spot?n="spotPublicGetMarketTicker":s.swap&&(n="contractPublicGetTicker");const r=await this[n](this.extend(i,t));if(s.spot){const a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseTicker(o,s)}else if(s.swap){const a=this.safeValue(r,"data",{});return this.parseTicker(a,s)}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"time","timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"volume","volume24"),a=this.safeString(e,"amount24"),o=this.safeString(e,"open"),d=this.safeString2(e,"last","lastPrice"),c=this.safeString(e,"riseFallValue"),u=this.safeString(e,"riseFallRate"),h=zi.stringAdd(u,"1");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"high","high24Price"),low:this.safeString2(e,"low","lower24Price"),bid:this.safeString2(e,"bid","bid1"),bidVolume:void 0,ask:this.safeString2(e,"ask","ask1"),askVolume:void 0,vwap:void 0,open:o,close:d,last:d,previousClose:void 0,change:c,percentage:h,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};let r;i.spot?(r="spotPublicGetMarketDepth",t===void 0&&(t=100),n.depth=t):i.swap&&(r="contractPublicGetDepthSymbol",t!==void 0&&(n.limit=t));const a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=i.spot?"price":0,c=i.spot?"quantity":1,u=this.safeInteger(o,"timestamp"),h=this.parseOrderBook(o,e,u,"bids","asks",d,c);return h.nonce=this.safeInteger(o,"version"),h}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;n.spot?a="spotPublicGetMarketDeals":n.swap&&(a="contractPublicGetDealsSymbol");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"create_time","trade_time");s=this.safeInteger(e,"t",s);const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeString2(e,"price","trade_price");r=this.safeString(e,"p",r);let a=this.safeString2(e,"quantity","trade_quantity");a=this.safeString(e,"v",a);const o=this.safeString(e,"amount");let d=this.safeString2(e,"trade_type","T");d==="BID"||d==="1"?d="buy":(d==="ASK"||d==="2")&&(d="sell");let c=this.safeString2(e,"id","trade_time");c===void 0&&(c=this.safeString(e,"t",c),c!==void 0&&(c+="-"+t.id+"-"+a));const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"fee_currency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const f=this.safeString(e,"order_id"),m=this.safeValue(e,"is_taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:f,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:o,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),d=this.safeMarket(a,void 0,"_").symbol;i[d]={info:r,symbol:d,maker:this.safeNumber(r,"maker_fee_rate"),taker:this.safeNumber(r,"taker_fee_rate"),percentage:!0,tierBased:!1}}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t);if(d===void 0)throw new FD(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");const c={symbol:r.id,interval:d};let u;r.spot?(u="spotPublicGetMarketKline",s!==void 0&&(c.start_time=parseInt(s/1e3)),i!==void 0&&(c.limit=i)):r.swap&&(u="contractPublicGetKlineSymbol",s!==void 0&&(c.start=parseInt(s/1e3)));const h=await this[u](this.extend(c,n));if(r.spot){const f=this.safeValue(h,"data",[]);return this.parseOHLCVs(f,r,t,s,i)}else if(r.swap){const f=this.safeValue(h,"data",{}),l=this.convertTradingViewToOHLCV(f,"time","open","high","low","close","vol");return this.parseOHLCVs(l,r,t,s,i)}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,t.spot?3:2),this.safeNumber(e,t.spot?4:3),this.safeNumber(e,t.spot?2:4),this.safeNumber(e,5)]}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPrivateGetAccountInfo",margin:"spotPrivateGetAccountInfo",swap:"contractPrivateGetAccountAssets"}),n=t==="spot",r=await this[i](s),a=this.safeValue(r,"data",{}),o=this.milliseconds(),d={info:r,timestamp:o,datetime:this.iso8601(o)};if(n){const c=Object.keys(a);for(let u=0;u<c.length;u++){const h=c[u],f=this.safeCurrencyCode(h),l=this.safeValue(a,h,{}),m=this.account();m.free=this.safeString(l,"available"),m.used=this.safeString(l,"frozen"),d[f]=m}}else for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"currency"),f=this.safeCurrencyCode(h),l=this.account();l.free=this.safeString(u,"availableBalance"),l.used=this.safeString(u,"frozenBalance"),d[f]=l}return this.safeBalance(d)}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotPrivateGetAssetDepositAddressList(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"chains",[]),o=[];for(let d=0;d<a.length;d++){const c=this.parseDepositAddress(a[d],s);o.push(c)}return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t),n=this.safeValue(this.options,"networks",{}),r=this.safeString(n,s,s);let a;if(r===void 0){if(a=this.safeValue(i,e),a===void 0){const o=this.safeString(n,e,e);if(a=this.safeValue(i,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(i,d),a===void 0){const c=Object.values(i);if(a=this.safeValue(c,0),a===void 0)throw new ap(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(i,s),a===void 0)throw new ap(this.id+" fetchDepositAddress() cannot find "+r+" deposit address for "+e);return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetDepositList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetWithdrawList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.parse8601(this.safeString(e,"create_time")),r=this.parse8601(this.safeString(e,"update_time"));let a=this.safeString(e,"currency"),o;if(a!==void 0&&a.indexOf("-")>=0){const g=a.split("-");a=this.safeString(g,0);const y=this.safeString(g,1);o=this.safeNetwork(y)}const d=this.safeCurrencyCode(a,t),c=this.parseTransactionStatus(this.safeString(e,"state"));let u=this.safeString(e,"amount");const h=this.safeString(e,"address"),f=this.safeString(e,"tx_id");let l;const m=this.safeString(e,"fee");return m!==void 0&&(l={cost:this.parseNumber(m),currency:d}),i==="withdrawal"&&(u=zi.stringSub(u,m)),{info:e,id:s,txid:f,timestamp:n,datetime:this.iso8601(n),network:o,address:h,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(u),currency:d,status:c,updated:r,fee:l}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.fetchPositions(this.extend(i,t)),r=this.safeValue(n,0);return this.parsePosition(r,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeString(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),f=this.safeNumber(e,"updateTime");return{info:e,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginMode:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:f,datetime:this.iso8601(f)}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r);if(o==="spot")return await this.createSpotOrder(e,t,s,i,n,d);if(o==="swap")return await this.createSwapOrder(e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;s==="buy"?o="BID":s==="sell"&&(o="ASK");let d=t.toUpperCase();const c=d==="MARKET";if(c)throw new ci(this.id+" createOrder () does not support market orders, only limit orders are allowed");d==="LIMIT"&&(d="LIMIT_ORDER");const u=this.isPostOnly(c,d==="POST_ONLY",r),h=this.safeStringUpper(r,"timeInForce");if(u?d="POST_ONLY":h==="IOC"&&(d="IMMEDIATE_OR_CANCEL"),h==="FOK")throw new ci(this.id+" createOrder () does not support timeInForce FOK, only IOC, PO, and GTC are allowed");if(d!=="POST_ONLY"&&d!=="IMMEDIATE_OR_CANCEL"&&d!=="LIMIT_ORDER")throw new ci(this.id+" createOrder () does not support "+t+" order type, only LIMIT, LIMIT_ORDER, POST_ONLY or IMMEDIATE_OR_CANCEL are allowed");const l={symbol:a.id,price:this.priceToPrecision(e,n),quantity:this.amountToPrecision(e,i),trade_type:o,order_type:d},m=this.safeString2(r,"clientOrderId","client_order_id");m!==void 0&&(l.client_order_id=m),r=this.omit(r,["type","clientOrderId","client_order_id","postOnly","timeInForce"]);const g=await this.spotPrivatePostOrderPlace(this.extend(l,r));return this.parseOrder(g,a)}async createSwapOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeInteger(r,"openType");if(o===void 0)throw new Oi(this.id+" createSwapOrder () requires an integer openType parameter, 1 for isolated margin, 2 for cross margin");if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new ci(this.id+" createSwapOrder () order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");const d=t==="market"||t===5;this.isPostOnly(d,t===2,r)?t=2:t==="limit"?t=1:t==="market"&&(t=5);const u=this.safeStringUpper(r,"timeInForce");if(u==="IOC"?t=3:u==="FOK"&&(t=4),s!==1&&s!==2&&s!==3&&s!==4)throw new ci(this.id+" createSwapOrder () order side must be 1 open long, 2 close short, 3 open short or 4 close long");const l={symbol:a.id,vol:parseFloat(this.amountToPrecision(e,i)),side:s,type:t,openType:o};let m="contractPrivatePostOrderSubmit";const g=this.safeNumber2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["stopPrice","triggerPrice","timeInForce","postOnly"]),g!==void 0&&(m="contractPrivatePostPlanorderPlace",l.triggerPrice=this.priceToPrecision(e,g),l.triggerType=this.safeInteger(r,"triggerType",1),l.executeCycle=this.safeInteger(r,"executeCycle",1),l.trend=this.safeInteger(r,"trend",1),l.orderType=this.safeInteger(r,"orderType",t)),t!==5&&t!==6&&t!=="market"&&(l.price=parseFloat(this.priceToPrecision(e,n))),o===1&&this.safeInteger(r,"leverage")===void 0)throw new Oi(this.id+" createSwapOrder () requires a leverage parameter for isolated margin orders");const y=this.safeString2(r,"clientOrderId","externalOid");y!==void 0&&(l.externalOid=y),r=this.omit(r,["clientOrderId","externalOid"]);const w=await this[m](this.extend(l,r));return this.parseOrder(w,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Oi(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(this.options,"cancelOrder",{}),r=this.safeString(n,"method","spotPrivateDeleteOrderCancel");let a=this.safeString(s,"method",r);const o=this.safeValue(s,"stop");let d={};if(i.type==="spot"){a="spotPrivateDeleteOrderCancel";const h=this.safeString2(s,"clientOrderId","client_order_ids");h!==void 0?(s=this.omit(s,["clientOrderId","client_order_ids"]),d.client_order_ids=h):d.order_ids=e}else if(o)if(a="contractPrivatePostPlanorderCancel",d=[],Array.isArray(e))for(let h=0;h<e.length;h++)d.push({symbol:i.id,orderId:e[h]});else typeof e=="string"&&d.push({symbol:i.id,orderId:e});else i.type==="swap"&&(a="contractPrivatePostOrderCancel",d=[e]);const c=await this[a](d);let u=this.safeValue(c,"data",[]);return o&&(u=c),this.parseOrder(u,i)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:t.type==="swap"?s={2:"open",3:"closed",4:"canceled"}:s={1:"open",2:"canceled",3:"closed"},this.safeString(s,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"data","id"),i;if(s===void 0){const T=Object.keys(e);s=this.safeString(T,0),this.safeString(e,s)==="success"&&(i="canceled")}const n=this.safeString(e,"state"),r=this.safeInteger2(e,"create_time","createTime"),a=this.safeString(e,"price"),o=this.safeString2(e,"quantity","vol"),d=this.safeString(e,"remain_quantity"),c=this.safeString2(e,"deal_quantity","dealVol"),u=this.safeString(e,"deal_amount"),h=this.safeString(e,"symbol"),f=this.safeSymbol(h,t,"_"),l=this.safeInteger(e,"side");let m;const g=this.safeString(e,"type");g==="BID"?m="buy":g==="ASK"&&(m="sell"),l===1?m="open long":m===2?m="close short":m===3?m="open short":m===4&&(m="close long"),i=this.parseOrderStatus(n,t);const y=this.safeString2(e,"client_order_id","orderId"),w=this.safeString2(e,"orderType","order_type");let b,S,v;return w!==void 0&&(v=!1,w==="1"?(b="limit",S="GTC"):w==="2"?(b="limit",S="PO",v=!0):w==="3"?(b="limit",S="IOC"):w==="4"?(b="limit",S="FOK"):w==="5"||w==="6"?(b="market",S="GTC"):w==="LIMIT_ORDER"?(b="limit",S="GTC"):w==="POST_ONLY"?(b="limit",S="PO",v=!0):w==="IMMEDIATE_OR_CANCEL"&&(b="limit",S="IOC")),this.safeOrder({id:s,clientOrderId:y,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:i,symbol:f,type:b,timeInForce:S,postOnly:v,side:m,price:a,stopPrice:this.safeString(e,"triggerPrice"),triggerPrice:this.safeString(e,"triggerPrice"),average:this.safeString(e,"dealAvgPrice"),amount:o,cost:u,filled:c,remaining:d,fee:void 0,trades:void 0,info:e},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oi(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),d=this.getSupportedMapping(a,{spot:"spotPrivateGetOrderOpenOrders",swap:"contractPrivateGetOrderListOpenOrdersSymbol"});if(this.safeValue(i,"stop"))return await this.fetchOrdersByState("1",e,t,s,i);const u=await this[d](this.extend(r,o)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Oi(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a={order_ids:e},o=this.getSupportedMapping(n,{spot:"spotPrivateGetOrderQuery",swap:"contractPrivateGetOrderBatchQuery"}),d=await this[o](this.extend(a,r)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);if(u===void 0)throw new DD(this.id+" fetchOrder() could not find the order id "+e);return this.parseOrder(u,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Oi(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id,states:e},o=this.safeValue(n,"stop"),d=o?"page_size":"limit";i!==void 0&&(a[d]=i),s!==void 0&&(a.start_time=s);const c=this.safeValue(this.options,"fetchOrdersByState",{}),u=this.safeString(c,"method","spotPrivateGetOrderList");let h=this.safeString(n,"method",u);h=this.getSupportedMapping(r.type,{spot:"spotPrivateGetOrderList",swap:"contractPrivateGetOrderListHistoryOrders"}),o&&(h="contractPrivateGetPlanorderListOrders");const f=this.omit(n,["method","stop"]),l=await this[h](this.extend(a,f)),m=this.safeValue(l,"data",[]);return this.parseOrders(m,r,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oi(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="CANCELED";return n.type==="swap"?a="4":r&&(a="2"),await this.fetchOrdersByState(a,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oi(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="FILLED";return(r||n.type==="swap")&&(a="3"),await this.fetchOrdersByState(a,e,t,s,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"spotPrivateDeleteOrderCancelBySymbol",swap:"contractPrivatePostOrderCancelAll"});this.safeValue(t,"stop")&&(n="contractPrivatePostPlanorderCancelAll");const a=this.omit(t,["method","stop"]);return await this[n](this.extend(i,a))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oi(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.start_time=t),s!==void 0&&(r.limit=s);const a=await this.spotPrivateGetOrderDeals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.spotPrivateGetOrderDealDetail(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,r,s,i)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new Oi(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r=this.market(e);t=this.amountToPrecision(e,t);const a={positionId:n,amount:t,type:s},o=await this.contractPrivatePostPositionChangeMargin(this.extend(a,i)),d=s==="ADD"?"add":"reduce";return this.extend(this.parseMarginModification(o,r),{amount:this.parseNumber(t),type:d})}parseMarginModification(e,t=void 0){const i=this.safeValue(e,"success")===!0?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:void 0,symbol:this.safeSymbol(void 0,t),status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new Oi(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.id,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchTransfer(e,t=void 0,s={}){const i={transact_id:e},n=await this.spotPrivateGetAssetInternalTransferInfo(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransfer(r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0){if(s>50)throw new op("This exchange supports a maximum limit of 50");n["page-size"]=s}const a=await this.spotPrivateGetAssetInternalTransferRecord(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransfers(d,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:t,from:o,to:d},u=await this.spotPrivatePostAssetInternalTransfer(this.extend(c,n)),h=this.safeValue(u,"data",{});return this.parseTransfer(h,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"transfer",{}),i=this.safeValue(s,"status",{}),n=this.safeString(e,"currency"),r=this.safeString(e,"transact_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(s,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.safeString(e,"transact_state");return{info:e,id:r,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),fromAccount:c,toAccount:u,status:this.safeString(i,h)}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+=":"+i);const d={currency:o.id,address:s,amount:t};a!==void 0&&(d.chain=a,n=this.omit(n,["network","chain"]));const c=await this.spotPrivatePostAssetWithdraw(this.extend(d,n)),u=this.safeValue(c,"data",{});return{info:u,id:this.safeString(u,"withdrawId")}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a][o]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json",source:this.safeString(this.options,"broker","CCXT")},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code");if(u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new op(h)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:f,datetime:this.iso8601(f),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oi(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const f=d[h],l=this.safeString(f,"symbol"),m=this.safeSymbol(l),g=this.safeInteger(f,"settleTime");c.push({info:f,symbol:m,fundingRate:this.safeNumber(f,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;zi.stringLt(d,n);){const h=zi.stringAdd(d,r);c.push({tier:this.parseNumber(zi.stringDiv(h,r)),currency:this.safeCurrencyCode(u),minNotional:this.parseNumber(d),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(zi.stringDiv("1",i)),info:e}),i=zi.stringAdd(i,o),s=zi.stringAdd(s,a),d=h}return c}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}};const GD=re,{BadRequest:jt,InvalidNonce:UD,BadSymbol:ek,InvalidOrder:ji,InvalidAddress:$D,ExchangeError:Hr,ArgumentsRequired:fs,NotSupported:tk,InsufficientFunds:Gr,PermissionDenied:WD}=Q,{TICK_SIZE:zD}=ne,Es=ae;var jD=class extends GD{describe(){return this.deepExtend(super.describe(),{id:"mexc3",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v3",has:{CORS:void 0,spot:void 0,margin:!0,swap:void 0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!0,deposit:void 0,editOrder:void 0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:void 0,fetchIndexOHLCV:!0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:void 0,setPositionMode:!0,signIn:void 0,transfer:void 0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://api.mexc.com",private:"https://api.mexc.com"},spot2:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/apidocs/spot_v3_en/","https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{spot:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:1,trades:1,historicalTrades:1,aggTrades:1,klines:1,avgPrice:1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1,"etf/info":1}},private:{get:{order:1,openOrders:1,allOrders:1,account:1,myTrades:1,"sub-account/list":1,"sub-account/apiKey":1,"capital/config/getall":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1,"capital/deposit/address":1,"capital/transfer":1,"capital/sub-account/universalTransfer":1,"margin/loan":1,"margin/allOrders":1,"margin/myTrades":1,"margin/openOrders":1,"margin/maxTransferable":1,"margin/priceIndex":1,"margin/order":1,"margin/isolated/account":1,"margin/maxBorrowable":1,"margin/repay":1,"margin/isolated/pair":1,"margin/forceLiquidationRec":1,"margin/isolatedMarginData":1,"margin/isolatedMarginTier":1,"rebate/taxQuery":1,"rebate/detail":1,"rebate/detail/kickback":1,"rebate/referCode":1,"mxDeduct/enable":1},post:{order:1,"order/test":1,"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"sub-account/futures":1,"sub-account/margin":1,batchOrders:1,"capital/withdraw/apply":1,"capital/transfer":1,"capital/deposit/address":1,"capital/sub-account/universalTransfer":1,"margin/tradeMode":1,"margin/order":1,"margin/loan":1,"margin/repay":1,"mxDeduct/enable":1},delete:{order:1,openOrders:1,"sub-account/apiKey":1,"margin/order":1,"margin/openOrders":1}}},contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2,"position/leverage":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot2:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"order/advanced/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:zD,timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{createMarketBuyOrderRequiresPrice:!0,unavailableContracts:{"BTC/USDT:USDT":!0,"LTC/USDT:USDT":!0,"ETH/USDT:USDT":!0},fetchMarkets:{types:{spot:!0,future:{linear:!1,inverse:!1},swap:{linear:!0,inverse:!1}}},timeframes:{spot:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},swap:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},networksById:{"BEP20(BSC)":"BSC"},networkAliases:{"BSC(BEP20)":"BSC"},recvWindow:5*1e3,maxTimeTillEnd:90*86400*1e3-1,broker:"CCXT"},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GMT:"GMT Token",STEPN:"GMT",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap"},exceptions:{exact:{"-1128":jt,"-2011":jt,"-1121":ek,10101:Gr,2009:ji,2011:jt,30004:Gr,33333:jt,44444:jt,1002:ji,30019:jt,30005:ji,2003:ji,2005:Gr,600:jt,70011:WD,88004:Gr,88009:Hr,88013:ji,88015:Gr,700003:UD},broad:{"Order quantity error, please try to modify.":jt,"Combination of optional parameters invalid":jt,"api market order is disabled":jt,"Contract not allow place order!":ji,Oversold:ji,"Insufficient position":Gr,"Insufficient balance!":Gr,"Bid price is great than max allow price":ji,"Invalid symbol.":ek,"Param error!":jt}}})}async fetchStatus(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);let i,n,r;return t==="spot"?(i=await this.spotPublicGetPing(s),n=Object.keys(i).length?this.json(i):"ok"):t==="swap"&&(i=await this.contractPublicGetPing(s),n=this.safeValue(i,"success")?"ok":this.json(i),r=this.safeInteger(i,"data")),{status:n,updated:r,url:void 0,eta:void 0,info:i}}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e);let i;if(t==="spot")return i=await this.spotPublicGetTime(s),this.safeInteger(i,"serverTime");if(t==="swap")return i=await this.contractPublicGetPing(s),this.safeInteger(i,"data")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.spotPrivateGetCapitalConfigGetall(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"coin"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name");let d=!1,c,u,h,f=!1,l=!1;const m={},g=this.safeValue(n,"networkList",[]);for(let b=0;b<g.length;b++){const S=g[b],v=this.safeString(S,"network"),T=this.safeNetwork(v),I=this.safeValue(S,"depositEnable",!1),A=this.safeValue(S,"withdrawEnable",!1),N=I&&A;d=N||d;const B=this.safeString(S,"withdrawMin"),x=this.safeString(S,"withdrawMax");u=u===void 0?B:u,h=h===void 0?x:h;const k=this.safeNumber(S,"withdrawFee");c=c===void 0?k:c,Es.stringGt(u,B)&&(u=B),Es.stringLt(h,x)&&(h=x),I&&(f=!0),A&&(l=!0),m[T]={info:S,id:v,network:T,active:N,deposit:I,withdraw:A,fee:k,precision:void 0,limits:{withdraw:{min:B,max:x}}}}const w=Object.keys(m).length;if(w===1||"NONE"in m){const b=this.safeValue2(m,"NONE",w-1);b!==void 0&&(c=b.fee)}s[a]={info:n,id:r,code:a,name:o,active:d,deposit:f,withdraw:l,fee:c,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:u,max:h}},networks:m}}return s}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchSwapMarkets(e);return this.arrayConcat(t,s)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"status"),f=this.safeValue(r,"isSpotTradingAllowed");let l=!1;h==="ENABLED"&&f&&(l=!0);const m=this.safeValue(r,"isMarginTradingAllowed"),g=this.safeNumber(r,"makerCommission"),y=this.safeNumber(r,"takerCommission"),w=this.safeNumber(r,"maxQuoteAmount");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:m,swap:!1,future:!1,option:!1,active:l,contract:!1,linear:void 0,inverse:void 0,taker:y,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"baseSizePrecision"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"quoteAmountPrecision"),max:w}},info:r})}return i}async fetchSwapMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),f=this.safeCurrencyCode(c),l=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+f,base:u,quote:h,settle:f,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:l==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r;if(i.spot){const a=await this.spotPublicGetDepth(this.extend(n,s));r=this.parseOrderBook(a,e),r.nonce=this.safeInteger(a,"lastUpdateId")}else if(i.swap){const a=await this.contractPublicGetDepthSymbol(this.extend(n,s)),o=this.safeValue(a,"data"),d=this.safeInteger(o,"timestamp");r=this.parseOrderBook(o,e,d),r.nonce=this.safeInteger(o,"version")}return r}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;if(n.spot){let o=this.safeString(this.options,"fetchTradesMethod","spotPublicGetAggTrades");o=this.safeString(i,"method",o),a=await this[o](this.extend(r,i))}else if(n.swap){const o=await this.contractPublicGetDealsSymbol(this.extend(r,i));a=this.safeValue(o,"data")}return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,d,c,u,h,f;if("v"in e)i=this.safeInteger(e,"t"),t=this.safeMarket(void 0,t),r=t.symbol,u=this.safeString(e,"p"),h=this.safeString(e,"v"),d=this.parseOrderSide(this.safeString(e,"T")),c="taker";else{const l=this.safeString(e,"symbol");if(t=this.safeMarket(l,t),r=t.symbol,s=this.safeString2(e,"id","a"),u=this.safeString2(e,"price","p"),n=this.safeString(e,"orderId"),"positionMode"in e)i=this.safeInteger(e,"timestamp"),h=this.safeString(e,"vol"),d=this.parseOrderSide(this.safeString(e,"side")),a={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))},c=this.safeValue(e,"taker")?"taker":"maker";else{i=this.safeInteger2(e,"time","T"),h=this.safeString2(e,"qty","q"),f=this.safeString(e,"quoteQty");const m=this.safeValue(e,"isBuyer"),g=this.safeValue(e,"isMaker"),y=this.safeString2(e,"isBuyerMaker","m");g!==void 0&&(c=g?"maker":"taker"),m!==void 0&&(d=m?"buy":"sell"),y!==void 0&&(d=y?"sell":"buy",c="taker");const w=this.safeString(e,"commissionAsset");w!==void 0&&(a={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(w)})}}return s===void 0&&(s=this.syntheticTradeId(t,i,d,h,u,void 0,c)),this.safeTrade({id:s,order:n,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:d,takerOrMaker:c,price:u,amount:h,cost:f,fee:a,info:e},t)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n)),a!==void 0&&(o+="-"+a),r!==void 0&&(o+="-"+r)),o}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t),c={symbol:r.id,interval:d};let u;if(r.spot)s!==void 0&&(c.startTime=s),i!==void 0&&(c.limit=i),u=await this.spotPublicGetKlines(this.extend(c,n));else if(r.swap){s!==void 0&&(c.start=parseInt(s/1e3));const h=this.safeString(n,"price","default");n=this.omit(n,"price");const f=this.getSupportedMapping(h,{default:"contractPublicGetKlineSymbol",index:"contractPublicGetKlineIndexPriceSymbol",mark:"contractPublicGetKlineFairPriceSymbol"}),l=await this[f](this.extend(c,n)),m=this.safeValue(l,"data");u=this.convertTradingViewToOHLCV(m,"time","open","high","low","close","vol")}return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i,n=!1;if(e!==void 0){n=e.length===1;const c=this.safeString(e,0);i=this.market(c)}const[r,a]=this.handleMarketTypeAndParams("fetchTickers",i,t);let o;if(n&&(s.symbol=i.id),r==="spot")o=await this.spotPublicGetTicker24hr(this.extend(s,a));else if(r==="swap"){const d=await this.contractPublicGetTicker(this.extend(s,a));o=this.safeValue(d,"data",[])}return n&&(o=[o]),this.parseTickers(o,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchTicker",s,t);let r;const a={symbol:s.id};if(i==="spot")r=await this.spotPublicGetTicker24hr(this.extend(a,n));else if(i==="swap"){const o=await this.contractPublicGetTicker(this.extend(a,n));r=this.safeValue(o,"data",{})}return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,n,r,a,o,d,c,u,h,f,l,m,g;return this.safeValue(t,"swap")||"timestamp"in e?(i=this.safeInteger(e,"timestamp"),n=this.safeNumber(e,"bid1"),r=this.safeNumber(e,"ask1"),d=this.safeString(e,"volume24"),c=this.safeString(e,"amount24"),h=this.safeNumber(e,"high24Price"),f=this.safeNumber(e,"lower24Price"),m=this.safeString(e,"riseFallValue"),l=this.safeString(e,"riseFallRate"),l=this.parseNumber(Es.stringMul(l,"100"))):(i=this.safeInteger(e,"closeTime"),n=this.safeNumber(e,"bidPrice"),r=this.safeNumber(e,"askPrice"),a=this.safeNumber(e,"bidQty"),o=this.safeNumber(e,"askQty"),a===0&&(a=void 0),o===0&&(o=void 0),d=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume"),u=this.safeString(e,"openPrice"),h=this.safeNumber(e,"highPrice"),f=this.safeNumber(e,"lowPrice"),g=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"priceChange"),l=this.safeString(e,"priceChangePercent"),l=this.parseNumber(Es.stringMul(l,"100"))),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:u,high:h,low:f,close:this.safeString(e,"lastPrice"),bid:n,bidVolume:a,ask:r,askVolume:o,vwap:void 0,previousClose:g,change:m,percentage:l,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();let s,i=!1;e!==void 0&&(i=e.length===1,s=this.market(e[0]));const[n,r]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t);let a;if(n==="spot")a=await this.spotPublicGetTickerBookTicker(r);else if(n==="swap")throw new tk(this.id+" fetchBidsAsks() is not available for "+n+" markets");return i&&(a=[a]),this.parseTickers(a,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r);if(a.spot)return await this.createSpotOrder(a,t,s,i,n,o,d);if(a.swap)return await this.createSwapOrder(a,t,s,i,n,o,d)}async createSpotOrder(e,t,s,i,n=void 0,r=void 0,a={}){const o=e.symbol,d=s==="buy"?"BUY":"SELL",c={symbol:e.id,side:d,type:t.toUpperCase()};if(d==="BUY"&&t==="market"){const l=this.safeNumber(a,"quoteOrderQty");if(l!==void 0)i=l;else if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new ji(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const m=this.numberToString(i),g=this.numberToString(n),y=Es.stringMul(m,g);i=this.parseNumber(y)}}c.quoteOrderQty=i}else c.quantity=this.amountToPrecision(o,i);n!==void 0&&(c.price=this.priceToPrecision(o,n));const u=this.safeString(a,"clientOrderId");u!==void 0&&(c.newClientOrderId=u,a=this.omit(a,["type","clientOrderId"]));let h="spotPrivatePostOrder";if(r!==void 0){if(r!=="isolated")throw new jt(this.id+" createOrder() does not support marginMode "+r+" for spot-margin trading");h="spotPrivatePostMarginOrder"}const f=await this[h](this.extend(c,a));return this.extend(this.parseOrder(f,e),{side:s,type:t,price:n,amount:i})}async createSwapOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=e.symbol,d=this.safeValue(this.options,"unavailableContracts",{});if(this.safeValue(d,o,!1))throw new tk(this.id+" createSwapOrder() does not support yet this symbol:"+o);let u;if(r!==void 0)if(r==="cross")u=2;else if(r==="isolated")u=1;else throw new fs(this.id+' createSwapOrder() marginMode parameter should be either "cross" or "isolated"');else u=this.safeInteger(a,"openType",2);if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new ji(this.id+" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");this.safeValue(a,"postOnly",!1)?t=2:t==="limit"?t=1:t==="market"&&(t=6);const f={symbol:e.id,vol:parseFloat(this.amountToPrecision(o,i)),type:t,openType:u};let l="contractPrivatePostOrderSubmit";const m=this.safeNumber2(a,"triggerPrice","stopPrice");if(a=this.omit(a,["stopPrice","triggerPrice"]),m&&(l="contractPrivatePostPlanorderPlace",f.triggerPrice=this.priceToPrecision(o,m),f.triggerType=this.safeInteger(a,"triggerType",1),f.executeCycle=this.safeInteger(a,"executeCycle",1),f.trend=this.safeInteger(a,"trend",1),f.orderType=this.safeInteger(a,"orderType",1)),t!==5&&t!==6&&t!=="market"&&(f.price=parseFloat(this.priceToPrecision(o,n))),u===1&&this.safeInteger(a,"leverage")===void 0)throw new fs(this.id+" createSwapOrder() requires a leverage parameter for isolated margin orders");this.safeValue(a,"reduceOnly",!1)?f.side=s==="buy"?2:4:f.side=s==="buy"?1:3;const y=this.safeString2(a,"clientOrderId","externalOid");y!==void 0&&(f.externalOid=y),a=this.omit(a,["clientOrderId","externalOid","postOnly"]);const w=await this[l](this.extend(f,a)),b=this.safeString(w,"data");return this.parseOrder(b,e)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new fs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id};let r;if(i.spot){const a=this.safeString(s,"clientOrderId");a!==void 0?(s=this.omit(s,"clientOrderId"),n.origClientOrderId=a):n.orderId=e;const[o,d]=this.handleMarginModeAndParams("fetchOrder",s);let c="spotPrivateGetOrder";if(o!==void 0){if(o!=="isolated")throw new jt(this.id+" fetchOrder() does not support marginMode "+o+" for spot-margin trading");c="spotPrivateGetMarginOrder"}r=await this[c](this.extend(n,d))}else if(i.swap){n.order_id=e;const a=await this.contractPrivateGetOrderGetOrderId(this.extend(n,s));r=this.safeValue(a,"data")}return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",r,i);if(a==="spot"){if(e===void 0)throw new fs(this.id+" fetchOrders() requires a symbol argument for spot market");const[d,c]=this.handleMarginModeAndParams("fetchOrders",i);let u="spotPrivateGetAllOrders";if(d!==void 0){if(d!=="isolated")throw new jt(this.id+" fetchOrders() does not support marginMode "+d+" for spot-margin trading");u="spotPrivateGetMarginAllOrders"}t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const h=await this[u](this.extend(n,c));return this.parseOrders(h,r,t,s)}else{t!==void 0&&(n.start_time=t,this.safeInteger(i,"end_time")===void 0&&(n.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(n.page_size=s);let d=this.safeString(this.options,"fetchOrders","contractPrivateGetOrderListHistoryOrders");d=this.safeString(o,"method",d);let c=[],u=[];if(d==="contractPrivateGetOrderListHistoryOrders"){const f=await this.contractPrivateGetOrderListHistoryOrders(this.extend(n,o));c=this.safeValue(f,"data")}else{const f=await this.contractPrivateGetPlanorderListOrders(this.extend(n,o));u=this.safeValue(f,"data")}const h=this.arrayConcat(u,c);return this.parseOrders(h,r,t,s,i)}}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i={};let n;t!==void 0&&(n=this.market(t),i.symbol=n.id);const[r,a]=this.handleMarketTypeAndParams("fetchOrdersByIds",n,s);if(r==="spot")throw new jt(this.id+" fetchOrdersByIds() is not supported for "+r);{i.order_ids=e.join(",");const o=await this.contractPrivateGetOrderBatchQuery(this.extend(i,a)),d=this.safeValue(o,"data");return this.parseOrders(d,n)}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),a==="spot"){if(e===void 0)throw new fs(this.id+" fetchOpenOrders() requires a symbol argument for spot market");let o="spotPrivateGetOpenOrders";const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);if(d!==void 0){if(d!=="isolated")throw new jt(this.id+" fetchOpenOrders() does not support marginMode "+d+" for spot-margin trading");o="spotPrivateGetMarginOpenOrders"}const u=await this[o](this.extend(n,c));return this.parseOrders(u,r,t,s)}else return await this.fetchOrdersByState(2,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(3,e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(4,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),r.id);const[a]=this.handleMarketTypeAndParams("fetchOrdersByState",r,n);if(a==="spot")throw new jt(this.id+" fetchOrdersByState() is not supported for "+a);return n.states=e,this.fetchOrders(t,s,i,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t),i.id);let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const[r,a]=this.handleMarginModeAndParams("cancelOrder",s);let o;if(n==="spot"){if(t===void 0)throw new fs(this.id+" cancelOrder() requires a symbol argument");const d={symbol:i.id},c=this.safeString(s,"clientOrderId");c!==void 0?(s=this.omit(a,"clientOrderId"),d.origClientOrderId=c):d.orderId=e;let u="spotPrivateDeleteOrder";if(r!==void 0){if(r!=="isolated")throw new jt(this.id+" cancelOrder() does not support marginMode "+r+" for spot-margin trading");u="spotPrivateDeleteMarginOrder"}o=await this[u](this.extend(d,a))}else{let d=this.safeString(this.options,"cancelOrder","contractPrivatePostOrderCancel");d=this.safeString(a,"method",d);const c=await this[d]([e]);o=this.safeValue(c,"data");const u=this.safeValue(o,0),h=this.safeValue(u,"errorMsg","");if(h!=="success")throw new ji(this.id+" cancelOrder() the order with id "+e+" cannot be cancelled: "+h)}return this.parseOrder(o,i)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,[n]=this.handleMarketTypeAndParams("cancelOrders",i,s);if(n==="spot")throw new jt(this.id+" cancelOrders() is not supported for "+n);{const r=await this.contractPrivatePostOrderCancel(e),a=this.safeValue(r,"data");return this.parseOrders(a,i)}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e!==void 0?this.market(e):void 0,i={};let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const[r,a]=this.handleMarginModeAndParams("cancelAllOrders",t);if(n==="spot"){if(e===void 0)throw new fs(this.id+" cancelAllOrders() requires a symbol argument on spot");i.symbol=s.id;let o="spotPrivateDeleteOpenOrders";if(r!==void 0){if(r!=="isolated")throw new jt(this.id+" cancelAllOrders() does not support marginMode "+r+" for spot-margin trading");o="spotPrivateDeleteMarginOpenOrders"}const d=await this[o](this.extend(i,a));return this.parseOrders(d,s)}else{e!==void 0&&(i.symbol=s.id);let o=this.safeString(this.options,"cancelAllOrders","contractPrivatePostOrderCancelAll");o=this.safeString(a,"method",o);const d=await this[o](this.extend(i,a)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,s)}}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString2(e,"orderId","id");const i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeIntegerN(e,["time","createTime","transactTime"]);let r;const a=this.safeString(e,"feeCurrency");if(a!==void 0){const o=this.safeString(e,"takerFee"),d=this.safeString(e,"makerFee"),c=Es.stringAdd(o,d);r={currency:a,cost:this.parseNumber(c)}}return this.safeOrder({id:s,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString2(e,"status","state")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeNumber(e,"price"),stopPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),triggerPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),average:this.safeNumber(e,"dealAvgPrice"),amount:this.safeNumber2(e,"origQty","vol"),cost:this.safeNumber(e,"cummulativeQuoteQty"),filled:this.safeNumber2(e,"executedQty","dealVol"),remaining:void 0,fee:r,trades:void 0,info:e},t)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",2:"open",3:"closed",4:"canceled"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}async fetchAccountHelper(e,t){if(e==="spot")return await this.spotPrivateGetAccount(t);if(e==="swap"){const s=await this.contractPrivateGetAccountAssets(t);return this.safeValue(s,"data")}}async fetchAccounts(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchAccounts",void 0,e);await this.loadMarkets();const i=await this.fetchAccountHelper(t,s),n=this.safeValue(i,"balances",[]),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString2(o,"asset","currency"),c=this.safeCurrencyCode(d);r.push({id:this.safeString(o,"id"),type:this.safeString(o,"type"),code:c,info:o})}return r}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.fetchAccountHelper("spot",e);let s=this.safeString(t,"makerCommission"),i=this.safeString(t,"takerCommission");s=Es.stringDiv(s,"1000"),i=Es.stringDiv(i,"1000");const n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={symbol:a,maker:this.parseNumber(s),taker:this.parseNumber(i),percentage:!0,tierBased:!1,info:t}}return n}parseBalance(e,t){let s;t==="margin"?s=this.safeValue(e,"assets",[]):t==="swap"?s=this.safeValue(e,"data",[]):s=this.safeValue(e,"balances",[]);const i={info:e};if(t==="margin"){for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeSymbol(a,void 0),d=this.safeValue(r,"baseAsset",{}),c=this.safeValue(r,"quoteAsset",{}),u=this.safeCurrencyCode(this.safeString(d,"asset")),h=this.safeCurrencyCode(this.safeString(c,"asset")),f={};f[u]=this.parseBalanceHelper(d),f[h]=this.parseBalanceHelper(c),i[o]=this.safeBalance(f)}return i}else if(t==="swap"){for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"availableBalance"),d.used=this.safeString(r,"frozenBalance"),i[o]=d}return this.safeBalance(i)}else{for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),i[o]=d}return this.safeBalance(i)}}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free"),t.total=this.safeString(e,"totalAsset");const s=this.safeString(e,"borrowed"),i=this.safeString(e,"interest");return t.debt=Es.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();let t;const s={};[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i=this.getSupportedMapping(t,{spot:"spotPrivateGetAccount",swap:"contractPrivateGetAccountAssets",margin:"spotPrivateGetMarginIsolatedAccount"});const n=this.safeString(e,"marginMode"),r=this.safeValue(e,"margin",!1);if(n!==void 0||r||t==="margin"){let o;const d=this.safeString(e,"symbol");if(d===void 0){const c=this.safeValue(e,"symbols");c!==void 0&&(o=this.marketIds(c).join(","))}else o=this.market(d).id;this.checkRequiredArgument("fetchBalance",o,"symbol or symbols"),i="spotPrivateGetMarginIsolatedAccount",t="margin",s.symbols=o}e=this.omit(e,["margin","marginMode","symbol","symbols"]);const a=await this[i](this.extend(s,e));return this.parseBalance(a,t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),o={symbol:n.id};let d;if(r==="spot")t!==void 0&&(o.start_time=t),s!==void 0&&(o.limit=s),d=await this.spotPrivateGetMyTrades(this.extend(o,a));else{t!==void 0&&(o.start_time=t,this.safeInteger(i,"end_time")===void 0&&(o.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(o.page_size=s);const c=await this.contractPrivateGetOrderListOrderDeals(this.extend(o,a));d=this.safeValue(c,"data")}return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t));const[o,d]=this.handleMarketTypeAndParams("fetchOrderTrades",a,n);let c;if(o==="spot"){if(t===void 0)throw new fs(this.id+" fetchOrderTrades() requires a symbol argument");r.symbol=a.id,r.orderId=e,c=await this.spotPrivateGetMyTrades(this.extend(r,d))}else{r.order_id=e;const u=await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(r,d));c=this.safeValue(u,"data")}return this.parseTrades(c,a,s,i,d)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new fs(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r={positionId:n,amount:t,type:s};return await this.contractPrivatePostPositionChangeMargin(this.extend(r,i))}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new fs(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.symbol,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:f,datetime:this.iso8601(f),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fs(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const f=d[h],l=this.safeString(f,"symbol"),m=this.safeSymbol(l),g=this.safeInteger(f,"settleTime");c.push({info:f,symbol:m,fundingRate:this.safeNumber(f,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;Es.stringLt(d,n);){const h=Es.stringAdd(d,r);c.push({tier:this.parseNumber(Es.stringDiv(h,r)),currency:this.safeCurrencyCode(u),notionalFloor:this.parseNumber(d),notionalCap:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(Es.stringDiv("1",i)),info:e}),i=Es.stringAdd(i,o),s=Es.stringAdd(s,a),d=h}return c}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotPrivateGetCapitalDepositAddress(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"coin"),c=this.currency(d),u=this.safeString(o,"network"),h=this.safeNetwork(u),f=this.safeString(o,"address",void 0),l=this.safeString2(o,"tag","memo",void 0);r.push({currency:c.id,network:h,address:f,tag:l})}return r}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t);if(s!==void 0)for(let r=0;r<i.length;r++){const a=i[r],o=this.safeStringUpper(a,"network");if(s===o)return a}const n=this.safeValue(i,0);if(n===void 0)throw new $D(this.id+" fetchDepositAddress() cannot find a deposit address for "+e+", consider creating one using the MEXC platform");return n}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fs(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n={};let r;const a=this.safeString(i,"network");if(i=this.omit(i,"network"),a===void 0)throw new fs(this.id+" fetchDeposits() requires a network parameter when the currency is specified");if(r=this.currency(e),n.coin=r.id+"-"+a,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Hr("This exchange supports a maximum limit of 1000");n.limit=s}const o=await this.spotPrivateGetCapitalDepositHisrec(this.extend(n,i));return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fs(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n={},r=this.currency(e);if(n.coin=r.id,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Hr("This exchange supports a maximum limit of 1000");n.limit=s}const a=await this.spotPrivateGetCapitalWithdrawHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.safeInteger2(e,"insertTime","applyTime"),r=this.safeString(e,"currency"),a=this.safeString(e,"network"),o=this.safeCurrencyCode(r,t),d=this.parseTransactionStatus(this.safeString(e,"status"));let c=this.safeString(e,"amount");const u=this.safeString(e,"address"),h=this.safeString(e,"txId");let f;const l=this.safeString(e,"transactionFee");return l!==void 0&&(f={cost:this.parseNumber(l),currency:o}),i==="withdrawal"&&(c=Es.stringSub(c,l)),{info:e,id:s,txid:h,timestamp:n,datetime:this.iso8601(n),network:a,address:u,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"memo"),tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(c),currency:o,status:d,updated:void 0,fee:f}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.fetchPositions(void 0,this.extend(i,t));return this.safeValue(n,0)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeNumber(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),f=this.safeNumber(e,"updateTime");return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginType:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:f,datetime:this.iso8601(f)}}async fetchTransfer(e,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfer",void 0,i);if(await this.loadMarkets(),n==="spot"){const a={transact_id:e},o=await this.spot2PrivateGetAssetInternalTransferInfo(this.extend(a,r)),d=this.safeValue(o,"data",{});return this.parseTransfer(d)}else if(n==="swap")throw new jt(this.id+" fetchTransfer() is not supported for "+n)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfers",void 0,i);await this.loadMarkets();const a={};let o,d;if(e!==void 0&&(o=this.currency(e),a.currency=o.id),n==="spot"){if(t!==void 0&&(a.start_time=t),s!==void 0){if(s>50)throw new Hr("This exchange supports a maximum limit of 50");a["page-size"]=s}const c=await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data",{});d=this.safeValue(u,"result_list",[])}else if(n==="swap"){s!==void 0&&(a.page_size=s);const c=await this.contractPrivateGetAccountTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data");d=this.safeValue(u,"resultList")}return this.parseTransfers(d,o,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={spot:"SPOT",swap:"FUTURES",margin:"ISOLATED_MARGIN"},o=this.safeString(a,s),d=this.safeString(a,i);if(o===void 0){const f=Object.keys(a);throw new Hr(this.id+" fromAccount must be one of "+f.join(", "))}if(d===void 0){const f=Object.keys(a);throw new Hr(this.id+" toAccount must be one of "+f.join(", "))}const c={asset:r.id,amount:t,fromAccountType:o,toAccountType:d};if(o==="ISOLATED_MARGIN"||d==="ISOLATED_MARGIN"){const f=this.safeString(n,"symbol");if(n=this.omit(n,"symbol"),f===void 0)throw new fs(this.id+" transfer() requires a symbol argument for isolated margin");const l=this.market(f);c.symbol=l.id}const u=await this.spotPrivatePostCapitalTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeStringN(e,["transact_id","txid","tranId"]),n=this.safeInteger(e,"createTime"),r=n!==void 0?this.iso8601(n):void 0,a=this.safeString(e,"type");let o,d;return a!==void 0?(o=a==="IN"?"MAIN":"CONTRACT",d=a==="IN"?"CONTRACT":"MAIN"):(o=this.safeString(e,"from"),d=this.safeString(e,"to")),{info:e,id:i,timestamp:n,datetime:r,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseAccountId(o),toAccount:this.parseAccountId(d),status:this.parseTransferStatus(this.safeString2(e,"transact_state","state"))}}parseAccountId(e){const t={MAIN:"spot",CONTRACT:"swap"};return this.safeString(t,e,e)}parseTransferStatus(e){const t={SUCCESS:"ok",FAILED:"failed",WAIT:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),d={coin:o.id,address:s,amount:t};i!==void 0&&(d.memo=i),a!==void 0&&(d.network=a,n=this.omit(n,"network"));const c=await this.spotPrivatePostCapitalWithdrawApply(this.extend(d,n));return this.parseTransaction(c,o)}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new fs(this.id+" borrowMargin() requires a symbol argument for isolated margin");const n=this.market(s),r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t),symbol:n.id},o=await this.spotPrivatePostMarginLoan(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new fs(this.id+" repayMargin() requires a symbol argument for isolated margin");const n=this.safeString2(i,"id","borrowId");if(n===void 0)throw new fs(this.id+" repayMargin() requires a borrowId argument in the params");const r=this.market(s),a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t),borrowId:n,symbol:r.id},d=await this.spotPrivatePostMarginRepay(this.extend(o,i)),c=this.parseMarginLoan(d,a);return this.extend(c,{amount:t,symbol:s})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"coin"),a=this.safeCurrency(r),o=this.safeString(a,"code");(t===void 0||this.inArray(o,t))&&(s[o]=this.parseTransactionFee(n,a))}return{withdraw:s,deposit:{},info:e}}parseTransactionFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.safeString(this.options.networks,a,a),d=this.safeNumber(r,"withdrawFee");i[o]=d}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseDepositWithdrawFees(s,e,"coin")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i=this.depositWithdrawFee(e);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.networkIdToCode(a,this.safeString(t,"code"));i.networks[o]={withdraw:{fee:this.safeNumber(r,"withdrawFee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return this.assignDefaultDepositWithdrawFees(i)}parseMarginLoan(e,t=void 0){return{id:this.safeString(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;return[r,t]=super.handleMarginModeAndParams(e,t,s),(i==="margin"||n===!0)&&(r="isolated"),[r,t]}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;[e,i]=this.resolvePath(e,i);let d;if(a==="spot"){d=this.urls.api[a][o]+"/api/"+this.version+"/"+e;let c="";if(o==="private"&&(i.timestamp=this.milliseconds(),i.recvWindow=this.safeInteger(this.options,"recvWindow",5e3)),Object.keys(i).length&&(c=this.urlencode(i),d+="?"+c),o==="private"){this.checkRequiredCredentials();const u=this.hmac(this.encode(c),this.encode(this.secret),"sha256");d+="&signature="+u,n={"X-MEXC-APIKEY":this.apiKey,source:this.safeString(this.options,"broker","CCXT")}}s==="POST"&&(n["Content-Type"]="application/json")}else if(a==="contract"||a==="spot2")if(d=this.urls.api[a][o]+"/"+this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json",source:this.safeString(this.options,"broker","CCXT")},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code",void 0);if(u!==void 0&&u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new Hr(h)}}};const KD=re,{AuthenticationError:XD,ExchangeError:pu,PermissionDenied:YD,BadRequest:ZD,CancelPending:QD,OrderNotFound:JD,InsufficientFunds:sk,RateLimitExceeded:e6,InvalidOrder:hn,AccountSuspended:t6,BadSymbol:ik,OnMaintenance:s6,ArgumentsRequired:i6,AccountNotEnabled:n6}=Q,{TICK_SIZE:r6}=ne;var a6=class extends KD{describe(){return this.deepExtend(super.describe(),{id:"novadax",name:"NovaDAX",countries:["BR"],rateLimit:16.6667,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"ONE_MIN","5m":"FIVE_MIN","15m":"FIFTEEN_MIN","30m":"HALF_HOU","1h":"ONE_HOU","1d":"ONE_DAY","1w":"ONE_WEE","1M":"ONE_MON"},urls:{logo:"https://user-images.githubusercontent.com/1294454/92337550-2b085500-f0b3-11ea-98e7-5794fb07dd3b.jpg",api:{public:"https://api.novadax.com",private:"https://api.novadax.com"},www:"https://www.novadax.com.br",doc:["https://doc.novadax.com/pt-BR/"],fees:"https://www.novadax.com.br/fees-and-limits",referral:"https://www.novadax.com.br/?s=ccxt"},api:{public:{get:{"common/symbol":1.2,"common/symbols":1.2,"common/timestamp":1.2,"market/tickers":1.2,"market/ticker":1.2,"market/depth":1.2,"market/trades":1.2,"market/kline/history":1.2}},private:{get:{"orders/get":3,"orders/list":3,"orders/fill":3,"orders/fills":3,"account/getBalance":3,"account/subs":3,"account/subs/balance":3,"account/subs/transfer/record":3,"wallet/query/deposit-withdraw":3},post:{"orders/create":3,"orders/cancel":3,"account/withdraw/coin":3,"account/subs/transfer":3}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:r6,exceptions:{exact:{A99999:pu,A10001:ZD,A10002:pu,A10003:XD,A10004:e6,A10005:YD,A10006:t6,A10007:n6,A10011:ik,A10012:ik,A10013:s6,A30001:JD,A30002:hn,A30003:hn,A30004:hn,A30005:hn,A30006:hn,A30007:sk,A30008:hn,A30009:hn,A30010:QD,A30011:hn,A30012:hn,A40004:sk},broad:{}},options:{fetchOHLCV:{volume:"amount"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"baseCurrency"),o=this.safeString(r,"quoteCurrency"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeString(r,"status");s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"valuePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOrderValue"),max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"open24h"),a=this.safeString(e,"lastPrice"),o=this.safeString(e,"baseVolume24h"),d=this.safeString(e,"quoteVolume24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"orderId"),n=this.safeInteger(e,"timestamp"),r=this.safeStringLower(e,"side"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"symbol"),c=this.safeSymbol(d,t,"_"),u=this.safeStringLower(e,"role"),h=this.safeString(e,"fee");let f;if(h!==void 0){const l=this.safeString(e,"feeCurrency"),m=this.safeCurrencyCode(l);f={cost:this.safeString(e,"feeAmount"),currency:m}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:void 0,side:r,price:a,amount:o,cost:void 0,takerOrMaker:u,fee:f,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,unit:this.timeframes[t]},o=this.parseTimeframe(t),d=this.seconds();if(i===void 0&&(i=3e3),s===void 0)a.from=d-i*o,a.to=d;else{const h=parseInt(s/1e3);a.from=h,a.to=this.sum(h,i*o)}const c=await this.publicGetMarketKlineHistory(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeValue(this.options,"fetchOHLCV",{}),i=this.safeString(s,"volume","amount");return[this.safeTimestamp(e,"score"),this.safeNumber(e,"openPrice"),this.safeNumber(e,"highPrice"),this.safeNumber(e,"lowPrice"),this.safeNumber(e,"closePrice"),this.safeNumber(e,i)]}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"available"),o.used=this.safeString(n,"hold"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountGetBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=t.toUpperCase();const d=s.toUpperCase(),c={symbol:a.id,side:d},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u===void 0){if(o==="STOP_LIMIT"||o==="STOP_MARKET")throw new i6(this.id+" createOrder() requires a stopPrice parameter for "+o+" orders")}else{o==="LIMIT"?o="STOP_LIMIT":o==="MARKET"&&(o="STOP_MARKET");const l=d==="BUY"?"LTE":"GTE";c.operator=this.safeString(r,"operator",l),c.stopPrice=this.priceToPrecision(e,u),r=this.omit(r,["triggerPrice","stopPrice"])}if(o==="LIMIT"||o==="STOP_LIMIT")c.price=this.priceToPrecision(e,n),c.amount=this.amountToPrecision(e,i);else if(o==="MARKET"||o==="STOP_MARKET"){if(d==="SELL")c.amount=this.amountToPrecision(e,i);else if(d==="BUY"){let l=this.safeNumber(r,"value");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)l===void 0&&(l=i*n);else if(l===void 0)throw new hn(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'value' extra parameter (the exchange-specific behaviour)")}else l=l===void 0?i:l;c.value=this.costToPrecision(e,l)}}c.type=o;const h=await this.privatePostOrdersCreate(this.extend(c,r)),f=this.safeValue(h,"data",{});return this.parseOrder(f,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersGet(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersList(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"SUBMITTED,PROCESSING,PARTIAL_FILLED,CANCELING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"FILLED,CANCELED,REJECTED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersFill(this.extend(r,n));let o;t!==void 0&&(o=this.market(t));const d=this.safeValue(a,"data",[]);return this.parseTrades(d,o,s,i)}parseOrderStatus(e){const t={SUBMITTED:"open",PROCESSING:"open",PARTIAL_FILLED:"open",CANCELING:"open",FILLED:"closed",CANCELED:"canceled",REJECTED:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=this.safeString(e,"price"),r=this.safeString2(e,"filledValue","value"),a=this.safeStringLower(e,"type"),o=this.safeStringLower(e,"side"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeInteger(e,"timestamp"),u=this.safeString(e,"averagePrice"),h=this.safeString(e,"filledAmount");let f;const l=this.safeNumber(e,"filledFee");l!==void 0&&(f={cost:l,currency:void 0});const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t,"_"),y=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:g,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:n,stopPrice:y,triggerPrice:y,amount:i,cost:r,average:u,filled:h,remaining:void 0,status:d,fee:f,trades:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(s!=="main"&&i!=="main")throw new pu(this.id+" transfer() supports transfers between main account and subaccounts only");const a=s==="main"?"master-transfer-in":"master-transfer-out",o={transferAmount:this.currencyToPrecision(e,t),currency:r.id,subId:a==="master-transfer-in"?i:s,transferType:a},d=await this.privatePostAccountSubsTransfer(this.extend(o,n)),c=this.parseTransfer(d,r),u=this.safeValue(this.options,"transfer",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.fromAccount=s,c.toAccount=i,c.amount=t),c}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeString(e,"message"),n=this.safeCurrencyCode(void 0,t);return{info:e,id:s,amount:void 0,code:n,currency:n,fromAccount:void 0,toAccount:void 0,timestamp:void 0,datetime:void 0,status:i}}parseTransferStatus(e){const t={SUCCESS:"pending"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={code:r.id,amount:this.currencyToPrecision(e,t),wallet:s};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdrawCoin(this.extend(a,n));return this.parseTransaction(o,r)}async fetchAccounts(e={}){const t=await this.privateGetAccountSubs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"subId"),o=this.safeString(r,"subAccount");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_in"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_out"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.size=s);const a=await this.privateGetWalletQueryDepositWithdraw(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){const t=e.split(" ");e=this.safeString(t,1,e);const s={Pending:"pending",confirming:"pending",SUCCESS:"ok",FAIL:"failed"};return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","data");let i=this.safeString(e,"type");i==="COIN_IN"?i="deposit":i==="COIN_OUT"&&(i="withdraw");const n=this.safeNumber(e,"amount"),r=this.safeString(e,"address"),a=this.safeString(e,"addressTag"),o=this.safeString(e,"txHash"),d=this.safeInteger(e,"createdAt"),c=this.safeInteger(e,"updatedAt"),u=this.safeString(e,"currency"),h=this.safeCurrencyCode(u,t),f=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeString(e,"chain");return{info:e,id:s,currency:h,amount:n,network:l,address:r,addressTo:r,addressFrom:void 0,tag:a,tagTo:a,tagFrom:void 0,status:f,type:i,updated:c,txid:o,timestamp:d,datetime:this.iso8601(d),fee:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersFills(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.milliseconds().toString();n={"X-Nova-Access-Key":this.apiKey,"X-Nova-Timestamp":c};let u;s==="POST"?(r=this.json(d),u=this.hash(this.encode(r),"md5"),n["Content-Type"]="application/json"):(Object.keys(d).length&&(o+="?"+this.urlencode(d)),u=this.urlencode(this.keysort(d)));const h=s+`
`+a+`
`+u+`
`+c;n["X-Nova-Signature"]=this.hmac(this.encode(h),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!=="A10000"){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new pu(h)}}};const o6=re,{ExchangeError:d6,AuthenticationError:wd,ArgumentsRequired:nk,BadRequest:bd,InvalidOrder:c6,InsufficientFunds:u6,OrderNotFound:cp,PermissionDenied:rk}=Q,{TICK_SIZE:h6}=ne;var f6=class extends o6{describe(){return this.deepExtend(super.describe(),{id:"oceanex",name:"OceanEx",countries:["BS"],version:"v1",rateLimit:3e3,urls:{logo:"https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",api:{rest:"https://api.oceanex.pro"},www:"https://www.oceanex.pro.com",doc:"https://api.oceanex.pro/doc/v1",referral:"https://oceanex.pro/signup?referral=VE24QX"},has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarkets:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFees:void 0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1440","3d":"4320","1w":"10080"},api:{public:{get:["markets","tickers/{pair}","tickers_multi","order_book","order_book/multi","fees/trading","trades","timestamp"],post:["k"]},private:{get:["key","members/me","orders","orders/filter"],post:["orders","orders/multi","order/delete","order/delete/multi","orders/clear"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}},commonCurrencies:{PLA:"Plair"},precisionMode:h6,exceptions:{codes:{"-1":bd,"-2":bd,1001:bd,1004:nk,1006:wd,1008:wd,1010:wd,1011:rk,2001:wd,2002:c6,2004:cp,9003:rk},exact:{"market does not have a valid value":bd,"side does not have a valid value":bd,"Account::AccountError: Cannot lock funds":u6,"The account does not exist":wd}}})}async fetchMarkets(e={}){const t={show_details:!0},s=await this.publicGetMarkets(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(a,"id"),d=this.safeValue(a,"name");let[c,u]=d.split("/");const h=this.safeCurrencyCode(c),f=this.safeCurrencyCode(u);c=c.toLowerCase(),u=u.toLowerCase();const l=h+"/"+f;i.push({id:o,symbol:l,base:h,quote:f,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minimum_trading_amount"),max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e),e===void 0&&(e=this.symbols);const i={markets:this.marketIds(e)},n=await this.publicGetTickersMulti(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeMarket(c),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeValue(e,"ticker",{}),i=this.safeTimestamp(e,"at"),n=this.safeSymbol(void 0,t);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(s,"high"),low:this.safeString(s,"low"),bid:this.safeString(s,"buy"),bidVolume:void 0,ask:this.safeString(s,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(s,"last"),last:this.safeString(s,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(s,"volume"),quoteVolume:void 0,info:s},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,e,o)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const n={markets:this.marketIds(e)};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookMulti(this.extend(n,s)),a=this.safeValue(r,"data",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"market"),h=this.safeSymbol(u),f=this.safeTimestamp(c,"timestamp");o[h]=this.parseOrderBook(c,h,f)}return o}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){let s=this.safeValue(e,"side");s==="bid"?s="buy":s==="ask"&&(s="sell");const i=this.safeValue(e,"market"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"volume");return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:this.safeString(e,"id"),order:void 0,type:"limit",takerOrMaker:void 0,side:s,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeTimestamp(t,"data")}async fetchTradingFees(e={}){const t=await this.publicGetFeesTrading(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"ask_fee",{}),o=this.safeValue(r,"bid_fee",{}),d=this.safeString(r,"market"),c=this.safeSymbol(d);i[c]={info:r,symbol:c,maker:this.safeNumber(a,"value"),taker:this.safeNumber(o,"value"),percentage:!0}}return i}async fetchKey(e={}){const t=await this.privateGetKey(e);return this.safeValue(t,"data")}parseBalance(e){const t=this.safeValue(e,"data"),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"balance"),d.used=this.safeString(r,"locked"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,ord_type:t,volume:this.amountToPrecision(e,i)};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){let i=e;Array.isArray(e)||(i=[e]),await this.loadMarkets();let n;t!==void 0&&(n=this.market(t));const r={ids:i},a=await this.privateGetOrders(this.extend(r,s)),o=this.safeValue(a,"data"),d=o.length;if(o===void 0)throw new cp(this.id+" could not found matching order");if(Array.isArray(e))return this.parseOrders(o,n);if(d===0)throw new cp(this.id+" could not found matching order");return this.parseOrder(o[0],n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["wait"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["done","cancel"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new nk(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"states",["wait","done","cancel"]),a=this.omit(i,"states"),o={market:n.id,states:r,need_price:"True"};s!==void 0&&(o.limit=s);const d=await this.privateGetOrdersFilter(this.extend(o,a)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const f=this.safeValue(c[h],"orders",[]),l=this.parseOrderStatus(this.safeValue(c[h],"state")),m=this.parseOrders(f,n,t,s,{status:l});u=this.arrayConcat(u,m)}return u}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]};s!==void 0&&(a.timestamp=s),i!==void 0&&(a.limit=i);const o=await this.publicPostK(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeValue(e,"state")),i=this.safeString2(e,"market","market_id"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"volume"),c=this.safeString(e,"remaining_volume"),u=this.safeString(e,"executed_volume");return this.safeOrder({info:e,id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:this.safeValue(e,"ord_type"),timeInForce:void 0,postOnly:void 0,side:this.safeValue(e,"side"),price:a,stopPrice:void 0,triggerPrice:void 0,average:o,amount:d,remaining:c,filled:u,status:s,cost:void 0,trades:void 0,fee:void 0},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}async createOrders(e,t,s={}){await this.loadMarkets();const n={market:this.market(e).id,orders:t},a=(await this.privatePostOrdersMulti(this.extend(n,s))).data;return this.parseOrders(a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDelete(this.extend({id:e},s)),n=this.safeValue(i,"data");return this.parseOrder(n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDeleteMulti(this.extend({ids:e},s)),n=this.safeValue(i,"data");return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostOrdersClear(t),i=this.safeValue(s,"data");return this.parseOrders(i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")if(e==="tickers_multi"||e==="order_book/multi"){let d="?";const c=this.safeValue(i,"markets");for(let h=0;h<c.length;h++)d+="markets[]="+c[h]+"&";const u=this.safeValue(i,"limit");u!==void 0&&(d+="limit="+u),a+=d}else Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){this.checkRequiredCredentials();const d={uid:this.apiKey,data:o},c=this.jwt(d,this.encode(this.secret),"RS256");a+="?user_jwt="+c}return n={"Content-Type":"application/json"},{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.codes,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new d6(h)}}};const l6=re,{ExchangeError:Y,ExchangeNotAvailable:Na,OnMaintenance:p6,ArgumentsRequired:js,BadRequest:Kt,AccountSuspended:mu,InvalidAddress:up,PermissionDenied:as,DDoSProtection:ak,InsufficientFunds:Ki,InvalidNonce:m6,CancelPending:g6,InvalidOrder:ue,OrderNotFound:hp,AuthenticationError:ii,RequestTimeout:ok,NotSupported:Ur,BadSymbol:dk,RateLimitExceeded:ck}=Q,{TICK_SIZE:y6}=ne,ft=ae;var ET=class extends l6{describe(){return this.deepExtend(super.describe(),{id:"okcoin",name:"OKCoin",countries:["CN","US"],version:"v3",rateLimit:20,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!0,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchLedger:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2678400","3M":"8035200","6M":"16070400","1y":"31536000"},hostname:"okcoin.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg",api:{rest:"https://www.{hostname}"},www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513",test:{rest:"https://testnet.okex.com"}},api:{general:{get:{time:8.3334}},account:{get:{wallet:8.3334,"sub-account":1e3,"asset-valuation":1e3,"wallet/{currency}":8.3334,"withdrawal/history":8.3334,"withdrawal/history/{currency}":8.3334,ledger:5,"deposit/address":8.3334,"deposit/history":8.3334,"deposit/history/{currency}":8.3334,currencies:8.3334,"withdrawal/fee":8.3334,"deposit-lightning":50,"withdrawal-lightning":50,"fiat/deposit/detail":5,"fiat/deposit/details":8.3334,"fiat/withdraw/detail":5,"fiat/withdraw/details":8.3334,"fiat/channel":8.3334},post:{transfer:100,withdrawal:8.3334,"fiat/cancel_deposit":1,"fiat/deposit":8.3334,"fiat/withdraw":8.3334,"fiat/cancel_withdrawal":1}},otc:{get:{"rfq/instruments":50,"rfq/trade":50,"rfq/history":50},post:{"rfq/quote":50,"rfq/trade":50}},users:{get:{"subaccount-info":20,"account-info":20,"subaccount/apikey":20},post:{"create-subaccount":5,"delete-subaccount":5,"subaccount/apikey":50,"subacount/delete-apikey":20,"subacount/modify-apikey":20}},earning:{get:{offers:5,orders:5,positions:8.3334},post:{purchase:5,redeem:5,cancel:5}},spot:{get:{accounts:5,"accounts/{currency}":5,"accounts/{currency}/ledger":5,orders:10,orders_pending:5,"orders/{order_id}":5,"orders/{client_oid}":5,trade_fee:5,fills:10,algo:5,instruments:5,"instruments/{instrument_id}/book":5,"instruments/ticker":5,"instruments/{instrument_id}/ticker":5,"instruments/{instrument_id}/trades":5,"instruments/{instrument_id}/candles":5},post:{order_algo:2.5,orders:1,batch_orders:2,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_algos:5,cancel_batch_orders:5,"amend_order/{instrument_id}":2.5,amend_batch_orders:5}},margin:{get:{accounts:5,"accounts/{instrument_id}":5,"accounts/{instrument_id}/ledger":5,"accounts/availability":5,"accounts/{instrument_id}/availability":5,"accounts/borrowed":5,"accounts/{instrument_id}/borrowed":5,orders:10,"accounts/{instrument_id}/leverage":1,"orders/{order_id}":5,"orders/{client_oid}":5,orders_pending:5,fills:10,"instruments/{instrument_id}/mark_price":5},post:{"accounts/borrow":1,"accounts/repayment":1,orders:1,batch_orders:2,cancel_orders:1,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_orders:2,"amend_order/{instrument_id}":2.5,amend_batch_orders:5,"accounts/{instrument_id}/leverage":1}},system:{get:{status:250}},market:{get:{oracle:250}},futures:{get:["position","{instrument_id}/position","accounts","accounts/{underlying}","accounts/{underlying}/leverage","accounts/{underlying}/ledger","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","trade_fee","accounts/{instrument_id}/holds","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/estimated_price","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/liquidation"],post:["accounts/{underlying}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","accounts/margin_mode","close_position","cancel_all","order_algo","cancel_algos"]},swap:{get:["position","{instrument_id}/position","accounts","{instrument_id}/accounts","accounts/{instrument_id}/settings","accounts/{instrument_id}/ledger","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","accounts/{instrument_id}/holds","trade_fee","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/depth","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/funding_time","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/historical_funding_rate"],post:["accounts/{instrument_id}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","order_algo","cancel_algos","close_position","cancel_all","order_algo","cancel_algos"]},option:{get:["accounts","position","{underlying}/position","accounts/{underlying}","orders/{underlying}","fills/{underlying}","accounts/{underlying}/ledger","trade_fee","orders/{underlying}/{order_id}","orders/{underlying}/{client_oid}","underlying","instruments/{underlying}","instruments/{underlying}/summary","instruments/{underlying}/summary/{instrument_id}","instruments/{instrument_id}/book","instruments/{instrument_id}/trades","instruments/{instrument_id}/ticker","instruments/{instrument_id}/candles"],post:["order","orders","cancel_order/{underlying}/{order_id}","cancel_order/{underlying}/{client_oid}","cancel_batch_orders/{underlying}","amend_order/{underlying}","amend_batch_orders/{underlying}"]},information:{get:["{currency}/long_short_ratio","{currency}/volume","{currency}/taker","{currency}/sentiment","{currency}/margin"]},index:{get:["{instrument_id}/constituents"]}},fees:{trading:{taker:.002,maker:.001},spot:{taker:.0015,maker:.001}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:Y,"failure to get a peer from the ring-balancer":Na,"Server is busy, please try again.":Na,"An unexpected error occurred":Y,"System error":Y,4010:as,4001:Y,4002:Y,30001:ii,30002:ii,30003:ii,30004:ii,30005:m6,30006:ii,30007:Kt,30008:ok,30009:Y,30010:ii,30011:as,30012:ii,30013:ii,30014:ak,30015:ii,30016:Y,30017:Y,30018:Y,30019:Na,30020:Kt,30021:Kt,30022:as,30023:Kt,30024:dk,30025:Kt,30026:ak,30027:ii,30028:as,30029:mu,30030:Na,30031:Kt,30032:dk,30033:Kt,30034:Y,30035:Y,30036:Y,30037:Na,30038:p6,30044:ok,32001:mu,32002:as,32003:g6,32004:Y,32005:ue,32006:ue,32007:ue,32008:ue,32009:ue,32010:Y,32011:Y,32012:Y,32013:Y,32014:Y,32015:Y,32016:Y,32017:Y,32018:Y,32019:Y,32020:Y,32021:Y,32022:Y,32023:Y,32024:Y,32025:Y,32026:Y,32027:Y,32028:Y,32029:Y,32030:ue,32031:js,32038:ii,32040:Y,32044:Y,32045:Y,32046:Y,32047:Y,32048:ue,32049:Y,32050:ue,32051:ue,32052:Y,32053:Y,32057:Y,32054:Y,32055:ue,32056:Y,32058:Y,32059:ue,32060:ue,32061:ue,32062:ue,32063:ue,32064:Y,32065:Y,32066:Y,32067:Y,32068:Y,32069:Y,32070:Y,32071:Y,32072:Y,32073:Y,32074:Y,32075:Y,32076:Y,32077:Y,32078:Y,32079:Y,32080:Y,32083:Y,33001:as,33002:mu,33003:Ki,33004:Y,33005:Y,33006:Y,33007:Y,33008:Ki,33009:Y,33010:Y,33011:Y,33012:Y,33013:ue,33014:hp,33015:ue,33016:Y,33017:Ki,33018:Y,33020:Y,33021:Kt,33022:ue,33023:Y,33024:ue,33025:ue,33026:Y,33027:ue,33028:ue,33029:ue,33034:Y,33035:Y,33036:Y,33037:Y,33038:Y,33039:Y,33040:Y,33041:Y,33042:Y,33043:Y,33044:Y,33045:Y,33046:Y,33047:Y,33048:Y,33049:Y,33050:Y,33051:Y,33059:Kt,33060:Kt,33061:Y,33062:Y,33063:Y,33064:Y,33065:Y,33085:ue,21009:Y,34001:as,34002:up,34003:Y,34004:Y,34005:Y,34006:Y,34007:Y,34008:Ki,34009:Y,34010:Y,34011:Y,34012:Y,34013:Y,34014:Y,34015:Y,34016:as,34017:mu,34018:ii,34019:as,34020:as,34021:up,34022:Y,34023:as,34026:ck,34036:Y,34037:Y,34038:Y,34039:Y,35001:Y,35002:Y,35003:Y,35004:Y,35005:ii,35008:ue,35010:ue,35012:ue,35014:ue,35015:ue,35017:Y,35019:ue,35020:ue,35021:ue,35022:Kt,35024:Kt,35025:Ki,35026:Kt,35029:hp,35030:ue,35031:ue,35032:Y,35037:Y,35039:Ki,35040:ue,35044:Y,35046:Ki,35047:Ki,35048:Y,35049:ue,35050:ue,35052:Ki,35053:Y,35055:Ki,35057:Y,35058:Y,35059:Kt,35060:Kt,35061:Kt,35062:ue,35063:ue,35064:ue,35066:ue,35067:ue,35068:ue,35069:ue,35070:ue,35071:ue,35072:ue,35073:ue,35074:ue,35075:ue,35076:ue,35077:ue,35078:ue,35079:ue,35080:ue,35081:ue,35082:ue,35083:ue,35084:ue,35085:ue,35086:ue,35087:ue,35088:ue,35089:ue,35090:Y,35091:Y,35092:Y,35093:Y,35094:Y,35095:Kt,35096:Y,35097:Y,35098:Y,35099:Y,35102:ck,36001:Kt,36002:Kt,36005:Y,36101:ii,36102:as,36103:as,36104:as,36105:as,36106:as,36107:as,36108:Ki,36109:as,36201:as,36202:as,36203:ue,36204:Y,36205:Kt,36206:Kt,36207:ue,36208:ue,36209:ue,36210:ue,36211:ue,36212:ue,36213:ue,36214:Y,36216:hp,36217:ue,36218:ue,36219:ue,36220:ue,36221:ue,36222:ue,36223:ue,36224:ue,36225:ue,36226:ue,36227:ue,36228:ue,36229:ue,36230:ue},broad:{}},precisionMode:y6,options:{fetchOHLCV:{type:"Candles"},createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot"],defaultType:"spot",accountsByType:{spot:"1",funding:"6",main:"6"},accountsById:{1:"spot",6:"funding"},auth:{time:"public",currencies:"private",instruments:"public",rate:"public","{instrument_id}/constituents":"public"},warnOnFetchCurrenciesWithoutAuthorization:!1},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.generalGetTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[];for(let i=0;i<t.length;i++){const n=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,n)}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instrument_id");let s=this.safeValue(e,"option_type");const i=this.safeNumber(e,"contract_val"),n=i!==void 0,r=this.safeString(e,"alias");let a="spot";const o=!n,d=s!==void 0,c=!d&&r!==void 0,u=n&&!c&&!d;let h=this.safeString(e,"base_currency"),f=this.safeString(e,"quote_currency");const l=this.safeString(e,"settlement_currency");if(d){const L=this.safeString(e,"underlying").split("-");h=this.safeString(L,0),f=this.safeString(L,1),a="option"}else c?(h=this.safeString(e,"underlying_index"),a="futures"):u&&(a="swap");const m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(f),y=this.safeCurrencyCode(l);let w=m+"/"+g,b=this.safeString(e,"delivery"),S;const v=this.safeValue(e,"strike");n&&(w=w+":"+y,(c||d)&&(c&&(b+="T00:00:00Z"),S=this.parse8601(b),w=w+"-"+this.yymmdd(S),d&&(w=w+":"+v+":"+s,s=s==="C"?"call":"put")));const T=this.safeNumber2(e,"lot_size","trade_increment"),I=this.safeString(e,"tick_size"),A=this.safeString2(e,"min_size","base_min_size"),N=this.parseNumber(A);let B;N!==void 0&&I!==void 0&&(B=this.parseNumber(ft.stringMul(I,A)));const x=this.safeValue2(this.fees,a,"trading",{}),k=this.safeString(e,"max_leverage","1"),O=this.parseNumber(ft.stringMax(k,"1")),P=this.parseNumber(I);return this.extend(x,{id:t,symbol:w,base:m,quote:g,settle:y,baseId:h,quoteId:f,settleId:l,type:a,spot:o,margin:!1,swap:u,future:c,futures:c,option:d,active:!0,contract:n,linear:n?g===y:void 0,inverse:n?m===y:void 0,contractSize:i,expiry:S,expiryDatetime:this.iso8601(S),strike:v,optionType:s,precision:{amount:this.safeNumber(e,"size_increment",T),price:P},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(O)},amount:{min:N,max:void 0},price:{min:P,max:void 0},cost:{min:B,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){if(e==="option"){const s=await this.optionGetUnderlying(t);let i=[];for(let n=0;n<s.length;n++){const r=await this.optionGetInstrumentsUnderlying({underlying:s[n]});i=this.arrayConcat(i,r)}return this.parseMarkets(i)}else if(e==="spot"||e==="futures"||e==="swap"){const s=e+"GetInstruments",i=await this[s](t);return this.parseMarkets(i)}else throw new Ur(this.id+" fetchMarketsByType() does not support market type "+e)}async fetchCurrencies(e={}){if(this.checkRequiredCredentials(!1)){const t=await this.accountGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name"),d=this.safeInteger(n,"can_deposit"),c=this.safeInteger(n,"can_withdraw"),u=d===1,h=c===1,f=!!(d&&c);s[a]={id:r,code:a,info:n,type:void 0,name:o,active:f,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber("1e-8"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"min_withdrawal"),max:void 0}}}}return s}else{if(this.options.warnOnFetchCurrenciesWithoutAuthorization)throw new Y(this.id+' fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = false to suppress this warning message.');return}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let n=i.type+"GetInstrumentsInstrumentId";n+=i.type==="swap"?"Depth":"Book";const r={instrument_id:i.id};t!==void 0&&(r.size=t);const a=await this[n](this.extend(r,s)),o=this.parse8601(this.safeString2(a,"timestamp","time"));return this.parseOrderBook(a,e,o)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"instrument_id");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open_24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_24h"),low:this.safeString(e,"low_24h"),bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"base_volume_24h"),quoteVolume:this.safeString(e,"quote_volume_24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.type+"GetInstrumentsInstrumentIdTicker",n={instrument_id:s.id},r=await this[i](this.extend(n,t));return this.parseTicker(r)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets(),t=this.marketSymbols(t);const i=e+"GetInstrumentsTicker",n=await this[i](s),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",t)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;return[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),await this.fetchTickersByType(n,e,this.omit(t,"type"))}parseTrade(e,t=void 0){const s=this.safeString(e,"instrument_id");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"timestamp","created_at")),r=this.safeString(e,"price");let a=this.safeString2(e,"size","qty");a=this.safeString(e,"order_qty",a);let o=this.safeString2(e,"exec_type","liquidity");o==="M"?o="maker":o==="T"&&(o="taker");const d=this.safeString(e,"side"),c=this.safeString(e,"fee");let u;if(c!==void 0){const f=d==="buy"?t.base:t.quote;u={cost:ft.stringNeg(c),currency:f}}const h=this.safeString(e,"order_id");return this.safeTrade({info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:this.safeString2(e,"trade_id","ledger_id"),order:h,type:void 0,takerOrMaker:o,side:d,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.type+"GetInstrumentsInstrumentIdTrades";(s===void 0||s>100)&&(s=100);const a={instrument_id:n.id,limit:s},o=await this[r](this.extend(a,i));return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){if(Array.isArray(e)){const i=e.length>6?6:5;let n=this.safeValue(e,0);return typeof n=="string"&&(n=this.parse8601(n)),[n,this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,i)]}else return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o={instrument_id:r.id,granularity:this.timeframes[t]},d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeString(d,"type","Candles"),u=this.safeString(n,"type",c);n=this.omit(n,"type");const h=r.type+"GetInstrumentsInstrumentId"+u;if(u==="Candles"){if(s!==void 0)i!==void 0&&(o.end=this.iso8601(this.sum(s,i*a*1e3))),o.start=this.iso8601(s);else if(i!==void 0){const l=this.milliseconds();o.start=this.iso8601(l-i*a*1e3),o.end=this.iso8601(l)}}else if(u==="HistoryCandles"){if(r.option)throw new Ur(this.id+" fetchOHLCV() does not have "+u+" for "+r.type+" markets");if(s!==void 0)i===void 0&&(i=300),o.start=this.iso8601(this.sum(s,i*a*1e3)),o.end=this.iso8601(s);else if(i!==void 0){const l=this.milliseconds();o.end=this.iso8601(l-i*a*1e3),o.start=this.iso8601(l)}}const f=await this[h](this.extend(o,n));return this.parseOHLCVs(f,r,t,s,i)}parseAccountBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"balance"),a.used=this.safeString(i,"hold"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseFuturesBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(s,r,{}),d=this.account(),c=this.safeString(o,"total_avail_balance");if(this.safeString(o,"margin_mode")==="fixed"){const u=this.safeValue(o,"contracts",[]);let h=c;for(let f=0;f<u.length;f++){const l=u[f],m=this.safeString(l,"fixed_balance"),g=this.safeString(l,"realized_pnl"),y=this.safeString(l,"margin_frozen"),w=this.safeString(l,"margin_for_unfilled"),b=ft.stringSub(ft.stringSub(ft.stringAdd(m,g),y),w);h=ft.stringAdd(h,b)}d.free=h}else{const u=this.safeString(o,"realized_pnl"),h=this.safeString(o,"unrealized_pnl"),f=this.safeString(o,"margin_frozen"),l=this.safeString(o,"margin_for_unfilled"),m=ft.stringAdd(ft.stringAdd(c,u),h);d.free=ft.stringSub(ft.stringSub(m,f),l)}d.total=this.safeString(o,"equity"),t[a]=d}return this.safeBalance(t)}parseSwapBalance(e){const t={info:e};let s;const i=this.safeValue(e,"info",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"instrument_id"),o=this.safeSymbol(a),d=this.parse8601(this.safeString(r,"timestamp"));s=s===void 0?d:Math.max(s,d);const c=this.account();c.total=this.safeString(r,"equity"),c.free=this.safeString(r,"total_avail_balance"),t[o]=c}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeString2(this.options,"fetchBalance","defaultType"),s=this.safeString(e,"type",t);if(s===void 0)throw new js(this.id+" fetchBalance() requires a type parameter (one of 'account', 'spot', 'futures', 'swap')");await this.loadMarkets();const i=s==="account"?"Wallet":"Accounts",n=s+"Get"+i,r=this.omit(e,"type"),a=await this[n](r);return this.parseBalanceByType(s,a)}parseBalanceByType(e,t){if(e==="account"||e==="spot")return this.parseAccountBalance(t);if(e==="futures")return this.parseFuturesBalance(t);if(e==="swap")return this.parseSwapBalance(t);throw new Ur(this.id+" fetchBalance does not support the '"+e+"' type (the type must be one of 'account', 'spot', 'futures', 'swap')")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={instrument_id:a.id};const d=this.safeString2(r,"client_oid","clientOrderId");d!==void 0&&(o.client_oid=d,r=this.omit(r,["client_oid","clientOrderId"]));let c;if(a.futures||a.swap){const f=a.futures?this.numberToString(i):this.amountToPrecision(e,i);o=this.extend(o,{type:t,size:f});const l=this.safeString(r,"order_type");t==="market"||l==="4"?o.order_type="4":o.price=this.priceToPrecision(e,n),a.futures&&(o.leverage="10"),c=a.type+"PostOrder"}else{if(o=this.extend(o,{side:s,type:t}),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let f=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)f===void 0&&(f=i*n);else if(f===void 0)throw new ue(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else f=f===void 0?i:f;o.notional=this.costToPrecision(e,f)}else o.size=this.amountToPrecision(e,i);c="spotPostOrders"}const u=await this[c](this.extend(o,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new js(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);let n;if(i.futures||i.swap)n=i.type;else{const h=this.safeString2(this.options,"cancelOrder","defaultType",i.type);n=this.safeString(s,"type",h)}if(n===void 0)throw new js(this.id+" cancelOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");let r=n+"PostCancelOrder";const a={instrument_id:i.id};i.futures||i.swap?r+="InstrumentId":r+="s";const o=this.safeString2(s,"client_oid","clientOrderId");o!==void 0?(r+="ClientOid",a.client_oid=o):(r+="OrderId",a.order_id=e);const d=this.omit(s,["type","client_oid","clientOrderId"]),c=await this[r](this.extend(a,d)),u="result"in c?c:this.safeValue(c,i.id,{});return this.parseOrder(u,i)}parseOrderStatus(e){const t={"-2":"failed","-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"};return this.safeString(t,e,e)}parseOrderSide(e){const t={1:"buy",2:"sell",3:"sell",4:"buy"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.parse8601(this.safeString(e,"timestamp"));let n=this.safeString(e,"side");const r=this.safeString(e,"type");n!=="buy"&&n!=="sell"&&(n=this.parseOrderSide(r));const a=this.safeString(e,"instrument_id");t=this.safeMarket(a,t);let o=this.safeString(e,"size");const d=this.safeString2(e,"filled_size","filled_qty");let c;o!==void 0&&d!==void 0&&(o=ft.stringMax(o,d),c=ft.stringMax("0",ft.stringSub(o,d))),r==="market"&&(c="0");let u=this.safeString2(e,"filled_notional","funds");const h=this.safeString(e,"price");let f=this.safeString(e,"price_avg");u===void 0?d!==void 0&&f!==void 0&&(u=ft.stringMul(f,d)):f===void 0&&d!==void 0&&ft.stringGt(d,"0")&&(f=ft.stringDiv(u,d));const l=this.parseOrderStatus(this.safeString(e,"state")),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={cost:m,currency:void 0});let y=this.safeString(e,"client_oid");y!==void 0&&y.length<1&&(y=void 0);const w=this.safeNumber(e,"trigger_price");return this.safeOrder({info:e,id:s,clientOrderId:y,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:w,triggerPrice:w,average:f,cost:u,amount:o,filled:d,remaining:c,status:l,fee:g,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new js(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType",i.type),r=this.safeString(s,"type",n);if(r===void 0)throw new js(this.id+" fetchOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");const a=i.futures||i.swap?"InstrumentId":"";let o=r+"GetOrders"+a;const d={instrument_id:i.id},c=this.safeString(s,"client_oid");c!==void 0?(o+="ClientOid",d.client_oid=c):(o+="OrderId",d.order_id=e);const u=this.omit(s,"type"),h=await this[o](this.extend(d,u));return this.parseOrder(h)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new js(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t);let a;if(r.futures||r.swap)a=r.type;else{const f=this.safeString2(this.options,"fetchOrder","defaultType",r.type);a=this.safeString(n,"type",f)}if(a===void 0)throw new js(this.id+" fetchOrdersByState() requires a type parameter (one of 'spot', 'futures', 'swap').");const o={instrument_id:r.id,state:e};let d=a+"GetOrders";(r.futures||r.swap)&&(d+="InstrumentId");const c=this.omit(n,"type"),u=await this[d](this.extend(o,c));let h;if(r.swap||r.futures)h=this.safeValue(u,"order_info",[]);else{h=u;const f=u.length;if(f<1)return[];f>1&&this.safeValue(u[1],"before")!==void 0&&(h=u[0])}return this.parseOrders(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("6",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("7",e,t,s,i)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");let i=this.safeString2(e,"tag","payment_id");i=this.safeString2(e,"memo","Memo",i);const n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=e.split("-"),n={currency:this.currency(s[0]).id},r=await this.accountGetDepositAddress(this.extend(n,t)),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new up(this.id+" fetchDepositAddress() cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first");return o}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={amount:this.currencyToPrecision(e,t),currency:r.id,from:o,to:d,type:"0"};o==="main"?(c.type="1",c.sub_account=d,c.to="0"):d==="main"&&(c.type="2",c.sub_account=o,c.from="0",c.to="6");const u=await this.accountPostTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"accountsById",{});return{info:e,id:this.safeString(e,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(s,this.safeString(e,"from")),toAccount:this.safeString(s,this.safeString(e,"to")),status:this.parseTransferStatus(this.safeString(e,"result"))}}parseTransferStatus(e){const t={true:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new js(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={currency:r.id,to_address:s,destination:"4",amount:this.numberToString(t),fee:a};"password"in n?o.trade_pwd=n.password:"trade_pwd"in n?o.trade_pwd=n.trade_pwd:this.password&&(o.trade_pwd=this.password);const d=this.omit(n,["fee","password","trade_pwd"]);if(!("trade_pwd"in o))throw new Y(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const c=await this.accountPostWithdrawal(this.extend(o,d));return this.parseTransaction(c,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetDepositHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetWithdrawalHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i,n;const r=this.safeString(e,"withdrawal_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeString(e,"tag");r!==void 0?(s="withdrawal",i=r,n=o):(i=this.safeString2(e,"payment_id","deposit_id"),s="deposit",n=o);const c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amount"),f=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeString(e,"txid"),m=this.parse8601(this.safeString(e,"timestamp"));let g;if(s==="deposit")g=0;else if(c!==void 0){const y=this.safeString(e,"fee");if(y!==void 0){const w=c.toLowerCase(),b=y.replace(w,"");g=parseFloat(b)}}return{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:a,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:f,type:s,updated:void 0,txid:l,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}parseMyTrade(e,t=void 0){const s=this.safeValue(e,1),i=this.safeValue(e,0),n=this.safeString(i,"instrument_id"),r=this.safeString(s,"instrument_id");if(n!==r)throw new Ur(this.id+" parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help");const a=n;t=this.safeMarket(a,t);const o=t.symbol,d=t.quoteId;let c,u,h;const f=this.safeString(s,"currency");let l;f===d?(c=this.safeString(i,"side"),u=this.safeString(i,"size"),h=this.safeString(s,"size"),l=this.safeString(i,"currency")):(c=this.safeString(s,"side"),u=this.safeString(s,"size"),h=this.safeString(i,"size"),l=this.safeString(s,"currency"));const m=this.safeString(s,"trade_id"),g=this.safeString(s,"price"),y=this.safeString(i,"fee"),w=this.safeString(s,"fee"),b=this.safeCurrencyCode(this.safeString(i,"currency")),S=this.safeCurrencyCode(this.safeString(s,"currency"));let v,T;y!==void 0&&!ft.stringEquals(y,"0")?w!==void 0&&!ft.stringEquals(w,"0")?T=[{cost:ft.stringNeg(y),currency:b},{cost:ft.stringNeg(w),currency:S}]:v={cost:ft.stringNeg(y),currency:b}:w!==void 0&&!ft.stringEquals(w,"0")?v={cost:ft.stringNeg(w),currency:S}:v={cost:"0",currency:this.safeCurrencyCode(l)};const I=this.parse8601(this.safeString2(s,"timestamp","created_at"));let A=this.safeString2(s,"exec_type","liquidity");A==="M"?A="maker":A==="T"&&(A="taker");const N=this.safeString(s,"order_id");return this.safeTrade({info:e,timestamp:I,datetime:this.iso8601(I),symbol:o,id:m,order:N,type:void 0,takerOrMaker:A,side:c,price:g,amount:u,cost:h,fee:v,fees:T},t)}parseMyTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.groupBy(e,"trade_id"),a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];if(u.length===2){const f=this.parseMyTrade(u);o.push(f)}}return t=this.safeMarket(void 0,t),this.filterBySymbolSinceLimit(o,t.symbol,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new js(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s!==void 0&&s>100&&(s=100);const r={instrument_id:n.id},a=this.safeString2(this.options,"fetchMyTrades","defaultType"),o=this.safeString(i,"type",a),d=this.omit(i,"type"),c=o+"GetFills",u=await this[c](this.extend(r,d));return this.parseMyTrades(u,n,t,s,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n={instrument_id:s.id},r=s.type;if(r==="futures"||r==="swap")i=r+"GetInstrumentIdPosition";else if(r==="option"){if(this.safeString(t,"underlying")===void 0)throw new js(this.id+" fetchPosition() requires an underlying parameter for "+r+" market "+e);i=r+"GetUnderlyingPosition"}else throw new Ur(this.id+" fetchPosition() does not support "+r+" market "+e+", supported market types are futures, swap or option");return await this[i](this.extend(n,t))}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;const i=this.safeString2(this.options,"fetchPositions","defaultType"),n=this.safeString(t,"type",i);if(n==="futures"||n==="swap")s=n+"GetPosition";else if(n==="option"){if(this.safeString(t,"underlying")===void 0)throw new js(this.id+" fetchPositions() requires an underlying parameter for "+n+" markets");s=n+"GetUnderlyingPosition"}else throw new Ur(this.id+" fetchPositions() does not support "+n+" markets, supported market types are futures, swap or option");return t=this.omit(t,"type"),await this[s](t)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString2(this.options,"fetchLedger","defaultType"),r=this.safeString(i,"type",n),a=this.omit(i,"type"),o=r==="account"?"":"Accounts";let d="";const c={};s!==void 0&&(c.limit=s);let u;if(r==="spot"){if(e===void 0)throw new js(this.id+" fetchLedger() requires a currency code argument for '"+r+"' markets");d="Currency",u=this.currency(e),c.currency=u.id}else if(r==="futures"){if(e===void 0)throw new js(this.id+" fetchLedger() requires an underlying symbol for '"+r+"' markets");d="Underlying";const m=this.market(e),g=this.safeValue(m,"info",{}),y=this.safeString(g,"settlement_currency"),w=this.safeCurrencyCode(y);u=this.currency(w);const b=this.safeString(g,"underlying");c.underlying=b}else if(r==="swap"){if(e===void 0)throw new js(this.id+" fetchLedger() requires a code argument (a market symbol) for '"+r+"' markets");d="InstrumentId";const m=this.market(e);u=this.currency(m.base),c.instrument_id=m.id}else if(r==="account")e!==void 0&&(u=this.currency(e),c.currency=u.id);else throw new Ur(this.id+" fetchLedger does not support the '"+r+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");const h=r+"Get"+o+d+"Ledger",f=await this[h](this.extend(c,a));if(f.length<1)return[];if(r==="swap"){const m=this.parseLedger(f);return this.filterBySymbolSinceLimit(m,e,t,s)}return this.parseLedger(f,u,t,s)}parseLedgerEntryType(e){const t={transfer:"transfer",trade:"trade",rebate:"rebate",match:"trade",fee:"fee",settlement:"trade",liquidation:"trade",funding:"fee",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"ledger_id"),i=void 0,n=this.safeValue(e,"details",{}),r=this.safeString(n,"order_id"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"currency"),t),c=this.safeNumber(e,"amount"),u=this.parse8601(this.safeString(e,"timestamp")),h={cost:this.safeNumber(e,"fee"),currency:d},f=void 0,l=this.safeNumber(e,"balance"),m="ok",g=this.safeString(e,"instrument_id"),y=this.safeSymbol(g);return{info:e,id:s,account:i,referenceId:r,referenceAccount:a,type:o,currency:d,symbol:y,amount:c,before:f,after:l,status:m,timestamp:u,datetime:this.iso8601(u),fee:h}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i);let o="/api/"+t+"/"+this.version+"/";o+=a?e:this.implodeParams(e,i);const d=a?i:this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;const u=this.getPathAuthenticationType(e);if(u==="public"||u==="information")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(u==="private"){this.checkRequiredCredentials();const h=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":h};let f=h+s+o;if(s==="GET"){if(Object.keys(d).length){const m="?"+this.urlencode(d);c+=m,f+=m}}else(a||Object.keys(d).length)&&(r=this.json(d),f+=r),n["Content-Type"]="application/json";const l=this.hmac(this.encode(f),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=l}return{url:c,method:s,body:r,headers:n}}getPathAuthenticationType(e){if(e==="underlying")return"public";const t=this.safeValue(this.options,"auth",{}),s=this.findBroadlyMatchedKey(t,e);return this.safeString(t,s,"private")}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.id+" "+r;if(e===503)throw new Na(c);const u=this.safeString(a,"message"),h=this.safeString2(a,"code","error_code"),f=u!==void 0&&u!=="",l=h!==void 0&&h!=="0";if(f&&(this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c)),l&&this.throwExactlyMatchedException(this.exceptions.exact,h,c),l||f)throw new Y(c)}};const w6=re,{ExchangeError:se,ExchangeNotAvailable:$r,OnMaintenance:b6,ArgumentsRequired:ui,BadRequest:Ee,AccountSuspended:sr,InvalidAddress:gu,PermissionDenied:fp,InsufficientFunds:Ii,InvalidNonce:uk,InvalidOrder:ce,OrderNotFound:yu,AuthenticationError:ct,RequestTimeout:k6,BadSymbol:hi,RateLimitExceeded:wu,NetworkError:S6,CancelPending:v6,NotSupported:hk,AccountNotEnabled:T6}=Q,{TICK_SIZE:O6}=ne,Ot=ae;var gg=class extends w6{describe(){return this.deepExtend(super.describe(),{id:"okx",name:"OKX",countries:["CN","US"],version:"v5",rateLimit:100,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!0,fetchBorrowRateHistory:!0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPermissions:void 0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!0,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W","1M":"1M","3M":"3M"},hostname:"www.okx.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",api:{rest:"https://{hostname}"},www:"https://www.okx.com",doc:"https://www.okx.com/docs-v5/en/",fees:"https://www.okx.com/pages/products/fees.html",referral:"https://www.okx.com/join/1888677",test:{rest:"https://{hostname}"}},api:{public:{get:{"market/tickers":1,"market/ticker":1,"market/index-tickers":1,"market/books":1,"market/books-lite":1.66,"market/candles":.5,"market/history-candles":1,"market/history-mark-price-candles":2,"market/history-index-candles":2,"market/index-candles":1,"market/mark-price-candles":1,"market/trades":1,"market/platform-24-volume":10,"market/open-oracle":40,"market/index-components":1,"market/option/instrument-family-trades":1,"public/instruments":1,"public/delivery-exercise-history":.5,"public/open-interest":1,"public/funding-rate":1,"public/funding-rate-history":1,"public/price-limit":1,"public/opt-summary":1,"public/estimated-price":2,"public/discount-rate-interest-free-quota":10,"public/time":2,"public/liquidation-orders":.5,"public/mark-price":2,"public/option-trades":1,"public/position-tiers":2,"public/underlying":1,"public/interest-rate-loan-quota":10,"public/vip-interest-rate-loan-quota":10,"rubik/stat/trading-data/support-coin":4,"rubik/stat/taker-volume":4,"rubik/stat/margin/loan-ratio":4,"rubik/stat/contracts/long-short-account-ratio":4,"rubik/stat/contracts/open-interest-volume":4,"rubik/stat/option/open-interest-volume":4,"rubik/stat/option/open-interest-volume-ratio":4,"rubik/stat/option/open-interest-volume-expiry":4,"rubik/stat/option/open-interest-volume-strike":4,"rubik/stat/option/taker-block-volume":4,"system/status":100,"asset/lending-rate-summary":5/3,"asset/lending-rate-history":5/3,"market/exchange-rate":20}},private:{get:{"account/account-position-risk":2,"account/balance":2,"account/positions":2,"account/bills":5/3,"account/bills-archive":5/3,"account/config":4,"account/max-size":1,"account/max-avail-size":1,"account/leverage-info":1,"account/max-loan":1,"account/trade-fee":4,"account/interest-accrued":4,"account/interest-rate":4,"account/max-withdrawal":1,"account/risk-state":2,"account/borrow-repay-history":4,"account/quick-margin-borrow-repay-history":4,"account/interest-limits":4,"account/vip-interest-accrued":4,"account/vip-loan-order-list":4,"account/vip-loan-order-detail":4,"asset/asset-valuation":1/5,"asset/deposit-address":5/3,"asset/balances":5/3,"asset/transfer-state":10,"asset/deposit-history":5/3,"asset/withdrawal-history":5/3,"asset/deposit-withdraw-status":20,"asset/currencies":5/3,"asset/bills":5/3,"asset/piggy-balance":5/3,"asset/deposit-lightning":5,"asset/lending-history":5/3,"asset/saving-balance":5/3,"asset/non-tradable-assets":5/3,"trade/order":1/3,"trade/orders-pending":1,"trade/orders-history":.5,"trade/orders-history-archive":1,"trade/fills":1/3,"trade/fills-history":2,"trade/orders-algo-pending":1,"trade/orders-algo-history":1,"account/subaccount/balances":10,"asset/subaccount/bills":5/3,"users/subaccount/list":10,"users/subaccount/apikey":10,"users/entrust-subaccount-list":10,"broker/nd/info":10,"broker/nd/subaccount-info":10,"asset/broker/nd/subaccount-deposit-address":4,"asset/broker/nd/subaccount-deposit-history":4,"broker/nd/rebate-daily":1,"broker/nd/subaccount/apikey":10,"broker/nd/rebate-per-orders":300,"asset/broker/nd/subaccount-withdrawal-history":4,"asset/convert/currencies":5/3,"asset/convert/currency-pair":5/3,"asset/convert/estimate-quote":5,"asset/convert/trade":5,"asset/convert/history":5/3,"account/greeks":2,"finance/staking-defi/offers":1,"finance/staking-defi/orders-active":1,"finance/staking-defi/orders-history":1,"rfq/counterparties":4,"rfq/maker-instrument-settings":4,"rfq/rfqs":10,"rfq/quotes":10,"rfq/trades":4,"rfq/public-trades":4,"copytrading/current-subpositions":10,"copytrading/subpositions-history":10,"copytrading/instruments":10,"copytrading/profit-sharing-details":10,"copytrading/total-profit-sharing":10,"copytrading/unrealized-profit-sharing-details":10,"tradingBot/grid/orders-algo-pending":1,"tradingBot/grid/orders-algo-history":1,"tradingBot/grid/orders-algo-details":1,"tradingBot/grid/sub-orders":1,"tradingBot/grid/positions":1,"tradingBot/grid/ai-param":1},post:{"account/set-position-mode":4,"account/set-leverage":1,"account/position/margin-balance":1,"account/set-greeks":4,"account/set-isolated-mode":4,"account/set-riskOffset-type":2,"account/simulated_margin":10,"account/borrow-repay":5/3,"account/quick-margin-borrow-repay":4,"account/activate-option":4,"asset/transfer":10,"asset/withdrawal":5/3,"asset/purchase_redempt":5/3,"asset/withdrawal-lightning":5,"asset/set-lending-rate":5/3,"asset/cancel-withdrawal":5/3,"asset/convert-dust-assets":10,"trade/order":1/3,"trade/batch-orders":1/15,"trade/cancel-order":1/3,"trade/cancel-batch-orders":1/15,"trade/amend-order":1/3,"trade/amend-batch-orders":1/3,"trade/close-position":1,"trade/order-algo":1,"trade/cancel-algos":1,"trade/cancel-advance-algos":1,"users/subaccount/delete-apikey":10,"users/subaccount/modify-apikey":10,"users/subaccount/apikey":10,"asset/subaccount/transfer":10,"asset/subaccount/set-transfer-out":10,"broker/nd/create-subaccount":10,"broker/nd/delete-subaccount":10,"broker/nd/set-subaccount-level":4,"broker/nd/set-subaccount-fee-rate":4,"asset/broker/nd/subaccount-deposit-address":4,"broker/nd/subaccount/apikey":10,"broker/nd/subaccount/delete-apikey":10,"broker/nd/subaccount/modify-apikey":10,"broker/nd/rebate-per-orders":36e3,"finance/staking-defi/purchase":3,"finance/staking-defi/redeem":3,"finance/staking-defi/cancel":3,"rfq/create-rfq":4,"rfq/cancel-rfq":4,"rfq/cancel-batch-rfqs":10,"rfq/cancel-all-rfqs":10,"rfq/execute-quote":10,"rfq/maker-instrument-settings":4,"rfq/mmp-reset":4,"rfq/create-quote":.4,"rfq/cancel-quote":.4,"rfq/cancel-batch-quotes":10,"rfq/cancel-all-quotes":10,"copytrading/algo-order":20,"copytrading/close-subposition":10,"copytrading/set-instruments":10,"tradingBot/grid/order-algo":1,"tradingBot/grid/amend-order-algo":1,"tradingBot/grid/stop-order-algo":1,"tradingBot/grid/withdraw-income":1,"tradingBot/grid/compute-margin-balance":1,"tradingBot/grid/margin-balance":1}}},fees:{trading:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},spot:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},future:{taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0002")},swap:{taker:this.parseNumber("0.00050"),maker:this.parseNumber("0.00020")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:se,2:se,5e4:Ee,50001:b6,50002:Ee,50004:k6,50005:$r,50006:Ee,50007:sr,50008:ct,50009:sr,50010:se,50011:wu,50012:se,50013:$r,50014:Ee,50015:se,50016:se,50017:se,50018:se,50019:se,50020:se,50021:se,50022:se,50023:se,50024:Ee,50025:se,50026:$r,50027:fp,50028:se,50044:Ee,50100:se,50101:ct,50102:uk,50103:ct,50104:ct,50105:ct,50106:ct,50107:ct,50108:se,50109:se,50110:fp,50111:ct,50112:ct,50113:ct,50114:ct,50115:Ee,51e3:Ee,51001:hi,51002:hi,51003:Ee,51004:ce,51005:ce,51006:ce,51007:ce,51008:Ii,51009:sr,51010:T6,51011:ce,51012:hi,51014:hi,51015:hi,51016:ce,51017:se,51018:se,51019:se,51020:ce,51021:hi,51022:hi,51023:se,51024:sr,51025:se,51026:hi,51027:hi,51028:hi,51029:hi,51030:hi,51031:ce,51100:ce,51101:ce,51102:ce,51103:ce,51104:ce,51105:ce,51106:ce,51107:ce,51108:ce,51109:ce,51110:ce,51111:Ee,51112:ce,51113:wu,51115:ce,51116:ce,51117:ce,51118:ce,51119:Ii,51120:ce,51121:ce,51122:ce,51124:ce,51125:ce,51126:ce,51127:Ii,51128:ce,51129:ce,51130:hi,51131:Ii,51132:ce,51133:ce,51134:ce,51135:ce,51136:ce,51137:ce,51138:ce,51139:ce,51156:Ee,51159:Ee,51162:ce,51163:ce,51166:ce,51201:ce,51202:ce,51203:ce,51204:ce,51205:ce,51250:ce,51251:ce,51252:ce,51253:ce,51254:ce,51255:ce,51256:ce,51257:ce,51258:ce,51259:ce,51260:ce,51261:ce,51262:ce,51263:ce,51264:ce,51265:ce,51267:ce,51268:ce,51269:ce,51270:ce,51271:ce,51272:ce,51273:ce,51274:ce,51275:ce,51276:ce,51277:ce,51278:ce,51279:ce,51280:ce,51321:ce,51322:ce,51323:Ee,51324:Ee,51325:ce,51327:ce,51328:ce,51329:ce,51330:ce,51400:yu,51401:yu,51402:yu,51403:ce,51404:ce,51405:se,51406:se,51407:Ee,51408:se,51409:se,51410:v6,51500:se,51501:se,51502:Ii,51503:se,51506:se,51508:se,51509:se,51510:se,51511:se,51600:se,51601:se,51602:se,51603:yu,51732:ct,51733:ct,51734:ct,51735:se,51736:Ii,52e3:se,54e3:se,54001:se,58e3:se,58001:ct,58002:fp,58003:se,58004:sr,58005:se,58006:se,58007:se,58100:se,58101:sr,58102:wu,58103:se,58104:se,58105:se,58106:se,58107:se,58108:se,58109:se,58110:se,58111:se,58112:se,58114:se,58115:se,58116:se,58117:se,58125:Ee,58126:Ee,58200:se,58201:se,58202:se,58203:gu,58204:sr,58205:se,58206:se,58207:gu,58208:se,58209:se,58210:se,58211:se,58212:se,58213:ct,58221:Ee,58222:Ee,58224:Ee,58227:Ee,58228:Ee,58229:Ii,58300:se,58350:Ii,59e3:se,59001:se,59100:se,59101:se,59102:se,59103:Ii,59104:se,59105:se,59106:se,59107:se,59108:Ii,59109:se,59128:ce,59200:Ii,59201:Ii,59216:Ee,59300:se,59301:se,59313:se,59401:se,59500:se,59501:se,59502:se,59503:se,59504:se,59505:se,59506:se,59507:se,59508:sr,60001:ct,60002:ct,60003:ct,60004:ct,60005:ct,60006:uk,60007:ct,60008:ct,60009:ct,60010:ct,60011:ct,60012:Ee,60013:Ee,60014:wu,60015:S6,60016:$r,60017:Ee,60018:Ee,60019:Ee,63999:se,70010:Ee,70013:Ee,70016:Ee},broad:{"Internal Server Error":$r,"server error":$r}},httpExceptions:{429:$r},precisionMode:O6,options:{defaultNetwork:"ERC20",networks:{ETH:"ERC20",TRX:"TRC20",OMNI:"Omni",SOLANA:"Solana",POLYGON:"Polygon",OEC:"OEC",ALGO:"ALGO",OPTIMISM:"Optimism",ARBITRUM:"Arbitrum one",AVALANCHE:"Avalanche C-Chain"},fetchOpenInterestHistory:{timeframes:{"5m":"5m","1h":"1H","1d":"1D","5M":"5m","1H":"1H","1D":"1D"}},fetchOHLCV:{timezone:"UTC"},createOrder:"privatePostTradeBatchOrders",createMarketBuyOrderRequiresPrice:!1,fetchMarkets:["spot","future","swap","option"],defaultType:"spot",fetchLedger:{method:"privateGetAccountBills"},fetchOrder:{method:"privateGetTradeOrder"},fetchOpenOrders:{method:"privateGetTradeOrdersPending"},cancelOrders:{method:"privatePostTradeCancelBatchOrders"},fetchCanceledOrders:{method:"privateGetTradeOrdersHistory"},fetchClosedOrders:{method:"privateGetTradeOrdersHistory"},algoOrderTypes:{conditional:!0,trigger:!0,oco:!0,move_order_stop:!0,iceberg:!0,twap:!0},accountsByType:{spot:"1",future:"3",futures:"3",margin:"5",funding:"6",swap:"9",option:"12",trading:"18"},accountsById:{1:"spot",3:"future",5:"margin",6:"funding",9:"swap",12:"option",18:"trading"},exchangeType:{spot:"SPOT",margin:"MARGIN",swap:"SWAP",future:"FUTURES",futures:"FUTURES",option:"OPTION",SPOT:"SPOT",MARGIN:"MARGIN",SWAP:"SWAP",FUTURES:"FUTURES",OPTION:"OPTION"},brokerId:"e847386590ce4dBC"},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString(s,"instType");return s=this.omit(s,"instType"),this.safeString(s,"type")===void 0&&i!==void 0&&(s.type=i),super.handleMarketTypeAndParams(e,t,s)}convertToInstrumentType(e){const t=this.safeValue(this.options,"exchangeType",{});return this.safeString(t,e,e)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e),s=this.safeValue(t,"data",[]),i=s.length,n={updated:void 0,status:i===0?"ok":"maintenance",eta:void 0,url:void 0,info:t};for(let r=0;r<s.length;r++){const a=s[r];this.safeString(a,"state")==="ongoing"&&(n.eta=this.safeInteger(a,"end"),n.status="maintenance")}return n}async fetchTime(e={}){const t=await this.publicGetPublicTime(e),s=this.safeValue(t,"data",[]),i=this.safeValue(s,0,{});return this.safeInteger(i,"ts")}async fetchAccounts(e={}){const t=await this.privateGetAccountConfig(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"uid"),o=this.safeString(r,"acctLv");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[],i=[];for(let n=0;n<t.length;n++)s.push(this.fetchMarketsByType(t[n],e));s=await Promise.all(s);for(let n=0;n<s.length;n++)i=this.arrayConcat(i,s[n]);return i}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instId");let s=this.safeStringLower(e,"instType");s==="futures"&&(s="future");const i=s==="spot",n=s==="future",r=s==="swap",a=s==="option",o=r||n||a;let d=this.safeString(e,"baseCcy"),c=this.safeString(e,"quoteCcy");const u=this.safeString(e,"settleCcy"),h=this.safeCurrencyCode(u),f=this.safeString(e,"uly");if(f!==void 0&&!i){const B=f.split("-");d=this.safeString(B,0),c=this.safeString(B,1)}const l=this.safeCurrencyCode(d),m=this.safeCurrencyCode(c);let g=l+"/"+m,y,w,b;if(o){if(g=g+":"+h,y=this.safeInteger(e,"expTime"),n){const B=this.yymmdd(y);g=g+"-"+B}else if(a){w=this.safeString(e,"stk"),b=this.safeString(e,"optType");const B=this.yymmdd(y);g=g+"-"+B+"-"+w+"-"+b,b=b==="P"?"put":"call"}}const S=this.safeString(e,"tickSz"),v=this.safeString(e,"minSz"),T=this.parseNumber(v),I=this.safeValue2(this.fees,s,"trading",{}),A=this.parseNumber(S);let N=this.safeString(e,"lever","1");return N=Ot.stringMax(N,"1"),this.extend(I,{id:t,symbol:g,base:l,quote:m,settle:h,baseId:d,quoteId:c,settleId:u,type:s,spot:i,margin:i&&Ot.stringGt(N,"1"),swap:r,future:n,option:a,active:!0,contract:o,linear:o?c===u:void 0,inverse:o?d===u:void 0,contractSize:o?this.safeNumber(e,"ctVal"):void 0,expiry:y,expiryDatetime:this.iso8601(y),strike:w,optionType:b,precision:{amount:this.safeNumber(e,"lotSz"),price:A},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(N)},amount:{min:T,max:void 0},price:{min:A,max:void 0},cost:{min:void 0,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){const s={instType:this.convertToInstrumentType(e)};if(e==="option"){const r=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),a=this.safeString2(t,"uly","marketId",r);if(a===void 0)throw new ui(this.id+" fetchMarketsByType() requires an underlying uly or marketId parameter for options markets");s.uly=a}const i=await this.publicGetPublicInstruments(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}safeNetwork(e){const t={Bitcoin:"BTC",Omni:"OMNI",TRON:"TRC20"};return this.safeString(t,e,e)}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetCurrencies(e),s=this.safeValue(t,"data",[]),i={},n=this.groupBy(s,"ccy"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],c=this.safeCurrency(o).code,u=n[o],h={};let f=!1,l,m,g;for(let w=0;w<u.length;w++){const b=u[w],S=this.safeValue(b,"canDep"),v=this.safeValue(b,"canWd"),T=this.safeValue(b,"canInternal"),I=!!(S&&v&&T);f=f===void 0?I:f;const A=this.safeString(b,"chain");if(S&&!l?l=!0:S||(l=!1),v&&!m?m=!0:v||(m=!1),A!==void 0&&A.indexOf("-")>=0){const N=A.split("-"),B=this.safeString(N,1,A),x=this.safeNetwork(B),k=this.parsePrecision(this.safeString(b,"wdTickSz"));g===void 0?g=k:g=Ot.stringMin(g,k),h[x]={id:A,network:x,active:I,deposit:S,withdraw:v,fee:this.safeNumber(b,"minFee"),precision:this.parseNumber(k),limits:{withdraw:{min:this.safeNumber(b,"minWd"),max:this.safeNumber(b,"maxWd")}},info:b}}}const y=this.safeValue(u,0);i[c]={info:void 0,code:c,id:o,name:this.safeString(y,"name"),active:f,deposit:l,withdraw:m,fee:void 0,precision:this.parseNumber(g),limits:{amount:{min:void 0,max:void 0}},networks:h}}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={instId:this.market(e).id};t=t===void 0?20:t,t!==void 0&&(n.sz=t);const r=await this.publicGetMarketBooks(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"ts");return this.parseOrderBook(o,e,d)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open24h"),d=this.safeValue(t,"spot",!1)?this.safeString(e,"volCcy24h"):void 0,c=this.safeString(e,"vol24h"),u=this.safeString(e,"high24h"),h=this.safeString(e,"low24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"bidPx"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPx"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets();const i={instType:this.convertToInstrumentType(e)};if(e==="option"){const a=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),o=this.safeString2(s,"uly","marketId",a);if(o===void 0)throw new ui(this.id+" fetchTickersByType() requires an underlying uly or marketId parameter for options markets");i.uly=o}const n=await this.publicGetMarketTickers(this.extend(i,s)),r=this.safeValue(n,"data",[]);return this.parseTickers(r,t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t);return await this.fetchTickersByType(n,e,r)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeInteger(e,"ts"),a=this.safeString2(e,"fillPx","px"),o=this.safeString2(e,"fillSz","sz"),d=this.safeString(e,"side"),c=this.safeString(e,"ordId"),u=this.safeString(e,"fee");let h;if(u!==void 0){const l=Ot.stringNeg(u),m=this.safeString(e,"feeCcy"),g=this.safeCurrencyCode(m);h={cost:l,currency:g}}let f=this.safeString(e,"execType");return f==="T"?f="taker":f==="M"&&(f="maker"),this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:s,order:c,type:void 0,takerOrMaker:f,side:d,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instId:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");n=this.omit(n,"price");const o=this.safeValue(this.options,"fetchOHLCV",{}),d=this.safeString(o,"timezone","UTC");i===void 0&&(i=100);const c=this.parseTimeframe(t);let u=this.timeframes[t];d==="UTC"&&c>=21600&&(u+=d.toLowerCase());const h={instId:r.id,bar:u,limit:i};let f="Candles";if(s!==void 0){this.milliseconds()-s>1440*c*1e3&&(f="HistoryCandles");const T=c*1e3,I=Math.max(s-1,0);h.before=I,h.after=this.sum(I,T*i)}const l=this.safeInteger(n,"until");l!==void 0&&(h.after=l,n=this.omit(n,"until")),f=this.safeString(o,"type",f);const m=this.safeString(n,"type",f);n=this.omit(n,"type");let g="publicGetMarket"+m;const y=m==="HistoryCandles";a==="mark"?g=y?"publicGetMarketHistoryMarkPriceCandles":"publicGetMarketMarkPriceCandles":a==="index"&&(g=y?"publicGetMarketHistoryIndexCandles":"publicGetMarketIndexCandles");const w=await this[g](this.extend(h,n)),b=this.safeValue(w,"data",[]);return this.parseOHLCVs(b,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ui(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instId:n.id};t!==void 0&&(r.before=Math.max(t-1,0)),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFundingRateHistory(this.extend(r,i)),o=[],d=this.safeValue(a,"data",[]);for(let u=0;u<d.length;u++){const h=d[u],f=this.safeNumber(h,"fundingTime");o.push({info:h,symbol:this.safeSymbol(this.safeString(h,"instId")),fundingRate:this.safeNumber(h,"realizedRate"),timestamp:f,datetime:this.iso8601(f)})}const c=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}parseBalanceByType(e,t){return e==="funding"?this.parseFundingBalance(t):this.parseTradingBalance(t)}parseTradingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),n=this.safeInteger(i,"uTime"),r=this.safeValue(i,"details",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"ccy"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(o,"eq"),f=this.safeString(o,"availEq");h===void 0||f===void 0?(u.free=this.safeString(o,"availBal"),u.used=this.safeString(o,"frozenBal")):(u.total=h,u.free=f),t[c]=u}return t.timestamp=n,t.datetime=this.iso8601(n),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"bal"),o.free=this.safeString(n,"availBal"),o.used=this.safeString(n,"frozenBal"),t[a]=o}return this.safeBalance(t)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.parseNumber(Ot.stringNeg(this.safeString2(e,"maker","makerU"))),taker:this.parseNumber(Ot.stringNeg(this.safeString2(e,"taker","takerU")))}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={instType:this.convertToInstrumentType(s.type)};if(s.spot)i.instId=s.id;else if(s.swap||s.future||s.option)i.uly=s.baseId+"-"+s.quoteId;else throw new hk(this.id+" fetchTradingFee() supports spot, swap, future or option markets only");const n=await this.privateGetAccountTradeFee(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;t==="funding"?i="privateGetAssetBalances":i="privateGetAccountBalance";const n={},r=await this[i](this.extend(n,s));return this.parseBalanceByType(t,r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={instId:a.id,side:s,ordType:t,sz:this.amountToPrecision(e,i)},d=a.spot,c=a.contract,u=this.safeValueN(r,["triggerPrice","stopPrice","triggerPx"]),h=this.safeString(r,"timeInForce","GTC"),f=this.safeValue2(r,"takeProfitPrice","tpTriggerPx"),l=this.safeValue(r,"tpOrdPx",n),m=this.safeString(r,"tpTriggerPxType","last"),g=this.safeValue2(r,"stopLossPrice","slTriggerPx"),y=this.safeValue(r,"slOrdPx",n),w=this.safeString(r,"slTriggerPxType","last"),b=this.safeString2(r,"clOrdId","clientOrderId"),S=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let v=this.safeString2(r,"marginMode","tdMode"),T=!1;if(v!==void 0&&v!=="cash"?T=!0:(v=S,T=this.safeValue(r,"margin",!1)),d){if(T){const $=s==="buy"?a.quote:a.base,Z=this.safeString(r,"ccy",$);o.ccy=this.safeCurrencyCode(Z)}const G=T?v:"cash";o.tdMode=G}else c&&(o.tdMode=v);const I=t==="market",A=this.isPostOnly(I,t==="post_only",r);r=this.omit(r,["currency","ccy","marginMode","timeInForce","stopPrice","triggerPrice","clientOrderId","stopLossPrice","takeProfitPrice","slOrdPx","tpOrdPx","margin"]);const N=h==="IOC"||t==="ioc",B=h==="FOK"||t==="fok",x=u!==void 0||t==="trigger",k=g!==void 0||f!==void 0||t==="conditional",O=I&&N||t==="optimal_limit_ioc",P=this.safeString(this.options,"createOrder","privatePostTradeBatchOrders"),q=this.safeString(this.options,"tgtCcy","base_ccy"),L=this.safeString(r,"tgtCcy",q);!c&&!T&&(o.tgtCcy=L);let D=P;if(I||O){if(o.ordType="market",d&&s==="buy"&&L==="quote_ccy"){let G=this.safeNumber2(r,"cost","sz");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(G===void 0){const Z=this.numberToString(i),he=this.numberToString(n),me=Ot.stringMul(Z,he);G=this.parseNumber(me)}}else if(G===void 0)throw new ce(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)")}else G=G===void 0?i:G;o.sz=this.costToPrecision(e,G),r=this.omit(r,["cost","sz"])}O&&c&&(o.ordType="optimal_limit_ioc")}else!x&&!k&&(o.px=this.priceToPrecision(e,n));if(A?(D=P,o.ordType="post_only"):N&&!O?(D=P,o.ordType="ioc"):B?(D=P,o.ordType="fok"):x?(D="privatePostTradeOrderAlgo",o.ordType="trigger",o.triggerPx=this.priceToPrecision(e,u),o.orderPx=I?"-1":this.priceToPrecision(e,n)):k&&(D="privatePostTradeOrderAlgo",o.ordType="conditional",f!==void 0&&g!==void 0&&(o.ordType="oco"),f!==void 0&&(o.tpTriggerPx=this.priceToPrecision(e,f),o.tpOrdPx=l===void 0?"-1":this.priceToPrecision(e,l),o.tpTriggerPxType=m),g!==void 0&&(o.slTriggerPx=this.priceToPrecision(e,g),o.slOrdPx=y===void 0?"-1":this.priceToPrecision(e,y),o.slTriggerPxType=w)),(t==="oco"||t==="move_order_stop"||t==="iceberg"||t==="twap")&&(D="privatePostTradeOrderAlgo"),b===void 0){const G=this.safeString(this.options,"brokerId");G!==void 0&&(o.clOrdId=G+this.uuid16(),o.tag=G)}else o.clOrdId=b,r=this.omit(r,["clOrdId","clientOrderId"]);let H;if(D==="privatePostTradeOrder"||D==="privatePostTradeOrderAlgo")H=this.extend(o,r);else if(D==="privatePostTradeBatchOrders")H=[this.extend(o,r)];else throw new se(this.id+' createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder');const R=await this[D](H),_=this.safeValue(R,"data",[]),E=this.safeValue(_,0),U=this.parseOrder(E,a);return this.extend(U,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(this.safeValue(s,"stop")){const h=await this.cancelOrders([e],t,s);return this.safeValue(h,0)}if(t===void 0)throw new ui(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n=this.market(t),r={instId:n.id},a=this.safeString2(s,"clOrdId","clientOrderId");a!==void 0?r.clOrdId=a:r.ordId=e;const o=this.omit(s,["clOrdId","clientOrderId"]),d=await this.privatePostTradeCancelOrder(this.extend(r,o)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);return this.parseOrder(u,n)}parseIds(e){return typeof e=="string"?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=[],r=this.safeValue(this.options,"cancelOrders",{}),a=this.safeString(r,"method","privatePostTradeCancelBatchOrders");let o=this.safeString(s,"method",a);const d=this.parseIds(this.safeValue2(s,"clOrdId","clientOrderId")),c=this.parseIds(this.safeValue(s,"algoId")),u=this.safeValue(s,"stop");if(u&&(o="privatePostTradeCancelAlgos"),d===void 0){if(e=this.parseIds(e),c!==void 0)for(let l=0;l<c.length;l++)n.push({algoId:c[l],instId:i.id});for(let l=0;l<e.length;l++)u?n.push({algoId:e[l],instId:i.id}):n.push({ordId:e[l],instId:i.id})}else for(let l=0;l<d.length;l++)n.push({instId:i.id,clOrdId:d[l]});const h=await this[o](n),f=this.safeValue(h,"data",[]);return this.parseOrders(f,i,void 0,void 0,s)}parseOrderStatus(e){const t={canceled:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"algoId","ordId"),i=this.safeInteger(e,"cTime"),n=this.safeInteger(e,"fillTime"),r=this.safeString(e,"side");let a=this.safeString(e,"ordType"),o,d;a==="post_only"?(o=!0,a="limit"):a==="fok"?(d="FOK",a="limit"):a==="ioc"&&(d="IOC",a="limit");const c=this.safeString(e,"instId"),u=this.safeSymbol(c,t,"-"),h=this.safeString(e,"accFillSz"),f=this.safeString2(e,"px","ordPx"),l=this.safeString(e,"avgPx"),m=this.parseOrderStatus(this.safeString(e,"state")),g=this.safeString(e,"fee");let y,w;const b=this.safeString(this.options,"tgtCcy","base_ccy"),S=this.safeString(e,"tgtCcy",b),v=this.safeString(e,"instType");r==="buy"&&a==="market"&&v==="SPOT"&&S==="quote_ccy"?w=this.safeString(e,"sz"):y=this.safeString(e,"sz");let T;if(g!==void 0){const B=Ot.stringNeg(g),x=this.safeString(e,"feeCcy"),k=this.safeCurrencyCode(x);T={cost:this.parseNumber(B),currency:k}}let I=this.safeString(e,"clOrdId");I!==void 0&&I.length<1&&(I=void 0);const A=this.safeNumberN(e,["tpTriggerPx","triggerPx","slTriggerPx"]);let N=this.safeString(e,"reduceOnly");return N!==void 0&&(N=N==="true"),this.safeOrder({info:e,id:s,clientOrderId:I,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:u,type:a,timeInForce:d,postOnly:o,side:r,price:f,stopPrice:A,triggerPrice:A,average:l,cost:w,amount:y,filled:h,remaining:void 0,status:m,fee:T,trades:void 0,reduceOnly:N},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={instId:i.id},r=this.safeString2(s,"clOrdId","clientOrderId"),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeString(a,"method","privateGetTradeOrder"),d=this.safeString(s,"method",o);if(this.safeValue(s,"stop"))throw new hk(this.id+" fetchOrder() does not support stop orders, use fetchOpenOrders() fetchCanceledOrders() or fetchClosedOrders()");r!==void 0?n.clOrdId=r:n.ordId=e;const u=this.omit(s,["method","clOrdId","clientOrderId"]),h=await this[d](this.extend(n,u)),f=this.safeValue(h,"data",[]),l=this.safeValue(f,0);return this.parseOrder(l,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id),s!==void 0&&(n.limit=s);const a=this.safeValue(this.options,"fetchOpenOrders",{}),o=this.safeValue(this.options,"algoOrderTypes",{}),d=this.safeString(a,"method","privateGetTradeOrdersPending");let c=this.safeString(i,"method",d);const u=this.safeString(i,"ordType"),h=this.safeValue(i,"stop");if((h||u in o)&&(c="privateGetTradeOrdersAlgoPending",h&&u===void 0))throw new ui(this.id+' fetchOpenOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');const f=this.omit(i,["method","stop"]),l=await this[c](this.extend(n,f)),m=this.safeValue(l,"data",[]);return this.parseOrders(m,r,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchCanceledOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s),n.state="canceled";const d=this.safeValue(this.options,"fetchCanceledOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const f=this.safeString(i,"ordType"),l=this.safeValue(i,"stop");if(l||f in c){h="privateGetTradeOrdersAlgoHistory";const w=this.safeString(i,"algoId");if(w!==void 0&&(n.algoId=w,i=this.omit(i,"algoId")),l){if(f===void 0)throw new ui(this.id+' fetchCanceledOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.ordType=f}}else{t!==void 0&&(n.begin=t);const w=this.safeInteger2(o,"till","until");w!==void 0&&(n.end=w,o=this.omit(o,["until","till"]))}const m=this.omit(o,["method","stop","ordType"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchClosedOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=this.safeValue(this.options,"fetchClosedOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const f=this.safeString(i,"ordType"),l=this.safeValue(i,"stop");if(l||f in c){if(h="privateGetTradeOrdersAlgoHistory",l&&f===void 0)throw new ui(this.id+' fetchClosedOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.state="effective"}else{t!==void 0&&(n.begin=t);const w=this.safeInteger2(o,"till","until");w!==void 0&&(n.end=w,o=this.omit(o,["until","till"])),n.state="filled"}const m=this.omit(o,["method","stop"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=await this.privateGetTradeFillsHistory(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseTrades(c,r,t,s,o)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={ordId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchLedger",{});let r=this.safeString(n,"method");r=this.safeString(i,"method",r),i=this.omit(i,"method");const a={};let o;[o,i]=this.handleMarginModeAndParams("fetchLedger",i),o===void 0&&(o=this.safeString(i,"mgnMode")),r!=="privateGetAssetBills"&&o!==void 0&&(a.mgnMode=o);const[d,c]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);d!==void 0&&(a.instType=this.convertToInstrumentType(d)),s!==void 0&&(a.limit=s);let u;e!==void 0&&(u=this.currency(e),a.ccy=u.id);const h=await this[r](this.extend(a,c)),f=this.safeValue(h,"data",[]);return this.parseLedger(f,u,t,s)}parseLedgerEntryType(e){const t={1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=void 0,n=this.safeString(e,"ordId"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"ccy"),t),d=this.safeString(e,"balChg"),c=this.parseNumber(d),u=this.safeInteger(e,"ts"),h=this.safeString(e,"fee");let f;h!==void 0&&(f={cost:this.parseNumber(Ot.stringNeg(h)),currency:o});const l=void 0,m=this.safeString(e,"bal"),g=this.parseNumber(m),y="ok",w=this.safeString(e,"instId"),b=this.safeSymbol(w,void 0,"-");return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),account:i,referenceId:n,referenceAccount:r,type:a,currency:o,symbol:b,amount:c,before:l,after:g,status:y,fee:f}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addr");let i=this.safeString2(e,"tag","pmtId");i=this.safeString(e,"memo",i);const n=this.safeString(e,"ccy");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id");let c=this.safeValue(d,a);a==="USDT-Polygon"&&(c=this.safeValue(d,"USDT-Polygon-Bridge"));const u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAssetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.filterBy(r,"selected",!0),o=this.parseDepositAddresses(a,[e],!1);return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s);t=this.omit(t,"network");const r=await this.fetchDepositAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new gu(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new gu(this.id+" fetchDepositAddress() cannot find "+n+" deposit address for "+e);return a}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&i.length>0&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new ui(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKX are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={ccy:r.id,toAddr:s,dest:"4",amt:this.numberToString(t),fee:this.numberToString(a)};"password"in n?o.pwd=n.password:"pwd"in n&&(o.pwd=n.pwd);const d=this.safeValue(this.options,"networks",{});let c=this.safeStringUpper(n,"network");c=this.safeString(d,c,c),c!==void 0&&(o.chain=r.id+"-"+c,n=this.omit(n,"network"));const u=this.omit(n,["fee","password","pwd"]);if(!("pwd"in o))throw new se(this.id+" withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase");const h=await this.privatePostAssetWithdrawal(this.extend(o,u)),f=this.safeValue(h,"data",[]),l=this.safeValue(f,0);return this.parseTransaction(l,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={depId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetDepositHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetWithdrawalHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={wdId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetWithdrawalHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"wdId"),r=this.safeString(e,"from"),a=this.safeString(e,"to"),o=a;let d=this.safeString2(e,"tag","memo");d=this.safeString2(e,"pmtId",d),n!==void 0?(s="withdrawal",i=n):(i=this.safeString(e,"depId"),s="deposit");const c=this.safeString(e,"ccy"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amt"),f=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeString(e,"txId"),m=this.safeInteger(e,"ts");let g;return s==="deposit"?g=0:g=this.safeNumber(e,"fee"),{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:r,addressTo:a,address:o,tagFrom:void 0,tagTo:d,tag:d,status:f,type:s,updated:void 0,txid:l,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}async fetchLeverage(e,t={}){await this.loadMarkets();let s;if([s,t]=this.handleMarginModeAndParams("fetchLeverage",t),s===void 0&&(s=this.safeString(t,"mgnMode","cross")),s!=="cross"&&s!=="isolated")throw new Ee(this.id+" fetchLeverage() requires a marginMode parameter that must be either cross or isolated");const n={instId:this.market(e).id,mgnMode:s};return await this.privateGetAccountLeverageInfo(this.extend(n,t))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchPosition",s,t);s.id,i!==void 0&&this.convertToInstrumentType(i);const r=await this.privateGetAccountPositions(n),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return o===void 0?o:this.parsePosition(o)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.market(d);a.push(c.id)}a.length>0&&(s.instId=a.join(","))}const i=await this.privateGetAccountPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]),r=[];for(let a=0;a<n.length;a++)r.push(this.parsePosition(n[a]));return this.filterByArray(r,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"pos"),r=Ot.stringAbs(n);let a,o=this.safeString(e,"posSide");const d=o!=="net";if(t.margin){if(o==="net"){const q=this.safeString(e,"posCcy"),L=this.safeCurrencyCode(q);L!==void 0&&(o=t.base===L?"long":"short")}}else n!==void 0&&(a=this.parseNumber(r),o==="net"&&(Ot.stringGt(n,"0")?o="long":Ot.stringLt(n,"0")?o="short":o=void 0));const c=this.safeValue(t,"contractSize"),u=this.numberToString(c),h=this.safeString(e,"markPx");let f=this.safeString(e,"notionalUsd");t.inverse&&(f=Ot.stringDiv(Ot.stringMul(r,u),h));const l=this.parseNumber(f),m=this.safeString(e,"mgnMode");let g;const y=this.safeString(e,"avgPx"),w=this.safeString(e,"upl"),b=this.safeString(e,"lever");let S,v;m==="cross"?(g=this.safeString(e,"imr"),v=Ot.stringAdd(g,w)):m==="isolated"&&(S=Ot.stringDiv("1",b),v=this.safeString(e,"margin"));const T=this.safeString(e,"mmr"),I=this.parseNumber(T);let A=Ot.stringDiv(T,f);S===void 0?S=this.parseNumber(Ot.stringDiv(g,f,4)):g===void 0&&(g=Ot.stringMul(S,f));const N="0.00005";A=this.parseNumber(Ot.stringDiv(Ot.stringAdd(A,N),"1",4));const B=this.safeNumber(e,"liqPx"),x=this.safeString(e,"uplRatio"),k=this.parseNumber(Ot.stringMul(x,"100")),O=this.safeInteger(e,"uTime"),P=this.parseNumber(Ot.stringDiv(T,v,4));return{info:e,id:void 0,symbol:i,notional:l,marginMode:m,liquidationPrice:B,entryPrice:this.parseNumber(y),unrealizedPnl:this.parseNumber(w),percentage:k,contracts:a,contractSize:c,markPrice:this.parseNumber(h),side:o,hedged:d,timestamp:O,datetime:this.iso8601(O),maintenanceMargin:I,maintenanceMarginPercentage:A,collateral:this.parseNumber(v),initialMargin:this.parseNumber(g),initialMarginPercentage:this.parseNumber(S),leverage:this.parseNumber(b),marginRatio:P}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={ccy:r.id,amt:this.currencyToPrecision(e,t),type:"0",from:o,to:d};o==="master"?(c.type="1",c.subAcct=d,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6")):d==="master"&&(c.type="2",c.subAcct=o,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6"));const u=await this.privatePostAssetTransfer(this.extend(c,n)),h=this.safeValue(u,"data",[]),f=this.safeValue(h,0,{});return this.parseTransfer(f,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeString(e,"ccy"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amt"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(this.options,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.milliseconds(),f=this.safeString(e,"state");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:n,amount:r,fromAccount:c,toAccount:u,status:f}}async fetchTransfer(e,t=void 0,s={}){await this.loadMarkets();const i={transId:e},n=await this.privateGetAssetTransferState(this.extend(i,s)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parseTransfer(a)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i),o="/api/"+this.version+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;if(t==="public")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const u=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":u};let h=u+s+o;if(s==="GET"){if(Object.keys(d).length){const l="?"+this.urlencode(d);c+=l,h+=l}}else(a||Object.keys(d).length)&&(r=this.json(d),h+=r),n["Content-Type"]="application/json";const f=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=f}return{url:c,method:s,body:r,headers:n}}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"nextFundingTime"),i=this.safeString(e,"instId"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"nextFundingRate"),a=this.safeInteger(e,"fundingTime");return{info:e,symbol:n,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:r,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new se(this.id+" fetchFundingRate() is only valid for swap markets");const i={instId:s.id},n=await this.publicGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseFundingRate(a,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={type:"8"};s!==void 0&&(n.limit=s.toString());let r;e!==void 0&&(r=this.market(e),e=r.symbol,r.contract&&(r.linear?(n.ctType="linear",n.ccy=r.quoteId):(n.ctType="inverse",n.ccy=r.baseId)));const[a,o]=this.handleMarketTypeAndParams("fetchFundingHistory",r,i);a==="swap"&&(n.instType=this.convertToInstrumentType(a));const d=await this.privateGetAccountBillsArchive(this.extend(n,o)),c=this.safeValue(d,"data",[]),u=[];for(let f=0;f<c.length;f++){const l=c[f],m=this.safeInteger(l,"ts"),g=this.safeString(l,"instId"),y=this.safeMarket(g),w=this.safeString(l,"ccy"),b=this.safeCurrencyCode(w);u.push({info:l,symbol:y.symbol,code:b,timestamp:m,datetime:this.iso8601(m),id:this.safeString(l,"billId"),amount:this.safeNumber(l,"balChg")})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,e,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new Ee(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if([n,s]=this.handleMarginModeAndParams("setLeverage",s),n===void 0&&(n=this.safeString(s,"mgnMode","cross")),n!=="cross"&&n!=="isolated")throw new Ee(this.id+" setLeverage() requires a marginMode parameter that must be either cross or isolated");const r={lever:e,mgnMode:n,instId:i.id},a=this.safeString(s,"posSide");if(n==="isolated"){if(a===void 0)throw new ui(this.id+" setLeverage() requires a posSide argument for isolated margin");if(a!=="long"&&a!=="short")throw new Ee(this.id+' setLeverage() requires the posSide argument to be either "long" or "short"')}return await this.privatePostAccountSetLeverage(this.extend(r,s))}async setPositionMode(e,t=void 0,s={}){let i;e?i="long_short_mode":i="net_mode";const n={posMode:i};return await this.privatePostAccountSetPositionMode(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="cross"&&e!=="isolated")throw new Ee(this.id+" setMarginMode() marginMode must be either cross or isolated");await this.loadMarkets();const i=this.market(t),n=this.safeInteger(s,"lever");if(n===void 0||n<1||n>125)throw new Ee(this.id+' setMarginMode() params["lever"] should be between 1 and 125');s=this.omit(s,["lever"]);const r={lever:n,mgnMode:e,instId:i.id};return await this.privatePostAccountSetLeverage(this.extend(r,s))}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetAccountInterestRate(e),s=this.milliseconds(),i=this.safeValue(t,"data"),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeCurrencyCode(this.safeString(a,"ccy"));n[o]={currency:o,rate:this.safeNumber(a,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a}}return n}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAccountInterestRate(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseBorrowRate(a)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"ccy"),i=this.safeInteger(e,"ts");return{currency:this.safeCurrencyCode(s),rate:this.safeNumber2(e,"interestRate","rate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}parseBorrowRateHistories(e,t,s,i){const n={};for(let a=0;a<e.length;a++){const o=e[a],d=this.safeCurrencyCode(this.safeString(o,"ccy"));if(t===void 0||this.inArray(d,t)){d in n||(n[d]=[]);const c=this.parseBorrowRate(o);n[d].push(c)}}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a];n[o]=this.filterByCurrencySinceLimit(n[o],o,s,i)}return n}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}async fetchBorrowRateHistories(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.before=t),s!==void 0&&(n.limit=s);const r=await this.publicGetAssetLendingRateHistory(this.extend(n,i)),a=this.safeValue(r,"data");return this.parseBorrowRateHistories(a,e,t,s)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={ccy:this.currency(e).id};t!==void 0&&(r.before=t),s!==void 0&&(r.limit=s);const a=await this.publicGetAssetLendingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseBorrowRateHistory(o,e,t,s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"posSide","net");i=this.omit(i,["posSide"]);const a={instId:n.id,amt:t,type:s,posSide:r},o=await this.privatePostAccountPositionMarginBalance(this.extend(a,i));return this.parseMarginModification(o,n)}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),r=this.safeString(e,"code")==="0"?"ok":"failed",a=this.safeNumber(i,"amt"),d=this.safeString(i,"type")==="reduce"?"reduce":"add",c=this.safeString(i,"instId"),u=this.safeMarket(c,t),h=u.inverse?u.base:u.quote;return{info:e,type:d,amount:a,code:h,symbol:u.symbol,status:r}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.spot?"MARGIN":this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly");if(!n&&i!=="MARGIN")throw new Ee(this.id+" fetchMarketLeverageTiers() cannot fetch leverage tiers for "+e);let r;[r,t]=this.handleMarginModeAndParams("fetchMarketLeverageTiers",t),r===void 0&&(r=this.safeString(t,"tdMode","cross"));const a={instType:i,tdMode:r,uly:n};i==="MARGIN"&&(a.instId=s.id);const o=await this.publicGetPublicPositionTiers(this.extend(a,t)),d=this.safeValue(o,"data");return this.parseMarketLeverageTiers(d,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeInteger(n,"tier"),currency:t.quote,minNotional:this.safeNumber(n,"minSz"),maxNotional:this.safeNumber(n,"maxSz"),maintenanceMarginRate:this.safeNumber(n,"mmr"),maxLeverage:this.safeNumber(n,"maxLever"),info:n})}return s}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r=this.safeString(n,"mgnMode","cross"));const a={mgnMode:r};let o;if(e!==void 0){const h=this.currency(e);a.ccy=h.id}s!==void 0&&(a.before=s-1),i!==void 0&&(a.limit=i),t!==void 0&&(o=this.market(t),a.instId=o.id);const d=await this.privateGetAccountInterestAccrued(this.extend(a,n)),c=this.safeValue(d,"data"),u=this.parseBorrowInterests(c);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"instId");s!==void 0&&(t=this.safeMarket(s,t));const i=this.safeInteger(e,"ts");return{symbol:this.safeString(t,"symbol"),marginMode:this.safeString(e,"mgnMode"),currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"liab"),timestamp:i,datetime:this.iso8601(i),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"borrow"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"repay"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"ccy");return{id:void 0,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amt"),symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Ee(this.id+" fetchOpenInterest() supports contract markets only");const i=this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly"),r={instType:i,uly:n,instId:s.id},a=await this.publicGetPublicOpenInterest(this.extend(r,t)),o=this.safeValue(a,"data",[]);return this.parseOpenInterest(o[0],s)}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){const r=this.safeValue(this.options,"fetchOpenInterestHistory",{}),a=this.safeValue(r,"timeframes",{});if(t=this.safeString(a,t,t),t!=="5m"&&t!=="1H"&&t!=="1D")throw new Ee(this.id+" fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe");await this.loadMarkets();const d={ccy:this.currency(e).id,period:t};s!==void 0&&(d.begin=s);const c=this.safeInteger2(n,"till","until");c!==void 0&&(d.end=c,n=this.omit(n,["until","till"]));const u=await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(d,n)),h=this.safeValue(u,"data");return this.parseOpenInterests(h,void 0,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=this.safeInteger(e,"ts"),n=this.safeNumber(e,0,i),r=this.safeNumber(e,"oi"),a=this.safeNumber(e,"oiCcy"),o=this.safeNumber(e,1,a);return{symbol:this.safeSymbol(s),baseVolume:void 0,quoteVolume:o,openInterestAmount:r,openInterestValue:o,timestamp:n,datetime:this.iso8601(n),info:e}}setSandboxMode(e){super.setSandboxMode(e),e?this.headers["x-simulated-trading"]="1":"x-simulated-trading"in this.headers&&(this.headers=this.omit(this.headers,"x-simulated-trading"))}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r,h=this.safeValue(a,"data",[]);for(let f=0;f<h.length;f++){const l=h[f],m=this.safeString(l,"sCode"),g=this.safeString(l,"sMsg");this.throwExactlyMatchedException(this.exceptions.exact,m,u),this.throwBroadlyMatchedException(this.exceptions.broad,g,u)}throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new se(u)}}};const I6=gg;var qT=class extends I6{describe(){return this.deepExtend(super.describe(),{id:"okex",alias:!0})}};const x6=qT;var _6=class extends x6{describe(){return this.deepExtend(super.describe(),{id:"okex5",alias:!0})}};const C6=re,{ExchangeError:lp}=Q,{TICK_SIZE:M6}=ne,P6=ae;var A6=class extends C6{describe(){return this.deepExtend(super.describe(),{id:"paymium",name:"Paymium",countries:["FR","EU"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153930-f0f02200-c2c0-11ea-9c0a-40337375ae89.jpg",api:{rest:"https://paymium.com/api"},www:"https://www.paymium.com",fees:"https://www.paymium.com/page/help/fees",doc:["https://github.com/Paymium/api-documentation","https://www.paymium.com/page/developers","https://paymium.github.io/api-documentation/"],referral:"https://www.paymium.com/page/sign-up?referral=eDAzPoRQFMvaAB8sf-qj"},api:{public:{get:["countries","data/{currency}/ticker","data/{currency}/trades","data/{currency}/depth","bitcoin_charts/{id}/trades","bitcoin_charts/{id}/depth"]},private:{get:["user","user/addresses","user/addresses/{address}","user/orders","user/orders/{uuid}","user/price_alerts","merchant/get_payment/{uuid}"],post:["user/addresses","user/orders","user/withdrawals","user/email_transfers","user/payment_requests","user/price_alerts","merchant/create_payment"],delete:["user/orders/{uuid}","user/orders/{uuid}/cancel","user/price_alerts/{id}"]}},markets:{"BTC/EUR":{id:"eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.001"),taker:this.parseNumber("0.005")}},precisionMode:M6})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o="balance_"+a;if(o in e){const d=this.account(),c="locked_"+a;d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUser(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id},r=await this.publicGetDataCurrencyDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"at"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=P6.stringMul(r,n),o=this.safeString(e,"price");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:this.safeString(e,"variation"),average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id},n=await this.publicGetDataCurrencyTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeTimestamp(e,"created_at_int"),i=this.safeString(e,"uuid");t=this.safeMarket(void 0,t);const n=this.safeString(e,"side"),r=this.safeString(e,"price"),a="traded_"+t.base.toLowerCase(),o=this.safeString(e,a);return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.publicGetDataCurrencyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostUserAddresses(t);return this.parseDepositAddress(s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={address:e},i=await this.privateGetUserAddressesAddress(this.extend(s,t));return this.parseDepositAddress(i)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetUserAddresses(t);return this.parseDepositAddresses(s,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"currency");return{info:e,currency:this.safeCurrencyCode(i,t),address:s,tag:void 0,network:void 0}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:this.capitalize(t)+"Order",currency:a.id,direction:s,amount:i};t!=="market"&&(o.price=n);const d=await this.privatePostUserOrders(this.extend(o,r));return{info:d,id:d.uuid}}async cancelOrder(e,t=void 0,s={}){const i={uuid:e};return await this.privateDeleteUserOrdersUuidCancel(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(i.indexOf("@")<0)throw new lp(this.id+" transfer() only allows transfers to an email address");if(e!=="BTC"&&e!=="EUR")throw new lp(this.id+" transfer() only allows BTC or EUR");const a={currency:r.id,amount:this.currencyToPrecision(e,t),email:i},o=await this.privatePostUserEmailTransfers(this.extend(a,n));return this.parseTransfer(o,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"updated_at"),n=this.parseDate(i),r=this.safeValue(e,"account_operations"),a=this.safeValue(r,0,{}),o=this.safeString(e,"state");return{info:e,id:this.safeString(e,"uuid"),timestamp:n,datetime:this.iso8601(n),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:void 0,toAccount:this.safeString(a,"address"),status:this.parseTransferStatus(o)}}parseTransferStatus(e){const t={executed:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d+a;if(n={"Api-Key":this.apiKey,"Api-Nonce":d},s==="POST")Object.keys(o).length&&(r=this.json(o),c+=r,n["Content-Type"]="application/json");else if(Object.keys(o).length){const u=this.urlencode(o);c+=u,a+="?"+u}n["Api-Signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"errors")!==void 0)throw new lp(this.id+" "+this.json(a))}};const B6=re,{ExchangeError:ws,BadSymbol:kd,AuthenticationError:pp,InsufficientFunds:fn,InvalidOrder:oe,ArgumentsRequired:bs,OrderNotFound:bu,BadRequest:xs,PermissionDenied:ku,AccountSuspended:N6,CancelPending:Su,DDoSProtection:fk,DuplicateOrderId:mp,RateLimitExceeded:V6}=Q,{TICK_SIZE:E6}=ne,Xt=ae;var LT=class extends B6{describe(){return this.deepExtend(super.describe(),{id:"phemex",name:"Phemex",countries:["CN"],rateLimit:100,version:"v1",certified:!1,pro:!0,hostname:"api.phemex.com",has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistories:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg",test:{v1:"https://testnet-api.phemex.com/v1",public:"https://testnet-api.phemex.com/exchange/public",private:"https://testnet-api.phemex.com"},api:{v1:"https://{hostname}/v1",v2:"https://{hostname}",public:"https://{hostname}/exchange/public",private:"https://{hostname}"},www:"https://phemex.com",doc:"https://github.com/phemex/phemex-api-docs",fees:"https://phemex.com/fees-conditions",referral:{url:"https://phemex.com/register?referralCode=EDNVJ",discount:.1}},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","3h":"10800","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2592000"},api:{public:{get:["cfg/v2/products","cfg/fundingRates","products","nomics/trades","md/kline","md/v2/kline/list","md/v2/kline/last"]},v1:{get:["md/orderbook","md/trade","md/ticker/24hr","md/ticker/24hr/all","md/spot/ticker/24hr","md/spot/ticker/24hr/all","exchange/public/products"]},v2:{get:["md/v2/orderbook","md/v2/trade","md/v2/ticker/24hr","md/v2/ticker/24hr/all"]},private:{get:["spot/orders/active","spot/orders","spot/wallets","exchange/spot/order","exchange/spot/order/trades","accounts/accountPositions","accounts/positions","api-data/futures/funding-fees","orders/activeList","exchange/order/list","exchange/order","exchange/order/trade","phemex-user/users/children","phemex-user/wallets/v2/depositAddress","phemex-user/wallets/tradeAccountDetail","phemex-user/order/closedPositionList","exchange/margins/transfer","exchange/wallets/confirm/withdraw","exchange/wallets/withdrawList","exchange/wallets/depositList","exchange/wallets/v2/depositAddress","api-data/spots/funds","assets/convert","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/quote","assets/convert"],post:["spot/orders","orders","positions/assign","exchange/wallets/transferOut","exchange/wallets/transferIn","exchange/margins","exchange/wallets/createWithdraw","exchange/wallets/cancelWithdraw","exchange/wallets/createWithdrawAddress","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/universal-transfer","assets/convert"],put:["spot/orders","orders/replace","positions/leverage","positions/riskLimit"],delete:["spot/orders","spot/orders/all","orders/cancel","orders","orders/all"]}},precisionMode:E6,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{412:xs,6001:xs,19999:xs,10001:mp,10002:bu,10003:Su,10004:Su,10005:Su,11001:fn,11002:oe,11003:fn,11004:oe,11005:fn,11006:ws,11007:ws,11008:ws,11009:ws,11010:fn,11011:oe,11012:oe,11013:oe,11014:oe,11015:oe,11016:xs,11017:ws,11018:ws,11019:ws,11020:ws,11021:ws,11022:N6,11023:ws,11024:ws,11025:xs,11026:ws,11027:kd,11028:kd,11029:ws,11030:ws,11031:fk,11032:fk,11033:mp,11034:oe,11035:oe,11036:oe,11037:oe,11038:oe,11039:oe,11040:oe,11041:oe,11042:oe,11043:oe,11044:oe,11045:oe,11046:oe,11047:oe,11048:oe,11049:oe,11050:oe,11051:oe,11052:oe,11053:oe,11054:oe,11055:oe,11056:oe,11057:oe,11058:oe,11059:oe,11060:oe,11061:Su,11062:oe,11063:oe,11064:oe,11065:oe,11066:oe,11067:oe,11068:oe,11069:ws,11070:kd,11071:oe,11072:oe,11073:oe,11074:oe,11075:oe,11076:oe,11077:oe,11078:oe,11079:oe,11080:oe,11081:oe,11082:fn,11083:oe,11084:oe,11085:mp,11086:oe,11087:oe,11088:oe,11089:oe,11090:oe,11091:oe,11092:oe,11093:oe,11094:oe,11095:oe,11096:oe,11097:xs,11098:xs,11099:ws,11100:fn,11101:fn,11102:xs,11103:xs,11104:xs,11105:fn,11106:fn,11107:ws,11108:oe,11109:oe,11110:oe,11111:oe,11112:oe,11113:xs,11114:oe,11115:oe,11116:oe,11117:oe,11118:oe,11119:oe,11120:oe,11121:oe,11122:oe,11123:oe,11124:oe,11125:oe,11126:oe,11128:oe,11129:oe,11130:oe,11131:oe,11132:oe,11133:oe,11134:oe,3e4:xs,30018:xs,34003:ku,35104:fn,39995:V6,39996:ku},broad:{"401 Insufficient privilege":ku,"401 Request IP mismatch":ku,"Failed to find api-key":pp,"Missing required parameter":xs,"API Signature verification failed":pp,"Api key not found":pp}},options:{brokerId:"ccxt2022","x-phemex-request-expiry":60,createOrderByQuoteRequiresPrice:!0,networks:{TRC20:"TRX",ERC20:"ETH"},defaultNetworks:{USDT:"ETH"},defaultSubType:"linear",accountsByType:{spot:"spot",swap:"future"},transfer:{fillResponseFromRequest:!0}}})}parseSafeNumber(e=void 0){if(e===void 0)return e;let t=e.split(",");return e=t.join(""),t=e.split(" "),this.safeNumber(t,0)}parseSwapMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString2(e,"baseCurrency","contractUnderlyingAssets"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"settleCurrency"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(n);let d=!1;n!==i&&(d=!0);const c=this.safeInteger(e,"priceScale"),u=this.safeInteger(e,"ratioScale"),h=this.safeInteger(e,"valueScale"),f=this.safeString(e,"minPriceEp"),l=this.safeString(e,"maxPriceEp"),m=this.safeString(e,"makerFeeRateEr"),g=this.safeString(e,"takerFeeRateEr"),y=this.safeString(e,"status"),w=this.safeString(e,"contractSize"," ");let b;if(w.indexOf(" ")){const S=w.split(" ");b=this.parseNumber(S[0])}else b=this.parseNumber(w);return{id:t,symbol:r+"/"+a+":"+o,base:r,quote:a,settle:o,baseId:s,quoteId:i,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:y==="Listed",contract:!0,linear:!d,inverse:d,taker:this.parseNumber(this.fromEn(g,u)),maker:this.parseNumber(this.fromEn(m,u)),contractSize:b,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:c,valueScale:h,ratioScale:u,precision:{amount:this.safeNumber(e,"lotSize"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(e,"maxLeverage")},amount:{min:void 0,max:void 0},price:{min:this.parseNumber(this.fromEn(f,c)),max:this.parseNumber(this.fromEn(l,c))},cost:{min:void 0,max:this.parseNumber(this.safeString(e,"maxOrderQty"))}},info:e}}parseSpotMarket(e){const t=this.safeStringLower(e,"type"),s=this.safeString(e,"symbol"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"baseCurrency"),r=this.safeCurrencyCode(n),a=this.safeCurrencyCode(i),o=this.safeString(e,"status"),d=this.parseSafeNumber(this.safeString(e,"baseTickSize")),c=this.parseSafeNumber(this.safeString(e,"quoteTickSize"));return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:n,quoteId:i,settleId:void 0,type:t,spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:o==="Listed",contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"defaultTakerFee"),maker:this.safeNumber(e,"defaultMakerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:8,valueScale:8,ratioScale:8,precision:{amount:d,price:c},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:this.parseSafeNumber(this.safeString(e,"maxBaseOrderSize"))},price:{min:c,max:void 0},cost:{min:this.parseSafeNumber(this.safeString(e,"minOrderValue")),max:this.parseSafeNumber(this.safeString(e,"maxOrderValue"))}},info:e}}async fetchMarkets(e={}){const t=await this.publicGetCfgV2Products(e),s=await this.v1GetExchangePublicProducts(e),i=this.safeValue(s,"data",[]),n=this.safeValue(t,"data",{}),r=this.safeValue(n,"products",[]),a=this.safeValue(n,"riskLimits",[]),o=this.indexBy(a,"symbol"),d=this.indexBy(i,"symbol"),c=[];for(let u=0;u<r.length;u++){let h=r[u];const f=this.safeStringLower(h,"type");if(f==="perpetual"||f==="perpetualv2"){const l=this.safeString(h,"symbol"),m=this.safeValue(o,l,{});h=this.extend(h,m);const g=this.safeValue(d,l,{});h=this.extend(h,g),h=this.parseSwapMarket(h)}else h=this.parseSpotMarket(h);c.push(h)}return c}async fetchCurrencies(e={}){const t=await this.publicGetCfgV2Products(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"currency"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o),u=this.safeString(a,"valueScale"),h=parseInt(u),f=this.safeString(a,"minValueEv"),l=this.safeString(a,"maxValueEv");let m,g,y;if(h!==void 0){const w=this.parsePrecision(u);y=this.parseNumber(w),m=this.parseNumber(Xt.stringMul(f,w)),g=this.parseNumber(Xt.stringMul(l,w))}n[c]={id:o,info:a,code:c,name:d,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:y,limits:{amount:{min:m,max:g},withdraw:{min:void 0,max:void 0}},valueScale:h}}return n}parseBidAsk(e,t=0,s=1,i=void 0){if(i===void 0)throw new bs(this.id+" parseBidAsk() requires a market argument");let n=this.safeString(e,s);return i.spot&&(n=this.fromEv(n,i)),[this.parseNumber(this.fromEp(this.safeString(e,t),i)),this.parseNumber(n)]}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d={symbol:t,timestamp:s,datetime:this.iso8601(s),nonce:void 0},c=[i,n];for(let u=0;u<c.length;u++){const h=c[u],f=[],l=this.safeValue(e,h);for(let m=0;m<l.length;m++)f.push(this.parseBidAsk(l[m],r,a,o));d[h]=f}return d[i]=this.sortBy(d[i],0,!0),d[n]=this.sortBy(d[n],0),d}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1GetMdOrderbook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"book",{}),d=this.safeIntegerProduct(a,"timestamp",1e-6),c=this.parseOrderBook(o,e,d,"bids","asks",0,1,i);return c.nonce=this.safeInteger(a,"sequence"),c}toEn(e,t){const s=e.toString(),i=new Xt(s);i.decimals=i.decimals-t,i.reduce();const n=i.toString();return parseInt(parseFloat(n))}toEv(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.valueScale)}toEp(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.priceScale)}fromEn(e,t){if(e===void 0)return;const s=new Xt(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}parseOHLCV(e,t=void 0){let s;return t!==void 0&&t.spot?s=this.parseNumber(this.fromEv(this.safeString(e,7),t)):s=this.safeNumber(e,7),[this.safeTimestamp(e,0),this.parseNumber(this.fromEp(this.safeString(e,3),t)),this.parseNumber(this.fromEp(this.safeString(e,4),t)),this.parseNumber(this.fromEp(this.safeString(e,5),t)),this.parseNumber(this.fromEp(this.safeString(e,6),t)),s]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={resolution:this.timeframes[t]},a=this.parseTimeframe(t),o=this.seconds(),d=2e3;i===void 0?i=100:i=Math.min(i,d),s!==void 0?(i=Math.min(i,d),s=parseInt(s/1e3),r.from=s,r.to=Math.min(o,this.sum(s,a*i))):(i<d&&(i=i+1),r.from=o-a*i,r.to=o),await this.loadMarkets();const c=this.market(e);r.symbol=c.id;const u=await this.publicGetMdKline(this.extend(r,n)),h=this.safeValue(u,"data",{}),f=this.safeValue(h,"rows",[]);return this.parseOHLCVs(f,c,t,s,i)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString2(e,"lastEp","closeRp"),t),a=this.fromEv(this.safeString2(e,"turnoverEv","turnoverRv"),t);let o=this.safeString(e,"volume");o===void 0&&(o=this.fromEv(this.safeString2(e,"volumeEv","volumeRq"),t));const d=this.fromEp(this.safeString(e,"openEp"),t);return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.fromEp(this.safeString2(e,"highEp","highRp"),t),low:this.fromEp(this.safeString2(e,"lowEp","lowRp"),t),bid:this.fromEp(this.safeString(e,"bidEp"),t),bidVolume:void 0,ask:this.fromEp(this.safeString(e,"askEp"),t),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n="v1GetMdSpotTicker24hr";s.swap&&(s.inverse||s.settle==="USD"?n="v1GetMdTicker24hr":n="v2GetMdV2Ticker24hr");const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseTicker(a,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1GetMdTrade(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c;const u=this.safeString(e,"symbol");t=this.safeMarket(u,t);const h=t.symbol;let f,l;if(Array.isArray(e)){const m=e.length;n=this.safeIntegerProduct(e,0,1e-6),m>4&&(r=this.safeString(e,m-4)),a=this.safeStringLower(e,m-3),s=this.fromEp(this.safeString(e,m-2),t),i=this.fromEv(this.safeString(e,m-1),t)}else{n=this.safeIntegerProduct(e,"transactTimeNs",1e-6),r=this.safeString2(e,"execId","execID"),f=this.safeString(e,"orderID"),a=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),this.safeString(e,"execStatus")==="MakerFill"&&(l="maker"),s=this.fromEp(this.safeString(e,"execPriceEp"),t),i=this.fromEv(this.safeString(e,"execBaseQtyEv"),t),i=this.safeString(e,"execQty",i),o=this.fromEv(this.safeString2(e,"execQuoteQtyEv","execValueEv"),t);const g=this.fromEv(this.safeString(e,"execFeeEv"),t);if(g!==void 0){const y=this.fromEr(this.safeString(e,"feeRateEr"),t);let w;if(t.spot)w=a==="buy"?t.base:t.quote;else{const b=this.safeValue(t,"info");if(b!==void 0){const S=this.safeString(b,"settlementCurrency");w=this.safeCurrencyCode(S)}}c={cost:g,rate:y,currency:w}}}return this.safeTrade({info:e,id:r,symbol:h,timestamp:n,datetime:this.iso8601(n),order:f,type:d,side:a,takerOrMaker:l,price:s,amount:i,cost:o,fee:c},t)}parseSpotBalance(e){let t;const s={info:e},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account(),h=this.safeString(r,"balanceEv"),f=this.safeString(r,"lockedTradingBalanceEv"),l=this.safeString(r,"lockedWithdrawEv"),m=this.fromEn(h,c),g=this.fromEn(f,c),y=this.fromEn(l,c),w=Xt.stringAdd(g,y),b=this.safeIntegerProduct(r,"lastUpdateTimeNs",1e-6);t=t===void 0?b:Math.max(t,b),u.total=m,u.used=w,s[o]=u}return s.timestamp=t,s.datetime=this.iso8601(t),this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"account",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.currency(r),o=this.account(),d=this.safeString(i,"accountBalanceEv"),c=this.safeString(i,"totalUsedBalanceEv"),u=this.safeInteger(a,"valueScale",8);return o.total=this.fromEn(d,u),o.used=this.fromEn(c,u),t[r]=o,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"defaultType","fetchBalance","spot"),s=this.safeString(e,"type",t);let i="privateGetSpotWallets";const n={};if(s==="swap"){const o=this.safeString(e,"code");if(o!==void 0){const d=this.currency(o);n.currency=d.id,e=this.omit(e,"code")}else if(this.safeString(e,"currency")===void 0)throw new bs(this.id+" fetchBalance() requires a code parameter or a currency parameter for "+s+" type");i="privateGetAccountsAccountPositions"}e=this.omit(e,"type");const r=await this[i](this.extend(n,e));return s==="swap"?this.parseSwapBalance(r):this.parseSpotBalance(r)}parseOrderStatus(e){const t={Created:"open",Untriggered:"open",Deactivated:"closed",Triggered:"open",Rejected:"rejected",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={Limit:"limit",Market:"market"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",PostOnly:"PO",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.fromEp(this.safeString(e,"priceEp"),t),o=this.fromEv(this.safeString(e,"baseQtyEv"),t),d=this.omitZero(this.fromEv(this.safeString(e,"leavesBaseQtyEv"),t)),c=this.fromEv(this.safeString2(e,"cumBaseQtyEv","cumBaseValueEv"),t),u=this.fromEv(this.safeString2(e,"cumQuoteValueEv","quoteQtyEv"),t),h=this.fromEp(this.safeString(e,"avgPriceEp"),t),f=this.parseOrderStatus(this.safeString(e,"ordStatus")),l=this.safeStringLower(e,"side"),m=this.parseOrderType(this.safeString(e,"ordType")),g=this.safeIntegerProduct2(e,"actionTimeNs","createTimeNs",1e-6);let y;const w=this.fromEv(this.safeString(e,"cumFeeEv"),t);w!==void 0&&(y={cost:w,currency:void 0});const b=this.parseTimeInForce(this.safeString(e,"timeInForce")),S=this.parseNumber(this.omitZero(this.fromEp(this.safeString(e,"stopPxEp",t)))),v=b==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:m,timeInForce:b,postOnly:v,side:l,price:a,stopPrice:S,triggerPrice:S,amount:o,cost:u,average:h,filled:c,remaining:d,status:f,fee:y,trades:void 0},t)}parseSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"orderType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeNumber(e,"orderQty"),h=this.safeNumber(e,"cumQty"),f=this.safeNumber(e,"leavesQty"),l=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeNumber(e,"cumValue");let g=this.safeIntegerProduct(e,"transactTimeNs",1e-6);g===0&&(g=void 0);const y=this.parseTimeInForce(this.safeString(e,"timeInForce")),w=this.safeNumber(e,"stopPx"),b=y==="PO";let S=this.safeValue(e,"reduceOnly");return this.safeString(e,"execInst")==="ReduceOnly"&&(S=!0),{info:e,id:s,clientOrderId:i,datetime:this.iso8601(l),timestamp:l,lastTradeTimestamp:g,symbol:r,type:d,timeInForce:y,postOnly:b,reduceOnly:S,side:o,price:c,stopPrice:w,triggerPrice:w,amount:u,filled:h,remaining:f,cost:m,average:void 0,status:a,fee:void 0,trades:void 0}}parseOrder(e,t=void 0){return"closedPnl"in e?this.parseSwapOrder(e,t):this.parseSpotOrder(e,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=this.capitalize(s),t=this.capitalize(t);const o=this.safeValue(r,"reduceOnly"),d={symbol:a.id,side:s,ordType:t},c=this.safeString2(r,"clOrdID","clientOrderId");if(c===void 0){const y=this.safeString(this.options,"brokerId");y!==void 0&&(d.clOrdID=y+this.uuid16())}else d.clOrdID=c,r=this.omit(r,["clOrdID","clientOrderId"]);const u=this.safeString2(r,"stopPx","stopPrice");if(u!==void 0&&(d.stopPxEp=this.toEp(u,a)),r=this.omit(r,["stopPx","stopPrice"]),a.spot){let y=this.safeValue(r,"qtyType","ByBase");if((t==="Market"||t==="Stop"||t==="MarketIfTouched")&&n!==void 0&&(y="ByQuote"),d.qtyType=y,y==="ByQuote"){let w=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),this.options.createOrderByQuoteRequiresPrice){if(n!==void 0){const S=this.numberToString(i),v=this.numberToString(n),T=Xt.stringMul(S,v);w=this.parseNumber(T)}else if(w===void 0)throw new bs(this.id+" createOrder() "+y+" requires a price argument or a cost parameter")}w=w===void 0?i:w;const b=w.toString();d.quoteQtyEv=this.toEv(b,a)}else{const w=i.toString();d.baseQtyEv=this.toEv(w,a)}}else if(a.swap&&(o!==void 0&&(d.reduceOnly=o),d.orderQty=parseInt(i),u!==void 0)){const y=this.safeString(r,"triggerType","ByMarkPrice");d.triggerType=y}if(t==="Limit"||t==="StopLimit"||t==="LimitIfTouched"){const y=n.toString();d.priceEp=this.toEp(y,a)}const h=this.safeString(r,"takeProfitPrice");h!==void 0&&(d.takeProfitEp=this.toEp(h,a),r=this.omit(r,"takeProfitPrice"));const f=this.safeString(r,"stopLossPrice");f!==void 0&&(d.stopLossEp=this.toEp(f,a),r=this.omit(r,"stopLossPrice"));const l=a.spot?"privatePostSpotOrders":"privatePostOrders";r=this.omit(r,"reduceOnly");const m=await this[l](this.extend(d,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,a)}async editOrder(e,t,s=void 0,i=void 0,n=void 0,r=void 0,a={}){if(t===void 0)throw new bs(this.id+" editOrder() requires a symbol argument");if(s!==void 0)throw new bs(this.id+" editOrder() type changing is not implemented. Try to cancel & recreate order for that purpose");if(i!==void 0)throw new bs(this.id+" editOrder() side changing is not implemented. Try to cancel & recreate order for that purpose");await this.loadMarkets();const o=this.market(t),d={symbol:o.id},c=this.safeString2(a,"clientOrderId","clOrdID");a=this.omit(a,["clientOrderId","clOrdID"]),c!==void 0?d.clOrdID=c:d.orderID=e,r!==void 0&&(d.priceEp=this.toEp(r,o));const u=this.safeString(a,"baseQtyEv");a=this.omit(a,["baseQtyEv"]),u!==void 0?d.baseQtyEV=u:n!==void 0&&(d.baseQtyEV=this.toEv(n,o));const h=this.safeString2(a,"stopPx","stopPrice");h!==void 0&&(d.stopPxEp=this.toEp(h,o)),a=this.omit(a,["stopPx","stopPrice"]);const f=o.spot?"privatePutSpotOrders":"privatePutOrdersReplace",l=await this[f](this.extend(d,a)),m=this.safeValue(l,"data",{});return this.parseOrder(m,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new bs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),r!==void 0?n.clOrdID=r:n.orderID=e;const a=i.spot?"privateDeleteSpotOrders":"privateDeleteOrdersCancel",o=await this[a](this.extend(n,s)),d=this.safeValue(o,"data",{});return this.parseOrder(d,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new bs(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={},i=this.market(e);let n="privateDeleteSpotOrdersAll";return i.swap&&(n="privateDeleteOrdersAll"),s.symbol=i.id,await this[n](this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new bs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.spot?"privateGetSpotOrdersActive":"privateGetExchangeOrder",r={symbol:i.id},a=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),a!==void 0?r.clOrdID=a:r.orderID=e;const o=await this[n](this.extend(r,s)),d=this.safeValue(o,"data",{});let c=d;if(Array.isArray(d)){if(d.length<1)throw a!==void 0?new bu(this.id+" fetchOrder() "+t+" order with clientOrderId "+a+" not found"):new bu(this.id+" fetchOrder() "+t+" order with id "+e+" not found");c=this.safeValue(d,0,{})}return this.parseOrder(c,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bs(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetOrdersActiveList",a={symbol:n.id};let o;try{o=await this[r](this.extend(a,i))}catch(c){if(c instanceof bu)return[]}const d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bs(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrder":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrderTrades":"privateGetExchangeOrderTrade",a={symbol:n.id};t!==void 0&&(a.start=t),n.swap&&s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"defaultNetworks"),r=this.safeStringUpper(n,e),a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network",r);o=this.safeString(a,o,o),o===void 0?i.chainName=s.id:(i.chainName=o,t=this.omit(t,"network"));const d=await this.privateGetPhemexUserWalletsV2DepositAddress(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.safeString(c,"address"),h=this.safeString(c,"tag");return this.checkAddress(u),{currency:e,address:u,tag:h,network:void 0,info:d}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsDepositList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsWithdrawList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}parseTransactionStatus(e){const t={Success:"ok",Succeed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=void 0,r=this.safeString(e,"txHash"),a=this.safeString(e,"currency");t=this.safeCurrency(a,t);const o=t.code,d=this.safeInteger2(e,"createdAt","submitedAt");let c=this.safeStringLower(e,"type");const u=this.parseNumber(this.fromEn(this.safeString(e,"feeEv"),t.valueScale));let h;u!==void 0&&(c="withdrawal",h={cost:u,currency:o});const f=this.parseTransactionStatus(this.safeString(e,"status")),l=this.parseNumber(this.fromEn(this.safeString(e,"amountEv"),t.valueScale));return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:c,amount:l,currency:o,status:f,updated:void 0,fee:h}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(this.options,"defaultSubType","linear");let i=this.safeString(t,"code");i===void 0?i=s==="linear"?"USD":"BTC":t=this.omit(t,"code");const r={currency:this.currency(i).id},a=await this.privateGetAccountsAccountPositions(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"positions",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u];c.push(this.parsePosition(h))}return this.filterByArray(c,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"positionMargin"),r=this.safeString(e,"value"),a=this.safeString(e,"maintMarginReq"),o=Xt.stringMul(r,a),d=this.safeString(e,"assignedPosBalance"),c=Xt.stringDiv(d,r),u=this.safeNumber(e,"liquidationPrice"),h=this.safeString(e,"markPrice"),f=this.safeString(e,"size"),l=this.safeValue(t,"contractSize"),m=this.numberToString(l),g=this.safeNumber(e,"leverage"),y=this.safeString(e,"avgEntryPrice"),w=this.safeString(e,"side");let b;w!==void 0&&(b=w==="Buy"?"long":"short");let S;this.safeString(e,"currency")==="USD"?b==="long"?S=Xt.stringSub(h,y):S=Xt.stringSub(y,h):b==="long"?S=Xt.stringSub(Xt.stringDiv("1",y),Xt.stringDiv("1",h)):S=Xt.stringSub(Xt.stringDiv("1",h),Xt.stringDiv("1",y));const T=Xt.stringMul(Xt.stringMul(S,f),m),I=Xt.stringMul(Xt.stringDiv(T,d),"100"),A=Xt.stringDiv(o,n);return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(f),contractSize:l,unrealizedPnl:this.parseNumber(T),leverage:g,liquidationPrice:u,collateral:this.parseNumber(n),notional:this.parseNumber(r),markPrice:this.parseNumber(h),entryPrice:this.parseNumber(y),timestamp:void 0,initialMargin:this.parseNumber(d),initialMarginPercentage:this.parseNumber(c),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(a),marginRatio:this.parseNumber(A),datetime:void 0,marginMode:void 0,side:b,hedged:!1,percentage:this.parseNumber(I)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new bs(this.id+" fetchFundingHistory() requires a symbol argument");const n=this.market(e),r={symbol:n.id};if(s>200)throw new xs(this.id+" fetchFundingHistory() limit argument cannot exceed 200");s!==void 0&&(r.limit=s);const a=await this.privateGetApiDataFuturesFundingFees(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.safeInteger(h,"createTime");c.push({info:h,symbol:this.safeString(h,"symbol"),code:this.safeCurrencyCode(this.safeString(h,"currency")),timestamp:f,datetime:this.iso8601(f),id:void 0,amount:this.fromEv(this.safeString(h,"execFeeEv"),n)})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new kd(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id};let n={};s.linear?n=await this.v2GetMdV2Ticker24hr(this.extend(i,t)):n=await this.v1GetMdTicker24hr(this.extend(i,t));const r=this.safeValue(n,"result",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeIntegerProduct(e,"timestamp",1e-6);return{info:e,symbol:i,markPrice:this.fromEp(this.safeString2(e,"markEp","markPriceRp"),t),indexPrice:this.fromEp(this.safeString2(e,"indexEp","indexPriceRp"),t),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.fromEr(this.safeString(e,"fundingRateEr"),t),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.fromEr(this.safeString2(e,"predFundingRateEr","predFundingRateRr"),t),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id,posBalanceEv:this.toEv(t,i)},r=await this.privatePostPositionsAssign(this.extend(n,s));return this.extend(this.parseMarginModification(r,i),{amount:t})}parseMarginStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseMarginModification(e,t=void 0){t=this.safeMarket(void 0,t);const i=this.safeValue(t,"inverse")?"base":"quote";return{info:e,type:"set",amount:void 0,total:void 0,code:t[i],symbol:this.safeSymbol(void 0,t),status:this.parseMarginStatus(this.safeString(e,"code"))}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new bs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new xs(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new kd(this.id+" setMarginMode() supports swap contracts only");let n=this.safeInteger(s,"leverage");if(e==="cross"&&(n=0),n===void 0)throw new bs(this.id+" setMarginMode() requires a leverage parameter");const r={symbol:i.id,leverage:n};return await this.privatePutPositionsLeverage(this.extend(r,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCfgV2Products(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"riskLimits");return this.parseLeverageTiers(n,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.info.riskLimits,i=[];let n=0;for(let r=0;r<s.length;r++){const a=s[r],o=this.safeInteger(a,"limit");i.push({tier:this.sum(r,1),currency:t.settle,minNotional:n,maxNotional:o,maintenanceMarginRate:this.safeString(a,"maintenanceMargin"),maxLeverage:void 0,info:a}),n=o}return i}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o="/"+this.implodeParams(e,i);let d=o,c="";if((s==="GET"||s==="DELETE"||s==="PUT"||d==="/positions/assign")&&Object.keys(a).length&&(c=this.urlencodeWithArrayRepeat(a),d+="?"+c),t==="private"){this.checkRequiredCredentials();const u=this.seconds(),h=this.safeInteger(this.options,"x-phemex-request-expiry",60),l=this.sum(u,h).toString();n={"x-phemex-access-token":this.apiKey,"x-phemex-request-expiry":l};let m="";s==="POST"&&(m=this.json(i),r=m,n["Content-Type"]="application/json");const g=o+c+l+m;n["x-phemex-request-signature"]=this.hmac(this.encode(g),this.encode(this.secret))}return d=this.implodeHostname(this.urls.api[t])+d,{url:d,method:s,body:r,headers:n}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new bs(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new xs(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const n={symbol:this.market(t).id,leverage:e};return await this.privatePutPositionsLeverage(this.extend(n,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.toEv(t,r);let u,h;if(o==="spot"&&d==="future"?u=2:o==="future"&&d==="spot"&&(u=1),u!==void 0){const m={currency:r.id,moveOp:u,amountEv:c},g=await this.privatePostAssetsTransfer(this.extend(m,n)),y=this.safeValue(g,"data",{});h=this.parseTransfer(y,r)}else{const m={fromUserId:o,toUserId:d,amountEv:c,currency:r.id,bizType:this.safeString(n,"bizType","SPOT")},g=await this.privatePostAssetsUniversalTransfer(this.extend(m,n));h=this.parseTransfer(g)}const f=this.safeValue(this.options,"transfer",{});return this.safeValue(f,"fillResponseFromRequest",!0)&&(h.fromAccount===void 0&&(h.fromAccount=s),h.toAccount===void 0&&(h.toAccount=i),h.amount===void 0&&(h.amount=t),h.currency===void 0&&(h.currency=e)),h}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new bs(this.id+" fetchTransfers() requires a code argument");const n=this.currency(e),r={currency:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetsTransfer(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]);return this.parseTransfers(d,n,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"linkKey"),i=this.safeString(e,"status"),n=this.safeString(e,"amountEv"),r=this.fromEv(n,t),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeInteger(e,"side");let c,u;d===1?(c="swap",u="spot"):d===2&&(c="spot",u="swap");const h=this.safeInteger(e,"createTime");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:o,amount:r,fromAccount:c,toAccount:u,status:this.parseTransferStatus(i)}}parseTransferStatus(e){const t={3:"rejected",6:"canceled",10:"ok",11:"failed"};return this.safeString(t,e,e)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",a),u=this.safeString(c,"code"),h=this.safeString(c,"msg");if(u!==void 0&&u!=="0"){const f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f),new ws(f)}}};const q6=re,{ArgumentsRequired:lk,ExchangeError:pk,ExchangeNotAvailable:L6,NotSupported:mk,RequestTimeout:R6,AuthenticationError:D6,PermissionDenied:gk,RateLimitExceeded:yk,InsufficientFunds:F6,OrderNotFound:vu,InvalidOrder:Sd,AccountSuspended:gp,CancelPending:H6,InvalidNonce:G6,OnMaintenance:U6,BadSymbol:yp}=Q,{TICK_SIZE:$6}=ne,wk=ae;var W6=class extends q6{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:["US"],rateLimit:5,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrder:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","10m":"MINUTE_10","15m":"MINUTE_15","30m":"MINUTE_30","1h":"HOUR_1","2h":"HOUR_2","4h":"HOUR_4","6h":"HOUR_6","12h":"HOUR_12","1d":"DAY_1","3d":"DAY_3","1w":"WEEK_1","1M":"MONTH_1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:"https://api.poloniex.com",test:"https://sand-spot-api-gateway.poloniex.com",www:"https://www.poloniex.com",doc:"https://docs.poloniex.com",fees:"https://poloniex.com/fees",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{markets:20,"markets/{symbol}":1,currencies:20,"currencies/{currency}":20,timestamp:1,"markets/price":1,"markets/{symbol}/price":1,"markets/{symbol}/orderBook":1,"markets/{symbol}/candles":1,"markets/{symbol}/trades":20,"markets/ticker24h":20,"markets/{symbol}/ticker24h":20}},private:{get:{accounts:4,"accounts/activity":4,"accounts/balances":4,"accounts/{id}/balances":4,"accounts/transfer":20,"accounts/transfer/{id}":4,subaccounts:4,"subaccounts/balances":20,"subaccounts/{id}/balances":4,"subaccounts/transfer":20,"subaccounts/transfer/{id}":4,feeinfo:20,"wallets/addresses":20,"wallets/activity":20,"wallets/addresses/{currency}":20,orders:20,"orders/{id}":4,"orders/history":20,"orders/killSwitchStatus":4,smartorders:20,"smartorders/{id}":4,"smartorders/history":20,trades:20,"orders/{id}/trades":4},post:{"accounts/transfer":4,"subaccounts/transfer":20,"wallets/address":20,"wallets/withdraw":20,orders:4,"orders/killSwitch":4,"orders/batch":20,smartorders:4},delete:{"orders/{id}":4,"orders/cancelByIds":20,orders:20,"smartorders/{id}":4,"smartorders/cancelByIds":20,smartorders:20},put:{"orders/{id}":4,"smartorders/{id}":4}}},fees:{trading:{feeSide:"get",maker:this.parseNumber("0.0009"),taker:this.parseNumber("0.0009")},funding:{}},commonCurrencies:{AIR:"AirCoin",APH:"AphroditeCoin",BCC:"BTCtalkcoin",BCHABC:"BCHABC",BDG:"Badgercoin",BTM:"Bitmark",CON:"Coino",GOLD:"GoldEagles",GPUC:"GPU",HOT:"Hotcoin",ITC:"Information Coin",KEY:"KEYCoin",MASK:"NFTX Hashmasks Index",MEME:"Degenerator Meme",PLX:"ParallaxCoin",REPV2:"REP",STR:"XLM",SOC:"SOCC",TRADE:"Unitrade",XAP:"API Coin",USDTTRON:"USDT",USDTETH:"USDT",UST:"USTC"},options:{networks:{BEP20:"BSC",ERC20:"ETH",TRX:"TRON",TRC20:"TRON"},limits:{cost:{min:{BTC:1e-4,ETH:1e-4,USDT:1,TRX:100,BNB:.06,USDC:1,USDJ:1,TUSD:1e-4,DAI:1,PAX:1,BUSD:1}}},accountsByType:{spot:"spot",future:"futures"},accountsById:{exchange:"spot",futures:"future"}},precisionMode:$6,exceptions:{exact:{"You may only place orders that reduce your position.":Sd,"Invalid order number, or you are not the person who placed the order.":vu,"Permission denied":gk,"Permission denied.":gk,"Connection timed out. Please try again.":R6,"Internal error. Please try again.":L6,"Currently in maintenance mode.":U6,"Order not found, or you are not the person who placed it.":vu,"Invalid API key/secret pair.":D6,"Please do not make more than 8 API calls per second.":yk,"This IP has been temporarily throttled. Please ensure your requests are valid and try again in one minute.":yk,"Rate must be greater than zero.":Sd,"Invalid currency pair.":yp,"Invalid currencyPair parameter.":yp,"Trading is disabled in this market.":yp,"Invalid orderNumber parameter.":vu,"Order is beyond acceptable bounds.":Sd,"This account is closed.":gp},broad:{"Total must be at least":Sd,"This account is frozen":gp,"This account is locked.":gp,"Not enough":F6,"Nonce must be greater":G6,"You have already called cancelOrder":H6,"Amount must be at least":Sd,"is either completed or does not exist":vu,"Error pulling ":pk}}})}parseOHLCV(e,t=void 0){return[this.safeInteger(e,12),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,0),this.safeNumber(e,3),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsSymbolCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=this.safeString(n,"symbol"),a=this.safeString(n,"baseCurrencyName"),o=this.safeString(n,"quoteCurrencyName"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),h=this.safeString(n,"state")==="NORMAL",f=this.safeValue(n,"symbolTradeLimit");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(f,"quantityScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(f,"priceScale")))},limits:{amount:{min:this.safeNumber(f,"minQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(f,"minAmount"),max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i);const n=this.safeString(e,"close"),r=this.safeString(e,"percentChange"),a=wk.stringMul(r,"100");return this.safeTicker({id:i,symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:this.safeString(e,"quantity"),quoteVolume:this.safeString(e,"amount"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketsTicker24h(t);return this.parseTickers(s,e)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.safeValue(o,"delisted"),h=this.safeString(o,"walletState")==="ENABLED",l=!c&&h,m=this.safeInteger(o,"id"),g=this.safeNumber(o,"withdrawalFee");s[d]={id:a,numericId:m,code:d,info:o,name:o.name,active:l,deposit:void 0,withdraw:void 0,fee:g,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:g,max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tradeID"),i=this.safeString(e,"orderId"),n=this.safeInteger2(e,"ts","createTime"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t,"_");const a=t.symbol,o=this.safeStringLower(e,"side");let d;const c=this.safeString(e,"price"),u=this.safeString(e,"quantity"),h=this.safeString(e,"amount"),f=this.safeString(e,"feeCurrency"),l=this.safeString(e,"feeAmount");if(l!==void 0){const m=this.safeCurrencyCode(f);d={cost:l,currency:m}}return this.safeTrade({id:s,info:e,timestamp:n,datetime:this.iso8601(n),symbol:a,order:i,type:this.safeStringLower(e,"type"),side:o,takerOrMaker:this.safeStringLower(e,"matchRole"),price:c,amount:u,cost:h,fee:d},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=parseInt(s));const a=await this.privateGetTrades(this.extend(r,i)),o=this.parseTrades(a,n);return this.filterBySinceLimit(o,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",PENDING_CANCEL:"canceled",PARTIALLY_CANCELED:"canceled",CANCELED:"canceled",FAILED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeInteger2(e,"timestamp","createTime");s===void 0&&(s=this.parse8601(this.safeString(e,"date")));const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeValue(e,"resultingTrades");Array.isArray(r)||(r=this.safeValue(r,this.safeString(t,"id",i)));const a=this.safeString2(e,"price","rate"),o=this.safeString(e,"quantity"),d=this.safeString(e,"filledQuantity"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeStringLower(e,"side"),h=this.safeString(e,"type"),f=this.parseOrderType(h),l=this.safeString2(e,"orderNumber","id");let m;const g=this.safeString(e,"tokenFeeCurrency");let y,w;const b=this.safeString(e,"fee");g===void 0?w=u==="buy"?t.base:t.quote:(w=this.safeCurrencyCode(g),y=this.safeString(e,"tokenFee")),y!==void 0&&(m={rate:b,cost:y,currency:w});const S=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:l,clientOrderId:S,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:c,symbol:n,type:f,timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:u,price:a,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:this.safeString(e,"avgPrice"),amount:o,filled:d,remaining:void 0,trades:r,fee:m},t)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit","STOP-LIMIT":"limit","STOP-MARKET":"market"};return this.safeString(t,e,e)}parseOpenOrders(e,t,s){for(let i=0;i<e.length;i++){const n=e[i],r=this.extend(n,{status:"open",type:"limit",side:n.type,price:n.rate});s.push(this.parseOrder(r,t))}return s}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o={status:"open"};return this.parseOrders(a,n,t,s,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(!a.spot)throw new mk(this.id+" createOrder() does not support "+a.type+" orders, only spot orders are accepted");const o={symbol:a.id,side:s},d=this.orderRequest(e,t,s,i,o,n,r);let c=await this.privatePostOrders(this.extend(d[0],d[1]));return c=this.extend(c,{type:s}),this.parseOrder(c,a)}orderRequest(e,t,s,i,n,r=void 0,a={}){const o=this.market(e);let d=t.toUpperCase();const c=d==="MARKET";this.isPostOnly(c,d==="LIMIT_MAKER",a)&&(d="LIMIT_MAKER",a=this.omit(a,"postOnly")),n.type=d,c?s==="buy"?n.amount=this.currencyToPrecision(o.quote,i):n.quantity=this.amountToPrecision(e,i):(n.quantity=this.amountToPrecision(e,i),n.price=this.priceToPrecision(e,r));const h=this.safeString(a,"clientOrderId");return h!==void 0&&(n.clientOrderId=h,a=this.omit(a,"clientOrderId")),[n,a]}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);if(!o.spot)throw new mk(this.id+" editOrder() does not support "+o.type+" orders, only spot orders are accepted");const d={id:e},c=this.orderRequest(t,s,i,n,d,r,a);let u=await this.privatePutOrdersId(this.extend(c[0],c[1]));return u=this.extend(u,{type:i}),this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeValue(s,"clientOrderId");return n!==void 0&&(e=n),i.id=e,s=this.omit(s,"clientOrderId"),await this.privateDeleteOrdersId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbols=[i.id]),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),e=e.toString();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.extend(this.parseOrder(n),{id:e})}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=await this.fetchOpenOrders(t,void 0,void 0,s),n=this.indexBy(i,"id");return e in n?"open":"closed"}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersIdTrades(this.extend(r,n));return this.parseTrades(a)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=this.safeValue(e,s,{}),n=this.safeValue(i,"balances");for(let r=0;r<n.length;r++){const a=this.safeValue(n,r),o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString(a,"available"),c.used=this.safeString(a,"hold"),t[d]=c}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={accountType:"SPOT"},s=await this.privateGetAccountsBalances(this.extend(t,e));return this.parseBalance(s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFeeinfo(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i];s[n]={info:t,symbol:n,maker:this.safeNumber(t,"makerRate"),taker:this.safeNumber(t,"takerRate"),percentage:!0,tierBased:!0}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s)),a=this.safeInteger(r,"time"),o=this.safeValue(r,"asks"),d=this.safeValue(r,"bids"),c=[],u=[];for(let h=0;h<o.length;h++)if(h%2<1){const f=this.safeNumber(o,h),l=this.safeNumber(o,this.sum(h,1));c.push([f,l])}for(let h=0;h<d.length;h++)if(h%2<1){const f=this.safeNumber(d,h),l=this.safeNumber(d,this.sum(h,1));u.push([f,l])}return{symbol:i.symbol,bids:this.sortBy(u,0,!0),asks:this.sortBy(c,0),timestamp:a,datetime:this.iso8601(a),nonce:void 0}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new lk(this.id+" createDepositAddress requires a network parameter for "+e+".");const a=await this.privatePostWalletsAddress(this.extend(i,t));let o=this.safeString(a,"address"),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new lk(this.id+" fetchDepositAddress requires a network parameter for "+e+".");const a=await this.privateGetWalletsAddresses(this.extend(i,t));let o=this.safeString(a,i.currency),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,s),c={amount:t,currency:r.id,fromAccount:o,toAccount:d},u=await this.privatePostAccountsTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransferStatus(e){const t={1:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const i=this.safeString(e,"message").split(" "),n=this.safeNumber(i,1),r=this.safeString(i,2),a=this.safeString(i,4),o=this.safeString(i,6),d=this.safeValue(this.options,"accountsById",{});return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(r,t),amount:n,fromAccount:this.safeString(d,a),toAccount:this.safeString(d,o),status:this.parseOrderStatus(this.safeString(e,"success","failed"))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostWalletsWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=31104e3,r=this.seconds(),o={start:t!==void 0?parseInt(t/1e3):r-10*n,end:r};return await this.privateGetWalletsActivity(this.extend(o,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.safeValue(n,"deposits",[]),d=this.parseTransactions(a,r,t,s),c=this.parseTransactions(o,r,t,s),u=this.arrayConcat(c,d);return this.filterByCurrencySinceLimit(this.sortBy(u,"timestamp"),e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"deposits",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",COMPLETED:"ok","AWAITING APPROVAL":"pending",AWAITING_APPROVAL:"pending",PENDING:"pending",PROCESSING:"pending","COMPLETE ERROR":"failed",COMPLETE_ERROR:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i);let r=this.safeString(e,"status","pending");r=this.parseTransactionStatus(r);const a=this.safeString(e,"txid"),o="withdrawalRequestsId"in e?"withdrawal":"deposit",d=this.safeString2(e,"withdrawalRequestsId","depositNumber"),c=this.safeString(e,"address"),u=this.safeString(e,"paymentID");let h=this.safeString(e,"amount");const f=this.safeString(e,"fee");return o==="withdrawal"&&(h=wk.stringSub(h,f)),{info:e,id:d,currency:n,amount:this.parseNumber(h),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:u,tagTo:void 0,tagFrom:void 0,status:r,type:o,updated:void 0,txid:a,timestamp:s,datetime:this.iso8601(s),fee:{currency:n,cost:this.parseNumber(f)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api;const o=this.omit(i,this.extractParams(e)),d=this.implodeParams(e,i);if(t==="public")a+="/"+d,Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const c=this.nonce().toString();let u=s+`
`;if(a+="/"+d,u+="/"+d,s==="POST"||s==="PUT"||s==="DELETE")u+=`
`,Object.keys(o).length&&(r=this.json(o),u+="requestBody="+r+"&"),u+="signTimestamp="+c;else{let f=this.extend({signTimestamp:c},o);f=this.keysort(f),u+=`
`+this.urlencode(f),Object.keys(o).length&&(a+="?"+this.urlencode(o))}const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","base64");n={"Content-Type":"application/json",key:this.apiKey,signTimestamp:c,signature:h}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a){const c=a.error,u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new pk(u)}}};const{BadRequest:Va,ArgumentsRequired:vd,InvalidOrder:wp,AuthenticationError:Wr,NotSupported:Tu,RateLimitExceeded:z6,ExchangeNotAvailable:bp,InvalidNonce:j6,AccountSuspended:K6,OrderNotFound:X6}=Q,fi=ae,Y6=re,{TICK_SIZE:Z6}=ne;var Q6=class extends Y6{describe(){return this.deepExtend(super.describe(),{id:"poloniexfutures",name:"Poloniex Futures",countries:["US"],rateLimit:33.3,certified:!1,pro:!1,version:"v1",has:{CORS:void 0,spot:!1,margin:!0,swap:!0,future:!1,option:void 0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!1,fetchFundingRate:!0,fetchL3OrderBook:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchPositions:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,setMarginMode:!0},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":480,"12h":720,"1d":1440,"1w":10080},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:{public:"https://futures-api.poloniex.com",private:"https://futures-api.poloniex.com"},www:"https://www.poloniex.com",doc:"https://futures-docs.poloniex.com",fees:"https://poloniex.com/fee-schedule",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{"contracts/active":10,"contracts/{symbol}":10,ticker:10,tickers:10,"level2/snapshot":180.002,"level2/depth":180.002,"level2/message/query":180.002,"level3/snapshot":180.002,"trade/history":10,"interest/query":10,"index/query":10,"mark-price/{symbol}/current":10,"premium/query":10,"funding-rate/{symbol}/current":10,timestamp:10,status:10,"kline/query":10},post:{"bullet-public":10}},private:{get:{"account-overview":1,"transaction-history":1,orders:1,stopOrders:1,recentDoneOrders:1,"orders/{order-id}":1,fills:1,openOrderStatistics:1,position:1.5,positions:1.5,"funding-history":1,"marginType/query":1},post:{orders:1.5,batchOrders:1.5,"position/margin/auto-deposit-status":1.5,"position/margin/deposit-margin":1.5,"bullet-private":1,"marginType/change":1},delete:{"orders/{order-id}":1.5,orders:150.016,stopOrders:150.016}}},precisionMode:Z6,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.00075"),maker:this.parseNumber("0.0001")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{},requiredCredentials:{apiKey:!0,secret:!0,password:!0},options:{networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"},versions:{public:{GET:{ticker:"v2",tickers:"v2","level3/snapshot":"v2"}}}},exceptions:{exact:{400:Va,401:Wr,403:Tu,404:Tu,405:Tu,415:Va,429:z6,500:bp,503:bp,400001:Wr,400002:j6,400003:Wr,400004:Wr,400005:Wr,400006:Wr,400007:Wr,404e3:Tu,400100:Va,411100:K6,5e5:bp},broad:{"Position does not exist":X6}}})}async fetchMarkets(e={}){const t=await this.publicGetContractsActive(e),s=[],i=this.safeValue(t,"data",[]),n=i.length;for(let r=0;r<n;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeString(a,"baseCurrency"),c=this.safeString(a,"quoteCurrency"),u=this.safeString(a,"rootSymbol"),h=this.safeCurrencyCode(d),f=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),m=h+"/"+f+":"+l,g=this.safeValue(a,"isInverse"),y=this.safeString(a,"status"),w=this.safeString(a,"multiplier"),b=this.safeNumber(a,"indexPriceTickSize"),S=this.safeNumber(a,"lotSize"),v=this.safeNumber(a,"maxOrderQty"),T=this.safeNumber(a,"maxPrice");s.push({id:o,symbol:m,base:h,quote:f,settle:l,baseId:d,quoteId:c,settleId:u,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:y==="Open",contract:!0,linear:!g,inverse:g,taker:this.safeNumber(a,"takerFeeRate"),maker:this.safeNumber(a,"makerFeeRate"),contractSize:this.parseNumber(fi.stringAbs(w)),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:S,price:b},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"maxLeverage")},amount:{min:S,max:v},price:{min:b,max:T},cost:{min:void 0,max:void 0}},info:a})}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeIntegerProduct(e,"ts",1e-6),r=this.safeString(e,"price");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"size"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(this.safeValue(n,"data",{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(this.safeValue(s,"data",[]),e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeNumber(s,"level");if(s=this.omit(s,"level"),i!==void 0&&i!==2&&i!==3)throw new Va(this.id+" fetchOrderBook() can only return level 2 & 3");const n=this.market(e),r={symbol:n.id};let a;i===3?a=await this.publicGetLevel3Snapshot(this.extend(r,s)):a=await this.publicGetLevel2Snapshot(this.extend(r,s));const o=this.safeValue(a,"data",{}),d=this.safeIntegerProduct(o,"ts",1e-6);let c;return i===3?c=this.parseOrderBook(o,n.symbol,d,"bids","asks",1,2):c=this.parseOrderBook(o,n.symbol,d,"bids","asks",0,1),c.nonce=this.safeInteger(o,"sequence"),c}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);return this.fetchOrderBook(i.id,void 0,{level:3})}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString(e,"tradeId"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"ts");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString(e,"price"),d=this.safeString(e,"size"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let f=this.safeString(e,"orderType");f==="match"&&(f=void 0);const l=this.safeString(e,"value");return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:f,takerOrMaker:r,side:c,price:o,amount:d,cost:l,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,granularity:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.from=s,i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),c=this.sum(s,i*d),o.to=c):i!==void 0&&(s=c-i*d,o.from=s);const u=await this.publicGetKlineQuery(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();return r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"accountEquity"),t[n]=r,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"currency");let s={};t!==void 0&&(s={currency:this.currency(t).id});const i=await this.privateGetAccountOverview(this.extend(s,e));return this.parseBalance(i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());if(r=this.omit(r,["clientOid","clientOrderId"]),i<1)throw new wp(this.id+" createOrder() minimum contract order amount is 1");const d=parseInt(this.amountToPrecision(e,i)),c={clientOid:o,side:s,symbol:a.id,type:t,size:d,leverage:1},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u){c.stop=s==="buy"?"up":"down";const w=this.safeString(r,"stopPriceType","TP");c.stopPriceType=w,c.stopPrice=this.priceToPrecision(e,u)}const h=this.safeStringUpper(r,"timeInForce");if(t==="limit"){if(n===void 0)throw new vd(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,n),h!==void 0&&(c.timeInForce=h)}const f=this.safeValue(r,"postOnly",!1),l=this.safeValue(r,"hidden");if(f&&l!==void 0)throw new Va(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(r,"iceberg")&&this.safeValue(r,"visibleSize")===void 0)throw new vd(this.id+" createOrder() requires a visibleSize parameter for iceberg orders");r=this.omit(r,["timeInForce","stopPrice","triggerPrice"]);const g=await this.privatePostOrders(this.extend(c,r)),y=this.safeValue(g,"data",{});return{id:this.safeString(y,"orderId"),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:g}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={"order-id":e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"data"),a=this.safeValue(r,"cancelledOrderIds");if(a.length===0)throw new wp(this.id+" cancelOrder() order already cancelled");return{id:this.safeString(a,0),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:n}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositions(t),i=this.safeValue(s,"data");return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"currentTimestamp"),n=this.safeString(e,"currentQty");let r;fi.stringGt(n,"0")?r="long":fi.stringLt(n,"0")&&(r="short");const a=fi.stringAbs(this.safeString(e,"posCost")),o=this.safeString(e,"posInit"),d=fi.stringDiv(o,a),c=this.safeString(e,"unrealisedPnl"),h=this.safeValue(e,"crossMode")?"cross":"isolated";return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(d),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber(e,"avgEntryPrice"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"realLeverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(fi.stringAbs(n)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),collateral:this.safeNumber(e,"maintMargin"),marginMode:h,side:r,percentage:this.parseNumber(fi.stringDiv(c,o))}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vd(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const r={symbol:this.market(e).id};t!==void 0&&(r.startAt=t),s!==void 0&&(r.maxCount=s);const a=await this.privateGetFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"dataList",[]),c=d.length,u=[];for(let h=0;h<c;h++){const f=d[h],l=this.safeInteger(f,"timePoint");u.push({info:f,symbol:e,code:this.safeCurrencyCode(this.safeString(f,"settleCurrency")),timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(f,"id"),amount:this.safeNumber(f,"funding"),fundingRate:this.safeNumber(f,"fundingRate"),markPrice:this.safeNumber(f,"markPrice"),positionQty:this.safeNumber(f,"positionQty"),positionCost:this.safeNumber(f,"positionCost")})}return u}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.symbol=this.marketId(e));const n=this.safeValue(t,"stop")?"privateDeleteStopOrders":"privateDeleteOrders",r=await this[n](this.extend(s,t)),a=this.safeValue(r,"data"),o=[],d=this.safeValue(a,"cancelledOrderIds"),c=d.length;for(let u=0;u<c;u++){const h=this.safeString(d,u);o.push({id:h,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:r})}return o}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.safeValue(n,"stop"),a=this.safeInteger2(n,"until","till");n=this.omit(n,["stop","until","till"]),e==="closed"?e="done":e==="open"&&(e="active");const o={};if(!r)o.status=e;else if(e!=="active")throw new Va(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders");let d;t!==void 0&&(d=this.market(t),o.symbol=d.id),s!==void 0&&(o.startAt=s),a!==void 0&&(o.endAt=a);const u=await this[r?"privateGetStopOrders":"privateGetOrders"](this.extend(o,n)),h=this.safeValue(u,"data",{}),f=this.safeValue(h,"items",[]),l=f.length,m=[];if(e==="done")for(let g=0;g<l;g++)f[g].cancelExist||m.push(f[g]);return this.parseOrders(m,d,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("active",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};let n="privateGetOrdersOrderId";if(e===void 0){const d=this.safeString2(s,"clientOid","clientOrderId");if(d===void 0)throw new wp(this.id+" fetchOrder() requires parameter id or params.clientOid");i.clientOid=d,n="privateGetOrdersByClientOid",s=this.omit(s,["clientOid","clientOrderId"])}else i["order-id"]=e;const r=await this[n](this.extend(i,s)),a=t!==void 0?this.market(t):void 0,o=this.safeValue(r,"data");return this.parseOrder(o,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),f=this.safeNumber(e,"fee"),l=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString2(e,"dealFunds","filledValue"),y=this.safeString(e,"leverage"),w=fi.stringDiv(g,y);let b;if(fi.stringGt(m,"0")){const k=this.safeString(t,"contractSize");t.linear?b=fi.stringDiv(g,fi.stringMul(k,m)):b=fi.stringDiv(fi.stringMul(k,m),g)}const S=this.safeValue(e,"isActive",!1),v=this.safeValue(e,"cancelExist",!1);let T=S?"open":"closed";T=v?"canceled":T;const I={currency:h,cost:f},A=this.safeString(e,"clientOid"),N=this.safeString(e,"timeInForce"),B=this.safeNumber(e,"stopPrice"),x=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:A,symbol:i,type:r,timeInForce:N,postOnly:x,side:c,amount:l,price:d,stopPrice:B,cost:w,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:I,status:T,info:e,lastTradeTimestamp:void 0,average:b,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetFundingRateSymbolCurrent(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeInteger(r,"timePoint");return{info:r,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(r,"predictedValue"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(r,"value"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.startAt=t);const a=await this.privateGetFills(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"items",{});return this.parseTrades(d,r,t,s)}async setMarginMode(e,t,s={}){if(t===void 0)throw new vd(this.id+" setMarginMode() requires a symbol argument");if(e!==0&&e!==1)throw new vd(this.id+" setMarginMode() marginMode must be 0 (isolated) or 1 (cross)");await this.loadMarkets();const n={symbol:this.market(t).id,marginType:e};return await this.privatePostMarginTypeChange(n)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.safeValue(this.options,"versions",{}),d=this.safeValue(o,t,{}),c=this.safeValue(d,s,{}),u=this.safeString(c,e,this.version),h=this.safeString(i,"version",u);a+="/api/"+h+"/"+this.implodeParams(e,i);const l=this.omit(i,e),m=Object.keys(l).length;if(t==="public")m&&(a+="?"+this.urlencode(l));else{this.checkRequiredCredentials();let g="/api/v1/"+this.implodeParams(e,i);const y=this.urlencode(l);s!=="GET"&&s!=="HEAD"?r=l:m&&y!==""&&(a+="?"+y,g+="?"+y);const w=this.milliseconds().toString();let b="";r!==void 0&&(r=this.json(l),b=r);const S=w+s+g+b;n={"PF-API-SIGN":this.hmac(this.encode(S),this.encode(this.secret),"sha256","base64"),"PF-API-TIMESTAMP":w,"PF-API-KEY":this.apiKey,"PF-API-PASSPHRASE":this.password},n["Content-Type"]="application/json"}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a){this.throwBroadlyMatchedException(this.exceptions.broad,r,r);return}const c=this.safeString(a,"code"),u=this.safeString(a,"msg",""),h=this.id+" "+u;this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h)}};const J6=re,{ExchangeError:eF,ExchangeNotAvailable:bk,BadResponse:tF,BadRequest:kp,InvalidOrder:kk,InsufficientFunds:sF,AuthenticationError:Sp,ArgumentsRequired:Sk,InvalidAddress:vk,RateLimitExceeded:iF,DDoSProtection:nF,BadSymbol:vp}=Q,{TRUNCATE:rF,TICK_SIZE:aF}=ne,Ou=ae;var oF=class extends J6{describe(){return this.deepExtend(super.describe(),{id:"probit",name:"ProBit",countries:["SC","KR"],rateLimit:50,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"1W","1M":"1M"},version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/79268032-c4379480-7ea2-11ea-80b3-dd96bb29fd0d.jpg",api:{accounts:"https://accounts.probit.com",public:"https://api.probit.com/api/exchange",private:"https://api.probit.com/api/exchange"},www:"https://www.probit.com",doc:["https://docs-en.probit.com","https://docs-ko.probit.com"],fees:"https://support.probit.com/hc/en-us/articles/360020968611-Trading-Fees",referral:"https://www.probit.com/r/34608773"},api:{public:{get:{market:1,currency:1,currency_with_platform:1,time:1,ticker:1,order_book:1,trade:1,candle:1}},private:{post:{new_order:2,cancel_order:1,withdrawal:2},get:{balance:1,order:1,open_order:1,order_history:1,trade_history:1,deposit_address:1}},accounts:{post:{token:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{UNAUTHORIZED:Sp,INVALID_ARGUMENT:kp,TRADING_UNAVAILABLE:bk,NOT_ENOUGH_BALANCE:sF,NOT_ALLOWED_COMBINATION:kp,INVALID_ORDER:kk,RATE_LIMIT_EXCEEDED:iF,MARKET_UNAVAILABLE:bk,INVALID_MARKET:vp,MARKET_CLOSED:vp,MARKET_NOT_FOUND:vp,INVALID_CURRENCY:kp,TOO_MANY_OPEN_ORDERS:nF,DUPLICATE_ADDRESS:vk,invalid_grant:Sp}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:aF,options:{createMarketBuyOrderRequiresPrice:!0,timeInForce:{limit:"gtc",market:"ioc"},networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON",TRX:"TRON"}},commonCurrencies:{AUTO:"Cube",AZU:"Azultec",BCC:"BCC",BDP:"BidiPass",BIRD:"Birdchain",BTCBEAR:"BEAR",BTCBULL:"BULL",CBC:"CryptoBharatCoin",CHE:"Chellit",CLR:"Color Platform",CTK:"Cryptyk",CTT:"Castweet",DIP:"Dipper",DKT:"DAKOTA",EGC:"EcoG9coin",EPS:"Epanus",FX:"Fanzy",GDT:"Gorilla Diamond",GM:"GM Holding",GOGOL:"GOL",GOL:"Goldofir",GRB:"Global Reward Bank",HBC:"Hybrid Bank Cash",HUSL:"The Hustle App",LAND:"Landbox",LBK:"Legal Block",ORC:"Oracle System",PXP:"PIXSHOP COIN",PYE:"CreamPYE",ROOK:"Reckoon",SOC:"Soda Coin",SST:"SocialSwap",TCT:"Top Coin Token",TOR:"Torex",TPAY:"Tetra Pay",UNI:"UNICORN Token",UNISWAP:"UNI"}})}async fetchMarkets(e={}){const t=await this.publicGetMarket(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"base_currency_id"),d=this.safeString(r,"quote_currency_id"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"closed",!1),f=this.safeString(r,"taker_fee_rate"),l=Ou.stringDiv(f,"100"),m=this.safeString(r,"maker_fee_rate"),g=Ou.stringDiv(m,"100");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!h,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(l),maker:this.parseNumber(g),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantity_precision"))),price:this.safeNumber(r,"price_increment"),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"cost_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_quantity"),max:this.safeNumber(r,"max_quantity")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:this.safeNumber(r,"min_cost"),max:this.safeNumber(r,"max_cost")}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyWithPlatform(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"display_name"),c=this.safeString(d,"en-us"),u=this.safeValue(r,"platform",[]),h=this.sortBy(u,"priority"),f=this.safeValue(h,0,{}),l=this.safeValue(f,"deposit_suspended"),m=this.safeValue(f,"withdrawal_suspended"),g=!l,y=!m,w=g&&y,b=this.safeValue(f,"withdrawal_fee",{}),S=[];for(let A=0;A<b.length;A++){const N=b[A],B=this.safeNumber(N,"amount"),x=this.safeInteger(N,"priority");B!==void 0&&x!==void 0&&S.push(N)}const v=this.sortBy(S,"priority"),T=this.safeValue(v,0,{}),I=this.safeNumber(T,"amount");i[o]={id:a,code:o,info:r,name:c,active:w,deposit:g,withdraw:y,fee:I,precision:this.parseNumber(this.parsePrecision(this.safeString(f,"precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(f,"min_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(f,"min_withdrawal_amount"),max:void 0}}}}return i}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"total"),o.free=this.safeString(n,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market_id:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.groupBy(a,"side");return this.parseOrderBook(o,i.symbol,void 0,"buy","sell","price","quantity")}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const r=this.marketIds(e);s.market_ids=r.join(",")}const i=await this.publicGetTicker(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_ids:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);if(a===void 0)throw new tF(this.id+" fetchTicker() returned an empty response");return this.parseTicker(a,s)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeString(e,"last"),a=this.safeString(e,"change"),o=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={limit:100,start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds())};e!==void 0&&(n=this.market(e),r.market_id=n.id),t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market_id:n.id,limit:100,start_time:"1970-01-01T00:00:00.000Z",end_time:this.iso8601(this.milliseconds())};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.publicGetTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"id");let n;if(i!==void 0){const f=i.split(":");n=this.safeString(f,0)}n=this.safeString(e,"market_id",n);const r=this.safeSymbol(n,t,"-"),a=this.safeString(e,"side"),o=this.safeString(e,"price"),d=this.safeString(e,"quantity"),c=this.safeString(e,"order_id"),u=this.safeString(e,"fee_amount");let h;if(u!==void 0){const f=this.safeString(e,"fee_currency_id"),l=this.safeCurrencyCode(f);h={cost:u,currency:l}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,order:c,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"data"))}normalizeOHLCVTimestamp(e,t,s=!1){const i=this.parseTimeframe(t);if(t==="1M"){const r=this.iso8601(e).split("-"),a=this.safeString(r,0);let o=this.safeInteger(r,1);return s&&(o=this.sum(o,1)),o<10?o="0"+o.toString():o=o.toString(),a+"-"+o+"-01T00:00:00.000Z"}else if(t==="1w"){e=parseInt(e/1e3);const n=259200,r=e-n,a=Math.floor(r/i);let o=this.sum(n,a*i);return s&&(o=this.sum(o,i)),this.iso8601(o*1e3)}else return e=parseInt(e/1e3),e=i*parseInt(e/i),s&&(e=this.sum(e,i)),this.iso8601(e*1e3)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t];i=i===void 0?100:i;let o=this.sum(i,1);o=Math.min(1e3,o);const d={market_ids:r.id,interval:a,sort:"asc",limit:o},c=this.milliseconds(),u=this.parseTimeframe(t);let h=s,f=c;s===void 0?(i===void 0&&(i=o),h=c-i*u*1e3):i===void 0?f=c:f=this.sum(s,this.sum(i,1)*u*1e3);const l=this.normalizeOHLCVTimestamp(h,t),m=this.normalizeOHLCVTimestamp(f,t,!0);d.start_time=l,d.end_time=m;const g=await this.publicGetCandle(this.extend(d,n)),y=this.safeValue(g,"data",[]);return this.parseOHLCVs(y,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"start_time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),t=this.parse8601(t);const n={};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id);const a=await this.privateGetOpenOrder(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds()),limit:100};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id),t&&(n.start_time=this.iso8601(t)),s&&(n.limit=s);const a=await this.privateGetOrderHistory(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Sk(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={market_id:i.id},r=this.safeString2(s,"clientOrderId","client_order_id");r!==void 0?n.client_order_id=r:n.order_id=e;const a=this.omit(s,["clientOrderId","client_order_id"]),o=await this.privateGetOrder(this.extend(n,a)),d=this.safeValue(o,"data",[]),c=this.safeValue(d,0);return this.parseOrder(c,i)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"id"),n=this.safeString(e,"type"),r=this.safeString(e,"side"),a=this.safeString(e,"market_id"),o=this.safeSymbol(a,t,"-"),d=this.parse8601(this.safeString(e,"time"));let c=this.safeString(e,"limit_price");const u=this.safeString(e,"filled_quantity");let h=this.safeString(e,"open_quantity");const f=this.safeString(e,"cancelled_quantity");f!==void 0&&(h=Ou.stringAdd(h,f));const l=this.safeString(e,"quantity",Ou.stringAdd(u,h)),m=this.safeString2(e,"filled_cost","cost");n==="market"&&(c=void 0);const g=this.safeString(e,"client_order_id"),y=this.safeStringUpper(e,"time_in_force");return this.safeOrder({id:i,info:e,clientOrderId:g,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,timeInForce:y,side:r,status:s,price:c,stopPrice:void 0,triggerPrice:void 0,amount:l,filled:u,remaining:h,average:void 0,cost:m,fee:void 0,trades:void 0},t)}costToPrecision(e,t){return this.decimalToPrecision(t,rF,this.markets[e].precision.cost,this.precisionMode)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"timeInForce"),d=this.safeValue(o,t),c=this.safeString2(r,"timeInForce","time_in_force",d),u={market_id:a.id,type:t,side:s,time_in_force:c},h=this.safeString2(r,"clientOrderId","client_order_id");h!==void 0&&(u.client_order_id=h);let f;if(t==="limit")u.limit_price=this.priceToPrecision(e,n),u.quantity=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let w=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)w===void 0&&(w=i*n);else if(w===void 0)throw new kk(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' extra parameter (the exchange-specific behaviour)")}else w=w===void 0?i:w;f=this.costToPrecision(e,w),u.cost=f}else u.quantity=this.amountToPrecision(e,i);const l=this.omit(r,["timeInForce","time_in_force","clientOrderId","client_order_id"]),m=await this.privatePostNewOrder(this.extend(u,l)),g=this.safeValue(m,"data"),y=this.parseOrder(g,a);return t==="market"&&s==="buy"&&(y.amount=void 0,y.cost=this.parseNumber(f),y.remaining=void 0),y}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Sk(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market_id:this.market(t).id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"destination_tag"),n=this.safeString(e,"currency_id");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"platform_id");return this.checkAddress(s),{currency:r,address:s,tag:i,network:a,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_id:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.platform_id=r,t=this.omit(t,"platform_id"));const a=await this.privateGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0);if(d===void 0)throw new vk(this.id+" fetchDepositAddress() returned an empty response");return this.parseDepositAddress(d,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s={};if(e){const r=[];for(let a=0;a<e.length;a++){const o=this.currency(e[a]);r.push(o.id)}s.currency_id=e.join(",")}const i=await this.privateGetDepositAddress(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseDepositAddresses(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i===void 0&&(i="");const a={currency_id:r.id,address:s,destination_tag:i,amount:this.numberToString(t)},o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.platform_id=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawal(this.extend(a,n)),u=this.safeValue(c,"data");return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"amount"),n=this.safeString(e,"address"),r=this.safeString(e,"destination_tag"),a=this.safeString(e,"hash"),o=this.parse8601(this.safeString(e,"time")),d=this.safeString(e,"type"),c=this.safeString(e,"currency_id"),u=this.safeCurrencyCode(c),h=this.parseTransactionStatus(this.safeString(e,"status")),f=this.safeNumber(e,"fee");let l;return f!==void 0&&f!==0&&(l={currency:u,cost:f}),{id:s,currency:u,amount:i,network:void 0,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,status:h,type:d,txid:a,timestamp:o,datetime:this.iso8601(o),updated:void 0,fee:l,info:e}}parseTransactionStatus(e){const t={requested:"pending",pending:"pending",confirming:"pending",confirmed:"pending",applying:"pending",done:"ok",cancelled:"canceled",cancelling:"canceled"};return this.safeString(t,e,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="accounts"){this.checkRequiredCredentials(),a+=this.implodeParams(e,i);const d=this.apiKey+":"+this.secret,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"},Object.keys(o).length&&(r=this.json(o))}else if(a+=this.version+"/",t==="public")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){const d=this.milliseconds();this.checkRequiredCredentials();const c=this.safeInteger(this.options,"expires");if(c===void 0||c<d)throw new Sp(this.id+" access token expired, call signIn() method");const u=this.safeString(this.options,"accessToken");n={Authorization:"Bearer "+u},a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}async signIn(e={}){this.checkRequiredCredentials();const t={grant_type:"client_credentials"},s=await this.accountsPostToken(this.extend(t,e)),i=this.safeInteger(s,"expires_in"),n=this.safeString(s,"access_token");return this.options.accessToken=n,this.options.expires=this.sum(this.milliseconds(),i*1e3),s}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"errorCode"in a){const c=this.safeString(a,"errorCode"),u=this.safeString(a,"message");if(c!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.exact,c,h),new eF(h)}}}};const dF=re,{AuthenticationError:Tk,ExchangeError:Tp,BadSymbol:Ok,BadRequest:Op,InvalidOrder:Ik,ArgumentsRequired:Iu,OrderNotFound:cF,InsufficientFunds:uF,DDoSProtection:hF}=Q,{TICK_SIZE:fF}=ne;var RT=class extends dF{describe(){return this.deepExtend(super.describe(),{id:"ripio",name:"Ripio",countries:["AR","BR"],rateLimit:50,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/94507548-a83d6a80-0218-11eb-9998-28b9cec54165.jpg",api:{public:"https://api.exchange.ripio.com/api",private:"https://api.exchange.ripio.com/api"},www:"https://exchange.ripio.com",doc:["https://exchange.ripio.com/en/api/"],fees:"https://exchange.ripio.com/en/fee"},api:{public:{get:["rate/all/","rate/{pair}/","orderbook/{pair}/","tradehistory/{pair}/","pair/","currency/","orderbook/{pair}/depth/"]},private:{get:["balances/exchange_balances/","order/{pair}/{order_id}/","order/{pair}/","trade/{pair}/"],post:["order/{pair}/","order/{pair}/{order_id}/cancel/"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0"),maker:this.parseNumber("0.0")}},precisionMode:fF,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{},broad:{"Authentication credentials were not provided":Tk,"Disabled pair":Ok,"Invalid order type":Ik,"Your balance is not enough":uF,"Order couldn't be created":Tp,"not found":cF,"Invalid pair":Ok,"amount must be a number":Op,"Total must be at least":Ik,"Account not found":Op,"Wrong password provided":Tk,"User tokens limit":hF,"Something unexpected ocurred":Tp,account_balance:Op}}})}async fetchMarkets(e={}){const t=await this.publicGetPair(e),s=[],i=this.safeValue(t,"results",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"base"),o=this.safeString(r,"quote"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeValue(r,"fees",[]),f=this.safeValue(h,0,{});s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(r,"enabled",!0),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(f,"taker_fee",0),maker:this.safeNumber(f,"maker_fee",0),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"min_amount"),price:this.safeNumber(r,"price_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_value"),max:void 0}},info:r})}return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"enabled",!0);i[o]={id:a,code:o,name:d,info:r,active:c,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"decimal_places"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"pair");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"last_price"),a=this.safeString(e,"avg");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bid_volume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"ask_volume"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:a,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetRatePair(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetRateAll(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderbookPair(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount");return a.nonce=this.safeInteger(r,"updated_id"),a}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeInteger(e,"timestamp");i=this.safeTimestamp(e,"created_at",i);let n=this.safeString(e,"side");const a=this.safeString(e,"taker_side")===n?"taker":"maker";n!==void 0&&(n=n.toLowerCase());const o=this.safeString2(e,"price","match_price"),d=this.safeString2(e,"amount","exchanged"),c=this.safeString(e,"pair");t=this.safeMarket(c,t);const u=this.safeString(e,a+"_fee"),h=this.safeString(e,a);let f;return u!==void 0&&(f={cost:u,currency:n==="buy"?t.base:t.quote}),this.safeTrade({id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:n,price:o,amount:d,cost:void 0,takerOrMaker:a,fee:f,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradehistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPair(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeSymbol(a,void 0,"_"),d=this.safeValue(r,"fees",[]),c=this.safeValue(d,0,{});i[o]={info:r,symbol:o,maker:this.safeNumber(c,"maker_fee"),taker:this.safeNumber(c,"taker_fee"),tierBased:!1}}return i}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalancesExchangeBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=s.toUpperCase(),c={pair:a.id,order_type:o,side:d,amount:this.amountToPrecision(e,i)};o==="LIMIT"&&(c.limit_price=this.priceToPrecision(e,n));const u=await this.privatePostOrderPair(this.extend(c,r));return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Iu(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostOrderPairOrderIdCancel(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Iu(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privateGetOrderPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Iu(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.offset=s);const a=await this.privateGetOrderPair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"OPEN,PART"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"CLOS,CANC,COMP"};return await this.fetchOrders(e,t,s,this.extend(n,i))}parseOrderStatus(e){const t={OPEN:"open",PART:"open",CLOS:"canceled",CANC:"canceled",COMP:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"amount"),n=this.safeString(e,"notional"),r=this.safeStringLower(e,"order_type"),a=r==="market"?"fill_price":"limit_price",o=this.safeString(e,a),d=this.safeStringLower(e,"side"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeTimestamp(e,"created_at"),h=this.safeString(e,"fill_price"),f=this.safeString(e,"filled"),l=this.safeValue(e,"fills"),m=this.safeString(e,"pair");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:this.safeSymbol(m,t,"_"),type:r,timeInForce:void 0,postOnly:void 0,side:d,price:o,stopPrice:this.safeString(e,"stop_price"),triggerPrice:this.safeString(e,"stop_price"),amount:i,cost:n,average:h,filled:f,remaining:void 0,status:c,fee:void 0,trades:l},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Iu(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTradePair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),s==="POST"?r=this.json(d):Object.keys(d).length&&(o+="?"+this.urlencode(d)),n={"Content-Type":"application/json",Authorization:"Bearer "+this.apiKey}),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"detail");if(c!==void 0){const h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,c,h)}const u=this.safeValue(a,"errors");if(u!==void 0){const h=this.id+" "+r,f=Object.keys(u);for(let l=0;l<f.length;l++){const m=f[l],g=this.safeValue(u,m,[]),y=this.safeString(g,0);this.throwBroadlyMatchedException(this.exceptions.broad,y,h)}throw new Tp(h)}}};const lF=re,{ArgumentsRequired:pF,AuthenticationError:mF,ExchangeError:Ea,InsufficientFunds:gF,OrderNotFound:xk,PermissionDenied:_k,BadRequest:yF,BadSymbol:wF,DDoSProtection:bF,InvalidOrder:kF,AccountSuspended:SF}=Q,{TICK_SIZE:vF}=ne,ln=ae;var TF=class extends lF{describe(){return this.deepExtend(super.describe(),{id:"stex",name:"STEX",countries:["EE"],rateLimit:1e3/3,certified:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrder:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFees:!0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},version:"v3",urls:{logo:"https://user-images.githubusercontent.com/1294454/69680782-03fd0b80-10bd-11ea-909e-7f603500e9cc.jpg",api:{rest:"https://api3.stex.com"},www:"https://www.stex.com",doc:["https://apidocs.stex.com/","https://help.stex.com/en/collections/1593608-api-v3-documentation"],fees:"https://app.stex.com/en/pairs-specification",referral:"https://app.stex.com?ref=36416021"},requiredCredentials:{apiKey:!1,secret:!1,token:!0},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D"},api:{public:{get:{currencies:1,"currencies/{currencyId}":1,markets:1,"pairs-groups":1,"currency_pairs/list/{code}":1,"currency_pairs/group/{currencyPairGroupId}":1,"currency_pairs/{currencyPairId}":1,ticker:1,"ticker/{currencyPairId}":1,"trades/{currencyPairId}":1,"orderbook/{currencyPairId}":1,"chart/{currencyPairId}/{candlesType}":1,"deposit-statuses":1,"deposit-statuses/{statusId}":1,"withdrawal-statuses":1,"withdrawal-statuses/{statusId}":1,ping:1,"mobile-versions":1,twitter:1}},trading:{get:{"fees/{currencyPairId}":1,orders:12,"orders/{currencyPairId}":6,"order/{orderId}":12},post:{"orders/{currencyPairId}":1.5,"orders/bulk/{currencyPairId}":12},delete:{orders:30,"orders/{currencyPairId}":12,"order/{orderId}":1.5}},reports:{get:{currencies:12,currency_pairs:12,orders:12,"orders/{orderId}":12,"trades/{currencyPairId}":12,"background/{listMode}":12,"background/{id}":12,"background/download/{id}":12},post:{"background/create":12},delete:{"background/{id}":12}},profile:{get:{info:3,wallets:3,"wallets/{walletId}":3,"wallets/address/{walletId}":3,deposits:3,"deposits/{id}":3,rewards:3,"rewards/{id}":3,addressbook:3,"addressbook/{itemId}":3,withdrawals:3,"withdrawals/{id}":3,notifications:3,"notifications/price":3,"favorite/currency_pairs":3,"token-scopes":3},post:{"wallets/burn/{walletId}":3,"wallets/{walletId}/hold_amount":3,"wallets/{currencyId}":3,"wallets/address/{walletId}":3,"addressbook/disable_item/{itemId}":3,"addressbook/enable_item/{itemId}":3,"addressbook/enable_strict_wd":3,"addressbook/disable_strict_wd":3,withdraw:30,"notifications/price":3,"referral/program":3,"referral/insert/{code}":3,"referral/bonus_transfer/{currencyId}":3},put:{"favorite/currency_pairs/set":3},delete:{"addressbook/{itemId}":3,"withdraw/{withdrawalId}":30,"notifications/price/{priceAlertId}":3}},verification:{get:{countries:1,status:1,"fractal/url":1,"smart-id":1,stex:1,"cryptonomica/code":1},post:{"smart-id":1,stex:1,cryptonomica:1}},settings:{get:{"notifications/{event}":1,notifications:1},put:{notifications:1,"notifications/set":1}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},commonCurrencies:{BC:"Bitcoin Confidential",BITS:"Bitcoinus",BITSW:"BITS",BHD:"Bithold",BTH:"Bithereum",MPH:"Chasyr Token",SBTC:"SBTCT"},options:{parseOrderToPrecision:!1,networks:{ERC20:5,ETH:5,OMNI:10,XLM:20,BEP2:22,TRC20:24,TRX:24,SOL:25,BEP20:501},accountsByType:{spot:"spot",hold:"hold",funding:"funding",referal:"referal"},transfer:{fillResponseFromRequest:!0}},precisionMode:vF,exceptions:{exact:{"Wrong parameters":yF,"Unauthenticated.":mF,"Server Error":Ea,"This feature is only enabled for users verifies by Cryptonomica":_k,"Too Many Attempts.":bF,"Selected Pair is disabled":wF,"Invalid scope(s) provided.":_k,"The maximum amount of open orders with the same price cannot exceed 10":kF,"Your account not verified!":SF},broad:{"Not enough":gF}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"id"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(this.safeString(r,"code")),c=this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),u=this.safeNumber(r,"withdrawal_fee_const"),h=this.safeValue(r,"active",!0);s[d]={id:a,numericId:o,code:d,info:r,type:void 0,name:this.safeString(r,"name"),active:h,deposit:void 0,withdraw:void 0,fee:u,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:this.safeNumber(r,"minimum_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(r,"minimum_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t={code:"ALL"},s=await this.publicGetCurrencyPairsListCode(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"id"),d=this.safeInteger(a,"id"),c=this.safeString(a,"currency_id"),u=this.safeString(a,"market_currency_id"),h=this.safeInteger(a,"currency_id"),f=this.safeInteger(a,"market_currency_id"),l=this.safeCurrencyCode(this.safeString(a,"currency_code")),m=this.safeCurrencyCode(this.safeString(a,"market_code")),g=this.safeString(a,"min_buy_price"),y=this.safeString(a,"min_sell_price"),w=ln.stringMax(g,y),b=ln.stringDiv(this.safeString(a,"buy_fee_percent"),"100"),S=ln.stringDiv(this.safeString(a,"sell_fee_percent"),"100"),v=ln.stringMax(b,S);i.push({id:o,numericId:d,symbol:l+"/"+m,base:l,quote:m,settle:void 0,baseId:c,quoteId:u,settleId:void 0,baseNumericId:h,quoteNumericId:f,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"active"),contract:!1,linear:void 0,inverse:void 0,taker:v,maker:v,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"currency_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_order_amount"),max:void 0},price:{min:w,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.publicGetTickerCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"server_datetime",{});return this.parse8601(this.safeString(i,"date"))}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={currencyPairId:this.market(e).id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetOrderbookCurrencyPairId(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,e,void 0,"bid","ask","price","amount")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"id","symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeQuote"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currencyPairId:r.id,candlesType:this.timeframes[t]};i===void 0?i=100:a.limit=i;const o=this.parseTimeframe(t),d=i*o;s===void 0?(a.timeEnd=this.seconds(),a.timeStart=a.timeEnd-d):(a.timeStart=parseInt(s/1e3),a.timeEnd=this.sum(a.timeStart,d));const c=await this.publicGetChartCurrencyPairIdCandlesType(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"amount");let a;a===void 0&&t!==void 0&&(a=t.symbol);const o=this.safeStringLower2(e,"type","trade_type");return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,id:s,order:void 0,type:void 0,takerOrMaker:void 0,side:o,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=parseInt(t/1e3));const a=await this.publicGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.tradingGetFeesCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data");return{info:n,symbol:s.symbol,maker:this.safeNumber(r,"sell_fee"),taker:this.safeNumber(r,"buy_fee"),percentage:!0,tierBased:!0}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currency_id")),a=this.account();a.free=this.safeString(n,"balance"),a.used=this.safeString(n,"frozen_balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.profileGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={PROCESSING:"open",PENDING:"open",PARTIAL:"open",FINISHED:"closed",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString2(e,"currency_pair_id","currency_pair_name"),r=this.safeSymbol(n,t,"_"),a=this.safeTimestamp(e,"timestamp"),o=this.safeString(e,"price"),d=this.safeString(e,"initial_amount"),c=this.safeString(e,"processed_amount");let u,h;c!==void 0&&(d!==void 0&&(u=ln.stringSub(d,c),this.options.parseOrderToPrecision&&(u=this.amountToPrecision(r,u)),u=ln.stringMax(u,"0.0")),o!==void 0&&h===void 0&&(h=ln.stringMul(o,c)));let f=this.safeString(e,"original_type");(f==="BUY"||f==="SELL")&&(f=void 0);const l=this.safeStringLower(e,"type"),m=this.safeValue(e,"trades"),g=this.safeNumber(e,"trigger_price"),y={info:e,id:s,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:r,type:f,timeInForce:void 0,postOnly:void 0,side:l,price:o,stopPrice:g,triggerPrice:g,amount:d,cost:h,average:void 0,filled:c,remaining:u,status:i,trades:m},w=this.safeValue(e,"fees");if(w===void 0)y.fee=void 0;else if(w.length>0){y.fees=[];for(let S=0;S<w.length;S++){const v=this.safeString(w[S],"amount");if(v!==void 0){const T=this.safeString(w[S],"currency_id"),I=this.safeCurrencyCode(T);y.fees.push({cost:v,currency:I})}}}else y.fee=void 0;return this.safeOrder(y,t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Ea(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e);t==="limit"&&(t=s);const o={currencyPairId:a.id,type:t.toUpperCase(),amount:parseFloat(this.amountToPrecision(e,i)),price:parseFloat(this.priceToPrecision(e,n))},d=await this.tradingPostOrdersCurrencyPairId(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingGetOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchClosedOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.reportsGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){return(await this.fetchClosedOrder(e,t,n)).trades}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r="tradingGetOrders";const a={};e!==void 0&&(r="tradingGetOrdersCurrencyPairId",n=this.market(e),a.currencyPairId=n.id),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingDeleteOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"put_into_processing_queue",[]),o=this.safeValue(r,"not_put_into_processing_queue",[]),d=a.length,c=o.length;if(d<1){if(c<1)throw new xk(this.id+" cancelOrder() received an empty response: "+this.json(n));return this.parseOrder(o[0])}else{if(c<1)return this.parseOrder(a[0]);throw new xk(this.id+" cancelOrder() received an empty response: "+this.json(n))}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="tradingDeleteOrders";if(e!==void 0){const r=this.market(e);s.currencyPairId=r.id,i="tradingDeleteOrdersCurrencyPairId"}return await this[i](this.extend(s,t))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new pF(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};t!==void 0&&(r.timeStart=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.reportsGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currencyId:this.currency(e).id},n=await this.profilePostWalletsCurrencyId(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"deposit_address",{}),o=this.safeString(a,"address"),d=this.safeString(a,"additional_address_parameter");return this.checkAddress(o),{currency:e,address:o,tag:d,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.fetchBalance(),i=this.safeValue(s.info,"data",[]),n=this.indexBy(i,"currency_id"),r=this.currency(e),a=this.safeValue(n,r.id);if(a===void 0)throw new Ea(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const o=this.safeInteger(a,"id");if(o===void 0)throw new Ea(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const d={walletId:o},c=await this.profileGetWalletsWalletId(this.extend(d,t)),u=this.safeValue(c,"data",[]),h=this.safeValue(u,"deposit_address",{}),f=this.safeString(h,"address"),l=this.safeString(h,"additional_address_parameter");return this.checkAddress(f),{currency:e,address:f,tag:l,network:void 0,info:c}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(this.checkRequiredCredentials(),n={Authorization:"Bearer "+this.token},s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),Object.keys(o).length&&(n["Content-Type"]="application/json"))),{url:a,method:s,body:r,headers:n}}parseTransactionStatus(e){const t={processing:"pending","checking by system":"pending",hodl:"pending","amount too low":"failed","not confirmed":"pending","cancelled by user":"canceled",approved:"pending",finished:"ok","withdrawal error":"failed","deposit error":"failed","cancelled by admin":"canceled",awaiting:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeValue(e,"withdrawal_address",{}),n=this.safeString(i,"address"),r=this.safeString(i,"additional_address_parameter"),a=this.safeString(e,"currency_id");let o;a in this.currencies_by_id?t=this.currencies_by_id[a]:o=this.commonCurrencyCode(this.safeString(e,"currency_code")),o===void 0&&t!==void 0&&(o=t.code);const d="deposit_status_id"in e?"deposit":"withdrawal",c=this.safeNumber(e,"amount"),u=this.parseTransactionStatus(this.safeStringLower(e,"status")),h=this.safeTimestamp2(e,"timestamp","created_ts"),f=this.safeTimestamp(e,"updated_ts"),l=this.safeString(e,"txid");let m;const g=this.safeNumber(e,"fee");if(g!==void 0){const w=this.safeString2(e,"fee_currency_id","deposit_fee_currency_id"),b=this.safeCurrencyCode(w);m={cost:g,currency:b}}const y=this.safeString(i,"protocol_name");return{info:e,id:s,txid:l,timestamp:h,datetime:this.iso8601(h),network:y,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,type:d,amount:c,currency:o,status:u,updated:f,fee:m}}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetDepositsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetDeposits(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetWithdrawalsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;const o={};if(s==="referal"&&i==="spot")o.currencyId=r.id,a="profilePostReferralBonusTransferCurrencyId";else if(i==="hold")o.walletId=s,t=this.currencyToPrecision(e,t),t=ln.stringNeg(t),o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else if(s==="hold")o.walletId=i,o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else throw new Ea(this.id+" transfer() only allows transfers of referal to spot and between a walletId and funding");const d=await this[a](this.extend(o,n)),c=this.safeValue(d,"data",{}),u=this.parseTransfer(c,r),h=this.safeValue(this.options,"transfer",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.fromAccount=s,u.toAccount=i,typeof t=="string"&&ln.stringLt(t,"0")&&(t=this.parseNumber(ln.stringNeg(t))),u.amount=t,u.currency===void 0&&(u.currency=e)),u}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency_id");let i;return s in this.currencies_by_id?t=this.currencies_by_id[s]:i=this.commonCurrencyCode(this.safeString(e,"currency_code")),i===void 0&&(i=this.safeValue(t,"code")),{info:e,id:this.safeString(e,"id"),timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),address:s};i!==void 0&&(a.additional_address_parameter=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeInteger(o,d,d),d!==void 0&&(a.protocol_id=d,n=this.omit(n,"network"));const c=await this.profilePostWithdraw(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=Object.keys(this.currencies),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.currencies[r];if(e!==void 0&&!this.inArray(r,e))continue;const o=this.safeValue(a,"info");i[r]={withdraw:this.safeNumber(a,"fee"),deposit:this.safeNumber(o,"deposit_fee_const"),info:o}}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCurrencies(t),i=this.safeValue(s,"data");return this.parseDepositWithdrawFees(i,e,"code")}parseDepositWithdrawFee(e,t=void 0){const s={withdraw:{fee:this.safeNumber(e,"withdrawal_fee_const"),percentage:!1},deposit:{fee:this.safeNumber(e,"deposit_fee_const"),percentage:!1},networks:{}},i=this.safeValue(e,"protocol_specific_settings",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"protocol_name"),o=this.networkIdToCode(a);s.networks[o]={withdraw:{fee:this.safeNumber(r,"withdrawal_fee_const"),percentage:!1},deposit:{fee:void 0,percentage:void 0}}}return s}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!1)){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new Ea(h)}}};const OF=re,{ExchangeError:Ck,ArgumentsRequired:Ip,BadRequest:zr,OrderNotFound:IF,InvalidAddress:Mk}=Q,{TICK_SIZE:xF}=ne,ir=ae;var _F=class extends OF{describe(){return this.deepExtend(super.describe(),{id:"therock",name:"TheRockTrading",countries:["MT"],rateLimit:100,version:"v1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg",api:{rest:"https://api.therocktrading.com"},www:"https://therocktrading.com",doc:["https://api.therocktrading.com/doc/v1/index.html","https://api.therocktrading.com/doc/"]},api:{public:{get:{funds:1,"funds/{id}":1,"funds/{id}/orderbook":1,"funds/{id}/ticker":1,"funds/{id}/trades":1,"funds/{id}/ohlc_statistics":1,"funds/tickers":1}},private:{get:{balances:1,"balances/{id}":1,discounts:1,"discounts/{id}":1,funds:1,"funds/{id}":1,"funds/{id}/trades":1,"funds/{fund_id}/orders":1,"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/position_balances":1,"funds/{fund_id}/positions":1,"funds/{fund_id}/positions/{id}":1,transactions:1,"transactions/{id}":1,"withdraw_limits/{id}":1,withdraw_limits:1},post:{"atms/withdraw":1,"funds/{fund_id}/orders":1},delete:{"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/orders/remove_all":1}}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,PPC:0,ETH:0,ZEC:0,LTC:0,EUR:0}}},precisionMode:xF,exceptions:{exact:{"Request already running":zr,"cannot specify multiple address types":zr,"Currency is not included in the list":zr,"Record not found":IF},broad:{"before must be greater than after param":zr,"must be shorter than 60 days":zr,"must be a multiple of (period param) in minutes":zr,"Address allocation limit reached for currency":Mk,"is not a valid value for param currency":zr," is invalid":Mk}},options:{withdraw:{fillResponseFromRequest:!0}}})}async fetchMarkets(e={}){const t=await this.publicGetFunds(e),s=this.safeValue(t,"funds"),i=[];if(s===void 0)throw new Ck(this.id+" fetchMarkets() got an unexpected response");for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"trade_currency"),d=this.safeString(r,"base_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"buy_fee"),f=this.safeString(r,"sell_fee");let l=ir.stringMax(h,f);l=this.parseNumber(ir.stringDiv(l,"100"));const m=this.safeValue(r,"leverages"),g=m.length;i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:g>0,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,taker:l,maker:l,contractSize:void 0,active:!0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"trade_currency_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"base_currency_decimals")))},limits:{leverage:{min:1,max:this.safeValue(m,g-1,1)},amount:{min:this.safeNumber(r,"minimum_quantity_offer"),max:void 0},price:{min:this.safeNumber(r,"minimum_price_offer"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"trading_balance"),o.total=this.safeString(n,"balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={id:i.id},r=await this.publicGetFundsIdOrderbook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"date"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"date"));t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:this.safeString(e,"close"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_traded"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetFundsTickers(t),i=this.indexBy(s.tickers,"fund_id"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetFundsIdTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fund_id"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"date")),r=this.safeString(e,"id"),a=this.safeString(e,"order_id"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"amount");let u,h;const f=this.safeValue(e,"transactions",[]),l=this.groupBy(f,"type"),m=this.safeValue(l,"paid_commission",[]);for(let g=0;g<m.length;g++)h===void 0&&(h="0.0"),h=ir.stringAdd(h,this.safeString(m[g],"price"));return h!==void 0&&(u={cost:h,currency:t.quote}),this.safeTrade({info:e,id:r,order:a,timestamp:n,datetime:this.iso8601(n),symbol:i,type:void 0,side:o,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:u},t)}parseLedgerEntryDirection(e){const t={affiliate_earnings:"in",atm_payment:"in",bought_currency_from_fund:"out",bought_shares:"out",paid_commission:"out",paypal_payment:"in",pos_payment:"in",released_currency_to_fund:"out",rollover_commission:"out",sold_currency_to_fund:"in",sold_shares:"in",transfer_received:"in",transfer_sent:"out",withdraw:"out"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={affiliate_earnings:"referral",atm_payment:"transaction",bought_currency_from_fund:"trade",bought_shares:"trade",paid_commission:"fee",paypal_payment:"transaction",pos_payment:"transaction",released_currency_to_fund:"trade",rollover_commission:"fee",sold_currency_to_fund:"trade",sold_shares:"trade",transfer_received:"transfer",transfer_sent:"transfer",withdraw:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"type");const r=this.parseLedgerEntryDirection(n);n=this.parseLedgerEntryType(n),(n==="trade"||n==="fee")&&(i=this.safeString(e,"trade_id"));const a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a),d=this.safeNumber(e,"price"),c=this.parse8601(this.safeString(e,"date"));return{info:e,id:s,direction:r,account:void 0,referenceId:i,referenceAccount:void 0,type:n,currency:o,amount:d,before:void 0,after:void 0,status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t));const a=await this.privateGetTransactions(this.extend(n,i)),o=this.safeValue(a,"transactions",[]);return this.parseLedger(o,r,t,s)}parseTransactionType(e){const t={withdraw:"withdrawal",atm_payment:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","transaction_id"),i=this.parseTransactionType(this.safeString(e,"type")),n=this.safeValue(e,"transfer_detail",{}),r=this.safeString(n,"method");let a,o;r!==void 0&&r!=="wire_transfer"&&(a=this.safeString(n,"id"),o=this.safeString(n,"recipient"));const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),u=this.safeNumber(e,"price"),h=this.parse8601(this.safeString(e,"date")),f="ok",l=this.safeString(n,"method");return{info:e,id:s,currency:c,amount:u,network:l,addressFrom:void 0,addressTo:o,address:o,tagFrom:void 0,tagTo:void 0,tag:void 0,status:f,type:i,updated:void 0,txid:a,timestamp:h,datetime:this.iso8601(h),fee:void 0}}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"withdraw"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"atm_payment"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t)),i=this.extend(n,i);const a=await this.privateGetTransactions(i),o=this.safeValue(a,"transactions",[]),d=["withdraw","atm_payment"],c=this.filterByArray(o,"type",d,!1);return this.parseTransactions(c,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a={currency:r.id,destination_address:s,amount:parseFloat(t)};i!==void 0&&(a.destination_tag=i);const o=await this.privatePostAtmsWithdraw(this.extend(a,n)),d=this.parseTransaction(o,r),c=this.safeValue(this.options,"withdraw",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.addressTo===s&&(d.addressTo=s),d.address===void 0&&(d.address=s),d.tagTo===void 0&&(d.tagTo=i),d.tag===void 0&&(d.tag=i),d.amount===void 0&&(d.amount=t)),d}parseOrderStatus(e){const t={active:"open",executed:"closed",deleted:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"fund_id"),n=this.parse8601(this.safeString(e,"date")),r=this.safeString(e,"amount"),a=this.safeString(e,"amount_unfilled"),o=this.safeString(e,"price"),d=this.safeValue(e,"trades"),c=this.safeString(e,"conditional_price");return this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),symbol:this.safeSymbol(i,t),type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:o,stopPrice:c,triggerPrice:c,cost:void 0,amount:r,filled:void 0,average:void 0,remaining:a,fee:void 0,trades:d},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"active"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"executed"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ip(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={fund_id:n.id};t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsFundIdOrders(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ip(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,fund_id:i.id},r=await this.privateGetFundsFundIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),t==="market"&&(n=0);const o={fund_id:this.market(e).id,side:s,amount:i,price:n},d=await this.privatePostFundsFundIdOrders(this.extend(o,r));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e,fund_id:this.marketId(t)},n=await this.privateDeleteFundsFundIdOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=parseInt(a/60),d={id:r.id,period:o};s===void 0&&(d.after=this.iso8601(s));const c=await this.publicGetFundsIdOhlcStatistics(this.extend(d,n));return this.parseOHLCVs(c,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"interval_starts_at");return[this.parse8601(s),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ip(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsIdTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.publicGetFundsIdTrades(this.extend(r,i));return this.parseTrades(a.trades,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);let i={id:s.id};const n=await this.publicGetFundsId(this.extend(i,t));i={id:s.quoteId};const r=await this.privateGetDiscountsId(this.extend(i,t));return this.parseTradingFee(n,r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFunds(e),s=await this.privateGetDiscounts(e),i=this.safeValue(t,"funds",[]),n=this.safeValue(s,"discounts",[]),r={};for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"id"),c=this.safeMarket(d),u=this.safeValue(c,"quoteId"),h=this.filterBy(n,"currency",u),f=this.parseTradingFee(o,h,c),l=f.symbol;r[l]=f}return r}parseTradingFee(e,t=void 0,s=void 0){const i=this.safeString(e,"id"),n=this.safeString(e,"buy_fee"),r=this.safeString(e,"sell_fee"),a=this.safeString(t,"discount","0"),o=ir.stringSub("100",a),d=this.parseNumber(ir.stringDiv(ir.stringMul(n,o),"10000")),c=this.parseNumber(ir.stringDiv(ir.stringMul(r,o),"10000"));return{info:e,symbol:this.safeSymbol(i,s),maker:c,taker:d,percentage:!0,tierBased:!0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n=n===void 0?{}:n,t==="private"){if(this.checkRequiredCredentials(),Object.keys(o).length)if(s==="POST")r=this.json(o),n["Content-Type"]="application/json";else{const u=this.rawencode(o);u.length&&(a+="?"+u)}const d=this.nonce().toString(),c=d+a;n["X-TRT-KEY"]=this.apiKey,n["X-TRT-NONCE"]=d,n["X-TRT-SIGN"]=this.hmac(this.encode(c),this.encode(this.secret),"sha512")}else t==="public"&&Object.keys(o).length&&(a+="?"+this.rawencode(o));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"errors",[]),u=c.length;if(u>0){const h=this.id+" "+r;for(let f=0;f<u;f++){const l=c[f],m=this.safeString(l,"message");this.throwExactlyMatchedException(this.exceptions.exact,m,h),this.throwBroadlyMatchedException(this.exceptions.broad,m,h)}throw new Ck(h)}}};const CF=re,{ExchangeError:Td,ArgumentsRequired:MF,ExchangeNotAvailable:xp,InsufficientFunds:Pk,OrderNotFound:PF,DDoSProtection:AF,InvalidOrder:jr,AuthenticationError:_p,PermissionDenied:BF}=Q,{TICK_SIZE:NF}=ne,Ak=ae;var VF=class extends CF{describe(){return this.deepExtend(super.describe(),{id:"tidex",name:"Tidex",countries:["UK"],rateLimit:2e3,version:"3",userAgent:this.userAgents.chrome,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg",api:{web:"https://gate.tidex.com/api",public:"https://api.tidex.com/api/3",private:"https://api.tidex.com/tapi"},www:"https://tidex.com",doc:"https://tidex.com/exchange/public-api",referral:"https://tidex.com/exchange",fees:["https://tidex.com/exchange/assets-spec","https://tidex.com/exchange/pairs-spec"]},api:{web:{get:["currency","pairs","tickers","orders","ordershistory","trade-data","trade-data/{id}"]},public:{get:["info","ticker/{pair}","depth/{pair}","trades/{pair}"]},private:{post:["getInfoExt","getInfo","Trade","ActiveOrders","OrderInfo","CancelOrder","TradeHistory","getDepositAddress","createWithdraw","getWithdraw"]}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},commonCurrencies:{DSH:"DASH",EMGO:"MGO",MGO:"WMGO"},precisionMode:NF,exceptions:{exact:{803:jr,804:jr,805:jr,806:jr,807:jr,831:Pk,832:Pk,833:PF},broad:{"Invalid pair name":Td,"invalid api key":_p,"invalid sign":_p,"api key dont have trade permission":_p,"invalid parameter":jr,"invalid order":jr,"Requests too often":AF,"not available":xp,"data unavailable":xp,"external service unavailable":xp,"IP restricted":BF}},options:{fetchTickersMaxLength:2048},orders:{}})}async fetchCurrencies(e={}){const t=await this.webGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r);let d=this.safeValue(n,"visible")===!0;const c=this.safeValue(n,"withdrawEnable",!0),u=this.safeValue(n,"depositEnable",!0);(!c||!u)&&(d=!1);const h=this.safeString(n,"name"),f=this.safeNumber(n,"withdrawFee");s[a]={id:r,code:a,name:h,active:d,deposit:u,withdraw:c,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"amountPoint"))),funding:{withdraw:{active:c,fee:f},deposit:{active:u,fee:this.parseNumber("0")}},limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawMinAmount"),max:void 0},deposit:{min:this.safeNumber(n,"depositMinAmount"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const s=(await this.publicGetInfo(e)).pairs,i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeInteger(o,"hidden");let l=this.safeString(o,"fee");l=Ak.stringDiv(l,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(l),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}parseBalance(e){const t=this.safeValue(e,"return"),s=this.safeTimestamp(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeValue(n,o,{}),u=this.account();u.free=this.safeString(c,"value"),u.used=this.safeString(c,"inOrders"),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfoExt(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new Td(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new Td(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;if(s=s.join("-"),s.length>this.options.fetchTickersMaxLength){const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);throw new MF(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeMarket(d),u=c.symbol;r[u]=this.parseTicker(n[d],c)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),f=this.parseNumber(Ak.stringMul(n,c)),l="limit";let m,g;const y=this.safeNumber(e,"commission");if(y!==void 0){const b=this.safeString(e,"commissionCurrency"),S=this.safeCurrencyCode(b);g={cost:y,currency:S}}const w=this.safeValue(e,"is_your_order");return w!==void 0&&(m="taker",w&&(m="maker"),g===void 0&&(g=this.calculateFee(d,l,i,h,u,m))),{id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:l,side:i,takerOrMaker:m,price:u,amount:h,cost:f,fee:g,info:e}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));return Array.isArray(a)&&a.length===0?[]:this.parseTrades(a[n.id],n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Td(this.id+" createOrder() allows limit orders only");const a=i.toString(),o=n.toString();await this.loadMarkets();const d=this.market(e),c={pair:d.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},u=await this.privatePostTrade(this.extend(c,r));let h,f="open",l="0.0",m=a;const g=this.safeValue(u,"return");g!==void 0&&(h=this.safeString(g,"order_id"),h==="0"&&(h=this.safeString(g,"init_order_id"),f="closed"),l=this.safeString(g,"received",l),m=this.safeString(g,"remains",a));const y=this.milliseconds();return this.safeOrder({id:h,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:void 0,status:f,symbol:e,type:t,side:s,price:o,cost:void 0,amount:a,remaining:m,filled:l,fee:void 0,info:u,clientOrderId:void 0,average:void 0,trades:void 0},d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeTimestamp(e,"timestamp_created"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t);let o,d;const c=this.safeString(e,"rate");"start_amount"in e?(d=this.safeString(e,"start_amount"),o=this.safeString(e,"amount")):o=this.safeString(e,"amount");const u=void 0;return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:"limit",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:c,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:d,remaining:o,filled:void 0,status:i,fee:u,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{}),a=this.safeValue(r,e);return this.parseOrder(this.extend({id:e},a))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id);const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",[]);return this.parseTrades(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:parseFloat(t),address:s};i!==void 0&&(a.memo=i);const o=await this.privatePostCreateWithdraw(this.extend(a,n)),d=this.safeValue(o,"return",{}),c=this.safeValue(d,"withdraw_info",{});return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwExactlyMatchedException(this.exceptions.exact,h,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f),new Td(f)}}}};const EF=re,{ArgumentsRequired:Bk,ExchangeError:xu,PermissionDenied:Nk,ExchangeNotAvailable:qF,InsufficientFunds:Vk,OrderNotFound:Ek,InvalidOrder:qk,RateLimitExceeded:LF,NotSupported:RF,BadRequest:qa,AuthenticationError:_u}=Q,{TICK_SIZE:DF}=ne,Cp=ae;var FF=class extends EF{describe(){return this.deepExtend(super.describe(),{id:"timex",name:"TimeX",countries:["AU"],version:"v1",rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":"I1","5m":"I5","15m":"I15","30m":"I30","1h":"H1","2h":"H2","4h":"H4","6h":"H6","12h":"H12","1d":"D1","1w":"W1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg",api:{rest:"https://plasma-relay-backend.timex.io"},www:"https://timex.io",doc:"https://docs.timex.io",referral:"https://timex.io/?refcode=1x27vNkTbP1uwkCck"},api:{addressbook:{get:["me"],post:["","id/{id}","id/{id}/remove"]},custody:{get:["credentials","credentials/h/{hash}","credentials/k/{key}","credentials/me","credentials/me/address","deposit-addresses","deposit-addresses/h/{hash}"]},history:{get:["orders","orders/details","orders/export/csv","trades","trades/export/csv"]},currencies:{get:["a/{address}","i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},manager:{get:["deposits","transfers","withdrawals"]},markets:{get:["i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},public:{get:["candles","currencies","markets","orderbook","orderbook/raw","orderbook/v2","tickers","trades"]},statistics:{get:["address"]},trading:{get:["balances","fees","orders"],post:["orders","orders/json"],put:["orders","orders/json"],delete:["orders","orders/json"]},tradingview:{get:["config","history","symbol_info","time"]}},precisionMode:DF,exceptions:{exact:{0:xu,1:RF,4e3:qa,4001:qa,4002:Vk,4003:_u,4004:_u,4005:qa,4006:qa,4007:qa,4300:Nk,4100:_u,4400:Ek,5001:qk,5002:xu,400:qa,401:_u,403:Nk,404:Ek,429:LF,500:xu,503:qF},broad:{Insufficient:Vk}},options:{expireIn:31536e3,fetchTickers:{period:"1d"},fetchTrades:{sort:"timestamp,asc"},fetchMyTrades:{sort:"timestamp,asc"},fetchOpenOrders:{sort:"createdAt,asc"},fetchClosedOrders:{sort:"createdAt,asc"},defaultSort:"timestamp,asc",defaultSortOrders:"createdAt,asc"}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++)s.push(this.parseMarket(t[i]));return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push(this.parseCurrency(n))}return this.indexBy(s,"code")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new Bk(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetDeposits(this.extend(r,i));return this.parseTransactions(a,e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new Bk(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetWithdrawals(this.extend(r,i));return this.parseTransactions(a,e,t,s)}getCurrencyByAddress(e){const t=this.currencies;for(let s=0;s<t.length;s++){const i=t[s],n=this.safeValue(i,"info",{});if(this.safeString(n,"address")===e)return i}}parseTransaction(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"token","");return t=this.getCurrencyByAddress(i),{info:e,id:this.safeString2(e,"transferHash"),txid:this.safeString(e,"txid"),timestamp:this.parse8601(s),datetime:s,network:void 0,address:void 0,addressTo:this.safeString(e,"to"),addressFrom:this.safeString(e,"from"),tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:this.safeNumber(e,"value"),currency:this.safeCurrencyCode(void 0,t),status:"ok",updated:void 0,fee:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(this.options.fetchTickers,"period","1d"),i={period:this.timeframes[s]},n=await this.publicGetTickers(this.extend(i,t));return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeString(this.options.fetchTickers,"period","1d"),n={market:s.id,period:this.timeframes[i]},r=await this.publicGetTickers(this.extend(n,t)),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookV2(this.extend(n,s)),a=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(r,e,a,"bid","ask","price","baseTokenAmount")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"fetchTrades",{}),a=this.safeValue(r,"sort","timestamp,asc"),o=this.safeString(i,"sort",a),d=this.omit(i,"sort"),c={market:n.id,sort:o};t!==void 0&&(c.from=this.iso8601(t)),s!==void 0&&(c.size=s);const u=await this.publicGetTrades(this.extend(c,d));return this.parseTrades(u,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0&&(i=1e3),s!==void 0)a.from=this.iso8601(s),a.till=this.iso8601(this.sum(s,this.sum(i,1)*o*1e3));else{const c=this.milliseconds();a.till=this.iso8601(c),a.from=this.iso8601(c-i*o*1e3-1)}const d=await this.publicGetCandles(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"totalBalance"),a.used=this.safeString(i,"lockedBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.tradingGetBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s.toUpperCase();let d=t.toUpperCase();this.safeValue(r,"postOnly",!1)&&(d="POST_ONLY",r=this.omit(r,["postOnly"]));const u={symbol:a.id,quantity:this.amountToPrecision(e,i),side:o,orderTypes:d};let h=r;if(d==="LIMIT"||d==="POST_ONLY"){u.price=this.priceToPrecision(e,n);const g=this.safeInteger(this.options,"expireIn"),y=this.safeValue(r,"expireTime"),w=this.safeValue(r,"expireIn",g);if(y!==void 0)u.expireTime=y;else if(w!==void 0)u.expireIn=w;else throw new qk(this.id+" createOrder() method requires a expireTime or expireIn param for a "+t+" order, you can also set the expireIn exchange-wide option");h=this.omit(r,["expireTime","expireIn"])}else u.price=0;const f=await this.tradingPostOrders(this.extend(u,h)),l=this.safeValue(f,"orders",[]),m=this.safeValue(l,0,{});return this.parseOrder(m,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:e};n!==void 0&&(d.quantity=this.amountToPrecision(t,n)),r!==void 0&&(d.price=this.priceToPrecision(t,r));const c=await this.tradingPutOrders(this.extend(d,a));if("unchangedOrders"in c){const l=this.safeValue(c,"unchangedOrders",[]);return{id:this.safeString(l,0),info:c}}const u=this.safeValue(c,"changedOrders",[]),h=this.safeValue(u,0,{}),f=this.safeValue(h,"newOrder",{});return this.parseOrder(f,o)}async cancelOrder(e,t=void 0,s={}){return await this.loadMarkets(),await this.cancelOrders([e],t,s)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.tradingDeleteOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderHash:e},n=await this.historyGetOrdersDetails(i),r=this.safeValue(n,"order",{}),a=this.safeValue(n,"trades",[]);return this.parseOrder(this.extend(r,{trades:a}))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchOpenOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),s!==void 0&&(d.size=s);const u=await this.tradingGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchClosedOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a,side:"BUY"};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchMyTrades",{}),r=this.safeValue(n,"sort","timestamp,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetTrades(this.extend(d,o)),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,c,t,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeNumber(e,"fee");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={markets:s.id},n=await this.tradingGetFees(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r,s)}parseMarket(e){const t=this.safeValue(e,"locked"),s=this.safeString(e,"symbol"),i=this.safeString(e,"baseCurrency"),n=this.safeString(e,"quoteCurrency"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=this.safeString(e,"quantityIncrement"),d=this.safeString(e,"baseMinSize"),c=Cp.stringMax(o,d),u=this.safeString(e,"tickSize"),h=this.safeString(e,"quoteMinSize");return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:i,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!t,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"quantityIncrement"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(c),max:void 0},price:{min:this.parseNumber(u),max:void 0},cost:{min:h,max:void 0}},info:e}}parseCurrency(e){const t=this.safeString(e,"symbol"),s=this.safeCurrencyCode(t),i=this.safeString(e,"name"),n=this.safeValue(e,"depositEnabled"),r=this.safeValue(e,"withdrawalEnabled"),a=this.safeValue(e,"active"),o=n&&r&&a,d=this.safeString(e,"withdrawalFee"),c=this.safeInteger(e,"tradeDecimals");let u;if(d!==void 0&&c!==void 0){const f=d.length-c;if(f>0){const l=d.slice(0,f),m=d.slice(-f);u=this.parseNumber(l+"."+m)}else{let l=".";for(let m=0;m<-f;m++)l+="0";u=this.parseNumber(l+d)}}return{id:s,code:s,info:e,type:void 0,name:i,active:o,deposit:n,withdraw:r,fee:u,precision:this.parseNumber(this.parsePrecision(this.safeString(e,"decimals"))),limits:{withdraw:{min:u,max:void 0},amount:{min:void 0,max:void 0}}}}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"/"),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"volumeQuote")},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(Cp.stringMul(r,a)),u=this.safeString(e,"id"),h=this.safeStringLower2(e,"direction","side"),f=this.safeStringLower(e,"makerOrTaker");let l;f!==void 0&&(l=this.safeString(e,f+"OrderId"));let m;const g=this.safeNumber(e,"fee"),y=this.safeCurrencyCode(this.safeString(e,"feeToken"));return g!==void 0&&(m={cost:g,currency:y}),{info:e,id:u,timestamp:n,datetime:this.iso8601(n),symbol:i,order:l,type:void 0,side:h,price:o,amount:d,cost:c,takerOrMaker:f,fee:m}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeStringLower(e,"type"),n=this.safeStringLower(e,"side"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t),o=this.parse8601(this.safeString(e,"createdAt")),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"filledQuantity"),h=this.omitZero(this.safeString(e,"cancelledQuantity"));let f;Cp.stringEquals(u,c)?f="closed":h!==void 0?f="canceled":f="open";const l=this.safeValue(e,"trades",[]),m=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:s,clientOrderId:m,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:a,type:i,timeInForce:void 0,postOnly:void 0,side:n,price:d,stopPrice:void 0,triggerPrice:void 0,amount:c,cost:void 0,average:void 0,filled:u,remaining:void 0,status:f,fee:void 0,trades:l},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+e;if(Object.keys(i).length&&(a+="?"+this.urlencodeWithArrayRepeat(i)),t!=="public"){this.checkRequiredCredentials();const o=this.stringToBase64(this.apiKey+":"+this.secret);n={authorization:"Basic "+this.decode(o)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;let u=this.safeValue(a,"error");u===void 0&&(u=a);const h=this.safeString2(u,"code","status"),f=this.safeString2(u,"message","debugMessage");throw this.throwBroadlyMatchedException(this.exceptions.broad,f,c),this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwExactlyMatchedException(this.exceptions.exact,f,c),new xu(c)}}};const HF=re,{ExchangeError:je,ArgumentsRequired:Lk,ExchangeNotAvailable:Od,InsufficientFunds:It,OrderNotFound:Mp,InvalidOrder:Yt,DDoSProtection:Id,InvalidNonce:GF,AuthenticationError:qs,RateLimitExceeded:xd,PermissionDenied:An,NotSupported:UF,BadRequest:de,BadSymbol:La,AccountSuspended:Ra,OrderImmediatelyFillable:Cu,OnMaintenance:$F,BadResponse:Rk,RequestTimeout:WF,OrderNotFillable:zF,MarginModeAlreadySet:jF}=Q,{TRUNCATE:Dk,DECIMAL_PLACES:KF}=ne,XF=ae;var YF=class extends HF{describe(){return this.deepExtend(super.describe(),{id:"tokocrypto",name:"Tokocrypto",countries:["ID"],certified:!1,pro:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:void 0,borrowMargin:void 0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:void 0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/183870484-d3398d0c-f6a1-4cce-91b8-d58792308716.jpg",api:{rest:{public:"https://www.tokocrypto.com",binance:"https://api.binance.com/api/v3",private:"https://www.tokocrypto.com"}},www:"https://tokocrypto.com",doc:"https://www.tokocrypto.com/apidocs/",fees:"https://www.tokocrypto.com/fees/newschedule"},api:{binance:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},public:{get:{"open/v1/common/time":1,"open/v1/common/symbols":1,"open/v1/market/depth":1,"open/v1/market/trades":1,"open/v1/market/agg-trades":1,"open/v1/market/klines":1}},private:{get:{"open/v1/orders/detail":1,"open/v1/orders":1,"open/v1/account/spot":1,"open/v1/account/spot/asset":1,"open/v1/orders/trades":1,"open/v1/withdraws":1,"open/v1/deposits":1,"open/v1/deposits/address":1},post:{"open/v1/orders":1,"open/v1/orders/cancel":1,"open/v1/orders/oco":1,"open/v1/withdraws":1,"open/v1/user-data-stream":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0075"),maker:this.parseNumber("0.0075")}},precisionMode:KF,options:{defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!1,networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":$F,"System abnormality":je,"You are not authorized to execute this request.":An,"API key does not exist":qs,"Order would trigger immediately.":Cu,"Stop price would trigger immediately.":Cu,"Order would immediately match and take.":Cu,"Account has insufficient balance for requested action.":It,"Rest API trading is not enabled.":Od,"You don't have permission.":An,"Market is closed.":Od,"Too many requests. Please try again later.":Id,"This action disabled is on this account.":Ra,"-1000":Od,"-1001":Od,"-1002":qs,"-1003":xd,"-1004":Id,"-1005":An,"-1006":Rk,"-1007":WF,"-1010":Rk,"-1011":An,"-1013":Yt,"-1014":Yt,"-1015":xd,"-1016":Od,"-1020":de,"-1021":GF,"-1022":qs,"-1023":de,"-1099":qs,"-1100":de,"-1101":de,"-1102":de,"-1103":de,"-1104":de,"-1105":de,"-1106":de,"-1108":de,"-1109":qs,"-1110":de,"-1111":de,"-1112":Yt,"-1113":de,"-1114":de,"-1115":de,"-1116":de,"-1117":de,"-1118":de,"-1119":de,"-1120":de,"-1121":La,"-1125":qs,"-1127":de,"-1128":de,"-1130":de,"-1131":de,"-1136":de,"-2008":qs,"-2010":je,"-2011":Mp,"-2013":Mp,"-2014":qs,"-2015":qs,"-2016":de,"-2018":It,"-2019":It,"-2020":zF,"-2021":Cu,"-2022":Yt,"-2023":It,"-2024":It,"-2025":Yt,"-2026":Yt,"-2027":Yt,"-2028":It,"-3000":je,"-3001":qs,"-3002":La,"-3003":de,"-3004":je,"-3005":It,"-3006":It,"-3007":je,"-3008":It,"-3009":de,"-3010":je,"-3011":de,"-3012":je,"-3013":de,"-3014":Ra,"-3015":je,"-3016":de,"-3017":je,"-3018":Ra,"-3019":Ra,"-3020":It,"-3021":de,"-3022":Ra,"-3023":de,"-3024":je,"-3025":de,"-3026":de,"-3027":La,"-3028":La,"-3029":je,"-3036":Ra,"-3037":je,"-3038":de,"-3041":It,"-3042":de,"-3043":de,"-3044":Id,"-3045":je,"-3999":je,"-4001":de,"-4002":de,"-4003":de,"-4004":qs,"-4005":xd,"-4006":de,"-4007":de,"-4008":de,"-4010":de,"-4011":de,"-4012":de,"-4013":qs,"-4014":An,"-4015":je,"-4016":An,"-4017":An,"-4018":La,"-4019":La,"-4021":de,"-4022":de,"-4023":je,"-4024":It,"-4025":It,"-4026":It,"-4027":je,"-4028":de,"-4029":de,"-4030":je,"-4031":je,"-4032":je,"-4033":de,"-4034":je,"-4035":An,"-4036":de,"-4037":je,"-4038":je,"-4039":de,"-4040":de,"-4041":je,"-4042":je,"-4043":de,"-4044":de,"-4045":je,"-4046":qs,"-4047":de,"-5001":de,"-5002":It,"-5003":It,"-5004":de,"-5005":It,"-5006":de,"-5007":de,"-5008":It,"-5009":de,"-5010":je,"-5011":de,"-5012":je,"-5013":It,"-5021":de,"-6001":de,"-6003":de,"-6004":je,"-6005":Yt,"-6006":de,"-6007":de,"-6008":de,"-6009":xd,"-6011":de,"-6012":It,"-6013":je,"-6014":de,"-6015":de,"-6016":de,"-6017":de,"-6018":de,"-6019":qs,"-6020":de,"-7001":de,"-7002":de,"-9000":It,"-10017":de,"-11008":It,"-12014":xd,"-13000":de,"-13001":de,"-13002":de,"-13003":de,"-13004":de,"-13005":de,"-13006":Yt,"-13007":qs,"-21001":de,"-21002":de,"-21003":de,100001003:de,2202:It,3210:Yt,3203:Yt,3211:Yt,3207:Yt,3218:Mp},broad:{"has no operation privilege":An,MAX_POSITION:Yt}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.publicGetOpenV1CommonSymbols(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"list",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"baseAsset"),d=this.safeString(a,"quoteAsset"),c=this.safeString(a,"symbol"),u=this.safeStringLower(a,"symbol"),h=this.safeString(a,"marginAsset"),f=this.safeCurrencyCode(o),l=this.safeCurrencyCode(d),m=this.safeCurrencyCode(h),g=f+"/"+l,y=this.safeValue(a,"filters",[]),w=this.indexBy(y,"filterType");let S=this.safeString2(a,"status","contractStatus")==="TRADING";const v=this.safeValue(a,"permissions",[]);for(let A=0;A<v.length;A++)if(v[A]==="TRD_GRP_003"){S=!1;break}const T=this.safeValue(a,"isMarginTradingAllowed",!1),I={id:c,lowercaseId:u,symbol:g,base:f,quote:l,settle:m,baseId:o,quoteId:d,settleId:h,type:"spot",spot:!0,margin:T,swap:!1,future:!1,delivery:!1,option:!1,active:S,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(a,"quantityPrecision"),price:this.safeInteger(a,"pricePrecision"),base:this.safeInteger(a,"baseAssetPrecision"),quote:this.safeInteger(a,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a};if("PRICE_FILTER"in w){const A=this.safeValue(w,"PRICE_FILTER",{}),N=this.safeString(A,"tickSize");I.precision.price=this.precisionFromString(N),I.limits.price={min:this.safeNumber(A,"minPrice"),max:this.safeNumber(A,"maxPrice")},I.precision.price=this.precisionFromString(A.tickSize)}if("LOT_SIZE"in w){const A=this.safeValue(w,"LOT_SIZE",{}),N=this.safeString(A,"stepSize");I.precision.amount=this.precisionFromString(N),I.limits.amount={min:this.safeNumber(A,"minQty"),max:this.safeNumber(A,"maxQty")}}if("MARKET_LOT_SIZE"in w){const A=this.safeValue(w,"MARKET_LOT_SIZE",{});I.limits.market={min:this.safeNumber(A,"minQty"),max:this.safeNumber(A,"maxQty")}}if("MIN_NOTIONAL"in w){const A=this.safeValue(w,"MIN_NOTIONAL",{});I.limits.cost.min=this.safeNumber2(A,"minNotional","notional")}n.push(I)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.baseId+i.quoteId};t!==void 0&&(n.limit=t);const r=await this.binanceGetDepth(this.extend(n,s)),a=this.safeInteger(r,"T"),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"lastUpdateId"),o}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString2(e,"t","a");d=this.safeString2(e,"id","tradeId",d);let c;const u=this.safeString(e,"orderId"),h=this.safeValue2(e,"m","isBuyerMaker");let f;h!==void 0?(c=h?"sell":"buy",f="taker"):"side"in e?c=this.safeStringLower(e,"side"):"isBuyer"in e&&(c=e.isBuyer?"buy":"sell");let l;return"commission"in e&&(l={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(f=e.isMaker?"maker":"taker"),"maker"in e&&(f=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:u,type:void 0,side:c,takerOrMaker:f,price:i,amount:n,cost:r,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.baseId+n.quoteId},a="binanceGetTrades",o=this.safeString(this.options,"fetchTradesMethod",a);o==="binanceGetAggTrades"&&t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const d=await this[o](this.extend(r,i));return this.parseTrades(d,n,t,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"lastPrice"),a="baseVolume"in e;let o,d;return a?(o=this.safeString(e,"baseVolume"),d=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),d=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s="binanceGetTicker24hr",i=this.safeString(this.options,"fetchTickersMethod",s),n=await this[i](t);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.baseId+s.quoteId},n=await this.binanceGetTicker24hr(this.extend(i,t));if(Array.isArray(n)){const r=this.safeValue(n,0,{});return this.parseTicker(r,s)}return this.parseTicker(n,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.binanceGetTickerBookTicker(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};d==="index"?u.pair=r.id:u.symbol=r.baseId+r.quoteId,s!==void 0&&(u.startTime=s),c!==void 0&&(u.endTime=c);const h=await this.binanceGetKlines(this.extend(u,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeString2(this.options,"marginMode","defaultMarginMode"),n=this.safeStringLower(e,"marginMode",i),r={},a=await this.privateGetOpenV1AccountSpot(this.extend(r,e));return this.parseBalance(a,s,n)}parseBalance(e,t=void 0,s=void 0){const i=this.safeInteger(e,"updateTime"),n={info:e,timestamp:i,datetime:this.iso8601(i)},r=this.safeValue(e,"data",{}),a=this.safeValue(r,"accountAssets",[]);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),n[u]=h}return this.safeBalance(n)}parseOrderStatus(e){const t={"-2":"open",0:"open",1:"open",2:"closed",3:"canceled",4:"canceling",5:"rejected",6:"expired",NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty","0"),a=this.safeInteger(e,"createTime"),o=this.safeString(e,"avgPrice"),d=this.safeString(e,"price"),c=this.safeString(e,"origQty");let u=this.safeString2(e,"cummulativeQuoteQty","cumQuote");u=this.safeString(e,"cumBase",u);const h=this.safeString(e,"orderId");let f=this.safeStringLower(e,"type"),l=this.safeStringLower(e,"side");l==="0"?l="buy":l==="1"&&(l="sell");const m=this.safeValue(e,"fills",[]),g=this.safeString(e,"clientOrderId");let y=this.safeString(e,"timeInForce");y==="GTX"&&(y="PO");const w=f==="limit_maker"||y==="PO";f==="limit_maker"&&(f="limit");const b=this.safeString(e,"stopPrice"),S=this.parseNumber(this.omitZero(b));return this.safeOrder({info:e,id:h,clientOrderId:g,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:n,type:f,timeInForce:y,postOnly:w,reduceOnly:this.safeValue(e,"reduceOnly"),side:l,price:d,stopPrice:S,triggerPrice:S,amount:c,cost:u,average:o,filled:r,remaining:void 0,status:s,fee:void 0,trades:m},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOrderId","clientId");this.safeValue(r,"postOnly",!1)&&(t="LIMIT_MAKER"),r=this.omit(r,["clientId","clientOrderId"]);const c=t.toUpperCase();let u=c;const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),u==="MARKET"?u="STOP_LOSS":u==="LIMIT"&&(u="STOP_LOSS_LIMIT"));const f=this.safeValue(a.info,"orderTypes");if(!this.inArray(u,f))throw c!==u?new Yt(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new Yt(this.id+" "+t+" is not a valid order type for the "+e+" market");const l={LIMIT:1,MARKET:2,STOP_LOSS:3,STOP_LOSS_LIMIT:4,TAKE_PROFIT:5,TAKE_PROFIT_LIMIT:6,LIMIT_MAKER:7},m={symbol:a.baseId+"_"+a.quoteId,type:this.safeString(l,u)};if(s==="buy"?m.side=0:s==="sell"&&(m.side=1),o===void 0){const v=this.safeValue(this.options,"broker");if(v!==void 0){const T=this.safeString(v,"marketType");T!==void 0&&(m.clientId=T+this.uuid22())}}else m.clientId=o;let g=!1,y=!1,w=!1;if(u==="MARKET")if(this.safeValue(this.options,"quoteOrderQty",!0)){const T=this.safeValue2(r,"quoteOrderQty","cost"),I=a.precision.price;T!==void 0?(m.quoteOrderQty=this.decimalToPrecision(T,Dk,I,this.precisionMode),r=this.omit(r,["quoteOrderQty","cost"])):n!==void 0?m.quoteOrderQty=this.decimalToPrecision(i*n,Dk,I,this.precisionMode):w=!0}else w=!0;else u==="LIMIT"?(g=!0,w=!0):u==="STOP_LOSS"||u==="TAKE_PROFIT"?(y=!0,w=!0,(a.linear||a.inverse)&&(g=!0)):u==="STOP_LOSS_LIMIT"||u==="TAKE_PROFIT_LIMIT"?(w=!0,y=!0,g=!0):u==="LIMIT_MAKER"&&(g=!0,w=!0);if(w&&(m.quantity=this.amountToPrecision(e,i)),g){if(n===void 0)throw new Yt(this.id+" createOrder() requires a price argument for a "+t+" order");m.price=this.priceToPrecision(e,n)}if(y){if(h===void 0)throw new Yt(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");m.stopPrice=this.priceToPrecision(e,h)}const b=await this.privatePostOpenV1Orders(this.extend(m,r)),S=this.safeValue(b,"data",{});return this.parseOrder(S,a)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateGetOpenV1Orders(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"list",[]),o=this.safeValue(a,0,{});return this.parseOrder(o)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lk(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOpenV1Orders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:2};return await this.fetchOrders(e,t,s,this.extend(n,i))}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privatePostOpenV1OrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lk(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeInteger2(i,"until","endTime");if(t!==void 0){const u=parseInt(t);r.startTime=u}a!==void 0&&(r.endTime=a,i=this.omit(i,["endTime","until"])),s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1OrdersTrades(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.privateGetOpenV1DepositsAddress(this.extend(i,t)),o=this.safeValue(a,"data",{}),d=this.safeString(o,"address");let c=this.safeString(o,"addressTag","");return c.length===0&&(c=void 0),this.checkAddress(d),{currency:e,address:d,tag:c,network:this.safeString(o,"network"),info:a}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={},a=this.safeInteger(i,"until");if(e!==void 0&&(n=this.currency(e),r.coin=n.id),t!==void 0){r.startTime=t;let u=this.sum(t,7776e6);a!==void 0&&(u=Math.min(u,a)),r.endTime=u}s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1Deposits(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6)),s!==void 0&&(n.limit=s);const a=await this.privateGetOpenV1Withdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",10:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"address");let i=this.safeString(e,"addressTag");i!==void 0&&i.length<1&&(i=void 0);let n=this.safeString(e,"txId");n!==void 0&&n.indexOf("Internal transfer ")>=0&&(n=n.slice(18));const r=this.safeString2(e,"coin","fiatCurrency"),a=this.safeCurrencyCode(r,t);let o;const d=this.safeInteger(e,"insertTime"),c=this.safeInteger(e,"createTime");let u=this.safeString(e,"type");u===void 0&&(d!==void 0&&c===void 0?(u="deposit",o=d):d===void 0&&c!==void 0&&(u="withdrawal",o=c));const h=this.safeNumber2(e,"transactionFee","totalFee"),f={currency:void 0,cost:void 0,rate:void 0};h!==void 0&&(f.currency=a,f.cost=h);let l=this.safeInteger(e,"transferType");return l!==void 0&&(l=!!l),{info:e,id:this.safeString(e,"id"),txid:n,type:u,currency:a,network:this.safeString(e,"network"),amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatusByType(this.safeString(e,"status"),u),timestamp:o,datetime:this.iso8601(o),address:s,addressFrom:void 0,addressTo:s,tag:i,tagFrom:void 0,tagTo:i,updated:this.safeInteger2(e,"successTime","updateTime"),comment:void 0,internal:l,fee:f}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api.rest))throw new UF(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api.rest[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new qs(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="sapi"&&e!=="system/status"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);const f=this.hmac(this.encode(d),this.encode(this.secret));d+="&signature="+f,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new Id(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Yt(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Yt(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Yt(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const f=this.safeString(a,"msg");let l;if(f!==void 0){try{l=JSON.parse(f)}catch{l=void 0}l!==void 0&&(a=l)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||XF.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new Id(this.id+" "+r);const f=this.id+" "+r;throw u==="No need to change margin type."?new jF(f):(this.throwExactlyMatchedException(this.exceptions.exact,h,f),new je(f))}if(!c)throw new je(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeInteger(n,"cost",1)}};const ZF=re,{ExchangeError:_d,BadRequest:QF,AuthenticationError:Pp,InvalidOrder:Cd,InsufficientFunds:JF,OrderNotFound:e8,PermissionDenied:Fk,AddressPending:t8}=Q,{TICK_SIZE:s8}=ne,Hk=ae;var DT=class extends ZF{describe(){return this.deepExtend(super.describe(),{id:"upbit",name:"Upbit",countries:["KR"],version:"v1",rateLimit:1e3,pro:!0,has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"minutes","3m":"minutes","5m":"minutes","15m":"minutes","30m":"minutes","1h":"minutes","4h":"minutes","1d":"days","1w":"weeks","1M":"months"},hostname:"api.upbit.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",api:{public:"https://{hostname}",private:"https://{hostname}"},www:"https://upbit.com",doc:"https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",fees:"https://upbit.com/service_center/guide"},api:{public:{get:["market/all","candles/{timeframe}","candles/{timeframe}/{unit}","candles/minutes/{unit}","candles/minutes/1","candles/minutes/3","candles/minutes/5","candles/minutes/15","candles/minutes/30","candles/minutes/60","candles/minutes/240","candles/days","candles/weeks","candles/months","trades/ticks","ticker","orderbook"]},private:{get:["accounts","orders/chance","order","orders","withdraws","withdraw","withdraws/chance","deposits","deposit","deposits/coin_addresses","deposits/coin_address"],post:["orders","withdraws/coin","withdraws/krw","deposits/generate_coin_address"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:s8,exceptions:{exact:{"This key has expired.":Pp,"Missing request parameter error. Check the required parameters!":QF,"side is missing, side does not have a valid value":Cd},broad:{thirdparty_agreement_required:Fk,out_of_scope:Fk,order_not_found:e8,insufficient_funds:JF,invalid_access_key:Pp,jwt_verification:Pp,create_ask_error:_d,create_bid_error:_d,volume_too_large:Cd,invalid_funds:Cd}},options:{createMarketBuyOrderRequiresPrice:!0,fetchTickersMaxLength:4096,fetchOrderBooksMaxLength:4096,tradingFeesByQuoteCurrency:{KRW:5e-4}},commonCurrencies:{TON:"Tokamak Network"}})}async fetchCurrency(e,t={}){await this.loadMarkets();const s=this.currency(e);return await this.fetchCurrencyById(s.id,t)}async fetchCurrencyById(e,t={}){const s={currency:e},i=await this.privateGetWithdrawsChance(this.extend(s,t)),n=this.safeValue(i,"member_level",{}),r=this.safeValue(i,"currency",{}),a=this.safeValue(i,"withdraw_limit",{}),o=this.safeValue(a,"can_withdraw"),d=this.safeString(r,"wallet_state"),c=this.safeValue(n,"wallet_locked"),u=this.safeValue(n,"locked");let h=!0;(o!==void 0&&!o||d!=="working"||c!==void 0&&c||u!==void 0&&u)&&(h=!1);const f=this.safeNumber(a,"onetime"),l=this.safeNumber(a,"daily",f),m=this.safeNumber(a,"remaining_daily",l);let g;m>0?g=m:g=l;const y=this.safeString(r,"code"),w=this.safeCurrencyCode(y);return{info:i,id:y,code:w,name:w,active:h,fee:this.safeNumber(r,"withdraw_fee"),precision:void 0,limits:{withdraw:{min:this.safeNumber(a,"minimum"),max:g}}}}async fetchMarket(e,t={}){await this.loadMarkets();const s=this.market(e);return await this.fetchMarketById(s.id,t)}async fetchMarketById(e,t={}){const s={market:e},i=await this.privateGetOrdersChance(this.extend(s,t)),n=this.safeValue(i,"market"),r=this.safeValue(n,"bid"),a=this.safeValue(n,"ask"),o=this.safeString(n,"id"),d=this.safeString(a,"currency"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),f=this.safeString(n,"state"),l=this.safeNumber(i,"bid_fee"),m=this.safeNumber(i,"ask_fee"),g=Math.max(l,m);return{id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f==="active",contract:!1,linear:void 0,inverse:void 0,taker:g,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_total"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_total"),max:this.safeNumber(n,"max_total")},info:i}}}async fetchMarkets(e={}){const t=await this.publicGetMarketAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"market"),[a,o]=r.split("-"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(a);s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:o,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.taker),maker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.maker),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber("1e-8"),amount:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"balance"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>this.options.fetchOrderBooksMaxLength){const o=this.ids.length;throw new _d(this.id+" fetchOrderBooks() has "+o.toString()+" symbols ("+i.length.toString()+" characters) exceeding max URL length ("+this.options.fetchOrderBooksMaxLength.toString()+" characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={markets:i},r=await this.publicGetOrderbook(this.extend(n,s)),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeSymbol(c,void 0,"-"),h=this.safeInteger(d,"timestamp");a[u]={symbol:u,bids:this.sortBy(this.parseBidsAsks(d.orderbook_units,"bid_price","bid_size"),0,!0),asks:this.sortBy(this.parseBidsAsks(d.orderbook_units,"ask_price","ask_size"),0),timestamp:h,datetime:this.iso8601(h),nonce:void 0}}return a}async fetchOrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBooks([e],t,s);return this.safeValue(i,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"trade_timestamp"),i=this.safeString2(e,"market","code");t=this.safeMarket(i,t,"-");const n=this.safeString(e,"trade_price");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_price"),low:this.safeString(e,"low_price"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"opening_price"),close:n,last:n,previousClose:this.safeString(e,"prev_closing_price"),change:this.safeString(e,"signed_change_price"),percentage:this.safeString(e,"signed_change_rate"),average:void 0,baseVolume:this.safeString(e,"acc_trade_volume_24h"),quoteVolume:this.safeString(e,"acc_trade_price_24h"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e===void 0){if(s=this.ids.join(","),s.length>this.options.fetchTickersMaxLength){const a=this.ids.length;throw new _d(this.id+" fetchTickers() has "+a.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join(",");const i={markets:s},n=await this.publicGetTicker(this.extend(i,t)),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeString2(e,"sequential_id","uuid"),i=void 0;let n=this.safeInteger(e,"timestamp");n===void 0&&(n=this.parse8601(this.safeString(e,"created_at")));let r;const a=this.safeStringLower2(e,"ask_bid","side");a==="ask"?r="sell":a==="bid"&&(r="buy");const o=this.safeString(e,"funds"),d=this.safeString2(e,"trade_price","price"),c=this.safeString2(e,"trade_volume","volume"),u=this.safeString2(e,"market","code");t=this.safeMarket(u,t,"-");let h;const f=this.safeString(e,a+"_fee");return f!==void 0&&(h={currency:t.quote,cost:f}),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:void 0,side:r,takerOrMaker:void 0,price:d,amount:c,cost:o,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);s===void 0&&(s=200);const r={market:n.id,count:s},a=await this.publicGetTradesTicks(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.privateGetOrdersChance(this.extend(i,t)),r=this.safeString(n,"ask_fee"),a=this.safeString(n,"bid_fee"),o=Hk.stringMax(r,a),d=this.safeString(n,"maker_ask_fee"),c=this.safeString(n,"maker_bid_fee"),u=Hk.stringMax(d,c);return{info:n,symbol:e,maker:this.parseNumber(u),taker:this.parseNumber(o),percentage:!0,tierBased:!1}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"candle_date_time_utc")),this.safeNumber(e,"opening_price"),this.safeNumber(e,"high_price"),this.safeNumber(e,"low_price"),this.safeNumber(e,"trade_price"),this.safeNumber(e,"candle_acc_trade_volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=this.timeframes[t];i===void 0&&(i=200);const d={market:r.id,timeframe:o,count:i};let c="publicGetCandlesTimeframe";if(o==="minutes"){const h=Math.round(a/60);d.unit=h,c+="Unit"}s!==void 0&&(d.to=this.iso8601(this.sum(s,a*i*1e3)));const u=await this[c](this.extend(d,n));return this.parseOHLCVs(u,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Cd(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}let a;if(s==="buy")a="bid";else if(s==="sell")a="ask";else throw new Cd(this.id+" createOrder() allows buy or sell side only!");await this.loadMarkets();const d={market:this.market(e).id,side:a};t==="limit"?(d.volume=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),d.ord_type=t):t==="market"&&(s==="buy"?(d.ord_type="price",d.price=this.priceToPrecision(e,i)):s==="sell"&&(d.ord_type=t,d.volume=this.amountToPrecision(e,i)));const c=this.safeString2(r,"clientOrderId","identifier");c!==void 0&&(d.identifier=c),r=this.omit(r,["clientOrderId","identifier"]);const u=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdraws(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransactionStatus(e){const t={submitting:"pending",submitted:"pending",almost_accepted:"pending",rejected:"failed",accepted:"pending",processing:"pending",done:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"uuid"),i=this.safeNumber(e,"amount"),n=void 0,r=void 0,a=this.safeString(e,"txid"),o=this.safeString(e,"done_at"),d=this.parse8601(o),c=this.parse8601(this.safeString(e,"created_at",o));let u=this.safeString(e,"type");u==="withdraw"&&(u="withdrawal");const h=this.safeString(e,"currency"),f=this.safeCurrencyCode(h),l=this.parseTransactionStatus(this.safeStringLower(e,"state")),m=this.safeNumber(e,"fee");return{info:e,id:s,currency:f,amount:i,network:void 0,address:n,addressTo:void 0,addressFrom:void 0,tag:r,tagTo:void 0,tagFrom:void 0,status:l,type:u,updated:d,txid:a,timestamp:c,datetime:this.iso8601(c),fee:{currency:f,cost:m}}}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"uuid");let i=this.safeString(e,"side");i==="bid"?i="buy":i="sell";let n=this.safeString(e,"ord_type");const r=this.parse8601(this.safeString(e,"created_at")),a=this.parseOrderStatus(this.safeString(e,"state"));let o,d=this.safeNumber(e,"price");const c=this.safeNumber(e,"volume"),u=this.safeNumber(e,"remaining_volume"),h=this.safeNumber(e,"executed_volume");let f;n==="price"&&(n="market",f=d,d=void 0);let l,m,g=this.safeNumber(e,"paid_fee");const y=this.safeString(e,"market");t=this.safeMarket(y,t);let w=this.safeValue(e,"trades",[]);w=this.parseTrades(w,t,void 0,void 0,{order:s,type:n});const b=w.length;if(b>0){o=w[b-1].timestamp;let v=!1;g===void 0&&(v=!0,g=0),f=0;for(let T=0;T<b;T++){const I=w[T];if(f=this.sum(f,I.cost),v){const A=this.safeValue(w[T],"fee",{}),N=this.safeNumber(A,"cost");N!==void 0&&(g=this.sum(g,N))}}l=f/h}return g!==void 0&&(m={currency:t.quote,cost:g}),{info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:o,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:d,stopPrice:void 0,triggerPrice:void 0,cost:f,average:l,amount:c,filled:h,remaining:u,status:a,fee:m,trades:w}}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={state:e};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("wait",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("done",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("cancel",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetDepositsCoinAddresses(t);return this.parseDepositAddresses(s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"deposit_address"),i=this.safeString(e,"secondary_address"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=await this.privateGetDepositsCoinAddress(this.extend({currency:s.id},t));return this.parseDepositAddress(i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostDepositsGenerateCoinAddress(this.extend(i,t));if(this.safeString(n,"message")!==void 0)throw new t8(this.id+" is generating "+e+" deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address");return this.parseDepositAddress(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={amount:t};let o="privatePostWithdraws";e!=="KRW"?(o+="Coin",a.currency=r.id,a.address=s,i!==void 0&&(a.secondary_address=i)):o+="Krw";const d=await this[o](this.extend(a,n));return this.parseTransaction(d)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname});a+="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s!=="POST"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce(),c={access_key:this.apiKey,nonce:d};if(Object.keys(o).length){const h=this.urlencode(o),f=this.hash(this.encode(h),"sha512");c.query_hash=f,c.query_hash_alg="SHA512"}const u=this.jwt(c,this.encode(this.secret));n={Authorization:"Bearer "+u},s!=="GET"&&s!=="DELETE"&&(r=this.json(i),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"message"),h=this.safeString(c,"name"),f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwExactlyMatchedException(this.exceptions.exact,h,f),this.throwBroadlyMatchedException(this.exceptions.broad,u,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f),new _d(f)}}};const i8=re,{ArgumentsRequired:n8,AuthenticationError:ni,InsufficientFunds:Mu,InvalidOrder:nr,AccountSuspended:r8,ExchangeError:Md,DuplicateOrderId:a8,OrderNotFound:o8,BadSymbol:d8,ExchangeNotAvailable:Gk,BadRequest:Pu}=Q,Au=ae;var c8=class extends i8{describe(){return this.deepExtend(super.describe(),{id:"wavesexchange",name:"Waves.Exchange",countries:["CH"],certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/84547058-5fb27d80-ad0b-11ea-8711-78ac8b3c7f31.jpg",test:{matcher:"https://matcher-testnet.waves.exchange",node:"https://nodes-testnet.wavesnodes.com",public:"https://api-testnet.wavesplatform.com/v0",private:"https://api-testnet.waves.exchange/v1",forward:"https://testnet.waves.exchange/api/v1/forward/matcher",market:"https://testnet.waves.exchange/api/v1/forward/marketdata/api/v1"},api:{matcher:"https://matcher.waves.exchange",node:"https://nodes.waves.exchange",public:"https://api.wavesplatform.com/v0",private:"https://api.waves.exchange/v1",forward:"https://waves.exchange/api/v1/forward/matcher",market:"https://waves.exchange/api/v1/forward/marketdata/api/v1"},doc:"https://docs.waves.exchange",www:"https://waves.exchange"},api:{matcher:{get:["matcher","matcher/settings","matcher/settings/rates","matcher/balance/reserved/{publicKey}","matcher/debug/allSnashotOffsets","matcher/debug/currentOffset","matcher/debug/lastOffset","matcher/debug/oldestSnapshotOffset","matcher/orderbook","matcher/orderbook/{amountAsset}/{priceAsset}","matcher/orderbook/{baseId}/{quoteId}/publicKey/{publicKey}","matcher/orderbook/{baseId}/{quoteId}/{orderId}","matcher/orderbook/{baseId}/{quoteId}/info","matcher/orderbook/{baseId}/{quoteId}/status","matcher/orderbook/{baseId}/{quoteId}/tradeableBalance/{address}","matcher/orderbook/{publicKey}","matcher/orderbook/{publicKey}/{orderId}","matcher/orders/{address}","matcher/orders/{address}/{orderId}","matcher/transactions/{orderId}"],post:["matcher/orderbook","matcher/orderbook/market","matcher/orderbook/cancel","matcher/orderbook/{baseId}/{quoteId}/cancel","matcher/orderbook/{amountAsset}/{priceAsset}/calculateFee","matcher/debug/saveSnapshots","matcher/orders/{address}/cancel","matcher/orders/cancel/{orderId}"],delete:["matcher/orderbook/{baseId}/{quoteId}","matcher/settings/rates/{assetId}"],put:["matcher/settings/rates/{assetId}"]},node:{get:["addresses","addresses/balance/{address}","addresses/balance/{address}/{confirmations}","addresses/balance/details/{address}","addresses/data/{address}","addresses/data/{address}/{key}","addresses/effectiveBalance/{address}","addresses/effectiveBalance/{address}/{confirmations}","addresses/publicKey/{publicKey}","addresses/scriptInfo/{address}","addresses/scriptInfo/{address}/meta","addresses/seed/{address}","addresses/seq/{from}/{to}","addresses/validate/{address}","alias/by-address/{address}","alias/by-alias/{alias}","assets/{assetId}/distribution/{height}/{limit}","assets/balance/{address}","assets/balance/{address}/{assetId}","assets/details/{assetId}","assets/nft/{address}/limit/{limit}","blockchain/rewards","blockchain/rewards/height","blocks/address/{address}/{from}/{to}/","blocks/at/{height}","blocks/delay/{signature}/{blockNum}","blocks/first","blocks/headers/last","blocks/headers/seq/{from}/{to}","blocks/height","blocks/height/{signature}","blocks/last","blocks/seq/{from}/{to}","blocks/signature/{signature}","consensus/algo","consensus/basetarget","consensus/basetarget/{blockId}","consensus/{generatingbalance}/address","consensus/generationsignature","consensus/generationsignature/{blockId}","debug/balances/history/{address}","debug/blocks/{howMany}","debug/configInfo","debug/historyInfo","debug/info","debug/minerInfo","debug/portfolios/{address}","debug/state","debug/stateChanges/address/{address}","debug/stateChanges/info/{id}","debug/stateWaves/{height}","leasing/active/{address}","node/state","node/version","peers/all","peers/blacklisted","peers/connected","peers/suspended","transactions/address/{address}/limit/{limit}","transactions/info/{id}","transactions/status","transactions/unconfirmed","transactions/unconfirmed/info/{id}","transactions/unconfirmed/size","utils/seed","utils/seed/{length}","utils/time","wallet/seed"],post:["addresses","addresses/data/{address}","addresses/sign/{address}","addresses/signText/{address}","addresses/verify/{address}","addresses/verifyText/{address}","debug/blacklist","debug/print","debug/rollback","debug/validate","node/stop","peers/clearblacklist","peers/connect","transactions/broadcast","transactions/calculateFee","tranasctions/sign","transactions/sign/{signerAddress}","tranasctions/status","utils/hash/fast","utils/hash/secure","utils/script/compileCode","utils/script/compileWithImports","utils/script/decompile","utils/script/estimate","utils/sign/{privateKey}","utils/transactionsSerialize"],delete:["addresses/{address}","debug/rollback-to/{signature}"]},public:{get:["assets","pairs","candles/{baseId}/{quoteId}","transactions/exchange"]},private:{get:["deposit/addresses/{currency}","deposit/addresses/{currency}/{platform}","platforms","deposit/currencies","withdraw/currencies","withdraw/addresses/{currency}/{address}"],post:["oauth2/token"]},forward:{get:["matcher/orders/{address}","matcher/orders/{address}/{orderId}"],post:["matcher/orders/{wavesAddress}/cancel"]},market:{get:["tickers"]}},currencies:{WX:{id:"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",numericId:void 0,code:"WX",precision:8}},options:{allowedCandles:1440,accessToken:void 0,createMarketBuyOrderRequiresPrice:!0,matcherPublicKey:void 0,quotes:void 0,createOrderDefaultExpiry:24192e5,wavesAddress:void 0,withdrawFeeUSDN:7420,withdrawFeeWAVES:1e5,wavesPrecision:8,messagePrefix:"W",networks:{ERC20:"ETH",BEP20:"BSC"},reverseNetworks:{ETH:"ERC20",BSC:"BEP20"}},commonCurrencies:{EGG:"Waves Ducks"},requiresEddsa:!0,exceptions:{3147270:Mu,112:Mu,4:Md,13:Gk,14:Gk,3145733:r8,3148040:a8,3148801:ni,9440512:ni,9440771:d8,9441026:nr,9441282:nr,9441286:nr,9441295:nr,9441540:nr,9441542:nr,106954752:ni,106954769:ni,106957828:ni,106960131:ni,106981137:ni,9437184:Pu,9437193:o8,1048577:Pu,1051904:ni}})}setSandboxMode(e){return this.options.messagePrefix=e?"T":"W",super.setSandboxMode(e)}async getFeesForAsset(e,t,s,i,n={}){await this.loadMarkets();const r=this.market(e);s=this.amountToPrecision(e,s),i=this.priceToPrecision(e,i);const a=this.extend({amountAsset:r.baseId,priceAsset:r.quoteId,orderType:t,amount:s,price:i},n);return await this.matcherPostMatcherOrderbookAmountAssetPriceAssetCalculateFee(a)}async calculateFee(e,t,s,i,n,r="taker",a={}){const o=await this.getFeesForAsset(e,s,i,n),d=this.safeValue(a,"isDiscountFee",!1);let c;d?c=this.safeValue(o,"discount"):c=this.safeValue(o,"base");const u=this.safeString(c,"matcherFee"),h=this.safeString(c,"feeAssetId"),f=this.safeCurrencyCode(h),l=this.currencyFromPrecision(f,u),m=this.numberToString(i),g=this.numberToString(n),y=this.feeToPrecision(e,this.parseNumber(l)),w=Au.stringDiv(l,Au.stringMul(m,g));return{type:r,currency:f,rate:this.parseNumber(w),cost:this.parseNumber(y)}}async getQuotes(){let e=this.safeValue(this.options,"quotes");if(e)return e;{const t=await this.matcherGetMatcherSettings();e={};const s=this.safeValue(t,"priceAssets");for(let i=0;i<s.length;i++)e[s[i]]=!0;return this.options.quotes=e,e}}async fetchMarkets(e={}){const t=await this.marketGetTickers(),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"amountAssetID"),a=this.safeString(n,"priceAssetID"),o=r+"/"+a,d=this.safeString(n,"symbol");let[c,u]=d.split("/");c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=c+"/"+u;s.push({id:o,symbol:h,base:c,quote:u,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(n,"amountAssetDecimals"),price:this.safeInteger(n,"priceAssetDecimals")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.extend({amountAsset:i.baseId,priceAsset:i.quoteId},s),r=await this.matcherGetMatcherOrderbookAmountAssetPriceAsset(n),a=this.safeInteger(r,"timestamp"),o=this.parseOrderBookSide(this.safeValue(r,"bids"),i,t),d=this.parseOrderBookSide(this.safeValue(r,"asks"),i,t);return{symbol:e,bids:o,asks:d,timestamp:a,datetime:this.iso8601(a),nonce:void 0}}parseOrderBookSide(e,t=void 0,s=void 0){const i=t.precision,n=this.safeInteger(this.options,"wavesPrecision",8),r=Math.pow(10,i.amount),a=i.amount-i.price,o=Math.pow(10,n-a),d=[];for(let c=0;c<e.length;c++){const u=e[c],h=this.safeInteger(u,"price",0)/o,f=this.safeInteger(u,"amount",0)/r;if(s!==void 0&&c>s)break;d.push([h,f])}return d}checkRequiredKeys(){if(this.apiKey===void 0)throw new ni(this.id+" requires apiKey credential");if(this.secret===void 0)throw new ni(this.id+" requires secret credential");let e,t;try{e=this.base58ToBinary(this.apiKey)}catch{throw new ni(this.id+" apiKey must be a base58 encoded public key")}try{t=this.base58ToBinary(this.secret)}catch{throw new ni(this.id+" secret must be a base58 encoded private key")}const s=this.binaryToBase16(e),i=this.binaryToBase16(t);if(s.length!==64)throw new ni(this.id+" apiKey must be a base58 encoded public key");if(i.length!==64)throw new ni(this.id+" secret must be a base58 encoded private key")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=e==="matcher/orders/{wavesAddress}/cancel";e=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+e,c=this.urlencodeWithArrayRepeat(a);if(t==="private"||t==="forward"){n={Accept:"application/json"};const u=this.safeString(this.options,"accessToken");u&&(n.Authorization="Bearer "+u),s==="POST"?n["content-type"]="application/json":n["content-type"]="application/x-www-form-urlencoded",o&&(r=this.json([a.orderId]),c=""),c.length>0&&(d+="?"+c)}else t==="matcher"?s==="POST"?(n={Accept:"application/json","Content-Type":"application/json"},r=this.json(a)):n=a:s==="POST"?(n={"content-type":"application/json"},r=this.json(a)):(n={"content-type":"application/x-www-form-urlencoded"},c.length>0&&(d+="?"+c));return{url:d,method:s,body:r,headers:n}}async signIn(e={}){if(!this.safeString(this.options,"accessToken")){const t="ffffff01";let i=this.sum(this.seconds(),604800);i=i.toString();const n="waves.exchange",a=this.safeString(this.options,"messagePrefix","W")+":"+n+":"+i,o=this.binaryToBase16(this.stringToBinary(this.encode(a))),d=t+o,c=this.binaryToBase16(this.base58ToBinary(this.secret)),u=this.eddsa(d,c,"ed25519"),h={grant_type:"password",scope:"general",username:this.apiKey,password:i+":"+u,client_id:n},f=await this.privatePostOauth2Token(h);return this.options.accessToken=this.safeString(f,"access_token"),this.options.accessToken}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"/");const n=t.symbol,r=this.safeString(e,"24h_close"),a=this.safeString(e,"24h_low"),o=this.safeString(e,"24h_high"),d=this.safeString(e,"24h_vwap"),c=this.safeString(e,"24h_volume"),u=this.safeString(e,"24h_priceVolume"),h=this.safeString(e,"24h_open");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:o,low:a,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:d,open:h,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pairs:s.id},n=await this.publicGetPairs(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetTickers(t);return this.parseTickers(s,e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={baseId:r.baseId,quoteId:r.quoteId,interval:this.timeframes[t]},o=this.safeInteger(this.options,"allowedCandles",1440);i===void 0&&(i=o),i=Math.min(o,i);const d=this.parseTimeframe(t)*1e3;if(s===void 0){const m=parseInt(this.milliseconds()/d)*d,g=(i-1)*d,y=m-g;a.timeStart=y.toString()}else{a.timeStart=s.toString();const m=this.sum(s,d*i);a.timeEnd=m.toString()}const c=await this.publicGetCandlesBaseIdQuoteId(this.extend(a,n)),u=this.safeValue(c,"data",[]);let h=this.parseOHLCVs(u,r,t,s,i);h=this.filterFutureCandles(h);let f;const l=h.length;for(let m=0;m<h.length;m++){const g=l-m-1,y=h[g];y[1]===void 0&&(y[1]=f,y[2]=f,y[3]=f,y[4]=f,h[g]=y),f=y[4]}return h}filterFutureCandles(e){const t=[],s=this.milliseconds();for(let i=0;i<e.length&&!(e[i][0]>s);i++)t.push(e[i]);return t}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.parse8601(this.safeString(s,"time")),this.safeNumber(s,"open"),this.safeNumber(s,"high"),this.safeNumber(s,"low"),this.safeNumber(s,"close"),this.safeNumber(s,"volume",0)]}async fetchDepositAddress(e,t={}){await this.signIn();const s=this.safeValue(this.options,"networks",{}),i=this.safeStringUpper(t,"network"),n=this.safeString(s,i,i);t=this.omit(t,["network"]);const r=await this.privateGetPlatforms(),a={},o={},d=this.safeValue(r,"items",[]);for(let y=0;y<d.length;y++){const w=d[y],b=this.safeString(w,"id"),S=this.safeValue(w,"currencies",[]);for(let v=0;v<S.length;v++){const T=this.safeString(S,v);a[T]=!0,T in o||(o[T]={}),o[T][b]=!0}}if(!(e in a)){const y=Object.keys(a);throw new Md(this.id+" fetchDepositAddress() "+e+" not supported. Currency code must be one of "+y.join(", "))}let c;if(n===void 0){const y={currency:e};c=await this.privateGetDepositAddressesCurrency(this.extend(y,t))}else{const y=o[e];if(!(n in y)){const w=Object.keys(y);throw new Md(this.id+" "+n+" network "+e+" deposit address not supported. Network must be one of "+w.join(", "))}if(n==="WAVES"){const w={publicKey:this.apiKey},b=await this.nodeGetAddressesPublicKeyPublicKey(this.extend(w,w));return{address:this.safeString(b,"address"),code:e,currency:e,network:n,tag:void 0,info:b}}else{const w={currency:e,platform:n};c=await this.privateGetDepositAddressesCurrencyPlatform(this.extend(w,t))}}const u=this.safeValue(c,"currency"),h=this.safeString(u,"platform_id"),f=this.safeValue(this.options,"reverseNetworks",{}),l=this.safeString(f,h,h),m=this.safeValue(c,"deposit_addresses");return{address:this.safeString(m,0),code:e,currency:e,tag:void 0,network:l,info:c}}async getMatcherPublicKey(){const e=this.safeString(this.options,"matcherPublicKey");if(e)return e;{const t=await this.matcherGetMatcher();return this.options.matcherPublicKey=t.slice(1,t.length-1),this.options.matcherPublicKey}}getAssetBytes(e){return e==="WAVES"?this.numberToBE(0,1):this.binaryConcat(this.numberToBE(1,1),this.base58ToBinary(e))}getAssetId(e){return e==="WAVES"?"":e}priceToPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=s.precision.amount-s.precision.price;return parseInt(parseFloat(this.toPrecision(t,i-n)))}amountToPrecision(e,t){return parseInt(parseFloat(this.toPrecision(t,this.markets[e].precision.amount)))}currencyToPrecision(e,t,s=void 0){return parseInt(parseFloat(this.toPrecision(t,this.currencies[e].precision)))}fromPrecision(e,t){if(e===void 0)return;const s=new Au(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}toPrecision(e,t){const s=e.toString(),i=new Au(s);return i.decimals=i.decimals-t,i.reduce(),i.toString()}currencyFromPrecision(e,t){const s=this.currencies[e].precision;return this.fromPrecision(t,s)}priceFromPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=this.sum(i,s.precision.price)-s.precision.amount;return this.fromPrecision(t,n)}safeGetDynamic(e){const t=this.safeValue(e,"orderFee");return"dynamic"in t?this.safeValue(t,"dynamic"):this.safeValue(t.composite.default,"dynamic")}safeGetRates(e){const t=this.safeValue(e,"rates");return t===void 0?{WAVES:1}:t}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const a=this.market(e),o=await this.getMatcherPublicKey(),d=this.getAssetId(a.baseId),c=this.getAssetId(a.quoteId),u=t==="market";if(u&&n===void 0)throw new nr(this.id+" createOrder() requires a price argument for "+t+" orders to determine the max price for buy and the min price for sell");const h=s==="buy"?0:1,f=this.milliseconds(),l=this.safeInteger(this.options,"createOrderDefaultExpiry",24192e5),m=this.sum(f,l),g=await this.getFeesForAsset(e,s,i,n),y=this.safeValue(g,"base"),w=this.safeString(y,"feeAssetId"),b=this.safeCurrencyCode(w),S=this.safeString(y,"matcherFee"),v=this.safeValue(g,"discount"),T=this.safeString(v,"feeAssetId"),I=this.safeCurrencyCode(T),A=this.safeString(v,"matcherFee");let N,B;if("feeAsset"in r||"feeAsset"in this.options){const D=this.safeString(r,"feeAsset",this.safeString(this.options,"feeAsset")),H=this.currency(D);N=this.safeString(H,"id")}const x=await this.fetchBalance();if(N!==void 0){if(w!==N&&T!==N)throw new nr(this.id+" asset fee must be "+b+" or "+I);const D=this.safeCurrencyCode(N),H=N===w?S:A,R=parseFloat(this.currencyFromPrecision(D,H));if(D in x&&x[D].free>=R)B=parseInt(H);else throw new Mu(this.id+" not enough funds of the selected asset fee")}if(N===void 0){const D=parseFloat(this.currencyFromPrecision(b,S));if(b in x&&x[b].free>=D)N=w,B=parseInt(S);else{const H=parseFloat(this.currencyFromPrecision(I,A));I in x&&x[I].free>=H&&(N=T,B=parseInt(A))}}if(N===void 0)throw new Mu(this.id+" not enough funds on none of the eligible asset fees");i=this.amountToPrecision(e,i),n=this.priceToPrecision(e,n);const k=[this.numberToBE(3,1),this.base58ToBinary(this.apiKey),this.base58ToBinary(o),this.getAssetBytes(a.baseId),this.getAssetBytes(a.quoteId),this.numberToBE(h,1),this.numberToBE(n,8),this.numberToBE(i,8),this.numberToBE(f,8),this.numberToBE(m,8),this.numberToBE(B,8),this.getAssetBytes(N)],O=this.binaryConcatArray(k),P=this.eddsa(this.binaryToBase16(O),this.binaryToBase16(this.base58ToBinary(this.secret)),"ed25519"),q={amountAsset:d,priceAsset:c},L={senderPublicKey:this.apiKey,matcherPublicKey:o,assetPair:q,orderType:s,price:n,amount:i,timestamp:f,expiration:m,matcherFee:parseInt(B),signature:P,version:3};if(N!=="WAVES"&&(L.matcherFeeAssetId=N),u){const D=await this.matcherPostMatcherOrderbookMarket(L),H=this.safeValue(D,"message");return this.parseOrder(H,a)}else{const D=await this.matcherPostMatcherOrderbook(L),H=this.safeValue(D,"message");return this.parseOrder(H,a)}}async cancelOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.signIn();const i=await this.getWavesAddress(),n=await this.forwardPostMatcherOrdersWavesAddressCancel({wavesAddress:i,orderId:e}),r=this.safeValue(n,"message"),a=this.safeValue(r,0),o=this.safeValue(a,0),d=this.safeString(o,"orderId");return{info:n,id:d,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:t,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async fetchOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.milliseconds(),r=[this.base58ToBinary(this.apiKey),this.numberToBE(n,8)],a=this.binaryConcatArray(r),o=this.binaryToBase16(this.base58ToBinary(this.secret)),d=this.eddsa(this.binaryToBase16(a),o,"ed25519"),c={Timestamp:n.toString(),Signature:d,publicKey:this.apiKey,orderId:e},u=await this.matcherGetMatcherOrderbookPublicKeyOrderId(this.extend(c,s));return this.parseOrder(u,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.checkRequiredDependencies(),this.checkRequiredKeys(),e===void 0)throw new n8(this.id+" fetchOrders() requires symbol argument");await this.loadMarkets();const n=this.market(e),r=this.milliseconds(),a=[this.base58ToBinary(this.apiKey),this.numberToBE(r,8)],o=this.binaryConcatArray(a),d=this.binaryToBase16(this.base58ToBinary(this.secret)),c=this.eddsa(this.binaryToBase16(o),d,"ed25519"),u={Accept:"application/json",Timestamp:r.toString(),Signature:c,publicKey:this.apiKey,baseId:n.baseId,quoteId:n.quoteId},h=await this.matcherGetMatcherOrderbookBaseIdQuoteIdPublicKeyPublicKey(this.extend(u,i));return this.parseOrders(h,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),activeOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),closedOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Cancelled:"canceled",Accepted:"open",Filled:"closed",PartiallyFilled:"open"};return this.safeString(t,e,e)}getSymbolFromAssetPair(e){const t=this.safeString(e,"amountAsset","WAVES"),s=this.safeString(e,"priceAsset","WAVES");return this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"type","orderType");let n="limit";"type"in e&&(n=this.safeString(e,"orderType",n));const r=this.safeString(e,"id"),a=this.safeString(e,"filled"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeValue(e,"assetPair");let u;c!==void 0?u=this.getSymbolFromAssetPair(c):t!==void 0&&(u=t.symbol);const h=this.safeCurrencyCode(this.safeString(c,"amountAsset","WAVES")),f=this.priceFromPrecision(u,o),l=this.currencyFromPrecision(h,d),m=this.currencyFromPrecision(h,a),g=this.priceFromPrecision(u,this.safeString(e,"avgWeighedPrice")),y=this.parseOrderStatus(this.safeString(e,"status"));let w;if("type"in e){const b=this.safeCurrencyCode(this.safeString(e,"feeAsset"));w={currency:b,fee:this.parseNumber(this.currencyFromPrecision(b,this.safeString(e,"filledFee")))}}else{const b=this.safeCurrencyCode(this.safeString(e,"matcherFeeAssetId","WAVES"));w={currency:b,fee:this.parseNumber(this.currencyFromPrecision(b,this.safeString(e,"matcherFee")))}}return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:f,stopPrice:void 0,triggerPrice:void 0,amount:l,cost:void 0,average:g,filled:m,remaining:void 0,status:y,fee:w,trades:void 0},t)}async getWavesAddress(){const e=this.safeString(this.options,"wavesAddress");if(e===void 0){const t={publicKey:this.apiKey},s=await this.nodeGetAddressesPublicKeyPublicKey(t);return this.options.wavesAddress=this.safeString(s,"address"),this.options.wavesAddress}else return e}async fetchBalance(e={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const t=await this.getWavesAddress(),s={address:t},i=await this.nodeGetAssetsBalanceAddress(s),n=this.safeValue(i,"balances",[]),r={};let a;const o=[],d=[];for(let T=0;T<n.length;T++){const I=n[T],A=this.safeInteger(I,"timestamp");a=a===void 0?A:Math.max(a,A);const N=this.safeValue(I,"issueTransaction"),B=this.safeString(I,"assetId"),x=this.safeString(I,"balance");if(N===void 0){o.push(B),d.push(x);continue}const k=this.safeInteger(N,"decimals");let O;B in this.currencies_by_id&&(O=this.safeCurrencyCode(B),r[O]=this.account(),r[O].total=this.fromPrecision(x,k))}if(o.length){const T={ids:o},I=await this.publicGetAssets(T),A=this.safeValue(I,"data",[]);for(let N=0;N<A.length;N++){const B=A[N],x=d[N],k=this.safeValue(B,"data"),O=this.safeInteger(k,"precision"),P=this.safeString(k,"ticker"),q=this.safeCurrencyCode(P);r[q]=this.account(),r[q].total=this.fromPrecision(x,O)}}const u=this.milliseconds(),h=[this.base58ToBinary(this.apiKey),this.numberToBE(u,8)],f=this.binaryConcatArray(h),l=this.binaryToBase16(this.base58ToBinary(this.secret)),m=this.eddsa(this.binaryToBase16(f),l,"ed25519"),g={publicKey:this.apiKey,signature:m,timestamp:u.toString()},y=await this.matcherGetMatcherBalanceReservedPublicKey(g),w=Object.keys(y);for(let T=0;T<w.length;T++){const I=w[T],A=this.safeCurrencyCode(I);A in r||(r[A]=this.account());const N=this.safeString(y,I);A in this.currencies?r[A].used=this.currencyFromPrecision(A,N):r[A].used=N}const b={address:t},S=await this.nodeGetAddressesBalanceAddress(b);r.WAVES=this.safeValue(r,"WAVES",{}),r.WAVES.total=this.currencyFromPrecision("WAVES",this.safeString(S,"balance"));const v=Object.keys(r);for(let T=0;T<v.length;T++){const I=v[T];this.safeValue(r[I],"used")===void 0&&(r[I].used="0")}return r.timestamp=a,r.datetime=this.iso8601(a),this.safeBalance(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={sender:await this.getWavesAddress()};let a;e!==void 0&&(a=this.market(e),r.amountAsset=a.baseId,r.priceAsset=a.quoteId);const o=await this.publicGetTransactionsExchange(r),d=this.safeValue(o,"data");return this.parseTrades(d,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={amountAsset:n.baseId,priceAsset:n.quoteId};s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.publicGetTransactionsExchange(r),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeValue(e,"data"),i=this.safeString(s,"timestamp"),n=this.parse8601(i),r=this.safeString(s,"id"),a=this.safeString(s,"price"),o=this.safeString(s,"amount"),d=this.safeValue(s,"order1"),c=this.safeValue(s,"order2");let u;this.safeString(d,"senderPublicKey")===this.apiKey?u=d:u=c;let h;const f=this.safeValue(u,"assetPair");f!==void 0?h=this.getSymbolFromAssetPair(f):t!==void 0&&(h=t.symbol);const l=this.safeString(u,"orderType"),m=this.safeString(u,"id"),g={cost:this.safeString(u,"matcherFee"),currency:this.safeCurrencyCode(this.safeString(u,"matcherFeeAssetId","WAVES"))};return this.safeTrade({info:e,timestamp:n,datetime:i,symbol:h,id:r,order:m,type:void 0,side:l,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:g},t)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"error"),u=this.safeValue(a,"success",!0),h=this.safeValue(this.exceptions,c);if(h!==void 0){const l=this.safeString(a,"message");throw new h(this.id+" "+l)}if(this.safeString(a,"message")==="Validation Error")throw new Pu(this.id+" "+r);if(!u)throw new Md(this.id+" "+r)}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),e!=="WAVES"){const N=await this.privateGetWithdrawCurrencies(),B={},x=this.safeValue(N,"items",[]);for(let k=0;k<x.length;k++){const O=x[k],P=this.safeString(O,"id");B[P]=!0}if(!(e in B)){const k=Object.keys(B);throw new Md(this.id+" withdraw() "+e+" not supported. Currency code must be one of "+k.toString())}}await this.loadMarkets();const r=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],a={};for(let N=0;N<r.length;N++){const B=r[N];a[B]=!0}let o=!0;const c=this.remove0xPrefix(s).toLowerCase();for(let N=0;N<c.length;N++)if(!(c[N]in a)){o=!1;break}await this.signIn();let u;if(e==="WAVES"&&!o)u=s;else{const N={address:s,currency:e},B=await this.privateGetWithdrawAddressesCurrencyAddress(N),x=this.safeValue(B,"currency"),k=this.safeValue(x,"allowed_amount"),O=this.safeNumber(k,"min");if(t<=O)throw new Pu(this.id+" "+e+" withdraw failed, amount "+t.toString()+" must be greater than the minimum allowed amount of "+O.toString());const P=this.safeValue(B,"proxy_addresses",[]);u=this.safeString(P,0)}const h=this.safeInteger(this.options,"withdrawFeeWAVES",1e5),f="WAVES",l=4,m=2,g=this.currencyToPrecision(e,t),y=this.currency(e),w=this.milliseconds(),b=[this.numberToBE(4,1),this.numberToBE(2,1),this.base58ToBinary(this.apiKey),this.getAssetBytes(y.id),this.getAssetBytes(f),this.numberToBE(w,8),this.numberToBE(g,8),this.numberToBE(h,8),this.base58ToBinary(u),this.numberToBE(0,2)],S=this.binaryConcatArray(b),v=this.binaryToBase16(this.base58ToBinary(this.secret)),T=this.eddsa(this.binaryToBase16(S),v,"ed25519"),I={senderPublicKey:this.apiKey,amount:g,fee:h,type:l,version:m,attachment:"",feeAssetId:this.getAssetId(f),proofs:[T],assetId:this.getAssetId(y.id),recipient:u,timestamp:w,signature:T},A=await this.nodePostTransactionsBroadcast(I);return this.parseTransaction(A,y)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}};const u8=re,{ExchangeError:Ap,BadRequest:Pd,RateLimitExceeded:h8,BadSymbol:f8,ArgumentsRequired:Bp,PermissionDenied:l8,InsufficientFunds:p8,InvalidOrder:Uk}=Q,{TICK_SIZE:m8}=ne,$k=ae;var FT=class extends u8{describe(){return this.deepExtend(super.describe(),{id:"wazirx",name:"WazirX",countries:["IN"],version:"v2",rateLimit:1e3,pro:!0,has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/148647666-c109c20b-f8ac-472f-91c3-5f658cb90f49.jpeg",api:{rest:"https://api.wazirx.com/sapi/v1"},www:"https://wazirx.com",doc:"https://docs.wazirx.com/#public-rest-api-for-wazirx",fees:"https://wazirx.com/fees",referral:"https://wazirx.com/invite/k7rrnks5"},api:{public:{get:{exchangeInfo:1,depth:1,ping:1,systemStatus:1,"tickers/24hr":1,"ticker/24hr":1,time:1,trades:1,klines:1}},private:{get:{account:1,allOrders:1,funds:1,historicalTrades:1,openOrders:1,order:1,myTrades:1},post:{order:1,"order/test":1},delete:{order:1,openOrders:1}}},fees:{WRX:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0")}},precisionMode:m8,exceptions:{exact:{"-1121":f8,1999:Pd,2002:p8,2005:Pd,2078:l8,2098:Pd,2031:Uk,2113:Pd,2115:Pd,2136:h8,94001:Uk}},timeframes:{"1m":"1m","5m":"5m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},options:{recvWindow:1e4}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"isSpotTradingAllowed"),f=this.safeValue(r,"filters");let l;for(let b=0;b<f.length;b++){const S=f[b];this.safeString(S,"filterType")==="PRICE_FILTER"&&(l=this.safeNumber(S,"minPrice"))}const m=this.safeValue(this.fees,u,{});let g=this.safeString(m,"taker","0.2");g=$k.stringDiv(g,"100");let y=this.safeString(m,"maker","0.2");y=$k.stringDiv(y,"100");const w=this.safeString(r,"status");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:h,margin:!1,swap:!1,future:!1,option:!1,active:w==="trading",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(g),maker:this.parseNumber(y),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},price:{min:l,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=this.safeInteger(n,"until");n=this.omit(n,["until"]),s!==void 0&&(a.startTime=parseInt(s/1e3)),o!==void 0&&(a.endTime=o);const d=await this.publicGetKlines(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers24hr(),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTicker(r),o=a.symbol;i[o]=a}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=this.safeString(this.options,"fetchTradesMethod","publicGetTrades"),o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"time"),n=this.iso8601(i);t=this.safeMarket(void 0,t);const a=this.safeValue(e,"isBuyerMaker")?"sell":"buy",o=this.safeNumber(e,"price"),d=this.safeNumber(e,"qty"),c=this.safeNumber(e,"quoteQty");return this.safeTrade({info:e,id:s,timestamp:i,datetime:n,symbol:t.symbol,order:s,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0},t)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e);return{status:this.safeString(t,"status")==="normal"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"lastPrice"),r=this.safeString(e,"openPrice"),a=this.safeString(e,"highPrice"),o=this.safeString(e,"lowPrice"),d=this.safeString(e,"volume"),c=this.safeString(e,"bidPrice"),u=this.safeString(e,"askPrice"),h=this.safeInteger(e,"at");return this.safeTicker({symbol:i,timestamp:h,datetime:this.iso8601(h),high:a,low:o,bid:c,bidVolume:void 0,ask:u,askVolume:void 0,vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:void 0,info:e},t)}parseBalance(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"free"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetFunds(e);return this.parseBalance(t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bp(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAllOrders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return o=this.filterBy(o,"symbol",e),o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Bp(this.id+" cancelAllOrders() requires a `symbol` argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.privateDeleteOpenOrders(this.extend(i,t))}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Bp(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const n={symbol:this.market(t).id,orderId:e},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){if(t=t.toLowerCase(),t!=="limit"&&t!=="stop_limit")throw new Ap(this.id+" createOrder() supports limit and stop_limit orders only");if(n===void 0)throw new Ap(this.id+" createOrder() requires a price argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,side:s,quantity:i,type:"limit"};o.price=this.priceToPrecision(e,n),this.safeString(r,"stopPrice")!==void 0&&(o.type="stop_limit");const c=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updatedTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"executedQty"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"id"),u=this.safeString(e,"price"),h=this.safeStringLower(e,"type"),f=this.safeStringLower(e,"side");return this.safeOrder({info:e,id:c,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:h,timeInForce:void 0,postOnly:void 0,side:f,price:u,amount:a,filled:o,remaining:void 0,cost:void 0,fee:void 0,average:void 0,trades:[]},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const o=this.milliseconds();let d=this.extend({recvWindow:this.options.recvWindow,timestamp:o},i);d=this.keysort(d);const c=this.hmac(this.encode(this.urlencode(d)),this.encode(this.secret),"sha256");a+="?"+this.urlencode(d),a+="&signature="+c,n={"Content-Type":"application/x-www-form-urlencoded","X-Api-Key":this.apiKey}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new Ap(u)}}};const g8=re,{ExchangeNotAvailable:y8,ExchangeError:Wk,DDoSProtection:w8,BadSymbol:zk,InvalidOrder:Ad,ArgumentsRequired:Da,AuthenticationError:b8,OrderNotFound:jk,PermissionDenied:Np,InsufficientFunds:Vp,BadRequest:Ep,NotSupported:Kk}=Q,{TICK_SIZE:k8}=ne,qp=ae;var HT=class extends g8{describe(){return this.deepExtend(super.describe(),{id:"whitebit",name:"WhiteBit",version:"v4",countries:["EE"],rateLimit:500,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,borrowMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,repayMargin:!1,setLeverage:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",api:{v1:{public:"https://whitebit.com/api/v1/public",private:"https://whitebit.com/api/v1"},v2:{public:"https://whitebit.com/api/v2/public"},v4:{public:"https://whitebit.com/api/v4/public",private:"https://whitebit.com/api/v4"}},www:"https://www.whitebit.com",doc:"https://github.com/whitebit-exchange/api-docs",fees:"https://whitebit.com/fee-schedule",referral:"https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963"},api:{web:{get:["v1/healthcheck"]},v1:{public:{get:["markets","tickers","ticker","symbols","depth/result","history","kline"]},private:{post:["account/balance","order/new","order/cancel","orders","account/order_history","account/executed_history","account/executed_history/all","account/order"]}},v2:{public:{get:["markets","ticker","assets","fee","depth/{market}","trades/{market}"]}},v4:{public:{get:["assets","collateral/markets","fee","orderbook/{market}","ticker","trades/{market}","time","ping","markets"]},private:{post:["collateral-account/balance","collateral-account/positions/history","collateral-account/leverage","collateral-account/positions/open","collateral-account/summary","main-account/address","main-account/balance","main-account/create-new-address","main-account/codes","main-account/codes/apply","main-account/codes/my","main-account/codes/history","main-account/fiat-deposit-url","main-account/history","main-account/withdraw","main-account/withdraw-pay","main-account/transfer","trade-account/balance","trade-account/executed-history","trade-account/order","trade-account/order/history","order/collateral/limit","order/collateral/market","order/collateral/trigger_market","order/new","order/market","order/stock_market","order/stop_limit","order/stop_market","order/cancel","orders","profile/websocket_token"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fiatCurrencies:["EUR","USD","RUB","UAH"],fetchBalance:{account:"spot"},accountsByType:{main:"main",spot:"spot",margin:"collateral",trade:"spot"},networksById:{BEP20:"BSC"},defaultType:"spot",brokerId:"ccxt"},precisionMode:k8,exceptions:{exact:{"Unauthorized request.":b8,"The market format is invalid.":zk,"Market is not available":zk,"Invalid payload.":Ep,"Amount must be greater than 0":Ad,"Not enough balance.":Vp,"The order id field is required.":Ad,"Not enough balance":Vp,"This action is unauthorized.":Np,"This API Key is not authorized to perform this action.":Np,"Unexecuted order was not found.":jk,"The selected from is invalid.":Ep,503:y8,422:jk},broad:{"Given amount is less than min amount":Ad,"Total is less than":Ad,"fee must be no less than":Ad,"Enable your key in API settings":Np,"You don't have such amount for transfer":Vp}}})}async fetchMarkets(e={}){const t=await this.v4PublicGetMarkets(),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"stock");let o=this.safeString(n,"money");o=o==="PERP"?"USDT":o;const d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeValue(n,"tradesEnabled"),h=this.safeValue(n,"isCollateral"),f=this.safeString(n,"type");let l,m,g,y=d+"/"+c;const w=f==="futures",b=h&&!w;w?(g=o,m=this.safeCurrencyCode(g),y=y+":"+m,l="swap"):l="spot";const S={id:r,symbol:y,base:d,quote:c,settle:m,baseId:a,quoteId:o,settleId:g,type:l,spot:!w,margin:b,swap:w,future:!1,option:!1,active:u,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"makerFee"),maker:this.safeNumber(n,"takerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"stockPrec"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"moneyPrec")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"minTotal"),max:void 0}},info:n};s.push(S)}return s}async fetchCurrencies(e={}){const t=await this.v4PublicGetAssets(e),s=Object.keys(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=this.safeValue(a,"can_deposit",!0),d=this.safeValue(a,"can_withdraw",!0),c=o&&d,u=this.safeCurrencyCode(r);i[u]={id:r,code:u,info:a,name:void 0,active:c,deposit:o,withdraw:d,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(a,"min_withdraw"),max:this.safeNumber(a,"max_withdraw")}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t),i=Object.keys(s),n={},r={};for(let a=0;a<i.length;a++){const o=i[a],d=s[o],c=this.safeCurrencyCode(o),u=this.safeValue(d,"withdraw",{});n[c]=this.safeString(u,"fixed");const h=this.safeValue(d,"deposit",{});r[c]=this.safeString(h,"fixed")}return{withdraw:n,deposit:r,info:s}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t);return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const n=Object.keys(e);for(let a=0;a<n.length;a++){const o=n[a],d=o.split(" "),c=d[0],u=e[o],h=this.safeCurrencyCode(c);if(t===void 0||this.inArray(h,t)){this.safeValue(i,h)===void 0&&(i[h]=this.depositWithdrawFee({})),i[h].info[o]=u;let l=this.safeString(d,1);const m=this.safeValue(u,"withdraw"),g=this.safeValue(u,"deposit"),y=this.safeNumber(m,"fixed"),w=this.safeNumber(g,"fixed"),b={fee:y,percentage:y!==void 0?!1:void 0},S={fee:w,percentage:w!==void 0?!1:void 0};if(l!==void 0){const v=l.length;l=l.slice(1,v-1);const T=this.networkIdToCode(l);i[h].networks[T]={withdraw:b,deposit:S}}else i[h].withdraw=b,i[h].deposit=S}}const r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.currency(o);i[o]=this.assignDefaultDepositWithdrawFees(i[o],d)}return i}async fetchTradingFees(e={}){const t=await this.v4PublicGetAssets(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.baseId,{});let o=this.safeString(a,"maker_fee"),d=this.safeString(a,"taker_fee");o=qp.stringDiv(o,"100"),d=qp.stringDiv(d,"100"),s[n]={info:a,symbol:r.symbol,percentage:!0,tierBased:!1,maker:this.parseNumber(o),taker:this.parseNumber(d)}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}parseTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:s,last:s,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString2(e,"base_volume","volume"),quoteVolume:this.safeString2(e,"quote_volume","deal"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v4PublicGetTicker(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=this.parseTicker(s[a],o),c=d.symbol;n[c]=d}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.v4PublicGetOrderbookMarket(this.extend(n,s)),a=this.parseNumber(qp.stringMul(this.safeString(r,"timestamp"),"1000"));return this.parseOrderBook(r,e,a)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.v4PublicGetTradesMarket(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.market=n.id);const a=await this.v4PrivatePostTradeAccountExecutedHistory(this.extend(r,i));if(Array.isArray(a))return this.parseTrades(a,n,t,s);{let o=[];const d=Object.keys(a);for(let u=0;u<d.length;u++){const h=d[u],f=this.safeMarket(h,void 0,"_"),l=this.safeValue(a,h,[]),m=this.parseTrades(l,f,t,s);o=this.arrayConcat(o,m)}o=this.sortBy2(o,"timestamp","id");const c=t===void 0;return this.filterBySinceLimit(o,t,s,"timestamp",c)}}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeTimestamp2(e,"time","trade_timestamp"),i=this.safeString2(e,"dealOrderId","orderId"),n=this.safeString(e,"deal"),r=this.safeString(e,"price"),a=this.safeString2(e,"amount","quote_volume"),o=this.safeString2(e,"id","tradeID"),d=this.safeString2(e,"type","side"),c=t.symbol,u=this.safeInteger(e,"role");let h;u!==void 0&&(h=u===1?"maker":"taker");let f;const l=this.safeString(e,"fee");return l!==void 0&&(f={cost:l,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:o,order:i,type:void 0,takerOrMaker:h,side:d,price:r,amount:a,cost:n,fee:f},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){i===void 0&&(i=1440),i=Math.min(i,1440);const u=parseInt(s/1e3),h=this.parseTimeframe(t),f=this.sum(u,h*i);a.start=u,a.end=f}i!==void 0&&(a.limit=Math.min(i,1440));const o=await this.v1PublicGetKline(this.extend(a,n)),d=this.safeValue(o,"result",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchStatus(e={}){const t=await this.v4PublicGetPing(e),s=this.safeString(t,0);return{status:s==="pong"?"ok":s,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v4PublicGetTime(e);return this.safeInteger(t,"time")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,amount:this.amountToPrecision(e,i)},d=this.safeString2(r,"clOrdId","clientOrderId");if(d===void 0){const v=this.safeString(this.options,"brokerId");v!==void 0&&(o.clientOrderId=v+this.uuid16())}else o.clientOrderId=d,r=this.omit(r,["clientOrderId"]);const c=this.safeString(a,"type"),u=t==="limit",h=t==="market",f=this.safeNumberN(r,["triggerPrice","stopPrice","activation_price"]),l=f!==void 0,m=this.isPostOnly(h,!1,r),[g,y]=this.handleMarginModeAndParams("createOrder",r);m&&(o.postOnly=!0);let w;if(g!==void 0&&g!=="cross")throw new Kk(this.id+" createOrder() is only available for cross margin");const b=g!==void 0||c==="swap";l?(o.activation_price=this.priceToPrecision(e,f),u?(w="v4PrivatePostOrderStopLimit",o.price=this.priceToPrecision(e,n)):(w="v4PrivatePostOrderStopMarket",b&&(w="v4PrivatePostOrderCollateralTriggerMarket"))):u?(w="v4PrivatePostOrderNew",b&&(w="v4PrivatePostOrderCollateralLimit"),o.price=this.priceToPrecision(e,n)):(w="v4PrivatePostOrderStockMarket",b&&(w="v4PrivatePostOrderCollateralMarket")),r=this.omit(y,["postOnly","triggerPrice","stopPrice"]);const S=await this[w](this.extend(o,r));return this.parseOrder(S)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Da(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market:this.market(t).id,orderId:parseInt(e)};return await this.v4PrivatePostOrderCancel(this.extend(n,s))}parseBalance(e){const t=Object.keys(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeCurrencyCode(n),a=e[n];if(typeof a=="object"&&a!==void 0){const o=this.account();o.free=this.safeString(a,"available"),o.used=this.safeString(a,"freeze"),o.total=this.safeString(a,"main_balance"),s[r]=o}else{const o=this.account();o.total=a,s[r]=o}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;if(t==="swap")i="v4PrivatePostCollateralAccountBalance";else{const r=this.safeValue(this.options,"fetchBalance",{}),a=this.safeString(r,"account"),o=this.safeString(e,"account",a);e=this.omit(e,"account"),o==="main"?i="v4PrivatePostMainAccountBalance":i="v4PrivatePostTradeAccountBalance"}const n=await this[i](s);return this.parseBalance(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Da(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=Math.min(s,100));const a=await this.v4PrivatePostOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,{status:"open"})}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.market=r.id),s!==void 0&&(n.limit=Math.min(s,100));const a=await this.v4PrivatePostTradeAccountOrderHistory(this.extend(n,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeMarket(u,void 0,"_"),f=a[u];for(let l=0;l<f.length;l++){const m=this.parseOrder(f[l],h);d.push(this.extend(m,{status:"closed"}))}}return d=this.sortBy(d,"timestamp"),d=this.filterBySymbolSinceLimit(d,e,t,s),d}parseOrderType(e){const t={limit:"limit",market:"market","stop market":"market","stop limit":"limit","stock market":"market","margin limit":"limit","margin market":"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeString(e,"side"),r=this.safeString(e,"dealStock"),a=this.safeString(e,"left");let o=this.safeString(e,"clientOrderId");o===""&&(o=void 0);const d=this.safeString(e,"price"),c=this.safeNumber(e,"activation_price"),u=this.safeString2(e,"orderId","id"),h=this.safeString(e,"type");let f=this.safeString(e,"amount");const l=this.safeString(e,"dealMoney");n==="buy"&&(h==="market"||h==="stop market")&&(f=r);const m=this.safeString(e,"dealFee");let g;m!==void 0&&(g={cost:this.parseNumber(m),currency:t.quote});const y=this.safeTimestamp2(e,"ctime","timestamp"),w=this.safeTimestamp(e,"ftime");return this.safeOrder({info:e,id:u,symbol:i,clientOrderId:o,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:w,timeInForce:void 0,postOnly:void 0,status:void 0,side:n,price:d,type:this.parseOrderType(h),stopPrice:c,triggerPrice:c,amount:f,filled:r,remaining:a,average:void 0,cost:l,fee:g,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:parseInt(e)};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=Math.min(i,100));const o=await this.v4PrivatePostTradeAccountOrder(this.extend(r,n)),d=this.safeValue(o,"records",[]);return this.parseTrades(d,a)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={ticker:this.currency(e).id};let n="v4PrivatePostMainAccountAddress";if(this.isFiat(e)){n="v4PrivatePostMainAccountFiatDepositUrl";const u=this.safeNumber(t,"provider");if(u===void 0)throw new Da(this.id+" fetchDepositAddress() requires a provider when the ticker is fiat");i.provider=u;const h=this.safeNumber(t,"amount");if(h===void 0)throw new Da(this.id+" fetchDepositAddress() requires an amount when the ticker is fiat");if(i.amount=h,this.safeValue(t,"uniqueId")===void 0)throw new Da(this.id+" fetchDepositAddress() requires an uniqueId when the ticker is fiat")}const r=await this[n](this.extend(i,t)),a=this.safeString(r,"url"),o=this.safeValue(r,"account",{}),d=this.safeString(o,"address",a),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:r}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t!==void 0)throw new Kk(this.id+" setLeverage() does not allow to set per symbol");if(e<1||e>20)throw new Ep(this.id+" setLeverage() leverage should be between 1 and 20");const i={leverage:e};return await this.v4PrivatePostCollateralAccountLeverage(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType"),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.currencyToPrecision(e,t),u={ticker:r.id,amount:c,from:o,to:d},h=await this.v4PrivatePostMainAccountTransfer(this.extend(u,n)),f=this.parseTransfer(h,r);return this.extend(f,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t){return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={ticker:r.id,amount:this.currencyToPrecision(e,t),address:s};let o=this.safeValue(n,"uniqueId");if(o===void 0&&(o=this.uuid22()),a.uniqueId=o,i!==void 0&&(a.memo=i),this.isFiat(e)){const c=this.safeValue(n,"provider");if(c===void 0)throw new Da(this.id+" withdraw() requires a provider when the ticker is fiat");a.provider=c}const d=await this.v4PrivatePostMainAccountWithdraw(this.extend(a,n));return this.extend({id:o},this.parseTransaction(d,r))}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);const s=this.safeString(e,"address"),i=this.safeTimestamp(e,"createdAt"),n=this.safeString(e,"ticker"),r=this.safeString(e,"status"),a=this.safeString(e,"method");return{id:this.safeString(e,"uniqueId"),txid:this.safeString(e,"transactionHash"),timestamp:i,datetime:this.iso8601(i),network:this.safeString(e,"network"),addressFrom:a==="1"?s:void 0,address:s,addressTo:a==="2"?s:void 0,amount:this.safeNumber(e,"amount"),type:a==="1"?"deposit":"withdrawal",currency:this.safeCurrencyCode(n,t),status:this.parseTransactionStatus(r),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"description"),fee:{cost:this.safeNumber(e,"fee"),currency:this.safeCurrencyCode(n,t)},info:e}}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"canceled",5:"pending",6:"pending",7:"ok",9:"canceled",10:"pending",11:"pending",12:"pending",13:"pending",14:"pending",15:"pending",16:"pending",17:"pending"};return this.safeString(t,e,e)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();let i;const n={transactionMethod:1,uniqueId:e,limit:1,offset:0};t!==void 0&&(i=this.currency(t),n.ticker=i.id);const r=await this.v4PrivatePostMainAccountHistory(this.extend(n,s)),a=this.safeValue(r,"records",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={transactionMethod:1,limit:100,offset:0};e!==void 0&&(n=this.currency(e),r.ticker=n.id),s!==void 0&&(r.limit=Math.min(s,100));const a=await this.v4PrivatePostMainAccountHistory(this.extend(r,i)),o=this.safeValue(a,"records",[]);return this.parseTransactions(o,n,t,s)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.v4PrivatePostCollateralAccountPositionsOpen(this.extend(r,n)),d=this.parseBorrowInterests(o,a);return this.filterByCurrencySinceLimit(d,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"_"),n=this.safeTimestamp(e,"modifyDate");return{symbol:i,marginMode:"cross",currency:"USDT",interest:this.safeNumber(e,"unrealizedFunding"),interestRate:98e-5,amountBorrowed:this.safeNumber(e,"amount"),timestamp:n,datetime:this.iso8601(n),info:e}}isFiat(e){const t=this.safeValue(this.options,"fiatCurrencies",[]);return this.inArray(e,t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.safeValue(t,0),d=this.safeValue(t,1),c="/"+this.implodeParams(e,i);let u=this.urls.api[o][d]+c;if(d==="public"&&Object.keys(a).length&&(u+="?"+this.urlencode(a)),d==="private"){this.checkRequiredCredentials();const h=this.nonce().toString(),f=this.stringToBinary(this.encode(this.secret)),l="/api/"+o+c;r=this.json(this.extend({request:l,nonce:h},i));const m=this.stringToBase64(r),g=this.hmac(m,f,"sha512");n={"Content-Type":"application/json","X-TXC-APIKEY":this.apiKey,"X-TXC-PAYLOAD":this.decode(m),"X-TXC-SIGNATURE":g}}return{url:u,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new w8(this.id+" "+e.toString()+" "+t+" "+r);if(e===404)throw new Wk(this.id+" "+e.toString()+" endpoint not found");if(a!==void 0){const c=this.safeString(a,"status"),u=this.safeString(a,"message"),h=this.safeInteger(a,"code"),f=c!==void 0&&c!=="200";if(f||h!==void 0){const l=this.id+" "+r;let m=u;if(f)m=c;else{const g=this.safeValue(a,"errors");if(g!==void 0){const y=Object.keys(g)[0],w=this.safeValue(g,y,[]);m=w.length>0?w[0]:r}}throw this.throwExactlyMatchedException(this.exceptions.exact,m,l),this.throwBroadlyMatchedException(this.exceptions.broad,r,l),new Wk(l)}}}};const S8=re,{ArgumentsRequired:Lp,AuthenticationError:Xk,RateLimitExceeded:v8,BadRequest:xi,ExchangeError:Yk,InvalidOrder:rr}=Q,{TICK_SIZE:T8}=ne,_i=ae;var GT=class extends S8{describe(){return this.deepExtend(super.describe(),{id:"woo",name:"WOO X",countries:["KY"],rateLimit:100,version:"v1",certified:!1,pro:!0,hostname:"woo.org",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelWithdraw:!1,createDepositAddress:!1,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!1,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!0,setMargin:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w","1M":"1mon","1y":"1y"},urls:{logo:"https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",api:{pub:"https://api-pub.woo.org",public:"https://api.{hostname}",private:"https://api.{hostname}"},test:{pub:"https://api-pub.staging.woo.org",public:"https://api.staging.woo.org",private:"https://api.staging.woo.org"},www:"https://woo.org/",doc:["https://docs.woo.org/"],fees:["https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"],referral:"https://referral.woo.org/BAJS6oNmZb3vi3RGA"},api:{v1:{pub:{get:{"hist/kline":10,"hist/trades":1}},public:{get:{info:1,"info/{symbol}":1,system_info:1,market_trades:1,token:1,token_network:1,funding_rates:1,"funding_rate/{symbol}":1,funding_rate_history:1,futures:1,"futures/{symbol}":1}},private:{get:{"client/token":1,"order/{oid}":1,"client/order/{client_order_id}":1,orders:1,"orderbook/{symbol}":1,kline:1,"client/trade/{tid}":1,"order/{oid}/trades":1,"client/trades":1,"client/info":60,"asset/deposit":10,"asset/history":60,"sub_account/all":60,"sub_account/assets":60,token_interest:60,"token_interest/{token}":60,"interest/history":60,"interest/repay":60,"funding_fee/history":30,positions:3.33,"position/{symbol}":3.33},post:{order:5,"asset/main_sub_transfer":30,"asset/withdraw":30,"interest/repay":60,"client/account_mode":120,"client/leverage":120},delete:{order:1,"client/order":1,orders:1,"asset/withdraw":120}}},v2:{private:{get:{"client/holding":1}}},v3:{private:{get:{"algo/order/{oid}":1,"algo/orders":1},post:{"algo/order":5},put:{"order/{oid}":2,"order/client/{oid}":2,"algo/order/{oid}":2,"algo/order/client/{oid}":2},delete:{"algo/order/{oid}":1,"algo/orders/pending":1,"algo/orders/pending/{symbol}":1,"orders/pending":1}}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},options:{createMarketBuyOrderRequiresPrice:!0,"network-aliases-for-tokens":{HT:"ERC20",OMG:"ERC20",UATOM:"ATOM",ZRX:"ZRX"},networks:{TRX:"TRON",TRC20:"TRON",ERC20:"ETH",BEP20:"BSC"},defaultNetworkCodeForCurrencies:{},transfer:{fillResponseFromRequest:!0}},commonCurrencies:{},exceptions:{exact:{"-1000":Yk,"-1001":Xk,"-1002":Xk,"-1003":v8,"-1004":xi,"-1005":xi,"-1006":xi,"-1007":xi,"-1008":rr,"-1009":xi,"-1011":Yk,"-1012":xi,"-1101":rr,"-1102":rr,"-1103":rr,"-1104":rr,"-1105":rr},broad:{"symbol must not be blank":xi,"The token is not supported":xi,"Your order and symbol are not valid or already canceled":xi,"Insufficient WOO. Please enable margin trading for leverage trading":xi}},precisionMode:T8})}async fetchMarkets(e={}){const t=await this.v1PublicGetInfo(e),s=[],i=this.safeValue(t,"rows",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=a.split("_");let d=this.safeStringLower(o,0);const c=d==="spot",u=d==="perp",h=this.safeString(o,1),f=this.safeString(o,2),l=this.safeCurrencyCode(h),m=this.safeCurrencyCode(f);let g,y,w=l+"/"+m,b,S;u&&(g=this.safeString(o,2),y=this.safeCurrencyCode(g),w=l+"/"+m+":"+y,b=this.parseNumber("1"),d="swap",S=!0),s.push({id:a,symbol:w,base:l,quote:m,settle:y,baseId:h,quoteId:f,settleId:g,type:d,spot:c,margin:!0,swap:u,future:!1,option:!1,active:void 0,contract:u,linear:S,inverse:void 0,contractSize:b,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"base_tick"),price:this.safeNumber(r,"quote_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"base_min"),max:this.safeNumber(r,"base_max")},price:{min:this.safeNumber(r,"quote_min"),max:this.safeNumber(r,"quote_max")},cost:{min:this.safeNumber(r,"min_notional"),max:void 0}},info:r})}return s}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lp(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.v1PublicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"rows",{});return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s="id"in e,i=this.safeTimestamp(e,"executed_timestamp"),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"executed_price"),o=this.safeString(e,"executed_quantity"),d=this.safeString(e,"order_id"),c=this.parseTokenAndFeeTemp(e,"fee_asset","fee"),u=_i.stringMul(a,o),h=this.safeStringLower(e,"side"),f=this.safeString(e,"id");let l;return s&&(l=this.safeString(e,"is_maker")==="1"?"maker":"taker"),this.safeTrade({id:f,timestamp:i,datetime:this.iso8601(i),symbol:r,side:h,price:a,amount:o,cost:u,order:d,takerOrMaker:l,type:void 0,fee:c,info:e},t)}parseTokenAndFeeTemp(e,t,s){const i=this.safeString(e,s);let n;if(i!==void 0){const r=this.safeString(e,t),a=this.safeCurrencyCode(r);n={cost:i,currency:a}}return n}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v1PrivateGetClientInfo(e),s=this.safeValue(t,"application",{}),i=this.safeString(s,"maker_fee_rate"),n=this.safeString(s,"taker_fee_rate"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:this.parseNumber(_i.stringDiv(i,"10000")),taker:this.parseNumber(_i.stringDiv(n,"10000")),percentage:!0,tierBased:!0}}return r}async fetchCurrencies(e={}){const t={},s=await this.v1PublicGetToken(e),i=this.safeValue(s,"rows",[]),n=this.groupBy(i,"balance_token"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o);let u,h;const f={};for(let l=0;l<d.length;l++){const m=d[l];u=this.safeString(m,"fullname");const g=this.safeString(m,"token"),w=g.split("_")[0],b=this.parsePrecision(this.safeString(m,"decimals"));b!==void 0&&(h=h===void 0?b:_i.stringMin(b,h)),f[w]={id:g,network:w,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(b),info:m}}t[c]={id:o,name:u,code:c,precision:this.parseNumber(h),active:void 0,fee:void 0,networks:f,deposit:void 0,withdraw:void 0,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},info:d}}return t}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeValue(r,"reduceOnly"),o=t.toUpperCase();if(a!==void 0&&o!=="LIMIT")throw new rr(this.id+" createOrder() only support reduceOnly for limit orders");await this.loadMarkets();const d=this.market(e),c=s.toUpperCase(),u={symbol:d.id,order_type:o,side:c},h=o==="MARKET",f=this.safeStringLower(r,"timeInForce");if(this.isPostOnly(h,void 0,r)?u.order_type="POST_ONLY":f==="fok"?u.order_type="FOK":f==="ioc"&&(u.order_type="IOC"),a&&(u.reduce_only=a),n!==void 0&&(u.order_price=this.priceToPrecision(e,n)),h)if(c==="BUY"){const y=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0))if(y===void 0){if(n===void 0)throw new rr(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or alternatively, supply the total cost value in the 'order_amount' in  exchange-specific parameters");{const w=this.numberToString(i),b=this.numberToString(n),S=_i.stringMul(w,b);u.order_amount=this.costToPrecision(e,S)}}else u.order_amount=this.costToPrecision(e,y)}else u.order_quantity=this.amountToPrecision(e,i);else u.order_quantity=this.amountToPrecision(e,i);const m=this.safeString2(r,"clOrdID","clientOrderId");m!==void 0&&(u.client_order_id=m),r=this.omit(r,["clOrdID","clientOrderId","postOnly","timeInForce"]);const g=await this.v1PrivatePostOrder(this.extend(u,r));return this.extend(this.parseOrder(g,d),{type:t})}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={oid:e};r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.quantity=this.amountToPrecision(t,n));const c=await this.v3PrivatePutOrderOid(this.extend(d,a)),u=this.safeValue(c,"data",{});return this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Lp(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={},n=this.safeString2(s,"clOrdID","clientOrderId"),r=this.safeString2(s,"client_order_id",n),a=r!==void 0;a?(i.client_order_id=r,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"])):i.order_id=e;let o;t!==void 0&&(o=this.market(t)),i.symbol=o.id;const d=await this.v1PrivateDeleteOrder(this.extend(i,s)),c={symbol:t};return a?c.client_order_id=r:c.id=e,this.extend(this.parseOrder(d),c)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Lp(this.id+" canelOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.v1PrivateDeleteOrders(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={},r=this.safeString2(s,"clOrdID","clientOrderId");let a;r?(a="v1PrivateGetClientOrderClientOrderId",n.client_order_id=r):(a="v1PrivateGetOrderOid",n.oid=e);const o=await this[a](this.extend(n,s));return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetOrders(this.extend(n,i)),o=this.safeValue(a,"rows");return this.parseOrders(o,r,t,s,i)}parseTimeInForce(e){const t={ioc:"IOC",fok:"FOK",post_only:"PO"};return this.safeString(t,e,void 0)}parseOrder(e,t=void 0){const s=this.safeTimestamp2(e,"timestamp","created_time"),i=this.safeString(e,"order_id"),n=this.safeString(e,"client_order_id"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t);const a=t.symbol,o=this.safeString2(e,"order_price","price"),d=this.safeString2(e,"order_quantity","quantity"),c=this.safeString2(e,"order_amount","amount"),u=this.safeStringLower2(e,"order_type","type"),h=this.safeValue(e,"status"),f=this.safeStringLower(e,"side"),l=this.safeValue(e,"executed"),m=_i.stringSub(c,l),g=this.safeValue(e,"total_fee"),y=this.safeString(e,"fee_asset"),w=this.safeValue(e,"Transactions");return this.safeOrder({id:i,clientOrderId:n,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseOrderStatus(h),symbol:a,type:u,timeInForce:this.parseTimeInForce(u),postOnly:void 0,reduceOnly:this.safeValue(e,"reduce_only"),side:f,price:o,stopPrice:void 0,triggerPrice:void 0,average:void 0,amount:d,filled:l,remaining:m,cost:c,trades:w,fee:{cost:g,currency:y},info:e},t)}parseOrderStatus(e){if(e!==void 0){const t={NEW:"open",FILLED:"closed",CANCEL_SENT:"canceled",CANCEL_ALL_SENT:"canceled",CANCELLED:"canceled",PARTIAL_FILLED:"open",REJECTED:"rejected",INCOMPLETE:"open",COMPLETED:"closed"};return this.safeString(t,e,e)}return e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(t=Math.min(t,1e3),n.max_level=t);const r=await this.v1PrivateGetOrderbookSymbol(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a,"bids","asks","price","quantity")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=Math.min(i,1e3));const o=await this.v1PrivateGetKline(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start_timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={oid:e},o=await this.v1PrivateGetOrderOidTrades(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseTrades(d,r,s,i,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetClientTrades(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseTrades(o,r,t,s,i)}async fetchAccounts(e={}){const t=await this.v1PrivateGetSubAccountAssets(e),s=this.safeValue(t,"rows",[]);return this.parseAccounts(s,e)}parseAccount(e){const t=this.safeString(e,"account");return{info:e,id:this.safeString(e,"application_id"),name:t,code:void 0,type:t==="Main"?"main":"subaccount"}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetClientHolding(e);return this.parseBalance(t)}parseBalance(e){const t={info:e},s=this.safeValue(e,"holding",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"token")),a=this.account();a.total=this.safeString(n,"holding");const o=this.safeString(n,"outstanding_holding");a.used=_i.stringNeg(o),t[r]=a}return this.safeBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.defaultNetworkCodeForCurrency(e),n=this.safeString(t,"network",i);t=this.omit(t,"network");const a={token:n+"_"+s.code},o=await this.v1PrivateGetAssetDeposit(this.extend(a,t)),d=this.safeString(o,"extra"),c=this.safeString(o,"address");return this.checkAddress(c),{currency:e,address:c,tag:d,network:n,info:o}}async getAssetHistoryRows(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.balance_token=r.id),t!==void 0&&(n.start_t=t),s!==void 0&&(n.pageSize=s);const a=this.safeString(i,"type");i=this.omit(i,"type"),a!==void 0&&(n.type=a);const o=await this.v1PrivateGetAssetHistory(this.extend(n,i));return[r,this.safeValue(o,"rows",{})]}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=await this.getAssetHistoryRows(e,t,s,i);return this.parseLedger(r,n,t,s,i)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code,r=this.safeNumber(e,"amount"),o=this.safeString(e,"token_side")==="DEPOSIT"?"in":"out",d=this.safeTimestamp(e,"created_time"),c=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");return{id:this.safeString(e,"id"),currency:n,account:this.safeString(e,"account"),referenceAccount:void 0,referenceId:this.safeString(e,"tx_id"),status:this.parseTransactionStatus(this.safeString(e,"status")),amount:r,before:void 0,after:void 0,fee:c,direction:o,timestamp:d,datetime:this.iso8601(d),type:this.parseLedgerEntryType(this.safeString(e,"type")),info:e}}parseLedgerEntryType(e){const t={BALANCE:"transaction",COLLATERAL:"transfer"};return this.safeString(t,e,e)}getCurrencyFromChaincode(e,t){if(t!==void 0)return t;{const s=e.split("_"),i=s.length,n=this.safeString(s,0);let r=this.safeString(s,1,n);i>2&&(r+="_"+this.safeString(s,2)),t=this.safeCurrency(r)}return t}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"DEPOSIT"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"WITHDRAW"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){const n={type:"BALANCE"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransactions(a,r,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");const a=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount"),o=this.safeString(e,"target_address"),d=this.safeString(e,"source_address"),c=this.safeTimestamp(e,"created_time");return{id:this.safeString2(e,"id","withdraw_id"),txid:this.safeString(e,"tx_id"),timestamp:c,datetime:this.iso8601(c),address:void 0,addressFrom:d,addressTo:o,tag:this.safeString(e,"extra"),type:r,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.safeTimestamp(e,"updated_time"),fee:a,info:e}}parseTransactionStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={token:r.id,amount:this.parseNumber(t),from_application_id:s,to_application_id:i},o=await this.v1PrivatePostAssetMainSubTransfer(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t,d.fromAccount=s,d.toAccount=i),d}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const n={type:"COLLATERAL"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransfers(a,r,t,s,i)}parseTransfer(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");let a,o;r==="withdraw"?(a=void 0,o="spot"):r==="deposit"&&(a="spot",o=void 0);const d=this.safeTimestamp(e,"created_time"),c=this.safeValue(e,"success");let u;return c!==void 0&&(u=c?"ok":"failed"),{id:this.safeString(e,"id"),timestamp:d,datetime:this.iso8601(d),currency:n,amount:this.safeNumber(e,"amount"),fromAccount:a,toAccount:o,status:this.parseTransferStatus(this.safeString(e,"status",u)),info:e}}parseTransferStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={amount:t,address:s};i!==void 0&&(a.extra=i);const o=this.safeValue(this.options,"networks",{}),d=this.safeValue(r,"networks",{}),c=this.safeStringUpper(n,"network"),u=this.safeString(o,c,c),h=this.safeValue(d,u,{}),f=this.safeString(h,"id");if(f===void 0)throw new xi(this.id+" withdraw() require network parameter");a.token=f;const l=await this.v1PrivatePostAssetWithdraw(this.extend(a,n));return this.parseTransaction(l,r)}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);const r=this.currency(e),a={token:r.id,amount:this.currencyToPrecision(e,t)},o=await this.v1PrivatePostInterestRepay(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1],d=this.implodeParams(e,i);let c=this.implodeHostname(this.urls.api[o]);if(c+="/"+a+"/",i=this.omit(i,this.extractParams(e)),i=this.keysort(i),o==="public")c+=o+"/"+d,Object.keys(i).length&&(c+="?"+this.urlencode(i));else{this.checkRequiredCredentials();let u="";const h=this.nonce().toString();c+=d,n={"x-api-key":this.apiKey,"x-api-timestamp":h},a==="v3"&&(s==="POST"||s==="PUT"||s==="DELETE")?(u=this.json(i),r=u,u=h+s+"/"+a+"/"+d+r,n["content-type"]="application/json"):(u=this.urlencode(i),s==="POST"||s==="PUT"||s==="DELETE"?r=u:c+="?"+u,u+="|"+h,n["content-type"]="application/x-www-form-urlencoded"),n["x-api-signature"]=this.hmac(this.encode(u),this.encode(this.secret),"sha256")}return{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"success"),u=this.safeString(a,"code");if(!c){const h=this.id+" "+this.json(a);this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h)}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"funding_fee"),r=this.safeCurrencyCode("USD"),a=this.safeString(e,"id"),o=this.safeTimestamp(e,"updated_time"),d=this.safe_number(e,"funding_rate");return{info:e,symbol:i,code:r,timestamp:o,datetime:this.iso8601(o),id:a,amount:n,rate:d}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetFundingFeeHistory(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseIncomes(o,r,t,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.market(s);const i=this.safeInteger(e,"next_funding_time"),n=this.safeInteger(e,"est_funding_rate_timestamp"),r=this.safeInteger(e,"last_funding_rate_timestamp");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.safeNumber(e,"est_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"last_funding_rate"),previousFundingTimestamp:r,previousFundingDatetime:this.iso8601(r)}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetFundingRateSymbol(this.extend(i,t));return this.parseFundingRate(n,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetFundingRates(t),i=this.safeValue(s,"rows",{}),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const c=this.market(e);e=c.symbol,n.symbol=c.id}t!==void 0&&(n.start_t=parseInt(t/1e3));const r=await this.v1PublicGetFundingRateHistory(this.extend(n,i)),a=this.safeValue(r,"rows"),o=[];for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),f=this.safeInteger(u,"funding_rate_timestamp");o.push({info:u,symbol:this.safeSymbol(h),fundingRate:this.safeNumber(u,"funding_rate"),timestamp:f,datetime:this.iso8601(f)})}const d=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(d,e,t,s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=await this.v1PrivateGetClientInfo(t),i=this.safeValue(s,"application"),n=this.safeNumber(i,"leverage");return{info:s,leverage:n}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),e<1||e>20)throw new xi(this.id+" leverage should be between 1 and 20");const i={leverage:e};return await this.v1PrivatePostClientLeverage(this.extend(i,s))}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PrivateGetPositionSymbol(this.extend(i,t));return this.parsePosition(n,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.v1PrivateGetPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeString(e,"holding"),n;_i.stringGt(i,"0")?n="long":n="short";const r=this.safeString(t,"contractSize"),a=this.safeString(e,"mark_price"),o=this.safeTimestamp(e,"timestamp"),d=this.safeString(e,"average_open_price"),c=_i.stringSub(a,d),u=_i.stringMul(c,i);i=_i.stringAbs(i);const h=_i.stringMul(i,a);return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:o,datetime:this.iso8601(o),initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(d),notional:this.parseNumber(h),leverage:void 0,unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.parseNumber(r),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"est_liq_price"),markPrice:this.parseNumber(a),collateral:void 0,marginMode:"cross",marginType:void 0,side:n,percentage:void 0}}defaultNetworkCodeForCurrency(e){const s=this.currency(e).networks,i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n];if(r==="ETH")return r}return this.safeValue(i,0)}};const O8=re,{ExchangeError:Fa,ArgumentsRequired:Rp,ExchangeNotAvailable:Dp,InvalidNonce:I8,InsufficientFunds:Fp,OrderNotFound:x8,DDoSProtection:_8,InvalidOrder:Xi,AuthenticationError:Bu,RateLimitExceeded:C8}=Q,{TICK_SIZE:M8}=ne,Hp=ae;var P8=class extends O8{describe(){return this.deepExtend(super.describe(),{id:"yobit",name:"YoBit",countries:["RU"],rateLimit:2e3,version:"3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg",api:{public:"https://yobit.net/api",private:"https://yobit.net/tapi"},www:"https://www.yobit.net",doc:"https://www.yobit.net/en/api/",fees:"https://www.yobit.net/en/fees/"},api:{public:{get:{"depth/{pair}":1,info:1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{ActiveOrders:1,CancelOrder:1,GetDepositAddress:1,getInfo:1,OrderInfo:1,Trade:1,TradeHistory:1,WithdrawCoinsToAddress:1}}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{}}},commonCurrencies:{AIR:"AirCoin",ANI:"ANICoin",ANT:"AntsCoin",ATMCHA:"ATM",ASN:"Ascension",AST:"Astral",ATM:"Autumncoin",AUR:"AuroraCoin",BAB:"Babel",BAN:"BANcoin",BCC:"BCH",BCS:"BitcoinStake",BITS:"Bitstar",BLN:"Bulleon",BNS:"Benefit Bonus Coin",BOT:"BOTcoin",BON:"BONES",BPC:"BitcoinPremium",BST:"BitStone",BTS:"Bitshares2",CAT:"BitClave",CBC:"CryptoBossCoin",CMT:"CometCoin",COIN:"Coin.com",COV:"Coven Coin",COVX:"COV",CPC:"Capricoin",CREDIT:"Creditbit",CS:"CryptoSpots",DCT:"Discount",DFT:"DraftCoin",DGD:"DarkGoldCoin",DIRT:"DIRTY",DROP:"FaucetCoin",DSH:"DASH",EGC:"EverGreenCoin",EGG:"EggCoin",EKO:"EkoCoin",ENTER:"ENTRC",EPC:"ExperienceCoin",ESC:"EdwardSnowden",EUROPE:"EUROP",EXT:"LifeExtension",FUND:"FUNDChains",FUNK:"FUNKCoin",FX:"FCoin",GCC:"GlobalCryptocurrency",GEN:"Genstake",GENE:"Genesiscoin",GMR:"Gimmer",GOLD:"GoldMint",GOT:"Giotto Coin",GSX:"GlowShares",GT:"GTcoin",HTML5:"HTML",HYPERX:"HYPER",ICN:"iCoin",INSANE:"INSN",JNT:"JointCoin",JPC:"JupiterCoin",JWL:"Jewels",KNC:"KingN Coin",LBTCX:"LiteBitcoin",LIZI:"LiZi",LOC:"LocoCoin",LOCX:"LOC",LUNYR:"LUN",LUN:"LunarCoin",LUNA:"Luna Coin",MASK:"Yobit MASK",MDT:"Midnight",MEME:"Memez Token",MIS:"MIScoin",MM:"MasterMint",NAV:"NavajoCoin",NBT:"NiceBytes",OMG:"OMGame",ONX:"Onix",PAC:"$PAC",PLAY:"PlayCoin",PIVX:"Darknet",PRS:"PRE",PURE:"PurePOS",PUTIN:"PutinCoin",SPACE:"Spacecoin",STK:"StakeCoin",SUB:"Subscriptio",PAY:"EPAY",PLC:"Platin Coin",RAI:"RaiderCoin",RCN:"RCoin",REP:"Republicoin",RUR:"RUB",SBTC:"Super Bitcoin",SMC:"SmartCoin",SOLO:"SoloCoin",SOUL:"SoulCoin",STAR:"StarCoin",SUPER:"SuperCoin",TNS:"Transcodium",TTC:"TittieCoin",UNI:"Universe",UST:"Uservice",VOL:"VolumeCoin",XIN:"XINCoin",XMT:"SummitCoin",XRA:"Ratecoin"},options:{fetchOrdersRequiresSymbol:!0,fetchTickersMaxLength:512,networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"}},precisionMode:M8,exceptions:{exact:{803:Xi,804:Xi,805:Xi,806:Xi,807:Xi,831:Fp,832:Fp,833:x8},broad:{"Invalid pair name":Fa,"invalid api key":Bu,"invalid sign":Bu,"api key dont have trade permission":Bu,"invalid parameter":Xi,"invalid order":Xi,"The given order has already been cancelled":Xi,"Requests too often":_8,"not available":Dp,"data unavailable":Dp,"external service unavailable":Dp,"Total transaction amount":Xi,"The given order has already been closed and cannot be cancelled":Xi,"Insufficient funds":Fp,"invalid key":Bu,"invalid nonce":I8,"Total order amount is less than minimal amount":Xi,"Rate Limited":C8}},orders:{}})}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeInteger(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=this.safeValue(t,"funds_incl_orders",{}),a=Object.keys(this.extend(n,r));for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(n,d),u.total=this.safeString(r,d),i[c]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_");let u=d.toUpperCase(),h=c.toUpperCase();u=this.safeCurrencyCode(u),h=this.safeCurrencyCode(h);const f=this.safeInteger(o,"hidden");let l=this.safeString(o,"fee");l=Hp.stringDiv(l,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:f===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(l),maker:this.parseNumber(l),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new Fa(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new Fa(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated"),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;s=s.join("-");const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);if(s.length>this.options.fetchTickersMaxLength)throw new Rp(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeMarket(d),h=u.symbol;r[h]=this.parseTicker(c,u)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),f="limit";let l;const m=this.safeNumber(e,"commission");if(m!==void 0){const y=this.safeString(e,"commissionCurrency"),w=this.safeCurrencyCode(y);l={cost:m,currency:w}}if(this.safeValue(e,"is_your_order")!==void 0&&l===void 0){const y=this.calculateFee(d,f,i,h,u,"taker");l={currency:this.safeString(y,"currency"),cost:this.safeString(y,"cost"),rate:this.safeString(y,"rate")}}return this.safeTrade({id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:f,side:i,takerOrMaker:void 0,price:n,amount:c,cost:void 0,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));if(Array.isArray(a)&&a.length===0)return[];const o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(s,a,{}),d=this.safeSymbol(a,void 0,"_"),c=this.safeString(o,"fee_buyer"),u=this.safeString(o,"fee_seller"),h=this.parseNumber(Hp.stringDiv(c,"100")),f=this.parseNumber(Hp.stringDiv(u,"100"));n[d]={info:o,symbol:d,taker:h,maker:f,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Fa(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},d=await this.privatePostTrade(this.extend(o,r)),c=this.safeValue(d,"return");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostCancelOrder(this.extend(i,s)),r=this.safeValue(n,"return",{});return this.parseOrder(r)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"id","order_id"),i=this.parseOrderStatus(this.safeString(e,"status","open"));s==="0"&&(s=this.safeString(e,"init_order_id"),i="closed");const n=this.safeTimestamp2(e,"timestamp_created","server_time"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t),o=this.safeString(e,"start_amount"),d=this.safeString2(e,"amount","remains"),c=this.safeString(e,"received","0.0"),u=this.safeString(e,"rate"),h=void 0,f="limit",l=this.safeString(e,"type");return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:f,timeInForce:void 0,postOnly:void 0,side:l,price:u,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:o,remaining:d,filled:c,status:i,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{});return this.parseOrder(this.extend({id:e},r[e]))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rp(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n={},r=void 0;if(e!==void 0){const d=this.market(e);n.pair=d.id}const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",{});return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rp(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",{}),d=Object.keys(o),c=[];for(let u=0;u<d.length;u++){const h=d[u],f=this.parseTrade(this.extend(o[h],{trade_id:h}),n);c.push(f)}return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async createDepositAddress(e,t={}){const s={need_new:1},i=await this.fetchDepositAddress(e,this.extend(s,t)),n=this.safeString(i,"address");return this.checkAddress(n),{currency:e,address:n,tag:void 0,info:i.info}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e).id;const n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(r!=="ERC20"&&(i=i+r.toLowerCase()),t=this.omit(t,"network"));const a={coinName:i,need_new:0},o=await this.privatePostGetDepositAddress(this.extend(a,t)),d=this.safeString(o.return,"address");return this.checkAddress(d),{currency:e,address:d,tag:void 0,network:void 0,info:o}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={coinName:this.currency(e).id,amount:t,address:s};if(i!==void 0)throw new Fa(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");return{info:await this.privatePostWithdrawCoinsToAddress(this.extend(a,n)),id:void 0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.version+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),f=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,f),this.throwExactlyMatchedException(this.exceptions.exact,h,f),this.throwBroadlyMatchedException(this.exceptions.broad,h,f),new Fa(f)}}}};const A8=re,{ExchangeError:Nu,BadRequest:B8}=Q,{TICK_SIZE:N8}=ne,V8=ae;var E8=class extends A8{describe(){return this.deepExtend(super.describe(),{id:"zaif",name:"Zaif",countries:["JP"],rateLimit:100,version:"1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",api:{rest:"https://api.zaif.jp"},www:"https://zaif.jp",doc:["https://techbureau-api-document.readthedocs.io/ja/latest/index.html","https://corp.zaif.jp/api-docs","https://corp.zaif.jp/api-docs/api_links","https://www.npmjs.com/package/zaif.jp","https://github.com/you21979/node-zaif"],fees:"https://zaif.jp/fee?lang=en"},fees:{trading:{percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},api:{public:{get:{"depth/{pair}":1,"currencies/{pair}":1,"currencies/all":1,"currency_pairs/{pair}":1,"currency_pairs/all":1,"last_price/{pair}":1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{active_orders:5,cancel_order:5,deposit_history:5,get_id_info:5,get_info:10,get_info2:5,get_personal_info:5,trade:5,trade_history:50,withdraw:5,withdraw_history:5}},ecapi:{post:{createInvoice:1,getInvoice:1,getInvoiceIdsByOrderNumber:1,cancelInvoice:1}},tlapi:{post:{get_positions:66,position_history:66,active_positions:5,create_position:33,change_position:33,cancel_position:33}},fapi:{get:{"groups/{group_id}":1,"last_price/{group_id}/{pair}":1,"ticker/{group_id}/{pair}":1,"trades/{group_id}/{pair}":1,"depth/{group_id}/{pair}":1}}},options:{fees:{"BTC/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.001")},"BCH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"BCH/BTC":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"PEPECASH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")},"PEPECASH/BT":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")}}},precisionMode:N8,exceptions:{exact:{"unsupported currency_pair":B8},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetCurrencyPairsAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_pair"),a=this.safeString(n,"name"),[o,d]=a.split("/"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u,f=this.safeValue(this.options.fees,h,this.fees.trading);s.push({id:r,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:f.taker,maker:f.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"item_unit_step"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"aux_unit_point")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"item_unit_min"),max:void 0},price:{min:this.safeNumber(n,"aux_unit_min"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"deposit"),i={info:e,timestamp:void 0,datetime:void 0},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeString(n,o),u=this.account();u.free=c,u.total=c,s!==void 0&&o in s&&(u.total=this.safeString(s,o)),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetDepthPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=V8.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeString(e,"trade_type");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"date"),n=this.safeString2(e,"id","tid"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"currency_pair"),d=this.safeSymbol(o,t,"_");return this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};let a=await this.publicGetTradesPair(this.extend(r,i));if(a.length===1){const d=a[0];Object.keys(d).length||(a=[])}return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new Nu(this.id+" createOrder() allows limit orders only");const o={currency_pair:this.market(e).id,action:s==="buy"?"bid":"ask",amount:i,price:n},d=await this.privatePostTrade(this.extend(o,r));return{info:d,id:d.return.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeString(e,"action");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"currency_pair"),r=this.safeSymbol(n,t,"_"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:"open",symbol:r,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:o,filled:void 0,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostActiveOrders(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostTradeHistory(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);if(e==="JPY")throw new Nu(this.id+" withdraw() does not allow "+e+" withdrawals");const a={currency:r.id,amount:t,address:s};i!==void 0&&(a.message=i);const o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"return");return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);let s;const i=this.safeValue(e,"fee");return i!==void 0&&(s={cost:i,currency:t.code}),{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:s,info:e}}nonce(){return parseFloat(this.milliseconds()/1e3).toFixed(8)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/";if(t==="public")a+="api/"+this.version+"/"+this.implodeParams(e,i);else if(t==="fapi")a+="fapi/"+this.version+"/"+this.implodeParams(e,i);else{this.checkRequiredCredentials(),t==="ecapi"?a+="ecapi":t==="tlapi"?a+="tlapi":a+="tapi";const o=this.nonce();r=this.urlencode(this.extend({method:e,nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"error");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new Nu(c);if(!this.safeValue(a,"success",!0))throw new Nu(c)}};const q8=re,{BadRequest:Ks,BadSymbol:Gp,ExchangeError:we,ArgumentsRequired:lt,AuthenticationError:xt,InsufficientFunds:Gt,NotSupported:Vu,OrderNotFound:Kr,ExchangeNotAvailable:Xr,RateLimitExceeded:Ha,PermissionDenied:Ci,InvalidOrder:Ce,InvalidAddress:L8,OnMaintenance:Zk,RequestTimeout:Eu,AccountSuspended:Up,NetworkError:Qk,DDoSProtection:R8,DuplicateOrderId:D8,BadResponse:Bd}=Q,{TICK_SIZE:F8}=ne,H8=ae;var UT=class extends q8{describe(){return this.deepExtend(super.describe(),{id:"zb",name:"ZB",countries:["CN"],rateLimit:6,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","5d":"5d","1w":"1w"},hostname:"zb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg",api:{spot:{v1:{public:"https://api.{hostname}/data",private:"https://trade.{hostname}/api"}},contract:{v1:{public:"https://fapi.{hostname}/api/public"},v2:{public:"https://fapi.{hostname}/Server/api",private:"https://fapi.{hostname}/Server/api"}}},www:"https://www.zb.com",doc:"https://www.zb.com/i/developer",fees:"https://www.zb.com/i/rate",referral:{url:"https://www.zb.com/en/register?ref=4301lera",discount:.16}},api:{spot:{v1:{public:{get:{markets:16.667,ticker:16.667,allTicker:16.667,depth:16.667,trades:16.667,kline:166.667,getGroupMarkets:16.667,getFeeInfo:16.667}},private:{get:{order:1,orderMoreV2:1,cancelOrder:1,cancelAllOrdersAfter:1,getOrder:1,getOrders:1,getOrdersNew:16.667,getOrdersIgnoreTradeType:1,getUnfinishedOrdersIgnoreTradeType:1,getFinishedAndPartialOrders:1,getAccountInfo:16.667,getUserAddress:16.667,getPayinAddress:16.667,getWithdrawAddress:16.667,getWithdrawRecord:16.667,getChargeRecord:16.667,getCnyWithdrawRecord:16.667,getCnyChargeRecord:16.667,withdraw:16.667,addSubUser:16.667,getSubUserList:16.667,doTransferFunds:16.667,createSubUserKey:16.667,getLeverAssetsInfo:16.667,getLeverBills:16.667,transferInLever:16.667,transferOutLever:16.667,loan:16.667,cancelLoan:16.667,getLoans:16.667,getLoanRecords:16.667,borrow:16.667,autoBorrow:16.667,repay:16.667,doAllRepay:16.667,getRepayments:16.667,getFinanceRecords:16.667,changeInvestMark:16.667,changeLoop:16.667,getCrossAssets:16.667,getCrossBills:16.667,transferInCross:16.667,transferOutCross:16.667,doCrossLoan:16.667,doCrossRepay:16.667,getCrossRepayRecords:16.667}}}},contract:{v1:{public:{get:{depth:16.667,fundingRate:16.667,indexKline:16.667,indexPrice:16.667,kline:16.667,markKline:16.667,markPrice:16.667,ticker:16.667,trade:16.667}}},v2:{public:{get:{allForceOrders:3.334,"config/marketList":3.334,topLongShortAccountRatio:3.334,topLongShortPositionRatio:3.334,fundingRate:3.334,premiumIndex:3.334}},private:{get:{"Fund/balance":3.334,"Fund/getAccount":3.334,"Fund/getBill":3.334,"Fund/getBillTypeList":3.334,"Fund/marginHistory":3.334,"Positions/getPositions":3.334,"Positions/getNominalValue":3.334,"Positions/marginInfo":3.334,"setting/get":3.334,"trade/getAllOrders":3.334,"trade/getOrder":3.334,"trade/getOrderAlgos":3.334,"trade/getTradeList":3.334,"trade/getUndoneOrders":3.334,"trade/tradeHistory":3.334},post:{"activity/buyTicket":3.334,"Fund/transferFund":3.334,"Positions/setMarginCoins":3.334,"Positions/updateAppendUSDValue":3.334,"Positions/updateMargin":3.334,"setting/setLeverage":3.334,"setting/setPositionsMode":3.334,"trade/batchOrder":3.334,"trade/batchCancelOrder":3.334,"trade/cancelAlgos":3.334,"trade/cancelAllOrders":3.334,"trade/cancelOrder":3.334,"trade/order":3.334,"trade/orderAlgo":3.334,"trade/updateOrderAlgo":3.334}}}}},fees:{funding:{withdraw:{}},trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},commonCurrencies:{ANG:"Anagram",ENT:"ENTCash",BCHABC:"BCHABC",BCHSV:"BCHSV"},options:{timeframes:{spot:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},swap:{"1m":"1M","5m":"5M","15m":"15M","30m":"30M","1h":"1H","6h":"6H","1d":"1D","5d":"5D"}}},precisionMode:F8,exceptions:{ws:{1001:we,1002:we,1003:xt,1004:xt,1005:xt,1006:Ci,1007:we,1009:Zk,1010:Xr,1012:Ci,1013:we,1014:we,2001:Gt,2002:Gt,2003:Gt,2005:Gt,2006:Gt,2007:Gt,2008:Gt,2009:Gt,3001:Kr,3002:Ce,3003:Ce,3004:xt,3005:Ks,3006:Ci,3007:Eu,3008:we,3009:Ce,3010:Ci,3011:Ce,3012:Ce,4001:Up,4002:Ha},exact:{10001:we,10002:Ci,10003:Bd,10004:Bd,10005:Ci,10006:Ks,10007:we,10008:we,10009:we,1001:we,10010:xt,10011:xt,10012:Up,10013:xt,10014:xt,10015:xt,10016:xt,10017:Ci,10018:Up,10019:Eu,1002:we,10020:Ks,10021:Ks,10022:Ks,10023:Ha,10024:xt,10025:we,10026:Qk,10027:Eu,10028:Xr,10029:R8,1003:xt,10030:Ks,10031:Ks,10032:Ks,10033:Ks,10034:Ks,10035:Ks,10036:Ks,10037:lt,10038:Ks,10039:Bd,1004:xt,10040:Bd,10041:Bd,10042:we,10043:we,10044:we,10045:we,10046:we,10047:we,10048:we,10049:Qk,1005:xt,1006:xt,1009:Xr,1010:Xr,10100:Zk,1012:Ci,1013:we,1014:we,11e3:we,11001:we,110011:we,11002:we,11003:we,11004:Gt,11005:Ce,11006:Gt,11007:Kr,11008:we,11009:we,110110:we,11012:Gt,11013:we,11014:we,11015:xt,11016:xt,11017:we,11018:Gt,11019:we,11021:Gt,11023:we,11030:Ci,11031:we,11032:we,11033:lt,11034:we,12e3:Ce,12001:Ce,12002:Ce,12003:Ce,12004:Ce,12005:Ce,12006:Ce,12007:Ce,12008:Ce,12009:Ce,12010:Ce,12011:Ce,12012:Kr,12013:Ce,12014:Ce,12015:Ce,12016:Ce,12017:Ce,12018:Ce,12019:lt,12020:we,12021:Ce,12022:Ce,12023:Kr,12024:Ce,12025:Ce,12026:D8,12027:Xr,12028:Ce,12029:Ce,12201:Ce,12202:Ce,12203:Ce,12204:Ce,12205:Ce,12206:Ce,12207:Ha,13001:xt,13002:Ci,13003:Ce,13004:Ce,13005:Ha,13006:we,13007:we,13008:we,13009:we,14e3:we,14001:xt,14002:xt,14003:we,14100:we,14101:Ha,14200:lt,14300:we,14301:we,14302:we,14303:we,14305:we,14306:we,14307:Ce,14308:Ce,14309:we,14310:Vu,14311:Vu,14312:we,14313:Ci,14314:we,2001:Gt,2002:Gt,2003:Gt,2005:Gt,2006:Gt,2007:Gt,2008:Gt,2009:Gt,3001:Kr,3002:Ce,3003:Ce,3004:xt,3005:Ks,3006:xt,3007:xt,3008:Kr,3009:Ce,3010:Ci,3011:Ce,3012:Ce,4001:Xr,4002:Ha,9999:we},broad:{"\u63D0\u5E01\u5730\u5740\u6709\u8BEF, \u8BF7\u5148\u6DFB\u52A0\u63D0\u5E01\u5730\u5740\u3002":L8,"\u8D44\u91D1\u4E0D\u8DB3,\u65E0\u6CD5\u5212\u8D26":Gt,\u54CD\u5E94\u8D85\u65F6:Eu}}})}async fetchMarkets(e={}){let t=[this.spotV1PublicGetMarkets(e),this.contractV2PublicGetConfigMarketList(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(i,"data",[]),r=this.indexBy(n,"marketName"),a=this.deepExtend(r,s),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=a[u],[f,l]=u.split("_"),m=this.safeCurrencyCode(f),g=this.safeCurrencyCode(l),y=this.safeValue(h,"marginCurrencyName"),w=this.safeCurrencyCode(y),b=w===void 0,S=this.safeValue(h,"futures",!1),v=S?!0:void 0;let T=!0,I=m+"/"+g;S&&(T=this.safeString(h,"status")==="1",I=m+"/"+g+":"+w),d.push({id:u,symbol:I,base:m,quote:g,settle:w,baseId:f,quoteId:l,settleId:y,type:S?"swap":"spot",spot:b,margin:!1,swap:S,future:!1,option:!1,active:T,contract:S,linear:v,inverse:S?!v:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString2(h,"amountScale","amountDecimal"))),price:this.parseNumber(this.parsePrecision(this.safeString2(h,"priceScale","priceDecimal")))},limits:{leverage:{min:void 0,max:this.safeNumber(h,"maxLeverage")},amount:{min:this.safeNumber(h,"minAmount"),max:this.safeNumber(h,"maxAmount")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber2(h,"minSize","minTradeMoney"),max:this.safeNumber(h,"maxTradeMoney")}},info:h})}return d}async fetchCurrencies(e={}){const t=await this.spotV1PublicGetGetFeeInfo(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(a);let c=!0,u=!0;const h={};for(let l=0;l<o.length;l++){const m=o[l],g=this.safeString(m,"chainName"),y=this.safeNumber(m,"fee"),w=this.safeValue(m,"canDeposit"),b=this.safeValue(m,"canWithdraw");u=u||w,c=c||b,h[g]=y}const f=c&&u;n[d]={id:a,name:void 0,code:d,precision:void 0,info:o,active:f,deposit:u,withdraw:c,fee:void 0,fees:h,limits:this.limits}}return n}parseBalance(e){const t=this.safeValue(e.result,"coins"),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.account(),a=this.safeString(n,"key"),o=this.safeCurrencyCode(a);r.free=this.safeString(n,"available"),r.used=this.safeString(n,"freez"),s[o]=r}return this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{});for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currencyName")),a=this.account();a.total=this.safeString(n,"accountBalance"),a.free=this.safeString(n,"allowTransferOutAmount"),a.used=this.safeString(n,"freezeAmount"),t[r]=a}return this.safeBalance(t)}parseMarginBalance(e,t){const s={info:e};let i;if(t==="isolated"){const n=this.safeValue(e,"message",{}),r=this.safeValue(n,"datas",{});i=this.safeValue(r,"levers",[])}else{const n=this.safeValue(e,"result",{});i=this.safeValue(n,"list",[])}for(let n=0;n<i.length;n++){const r=i[n],a=this.account();if(t==="isolated"){const o=this.safeCurrencyCode(this.safeString(r,"fShowName"));a.total=this.safeString(r,"fAvailableUSD"),a.free=this.safeString(r,"couldTransferOutFiat"),a.used=this.safeString(r,"fFreeze"),s[o]=a}else{const o=this.safeCurrencyCode(this.safeString(r,"key"));a.total=this.safeString(r,"amount"),a.free=this.safeString(r,"canTransferOut"),a.used=this.safeString(r,"freeze"),s[o]=a}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[i,n]=this.handleMarginModeAndParams("fetchBalance",s),r=t==="swap",a=i==="cross"?"spotV1PrivateGetGetCrossAssets":"spotV1PrivateGetGetLeverAssetsInfo";let o=this.getSupportedMapping(t,{spot:"spotV1PrivateGetGetAccountInfo",swap:"contractV2PrivateGetFundBalance",margin:a});i==="isolated"?o="spotV1PrivateGetGetLeverAssetsInfo":i==="cross"&&(o="spotV1PrivateGetGetCrossAssets");const d={};r&&(d.futuresAccountType=1);const c=await this[o](this.extend(d,n));return r?this.parseSwapBalance(c):i!==void 0?this.parseMarginBalance(c,i):this.parseBalance(c)}parseDepositAddress(e,t=void 0){let s=this.safeString2(e,"key","address"),i;const n=this.safeString(e,"memo");if(n!==void 0)i=n;else if(s.indexOf("_")>=0){const o=s.split("_");s=o[0],i=o[1]}this.checkAddress(s);const r=this.safeString(e,"blockChain");return{currency:this.safeCurrencyCode(r,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.spotV1PrivateGetGetPayinAddress(t),i=this.safeValue(s,"message",{}),n=this.safeValue(i,"datas",[]);return this.parseDepositAddresses(n,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotV1PrivateGetGetUserAddress(this.extend(i,t)),r=this.safeValue(n,"message",{}),a=this.safeValue(r,"datas",{});return this.parseDepositAddress(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={},r=i.swap?"symbol":"market";n[r]=i.id;const a=this.getSupportedMapping(i.type,{spot:"spotV1PublicGetDepth",swap:"contractV1PublicGetDepth"});t!==void 0&&(n.size=t);const o=await this[a](this.extend(n,s));let d,c;return i.type==="swap"?(d=this.safeValue(o,"data"),c=this.safeInteger(d,"time")):(d=o,c=this.safeTimestamp(o,"timestamp")),this.parseOrderBook(d,e,c)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.spotV1PublicGetAllTicker(t),i={},n={},r=this.ids;for(let o=0;o<r.length;o++){const d=r[o],c=d.replace("_","");n[c]=d}const a=Object.keys(s);for(let o=0;o<a.length;o++){const d=this.safeValue(n,a[o]),c=this.safeMarket(d,void 0,"_");if(c!==void 0){const u=c.symbol,h=this.safeValue(s,a[o]);h!==void 0&&(i[u]=this.parseTicker(h,c))}}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={},n=s.swap?"symbol":"market";i[n]=s.id;const r=this.getSupportedMapping(s.type,{spot:"spotV1PublicGetTicker",swap:"contractV1PublicGetTicker"}),a=await this[r](this.extend(i,t));let o;if(s.type==="swap"){o={};const d=this.safeValue(a,"data"),c=this.safeValue(d,s.id,[]);for(let u=0;u<c.length;u++)o.open=this.safeValue(c,0),o.high=this.safeValue(c,1),o.low=this.safeValue(c,2),o.last=this.safeValue(c,3),o.vol=this.safeValue(c,4),o.riseRate=this.safeValue(c,5)}else o=this.safeValue(a,"ticker",{}),o.date=this.safeValue(a,"date");return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date",this.milliseconds()),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}parseOHLCV(e,t=void 0){return t.swap?e.length>5?[this.safeTimestamp(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]:[this.safeTimestamp(e,4),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),void 0]:[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.swap,o=r.spot,d=this.safeValue(this.options,"timeframes",{}),c=this.safeValue(d,r.type,{}),u=this.safeString(c,t);if(u===void 0)throw new Vu(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");i===void 0&&(i=1e3);const h={size:i},f=a?"symbol":"market";h[f]=r.id;const l=a?"period":"type";h[l]=u;const m=this.safeString(n,"price");n=this.omit(n,"price");let g=this.getSupportedMapping(r.type,{spot:"spotV1PublicGetKline",swap:"contractV1PublicGetKline"});a?m==="mark"?g="contractV1PublicGetMarkKline":m==="index"&&(g="contractV1PublicGetIndexKline"):o&&s!==void 0&&(h.since=s);const y=await this[g](this.extend(h,n)),w=this.safeValue(y,"data",[]);return this.parseOHLCVs(w,r,t,s,i)}parseTrade(e,t=void 0){const s=t.swap?"side":"trade_type";let i=this.safeString(e,s),n;const r=this.safeValue(e,"maker");r!==void 0&&(n=r?"maker":"taker"),t.spot?i=i==="bid"?"buy":"sell":i==="3"?i="sell":i==="4"||i==="1"?i="buy":i==="2"&&(i="sell");let a;t.swap?a=this.safeInteger(e,"createTime"):a=this.safeTimestamp(e,"date");const o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;const u=this.safeString(e,"feeAmount");if(u!==void 0){const h=this.safeString(e,"feeCurrency");c={cost:u,currency:this.safeCurrencyCode(h)}}return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:this.safeString(e,"tid"),timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:void 0,side:i,order:this.safeString(e,"orderId"),takerOrMaker:n,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new lt(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a={};s!==void 0&&(a.pageSize=s),t!==void 0&&(a.startTime=t);const o=r?"symbol":"market";a[o]=n.id,r&&i.pageNum===void 0&&(a.pageNum=1);const d=this.getSupportedMapping(n.type,{spot:"spotV1PublicGetTrades",swap:"contractV2PrivateGetTradeTradeHistory"});let c=await this[d](this.extend(a,i));if(r){const u=this.safeValue(c,"data");c=this.safeValue(u,"list")}return this.parseTrades(c,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r),c=a.swap,u=a.spot,h=this.safeString(r,"timeInForce");let f=this.safeValue(r,"reduceOnly");const l=this.safeValue2(r,"triggerPrice","stopPrice"),m=this.safeValue(r,"stopLossPrice"),g=this.safeValue(r,"takeProfitPrice"),y=m!==void 0,w=g!==void 0,b=l!==void 0;if(this.sum(y,w,b))throw new we(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const S=y||w||b;if(S&&u)throw new we(this.id+" createOrder() it is not possible to make a stop order on spot markets");if(t==="market")throw new Ce(this.id+" createOrder() on "+a.type+" markets does not allow market orders");let v=this.getSupportedMapping(a.type,{spot:"spotV1PrivateGetOrder",margin:"spotV1PrivateGetOrder",swap:"contractV2PrivatePostTradeOrder"});const T={amount:this.amountToPrecision(e,i)};if(u){const N=this.safeInteger(r,"orderType",t)===1,B=this.isPostOnly(!1,N,r);T.tradeType=s==="buy"?1:0,T.currency=a.id,B?T.orderType=1:h==="IOC"&&(T.orderType=2),n!==void 0&&(T.price=this.priceToPrecision(e,n)),o!==void 0&&(o==="isolated"?T.acctType=1:o==="cross"&&(T.acctType=2))}else if(c){const N=this.safeInteger(r,"action",t)===4,B=this.isPostOnly(!1,N,r);(y||w)&&(f=!0),f?T.side=0:T.side=s==="buy"?5:6,S?(v="contractV2PrivatePostTradeOrderAlgo",y?(T.orderType=2,T.bizType=2,T.triggerPrice=this.priceToPrecision(e,m)):w?(T.orderType=2,T.bizType=1,T.triggerPrice=this.priceToPrecision(e,g)):b&&(T.orderType=1,T.triggerPrice=this.priceToPrecision(e,l)),T.algoPrice=this.priceToPrecision(e,n),T.pricetype=2):h==="IOC"?T.action=3:B?T.action=4:h==="FOK"?T.action=5:t==="limit"?T.action=1:T.action=t,n!==void 0&&(T.price=this.priceToPrecision(e,n)),T.symbol=a.id;const x=this.safeString(r,"clientOrderId");x!==void 0&&(T.clientOrderId=x);const k=this.safeValue(r,"extend",void 0);k!==void 0&&(T.extend=k)}r=this.omit(d,["takeProfitPrice","stopLossPrice","stopPrice","reduceOnly","orderType","triggerPrice","priceType","clientOrderId","extend"]);const I=await this[v](this.extend(T,r));let A=I;return c&&!S&&(A=this.safeValue(I,"data")),this.parseOrder(A,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new lt(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r={},a=n?"symbol":"currency";r[a]=this.marketId(t);const o=n?"orderId":"id";r[o]=e.toString();const d=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetCancelOrder",swap:"contractV2PrivatePostTradeCancelOrder"}),c=await this[d](this.extend(r,s));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new lt(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=this.safeValue(t,"stop");if(s.spot)throw new Vu(this.id+" cancelAllOrders() is not supported on "+s.type+" markets");const n={symbol:s.id};let r="contractV2PrivatePostTradeCancelAllOrders";i&&(r="contractV2PrivatePostTradeCancelAlgos");const a=this.omit(t,"stop");return await this[r](this.extend(n,a))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new lt(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(this.safeInteger(s,"orderType")!==void 0)throw new we(this.id+" fetchOrder() it is not possible to fetch a single conditional order, use fetchOrders() instead");const r=i.swap,a={},o=r?"symbol":"currency";a[o]=this.marketId(t);const d=r?"orderId":"id";a[d]=e.toString();const c=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetGetOrder",swap:"contractV2PrivateGetTradeGetOrder"}),u=await this[c](this.extend(a,s));let h=u;return r&&(h=this.safeValue(u,"data")),this.parseOrder(h,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new lt(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={pageSize:s},d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetAllOrders"});"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew"),r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos");const h=await this[u](this.extend(o,i));let f=h;if(a){const l=this.safeValue(h,"data",{});f=this.safeValue(l,"list",[])}return this.parseOrders(f,n,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new lt(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"reduceOnly"),a=this.safeValue(i,"stop"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1;let u="spotV1PrivateGetGetOrdersIgnoreTradeType";if(a){u="contractV2PrivateGetTradeGetOrderAlgos";const m=this.safeInteger(i,"orderType");if(m===void 0)throw new lt(this.id+" fetchCanceledOrders() requires an orderType parameter for stop orders");const g=this.safeValue(i,"side"),y=this.safeInteger(i,"bizType");g==="sell"&&r?o.side=3:g==="buy"&&r?o.side=4:g==="buy"?o.side=1:g==="sell"?o.side=2:g===5?o.side=5:g===6?o.side=6:g===0&&(o.side=0),m===1?o.orderType=1:(m===2||y)&&(o.orderType=2,o.bizType=y),o.status=2}"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");let h;try{h=await this[u](this.extend(o,i))}catch(m){if(m instanceof Kr)return[];throw m}const f=this.omit(i,["reduceOnly","stop","side","orderType","bizType"]);if(h=await this[u](this.extend(o,f)),a){const m=this.safeValue(h,"data",{});h=this.safeValue(m,"list",[])}const l=[];if(n.type==="spot"){for(let m=0;m<h.length;m++){const g=h[m];this.safeString(g,"status")==="1"&&l.push(g)}h=l}return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new lt(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a=this.safeInteger(i,"orderType"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1,r&&t!==void 0&&(o.startTime=t);const u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetFinishedAndPartialOrders",swap:"contractV2PrivateGetTradeGetOrderAlgos"});if(r&&a===void 0)throw new we(this.id+" fetchClosedOrders() can not fetch swap orders, use fetchOrders instead");r&&(o.status=5);const h=await this[u](this.extend(o,i));let f=h;if(r){const l=this.safeValue(h,"data",{});f=this.safeValue(l,"list",[])}return this.parseOrders(f,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new lt(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={};s!==void 0&&(o.pageSize=s);const d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&t!==void 0&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetUndoneOrders"});r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos",o.status=1),"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");const h=await this[u](this.extend(o,i));let f=h;if(a){const l=this.safeValue(h,"data",{});f=this.safeValue(l,"list",[])}return this.parseOrders(f,n,t,s)}parseOrder(e,t=void 0){let s=t.swap?this.safeString2(e,"orderId","data"):this.safeString(e,"id");s===void 0&&(s=this.safeValue(e,"id"));let i=this.safeInteger2(e,"type","side");i===void 0?i=void 0:t.spot?i=i===1?"buy":"sell":t.swap&&(i===0?i=void 0:i===1||i===4||i===5?i="buy":(i===2||i===3||i===6)&&(i="sell"));let n=this.safeInteger(e,"trade_date");n===void 0&&(n=this.safeInteger(e,"createTime"));const r=this.safeString(e,"currency");t=this.safeMarket(r,t,"_");const a=this.safeString2(e,"price","algoPrice"),o=t.swap?this.safeString(e,"tradeAmount"):this.safeString(e,"trade_amount");let d=this.safeString(e,"total_amount");d===void 0&&(d=this.safeString(e,"amount"));const c=this.safeString(e,"trade_money"),u=this.parseOrderStatus(this.safeString(e,"status"),t),h=this.safeString(e,"timeInForce"),f=h==="PO",l=this.safeNumber(e,"fees");let m;if(l!==void 0){let g;this.safeValue(e,"useZbFee")===!0?g="ZB":g=i==="sell"?t.quote:t.base,m={cost:l,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:this.safeString(e,"userId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:t.symbol,type:"limit",timeInForce:h,postOnly:f,side:i,price:a,stopPrice:this.safeNumber(e,"triggerPrice"),triggerPrice:this.safeNumber(e,"triggerPrice"),average:this.safeString(e,"avgPrice"),cost:c,amount:d,filled:o,remaining:void 0,status:u,fee:m,trades:void 0},t)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={0:"open",1:"canceled",2:"closed",3:"open"}:s={1:"open",2:"canceled",3:"open",4:"rejected",5:"closed"},this.safeString(s,e,e)}parseTransactionStatus(e){const t={0:"pending",1:"failed",2:"ok",3:"canceled",5:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"hash"),n=this.safeNumber(e,"amount");let r=this.parse8601(this.safeString(e,"submit_time"));r=this.safeInteger(e,"submitTime",r);let a=this.safeString2(e,"toAddress","address"),o;if(a!==void 0){const y=a.split("_");a=this.safeString(y,0),o=this.safeString(y,1)}const d=this.safeInteger(e,"confirmTimes"),c=this.safeInteger(e,"manageTime");let u;const h=this.safeString(e,"currency"),f=this.safeCurrencyCode(h,t);a!==void 0&&(u=d===void 0?"withdrawal":"deposit");const l=this.parseTransactionStatus(this.safeString(e,"status"));let m;const g=this.safeNumber(e,"fees");return g!==void 0&&(m={cost:g,currency:f}),{info:e,id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:a,addressTo:a,tagFrom:void 0,tag:o,tagTo:o,type:u,amount:n,currency:f,status:l,updated:c,fee:m}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new lt(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new Ks(this.id+" setLeverage() leverage should be between 1 and 125");const i=this.market(t);let n;if(i.swap)n=1;else throw new Gp(this.id+" setLeverage() supports swap contracts only");const r={symbol:i.id,leverage:e,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetLeverage(this.extend(r,s))}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const u=this.market(e);e=u.symbol,n.symbol=u.id}t!==void 0&&(n.startTime=t);const r=this.safeInteger2(i,"until","till");i=this.omit(i,["endTime","till","until"]),r!==void 0&&(n.endTime=r),s!==void 0&&(n.limit=s);const a=await this.contractV2PublicGetFundingRate(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],f=this.safeString(h,"symbol"),l=this.safeSymbol(f),m=this.safeInteger(h,"fundingTime");d.push({info:h,symbol:l,fundingRate:this.safeNumber(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Gp(this.id+" fetchFundingRate() does not supports contracts only");const i={symbol:s.id},n=await this.contractV1PublicGetFundingRate(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber2(e,"fundingRate","lastFundingRate"),r=this.parse8601(this.safeString(e,"nextCalculateTime")),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeString(e,"markPrice"),indexPrice:this.safeString(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:n,fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:void 0,nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.contractV2PublicGetPremiumIndex(t),i=this.safeValue(s,"data",[]),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeString(n,"safePwd",this.password);if(r===void 0)throw new lt(this.id+" withdraw() requires exchange.password or a safePwd parameter");const a=this.safeNumber(n,"fees");if(a===void 0)throw new lt(this.id+" withdraw() requires a fees parameter");this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+="_"+i);const d={amount:this.currencyToPrecision(e,t),currency:o.id,fees:this.currencyToPrecision(e,a),method:"withdraw",receiveAddr:s,safePwd:r},c=await this.spotV1PrivateGetWithdraw(this.extend(d,n)),u=this.parseTransaction(c,o);return this.extend(u,{type:"withdrawal",address:s,addressTo:s,amount:t})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetWithdrawRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetChargeRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchPosition(e,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={futuresAccountType:1},n=await this.contractV2PrivateGetPositionsGetPositions(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={futuresAccountType:1},i=await this.contractV2PrivateGetPositionsGetPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parsePositions(n,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"marketName");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"amount"),r=this.safeNumber(e,"avgPrice"),a=this.safeString(e,"margin"),d=this.safeString(e,"side")==="1"?"long":"short",u=this.safeString(e,"marginMode")==="1"?"isolated":"cross",h=this.safeString(e,"leverage"),f=this.safeNumber(e,"liquidatePrice"),l=this.safeNumber(e,"unrealizedPnl"),m=this.safeNumber(e,"maintainMargin"),g=this.safeNumber(e,"marginRate"),y=this.safeNumber(e,"nominalValue"),w=H8.stringMul(this.safeString(e,"returnRate"),"100"),b=this.safeNumber(e,"createTime");return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(n),contractSize:void 0,entryPrice:r,collateral:void 0,side:d,unrealizedProfit:l,leverage:this.parseNumber(h),percentage:w,marginMode:u,notional:y,markPrice:void 0,liquidationPrice:f,initialMargin:this.parseNumber(a),initialMarginPercentage:void 0,maintenanceMargin:m,maintenanceMarginPercentage:void 0,marginRatio:g,timestamp:b,datetime:this.iso8601(b)}}parseLedgerEntryType(e){const t={1:"realized pnl",2:"commission",3:"funding fee subtract",4:"funding fee addition",5:"insurance clear",6:"transfer in",7:"transfer out",8:"margin addition",9:"margin subtraction",10:"commission addition",11:"bill type freeze",12:"bill type unfreeze",13:"system take over margin",14:"transfer",15:"realized pnl collection",16:"funding fee collection",17:"recommender return commission",18:"by level subtract positions",19:"system add",20:"system subtract",23:"trading competition take over fund",24:"trading contest tickets",25:"return of trading contest tickets",26:"experience expired recall",50:"test register gift",51:"register gift",52:"deposit gift",53:"trading volume gift",54:"awards gift",55:"trading volume gift",56:"awards gift expire",201:"open positions",202:"close positions",203:"take over positions",204:"trading competition take over positions",205:"one way open long",206:"one way open short",207:"one way close long",208:"one way close short",301:"coupon deduction service charge",302:"experience deduction",303:"experience expired"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"createTime");let i;this.safeNumber(e,"isIn")===1?i="increase":i="reduce";let r;const a=this.safeNumber(e,"fee");return a!==void 0&&(r={cost:a,currency:this.safeCurrencyCode(this.safeString(e,"unit"))}),{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),direction:i,account:this.safeString(e,"userId"),referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeInteger(e,"type")),currency:this.safeCurrencyCode(this.safeString(e,"unit")),amount:this.safeNumber(e,"changeAmount"),before:this.safeNumber(e,"beforeAmount"),after:this.safeNumber(e,"available"),status:void 0,fee:r}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new lt(this.id+" fetchLedger() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={futuresAccountType:1};e!==void 0&&(r.currencyName=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.pageSize=s);const a=await this.contractV2PrivateGetFundGetBill(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseLedger(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const[r,a]=this.handleMarketTypeAndParams("transfer",void 0,n),[o,d]=this.handleMarginModeAndParams("transfer",a),c=this.currency(e),u=r==="swap",h=this.currencyToPrecision(e,t),f={amount:h};let l,m;if(u)l="contractV2PrivatePostFundTransferFund",s==="spot"||i==="future"?m=1:m=0,f.currencyName=c.id,f.clientId=this.safeString(n,"clientId"),f.side=m;else{if(o==="isolated"||i==="isolated"||s==="isolated"){s==="spot"||i==="isolated"?l="spotV1PrivateGetTransferInLever":l="spotV1PrivateGetTransferOutLever";const y=this.safeString2(n,"marketName","symbol");if(y===void 0)throw new lt(this.id+" transfer() requires a symbol argument for isolated margin");const w=this.market(y);f.marketName=this.safeSymbol(w.id,w,"_")}else(o==="cross"||i==="cross"||s==="cross")&&(s==="spot"||i==="cross"?l="spotV1PrivateGetTransferInCross":l="spotV1PrivateGetTransferOutCross");f.coin=c.id}const g=await this[l](this.extend(f,d));return this.extend(this.parseTransfer(g,c),{amount:this.parseNumber(h),fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"data"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,"currency"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async modifyMarginHelper(e,t,s,i={}){if(i.positionsId===void 0)throw new lt(this.id+" modifyMarginHelper() requires a positionsId argument in the params");await this.loadMarkets();const n=this.market(e);t=this.amountToPrecision(e,t);const a={positionsId:this.safeString(i,"positionsId"),amount:t,type:s,futuresAccountType:1},o=await this.contractV2PrivatePostPositionsUpdateMargin(this.extend(a,i));return this.extend(this.parseMarginModification(o,n),{amount:this.parseNumber(t)})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",{}),n=this.safeInteger(s,"side")===1?"add":"reduce",a=this.safeInteger(s,"status")===1?"ok":"failed";return{info:e,type:n,amount:void 0,code:t.quote,symbol:t.symbol,status:a}}async addMargin(e,t,s={}){if(s.positionsId===void 0)throw new lt(this.id+" addMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){if(s.positionsId===void 0)throw new lt(this.id+" reduceMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,0,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotV1PrivateGetGetLoans(this.extend(i,t)),r=this.milliseconds(),a=this.safeValue(n,"result",[]),o=this.safeValue(a,0,{});return{currency:this.safeCurrencyCode(this.safeString(o,"coinName")),rate:this.safeNumber(o,"interestRateOfDay"),period:this.safeNumber(o,"repaymentDay"),timestamp:r,datetime:this.iso8601(r),info:o}}async fetchBorrowRates(e={}){if(e.coin===void 0)throw new lt(this.id+" fetchBorrowRates() requires a coin argument in the params");await this.loadMarkets();const s={coin:this.currency(this.safeString(e,"coin")).id},i=await this.spotV1PrivateGetGetLoans(this.extend(s,e)),n=this.milliseconds(),r=this.safeValue(i,"result",[]),a=[];for(let o=0;o<r.length;o++){const d=r[o];a.push({currency:this.safeCurrencyCode(this.safeString(d,"coinName")),rate:this.safeNumber(d,"interestRateOfDay"),period:this.safeNumber(d,"repaymentDay"),timestamp:n,datetime:this.iso8601(n),info:d})}return a}async setPositionMode(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new lt(this.id+" setPositionMode() requires a symbol argument");const i=this.market(t);let n;if(i.swap)n=1;else throw new Gp(this.id+" setPositionMode() supports swap contracts only");const r={marketId:i.id,positionMode:e?2:1,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetPositionsMode(this.extend(r,s))}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);let r;[r,i]=this.handleMarginModeAndParams("borrowMargin",i),r===void 0&&(s!==void 0?r="isolated":r="cross");const a=this.safeString(i,"safePwd",this.password),o=this.currency(e),d={coin:o.id,amount:this.currencyToPrecision(e,t),safePwd:a};let c;if(r==="isolated"){if(s===void 0)throw new lt(this.id+" borrowMargin() requires a symbol argument for isolated margin");const f=this.market(s);d.marketName=this.safeSymbol(f.id,f,"_"),c="spotV1PrivateGetBorrow"}else r==="cross"&&(c="spotV1PrivateGetDoCrossLoan");const u=await this[c](this.extend(d,i)),h=this.parseMarginLoan(u,o);return this.extend(h,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o,d]=t;let c=this.implodeHostname(this.urls.api[a][o][d]);if(d==="public")e==="getFeeInfo"?c=this.implodeHostname(this.urls.api[a][o].private)+"/"+e:c+="/"+o+"/"+e,Object.keys(i).length&&(c+="?"+this.urlencode(i));else if(a==="contract"){const u=this.milliseconds(),h=this.iso8601(u);let f=h+s+"/Server/api/"+o+"/"+e;if(i=this.keysort(i),n={"ZB-APIKEY":this.apiKey,"ZB-TIMESTAMP":h},c+="/"+o+"/"+e,s==="POST")n["Content-Type"]="application/json",r=this.json(i),f+=this.urlencode(i);else if(Object.keys(i).length){const g=this.urlencode(i);c+="?"+g,f+=g}const l=this.hash(this.encode(this.secret),"sha1"),m=this.hmac(this.encode(f),this.encode(l),"sha256","base64");n["ZB-SIGN"]=m}else{let u=this.keysort(this.extend({method:e,accesskey:this.apiKey},i));const h=this.nonce();u=this.keysort(u);const f=this.rawencode(u),l=this.hash(this.encode(this.secret),"sha1"),m=this.hmac(this.encode(f),this.encode(l),"md5"),g="sign="+m+"&reqTime="+h.toString();c+="/"+e+"?"+f+"&"+g}return{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;if(this.throwBroadlyMatchedException(this.exceptions.broad,r,c),"code"in a){const h=this.safeString(a,"code");if(this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!=="1000"&&h!=="10000")throw new we(c)}const u=this.safeValue(a,"result");if(u!==void 0&&!u)throw this.safeString(a,"message")==="\u670D\u52A1\u7AEF\u5FD9\u788C"?new Xr(c):new we(c)}}};const G8=Ah;var U8=class extends G8{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};class $T extends Array{constructor(e=void 0){super(),Object.defineProperty(this,"maxSize",{__proto__:null,value:e,writable:!0})}clear(){this.length=0}}class WT extends $T{constructor(e=void 0){super(e),Object.defineProperty(this,"nestedNewUpdatesBySymbol",{__proto__:null,value:!1,writable:!0}),Object.defineProperty(this,"newUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"clearUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"allNewUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearAllUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){let s;return e===void 0?(s=this.allNewUpdates,this.clearAllUpdates=!0):(s=this.newUpdatesBySymbol[e],s!==void 0&&this.nestedNewUpdatesBySymbol&&(s=s.size),this.clearUpdatesBySymbol[e]=!0),s===void 0?t:t!==void 0?Math.min(s,t):s}append(e){this.maxSize&&this.length===this.maxSize&&this.shift(),this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol]=0),this.newUpdatesBySymbol[e.symbol]=(this.newUpdatesBySymbol[e.symbol]||0)+1,this.allNewUpdates=(this.allNewUpdates||0)+1}}class $8 extends $T{constructor(e=void 0){super(e),Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"sizeTracker",{__proto__:null,value:new Set,writable:!0}),Object.defineProperty(this,"newUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){return this.clearUpdates=!0,t===void 0?this.newUpdates:Math.min(this.newUpdates,t)}append(e){if(e[0]in this.hashmap){const t=this.hashmap[e[0]];if(t!==e)for(const s in e)t[s]=e[s]}else{if(this.hashmap[e[0]]=e,this.maxSize&&this.length===this.maxSize){const t=this.shift();delete this.hashmap[t[0]]}this.push(e)}this.clearUpdates&&(this.clearUpdates=!1,this.sizeTracker.clear()),this.sizeTracker.add(e[0]),this.newUpdates=this.sizeTracker.size}}class W8 extends WT{constructor(e=void 0){super(e),this.nestedNewUpdatesBySymbol=!0,Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0})}append(e){const t=this.hashmap[e.symbol]=this.hashmap[e.symbol]||{};if(e.id in t){const r=t[e.id];if(r!==e)for(const o in e)r[o]=e[o];e=r;const a=this.findIndex(o=>o.id===e.id);this.splice(a,1)}else t[e.id]=e;if(this.maxSize&&this.length===this.maxSize){const r=this.shift();delete this.hashmap[r.symbol][r.id]}this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.newUpdatesBySymbol[e.symbol]===void 0&&(this.newUpdatesBySymbol[e.symbol]=new Set),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol].clear());const s=this.newUpdatesBySymbol[e.symbol],i=s.size;s.add(e.id);const n=s.size;this.allNewUpdates=(this.allNewUpdates||0)+(n-i)}}var Pe={ArrayCache:WT,ArrayCacheByTimestamp:$8,ArrayCacheBySymbolById:W8};const z8=rT,{ExchangeError:j8,AuthenticationError:K8}=Q,{ArrayCache:X8,ArrayCacheBySymbolById:Jk,ArrayCacheByTimestamp:Y8}=Pe;var Z8=class extends z8{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchPosition:!1},urls:{api:{ws:{crypto:"wss://stream.data.alpaca.markets/v1beta2/crypto",trading:"wss://api.alpaca.markets/stream"}},test:{ws:{crypto:"wss://stream.data.alpaca.markets/v1beta2/crypto",trading:"wss://paper-api.alpaca.markets/stream"}}},options:{},streaming:{},exceptions:{ws:{exact:{}}}})}async watchTicker(e,t={}){const s=this.urls.api.ws.crypto;await this.authenticate(s),await this.loadMarkets();const i=this.market(e),n="ticker:"+i.symbol,r={action:"subscribe",quotes:[i.id]};return await this.watch(s,n,this.extend(r,t),n)}handleTicker(e,t){const s=this.parseTicker(t),i=s.symbol,n="ticker:"+i;this.tickers[i]=s,e.resolve(this.tickers[i],n)}parseTicker(e,t=void 0){const s=this.safeString(e,"S"),i=this.safeString(e,"t");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:this.parse8601(i),datetime:i,high:void 0,low:void 0,bid:this.safeString(e,"bp"),bidVolume:this.safeString(e,"bs"),ask:this.safeString(e,"ap"),askVolume:this.safeString(e,"as"),vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.urls.api.ws.crypto;await this.authenticate(r),await this.loadMarkets();const a=this.market(e);e=a.symbol;const o={action:"subscribe",bars:[a.id]},d="ohlcv:"+e,c=await this.watch(r,d,this.extend(o,n),d);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s);let n=this.safeValue(this.ohlcvs,i);if(n===void 0){const o=this.safeInteger(this.options,"OHLCVLimit",1e3);n=new Y8(o),this.ohlcvs[i]=n}const r=this.parseOHLCV(t);n.append(r);const a="ohlcv:"+i;e.resolve(n,a)}async watchOrderBook(e,t=void 0,s={}){const i=this.urls.api.ws.crypto;await this.authenticate(i),await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="orderbook:"+e,a={action:"subscribe",orderbooks:[n.id]};return(await this.watch(i,r,this.extend(a,s),r)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s),n=this.safeString(t,"t"),r=this.parse8601(n),a=this.safeValue(t,"r",!1);let o=this.safeValue(this.orderbooks,i);if(o===void 0&&(o=this.orderBook()),a){const c=this.parseOrderBook(t,i,r,"b","a","p","s");o.reset(c)}else{const c=this.safeValue(t,"a",[]),u=this.safeValue(t,"b",[]);this.handleDeltas(o.asks,c),this.handleDeltas(o.bids,u),o.timestamp=r,o.datetime=n}const d="orderbook:"+i;this.orderbooks[i]=o,e.resolve(o,d)}handleDelta(e,t){const s=this.parseBidAsk(t,"p","s");e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){const n=this.urls.api.ws.crypto;await this.authenticate(n),await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="trade:"+e,o={action:"subscribe",trades:[r.id]},d=await this.watch(n,a,this.extend(o,i),a);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s);let n=this.safeValue(this.trades,i);if(n===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);n=new X8(o),this.trades[i]=n}const r=this.parseTrade(t);n.append(r);const a="trade:"+i;e.resolve(n,a)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.urls.api.ws.trading;await this.authenticate(n);let r="myTrades";await this.loadMarkets(),e!==void 0&&(e=this.symbol(e),r+=":"+e);const a={action:"listen",data:{streams:["trade_updates"]}},o=await this.watch(n,r,this.extend(a,i),r);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.urls.api.ws.trading;await this.authenticate(n),await this.loadMarkets();let r="orders";e!==void 0&&(e=this.market(e).symbol,r="orders:"+e);const a={action:"listen",data:{streams:["trade_updates"]}},o=await this.watch(n,r,this.extend(a,i),r);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleTradeUpdate(e,t){this.handleOrder(e,t),this.handleMyTrade(e,t)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"order",{});if(this.orders===void 0){const o=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new Jk(o)}const n=this.orders,r=this.parseOrder(i);n.append(r);let a="orders";e.resolve(n,a),a="orders:"+r.symbol,e.resolve(n,a)}handleMyTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"event");if(i!=="fill"&&i!=="partial_fill")return;const n=this.safeValue(s,"order",{});let r=this.myTrades;if(r===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);r=new Jk(d)}const a=this.parseMyTrade(n);r.append(a);let o="myTrades:"+a.symbol;e.resolve(r,o),o="myTrades",e.resolve(r,o)}parseMyTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"filled_at");let n=this.safeString(e,"type");return n.indexOf("limit")>=0&&(n="limit"),this.safeTrade({id:this.safeString(e,"i"),info:e,timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,void 0,"/"),order:this.safeString(e,"id"),type:n,side:this.safeString(e,"side"),takerOrMaker:n==="market"?"taker":"maker",price:this.safeString(e,"filled_avg_price"),amount:this.safeString(e,"filled_qty"),cost:void 0,fee:void 0},t)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");let r={action:"auth",key:this.apiKey,secret:this.secret};e===this.urls.api.ws.trading&&(r={action:"authenticate",data:{key_id:this.apiKey,secret_key:this.secret}}),this.spawn(this.watch,e,s,r,s,n)}return await n}handleErrorMessage(e,t){const s=this.safeString(t,"code"),i=this.safeValue(t,"msg",{});throw new j8(this.id+" code: "+s+" message: "+i)}handleConnected(e,t){return t}handleCryptoMessage(e,t){for(let s=0;s<t.length;s++){const i=t[s],n=this.safeString(i,"T"),r=this.safeValue(i,"msg",{});if(n==="subscription")return this.handleSubscription(e,i);if(n==="success"&&r==="connected")return this.handleConnected(e,i);if(n==="success"&&r==="authenticated")return this.handleAuthenticate(e,i);const a={error:this.handleErrorMessage,b:this.handleOHLCV,q:this.handleTicker,t:this.handleTrades,o:this.handleOrderBook},o=this.safeValue(a,n);o!==void 0&&o.call(this,e,i)}}handleTradingMessage(e,t){const s=this.safeString(t,"stream"),i={authorization:this.handleAuthenticate,listening:this.handleSubscription,trade_updates:this.handleTradeUpdate},n=this.safeValue(i,s);n!==void 0&&n.call(this,e,t)}handleMessage(e,t){if(Array.isArray(t))return this.handleCryptoMessage(e,t);this.handleTradingMessage(e,t)}handleAuthenticate(e,t){const s=this.safeString(t,"T"),i=this.safeValue(t,"data",{}),n=this.safeString(i,"status");if(s==="success"||n==="authorized"){e.resolve(t,"authenticated");return}throw new K8(this.id+" failed to authenticate.")}handleSubscription(e,t){return t}};const Q8=aT,{AuthenticationError:J8}=Q,{ArrayCache:eH,ArrayCacheByTimestamp:tH,ArrayCacheBySymbolById:sH}=Pe;var iH=class extends Q8{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ascendex.com:443/api/pro/v2/stream",private:"wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream"}},test:{ws:{public:"wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream",private:"wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,categoriesAccount:{cash:"spot",futures:"swap",margin:"margin"}}})}async watchPublic(e,t={}){const s=this.urls.api.ws.public,n={id:this.nonce().toString(),op:"sub"},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t,s={}){await this.loadAccounts();const i=this.safeString(this.options,"account-group");let n=this.urls.api.ws.private;n=this.implodeParams(n,{accountGroup:i});const a={id:this.nonce().toString(),op:"sub",ch:e},o=this.extend(a,s);return await this.authenticate(n,s),await this.watch(n,t,o,e)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol,(i===void 0||i>1440)&&(i=100);const a=this.timeframes[t],o="bar:"+a+":"+r.id;n={ch:o};const d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeSymbol(s),n=this.safeString(t,"m"),r=this.safeValue(t,"data",{}),a=this.safeString(r,"i"),o=n+":"+a+":"+s,d=this.findTimeframe(a),c=this.market(i),u=this.parseOHLCV(t,c);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let h=this.safeValue(this.ohlcvs[i],d);if(h===void 0){const f=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new tH(f),this.ohlcvs[i][d]=h}return h.append(u),e.resolve(h,o),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades:"+n.id;i=this.extend(i,{ch:r});const a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+s,a=this.market(i);let o=this.safeValue(t,"data");o===void 0&&(o=[]);const d=this.parseTrades(o,a);let c=this.safeValue(this.trades,i);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new eH(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[i]=c,e.resolve(c,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="depth-realtime:"+i.id;return s=this.extend(s,{ch:n}),(await this.watchPublic(n,s)).limit()}async watchOrderBookSnapshot(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="depth-snapshot-realtime",r=n+":"+i.id;return s=this.extend(s,{action:n,args:{symbol:i.id},op:"req"}),(await this.watchPublic(r,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+i,a=this.orderbooks[i],o=this.safeValue(t,"data"),d=this.parseOrderBook(o,i);d.nonce=this.safeInteger(o,"seqnum"),a.reset(d);const c=a.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,a)}this.orderbooks[i]=a,e.resolve(a,r)}handleOrderBook(e,t){const s=this.safeString(t,"m"),i=this.safeString(t,"symbol"),n=this.safeSymbol(i),r=s+":"+i;let a=this.safeValue(this.orderbooks,n);a===void 0&&(a=this.orderBook({})),a.nonce===void 0?a.cache.push(t):(this.handleOrderBookMessage(e,t,a),e.resolve(a,r))}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"seqnum");if(n>s.nonce){const r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a),s.nonce=n;const o=this.safeInteger(i,"ts");s.timestamp=o,s.datetime=this.iso8601(o)}return s}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let i,n;if(t==="spot"||t==="margin"){const r=this.safeValue(this.options,"accountCategories",{});let a=this.safeString(r,t,"cash");a=a.toUpperCase(),i="order:"+a,n="balance:"+t}else i="futures-account-update",n="balance:swap";return await this.watchPrivate(i,n,s)}handleBalance(e,t){const s=this.safeString(t,"m");let i,n;if(s==="order"||s==="futures-order"){const a=this.safeValue(t,"data"),o=this.safeString(a,"s"),d=this.safeMarket(o),c=this.account();c.free=this.safeString(a,"bab"),c.total=this.safeString(a,"btb");const u=this.account();u.free=this.safeString(a,"qab"),u.total=this.safeString(a,"qtb"),d.contract?(n="swap",i=this.safeValue(this.balance,n,{})):(n=d.type,i=this.safeValue(this.balance,n,{})),i[d.base]=c,i[d.quote]=u}else{const a=this.safeStringLower2(t,"ac","at"),o=this.safeValue(this.options,"categoriesAccount");n=this.safeString(o,a,"spot"),i=this.safeValue(this.balance,n,{});const d=this.safeValue(t,"data");let c;d===void 0?c=this.safeValue(t,"col"):c=[d];for(let u=0;u<c.length;u++){const h=c[u],f=this.safeCurrencyCode(this.safeString(h,"a")),l=this.account();l.free=this.safeString(h,"ab"),l.total=this.safeString2(h,"tb","b"),i[f]=l}}const r="balance:"+n;e.resolve(this.safeBalance(i),r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);let o,d;if(r!=="spot")d="futures-order",o="order:FUTURES";else{const u=this.safeValue(this.options,"accountCategories",{});let h=this.safeString(u,r,"cash");h=h.toUpperCase(),o="order:"+h,d=o}e!==void 0&&(o=o+":"+e);const c=await this.watchPrivate(d,o,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const s=this.safeString(t,"ac"),i="order:"+s,n=this.safeValue(t,"data",t),r=this.parseWsOrder(n);if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new sH(d)}const a=this.orders;a.append(r);const o=i+":"+r.symbol;e.resolve(a,o),e.resolve(a,i)}parseWsOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"st")),i=this.safeString(e,"s"),n=this.safeInteger(e,"t"),r=this.safeSymbol(i,t,"/"),a=this.safeInteger(e,"t"),o=this.safeString(e,"p"),d=this.safeString(e,"q"),c=this.safeString(e,"ap"),u=this.safeString(e,"cfq"),h=this.safeString(e,"orderId"),f=this.safeStringLower(e,"ot"),l=this.safeStringLower(e,"sd"),m=this.safeNumber(e,"cf");let g;if(m!==void 0){const w=this.safeString(e,"fa"),b=this.safeCurrencyCode(w);g={cost:m,currency:b}}const y=this.parseNumber(this.omitZero(this.safeString(e,"sp")));return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:a,symbol:r,type:f,timeInForce:void 0,postOnly:void 0,side:l,price:o,stopPrice:y,triggerPrice:y,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:g,trades:void 0},t)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}return!1}catch(i){if(i instanceof J8){const n="authenticated";e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n]}else e.reject(i);return!0}}handleAuthenticate(e,t){const s="authenticated";e.resolve(t,s)}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"m"),i={ping:this.handlePing,auth:this.handleAuthenticate,sub:this.handleSubscriptionStatus,"depth-realtime":this.handleOrderBook,"depth-snapshot-realtime":this.handleOrderBookSnapshot,trades:this.handleTrades,bar:this.handleOHLCV,balance:this.handleBalance,"futures-account-update":this.handleBalance},n=this.safeValue(i,s);return n!==void 0&&n.call(this,e,t),(s==="order"||s==="futures-order")&&(this.handleOrder(e,t),s==="order"&&this.handleBalance(e,t)),t}handleSubscriptionStatus(e,t){return this.safeString(t,"ch","").indexOf("depth-realtime")>-1&&this.handleOrderBookSubscription(e,t),t}handleOrderBookSubscription(e,t){const n=this.safeString(t,"ch").split(":")[1],r=this.safeSymbol(n);r in this.orderbooks&&delete this.orderbooks[r],this.orderbooks[r]=this.orderBook({}),this.spawn(this.watchOrderBookSnapshot,r)}async pong(e,t){await e.send({op:"pong",hp:this.safeInteger(t,"hp")})}handlePing(e,t){this.spawn(this.pong,e,t)}authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let n=this.safeValue(i.futures,s);if(n===void 0){const r=this.milliseconds().toString(),a=e.split("/"),o=a.length,d=this.safeString(a,o-1),c=this.safeString(a,o-2),u=r+"+"+c+"/"+d,h=this.base64ToBinary(this.secret),f=this.hmac(this.encode(u),h,"sha256","base64"),l={op:"auth",id:this.nonce().toString(),t:r,key:this.apiKey,sig:f};n=this.watch(e,s,this.extend(l,t)),i.subscriptions[s]=n}return n}};const nH=Ph,{ArrayCache:rH,ArrayCacheByTimestamp:aH}=Pe;var yg=class extends nH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:"wss://api.hitbtc.com/api/2/ws"}},options:{tradesLimit:1e3,methods:{orderbook:"subscribeOrderbook",ticker:"subscribeTicker",trades:"subscribeTrades",ohlcv:"subscribeCandles"}}})}async watchPublic(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.marketId(e),r=this.urls.api.ws;let a=t+":"+n;s!==void 0&&(a+=":"+s);const o=this.safeValue(this.options,"methods",{}),d=this.safeString(o,t,t),c=this.nonce(),u={method:d,params:{symbol:n},id:c},h=this.deepExtend(u,i);return await this.watch(r,a,h,a)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook",void 0,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence");r in this.orderbooks&&delete this.orderbooks[r];const d=this.parseOrderBook(s,r,a,"bid","ask","price","size"),c=this.orderBook(d);c.nonce=o,this.orderbooks[r]=c;const u="orderbook:"+i;e.resolve(c,u)}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol;if(r in this.orderbooks){const a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence"),d=this.orderbooks[r],c=this.safeValue(s,"ask",[]),u=this.safeValue(s,"bid",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.timestamp=a,d.datetime=this.iso8601(a),d.nonce=o,this.orderbooks[r]=d;const h="orderbook:"+i;e.resolve(d,h)}}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"size");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker",void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"params"),i=this.safeValue(s,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const d=this.safeValue(t,"method")+":"+i;e.resolve(a,d)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.watchPublic(e,"trades",void 0,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o="trades:"+n,d=this.safeInteger(this.options,"tradesLimit",1e3);let c=this.safeValue(this.trades,a);if(c===void 0&&(c=new rH(d),this.trades[a]=c),Array.isArray(i)){const u=this.parseTrades(i,r);for(let h=0;h<u.length;h++)c.append(u[h])}else{const u=this.parseTrade(t,r);c.append(u)}return e.resolve(c,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.timeframes[t],a={params:{period:r}},o=this.deepExtend(a,n),d=await this.watchPublic(e,"ohlcv",r,o);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o=this.safeString(s,"period"),d=this.findTimeframe(o),c="ohlcv:"+n+":"+o;for(let u=0;u<i.length;u++){const h=i[u],f=this.parseOHLCV(h,r);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let l=this.safeValue(this.ohlcvs[a],d);if(l===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new aH(m),this.ohlcvs[a][d]=l}l.append(f),e.resolve(l,c)}return t}handleNotification(e,t){return t}handleMessage(e,t){const s={snapshotOrderbook:this.handleOrderBookSnapshot,updateOrderbook:this.handleOrderBookUpdate,ticker:this.handleTicker,snapshotTrades:this.handleTrades,updateTrades:this.handleTrades,snapshotCandles:this.handleOHLCV,updateCandles:this.handleOHLCV},i=this.safeString(t,"method"),n=this.safeValue(s,i);n===void 0?this.handleNotification(e,t):n.call(this,e,t)}};const oH=yg;var dH=class extends oH{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const cH=tc,uH=ae,{ExchangeError:$p,ArgumentsRequired:e1}=Q,{ArrayCache:hH,ArrayCacheByTimestamp:fH,ArrayCacheBySymbolById:t1}=Pe;var Bh=class extends cH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0},urls:{test:{ws:{spot:"wss://testnet.binance.vision/ws",margin:"wss://testnet.binance.vision/ws",future:"wss://stream.binancefuture.com/ws",delivery:"wss://dstream.binancefuture.com/ws"}},api:{ws:{spot:"wss://stream.binance.com:9443/ws",margin:"wss://stream.binance.com:9443/ws",future:"wss://fstream.binance.com/ws",delivery:"wss://dstream.binance.com/ws"}}},options:{streamLimits:{spot:50,margin:50,future:50,delivery:50},streamBySubscriptionsHash:{},streamIndex:-1,watchOrderBookRate:100,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,requestId:{},watchOrderBookLimit:1e3,watchTrades:{name:"trade"},watchTicker:{name:"ticker"},watchTickers:{name:"ticker"},watchBalance:{fetchBalanceSnapshot:!1,awaitBalanceSnapshot:!0},wallet:"wb",listenKeyRefreshRate:12e5,ws:{cost:5}}})}requestId(e){const t=this.safeValue(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}stream(e,t){const s=this.safeValue(this.options,"streamBySubscriptionsHash",{});let i=this.safeString(s,t);if(i===void 0){let n=this.safeInteger(this.options,"streamIndex",-1);const r=this.safeValue(this.options,"streamLimits"),a=this.safeInteger(r,e);n=n+1;const o=n%a;this.options.streamIndex=n,i=this.numberToString(o),this.options.streamBySubscriptionsHash[t]=i}return i}onError(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onError(e,t)}onClose(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onClose(e,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new $p(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.market(e);let n=i.type;i.contract&&(n=i.linear?"future":"delivery");const r="depth",a=i.lowercaseId+"@"+r,o=this.urls.api.ws[n]+"/"+this.stream(n,a),d=this.requestId(o),c=this.safeString(this.options,"watchOrderBookRate","100"),u={method:"SUBSCRIBE",params:[a+"@"+c+"ms"],id:d},h={id:d.toString(),messageHash:a,name:r,symbol:i.symbol,method:this.handleOrderBookSubscription,limit:t,type:n,params:s},f=this.extend(u,s);return(await this.watch(o,a,f,a,h)).limit()}async fetchOrderBookSnapshot(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeValue(s,"type"),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.safeInteger(s,"limit",i),d=this.safeValue(s,"params"),c=await this.fetchOrderBook(r,o,d),u=this.safeValue(this.orderbooks,r);if(u===void 0)return;u.reset(c);const h=u.cache;for(let f=0;f<h.length;f++){const l=h[f],m=this.safeInteger(l,"U"),g=this.safeInteger(l,"u"),y=this.safeInteger(l,"pu");if(n==="future"){if(g<u.nonce)continue;(m<=u.nonce&&g>=u.nonce||y===u.nonce)&&this.handleOrderBookMessage(e,l,u)}else{if(g<=u.nonce)continue;m-1<=u.nonce&&g-1>=u.nonce&&this.handleOrderBookMessage(e,l,u)}}this.orderbooks[r]=u,e.resolve(u,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"u");this.handleDeltas(s.asks,this.safeValue(t,"a",[])),this.handleDeltas(s.bids,this.safeValue(t,"b",[])),s.nonce=i;const n=this.safeInteger(t,"E");return s.timestamp=n,s.datetime=this.iso8601(n),s}handleOrderBook(e,t){const i=e.url.indexOf("/stream")>=0?"spot":"contract",n=this.safeString(t,"s"),r=this.safeMarket(n,void 0,void 0,i),a=r.symbol,o="depth",d=r.lowercaseId+"@"+o,c=this.safeValue(this.orderbooks,a);if(c===void 0)return;const u=this.safeInteger(c,"nonce");if(u===void 0)c.cache.push(t);else try{const h=this.safeInteger(t,"U"),f=this.safeInteger(t,"u"),l=this.safeInteger(t,"pu");if(l===void 0){if(f>c.nonce){const m=this.safeInteger(c,"timestamp");let g;if(m===void 0?g=h-1<=c.nonce&&f-1>=c.nonce:g=h-1===c.nonce,g)this.handleOrderBookMessage(e,t,c),u<c.nonce&&e.resolve(c,d);else throw new $p(this.id+" handleOrderBook received an out-of-order nonce")}}else if(f>=c.nonce)if(h<=c.nonce||l===c.nonce)this.handleOrderBookMessage(e,t,c),u<=c.nonce&&e.resolve(c,d);else throw new $p(this.id+" handleOrderBook received an out-of-order nonce")}catch(h){delete this.orderbooks[a],delete e.subscriptions[d],e.reject(h,d)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit",i);n in this.orderbooks&&delete this.orderbooks[n],this.orderbooks[n]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"watchTrades",{}),a=this.safeString(r,"name","trade"),o=n.lowercaseId+"@"+a;let d=n.type;n.contract&&(d=n.linear?"future":"delivery");const c=this.omit(i,"type"),u=this.urls.api.ws[d]+"/"+this.stream(d,o),h=this.requestId(u),f={method:"SUBSCRIBE",params:[o],id:h},l={id:h},m=await this.watch(u,o,this.extend(f,c),o,l);return this.newUpdates&&(s=m.getLimit(e,s)),this.filterBySinceLimit(m,t,s,"timestamp",!0)}parseTrade(e,t=void 0){const i=this.safeString(e,"x")==="TRADE";if(!i)return super.parseTrade(e,t);const n=this.safeString2(e,"t","a"),r=this.safeInteger(e,"T"),a=this.safeFloat2(e,"L","p");let o=this.safeFloat(e,"q");i&&(o=this.safeFloat(e,"l",o));let d=this.safeFloat(e,"Y");d===void 0&&a!==void 0&&o!==void 0&&(d=a*o);const c=this.safeString(e,"s"),u="ps"in e?"contract":"spot",h=this.safeSymbol(c,void 0,void 0,u);let f=this.safeStringLower(e,"S"),l;const m=this.safeString(e,"i");"m"in e&&(f===void 0&&(f=e.m?"sell":"buy"),l=e.m?"maker":"taker");let g;const y=this.safeFloat(e,"n");if(y!==void 0){const b=this.safeString(e,"N"),S=this.safeCurrencyCode(b);g={cost:y,currency:S}}const w=this.safeStringLower(e,"o");return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:h,id:n,order:m,type:w,takerOrMaker:l,side:f,price:a,amount:o,cost:d,fee:g}}handleTrade(e,t){const i=e.url.indexOf("/stream")>=0?"spot":"contract",n=this.safeString(t,"s"),r=this.safeMarket(n,void 0,void 0,i),a=r.symbol,o=this.safeStringLower(t,"s"),d=this.safeString(t,"e"),c=o+"@"+d,u=this.parseTrade(t,r);let h=this.safeValue(this.trades,a);if(h===void 0){const f=this.safeInteger(this.options,"tradesLimit",1e3);h=new hH(f)}h.append(u),this.trades[a]=h,e.resolve(h,c)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.lowercaseId,o=this.timeframes[t],d="kline",c=a+"@"+d+"_"+o;let u=r.type;r.contract&&(u=r.linear?"future":"delivery");const h=this.urls.api.ws[u]+"/"+this.stream(u,c),f=this.requestId(h),l={method:"SUBSCRIBE",params:[c],id:f},m={id:f},g=await this.watch(h,c,this.extend(l,n),c,m);return this.newUpdates&&(i=g.getLimit(e,i)),this.filterBySinceLimit(g,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeStringLower(t,"s"),n=this.safeString(t,"e"),r=this.safeValue(t,"k"),a=this.safeString(r,"i"),o=this.findTimeframe(a),d=i+"@"+n+"_"+a,c=[this.safeInteger(r,"t"),this.safeFloat(r,"o"),this.safeFloat(r,"h"),this.safeFloat(r,"l"),this.safeFloat(r,"c"),this.safeFloat(r,"v")],h=e.url.indexOf("/stream")>=0?"spot":"contract",f=this.safeSymbol(s,void 0,void 0,h);this.ohlcvs[f]=this.safeValue(this.ohlcvs,f,{});let l=this.safeValue(this.ohlcvs[f],o);if(l===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new fH(m),this.ohlcvs[f][o]=l}l.append(c),e.resolve(l,d)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.lowercaseId;let n=s.type;s.contract&&(n=s.linear?"future":"delivery");const r=this.safeValue(this.options,"watchTicker",{});let a=this.safeString(r,"name","ticker");a=this.safeString(t,"name",a),t=this.omit(t,"name");const o=i+"@"+a,d=this.urls.api.ws[n]+"/"+this.stream(n,o),c=this.requestId(d),u={method:"SUBSCRIBE",params:[o],id:c},h={id:c};return await this.watch(d,o,this.extend(u,t),o,h)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.marketIds(e);let i,n;[n,t]=this.handleMarketTypeAndParams("watchTickers",i,t),s!==void 0&&(i=this.safeMarket(s[0],void 0,void 0,n));let r;[r,t]=this.handleSubTypeAndParams("watchTickers",i,t),this.isLinear(n,r)?n="future":this.isInverse(n,r)&&(n="delivery");const a=this.safeValue(this.options,"watchTickers",{});let o=this.safeString(a,"name","ticker");o=this.safeString(t,"name",o);const d=t;t=this.omit(t,"name");let c=[];const u="!"+o+"@arr";if(o==="bookTicker"){if(s===void 0)throw new e1(this.id+" watchTickers() requires symbols for bookTicker");for(let S=0;S<s.length;S++)c.push(s[S].toLowerCase()+"@bookTicker")}else c=[u];const h=this.urls.api.ws[n]+"/"+this.stream(n,u),f=this.requestId(h),l={method:"SUBSCRIBE",params:c,id:f},m={id:f},g=await this.watch(h,u,this.extend(l,t),u,m),y={};for(let S=0;S<g.length;S++){const v=g[S],T=v.symbol;(e===void 0||this.inArray(T,e))&&(y[T]=v)}return Object.keys(y).length>0?this.newUpdates?y:this.filterByArray(this.tickers,"symbol",e):await this.watchTickers(e,d)}parseWsTicker(e,t){let s=this.safeString(e,"e","bookTicker");s==="24hrTicker"&&(s="ticker");let i;const n=this.milliseconds();s==="bookTicker"?i=this.safeInteger(e,"E",n):i=this.safeInteger(e,"C",n);const r=this.safeString(e,"s"),a=this.safeSymbol(r,void 0,void 0,t),o=this.safeFloat(e,"c");return{symbol:a,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"h"),low:this.safeFloat(e,"l"),bid:this.safeFloat(e,"b"),bidVolume:this.safeFloat(e,"B"),ask:this.safeFloat(e,"a"),askVolume:this.safeFloat(e,"A"),vwap:this.safeFloat(e,"w"),open:this.safeFloat(e,"o"),close:o,last:o,previousClose:this.safeFloat(e,"x"),change:this.safeFloat(e,"p"),percentage:this.safeFloat(e,"P"),average:void 0,baseVolume:this.safeFloat(e,"v"),quoteVolume:this.safeFloat(e,"q"),info:e}}handleTicker(e,t){let s=this.safeString(t,"e","bookTicker");s==="24hrTicker"?s="ticker":s==="24hrMiniTicker"&&(s="miniTicker");const n=this.safeStringLower(t,"s")+"@"+s,a=e.url.indexOf("/stream")>=0?"spot":"contract",o=this.parseWsTicker(t,a),d=o.symbol;this.tickers[d]=o,e.resolve(o,n),s==="bookTicker"&&e.resolve([o],"!bookTicker@arr")}handleTickers(e,t){let s;const n=e.url.indexOf("/stream")>=0?"spot":"contract";for(let a=0;a<t.length;a++){const o=t[a];s=this.safeString(o,"e"),s==="24hrTicker"?s="ticker":s==="24hrMiniTicker"&&(s="miniTicker");const c=this.safeStringLower(o,"s")+"@"+s,u=this.parseWsTicker(o,n),h=u.symbol;this.tickers[h]=u,e.resolve(u,c)}const r=Object.values(this.tickers);e.resolve(r,"!"+s+"@arr")}async authenticate(e={}){const t=this.milliseconds();let s=this.safeString2(this.options,"defaultType","authenticate","spot");s=this.safeString(e,"type",s);let i;[i,e]=this.handleSubTypeAndParams("authenticate",void 0,e),this.isLinear(s,i)?s="future":this.isInverse(s,i)&&(s="delivery");let n;[n,e]=this.handleMarginModeAndParams("authenticate",e);const r=n==="isolated",a=n==="cross"||n===void 0,o=this.safeString(e,"symbol");e=this.omit(e,"symbol");const d=this.safeValue(this.options,s,{}),c=this.safeInteger(d,"lastAuthenticatedTime",0),u=this.safeInteger(this.options,"listenKeyRefreshRate",12e5),h=this.sum(u,1e4);if(t-c>h){let f="publicPostUserDataStream";if(s==="future")f="fapiPrivatePostListenKey";else if(s==="delivery")f="dapiPrivatePostListenKey";else if(s==="margin"&&a)f="sapiPostUserDataStream";else if(r){if(f="sapiPostUserDataStreamIsolated",o===void 0)throw new e1(this.id+" authenticate() requires a symbol argument for isolated margin mode");const m=this.marketId(o);e.symbol=m}const l=await this[f](e);this.options[s]=this.extend(d,{listenKey:this.safeString(l,"listenKey"),lastAuthenticatedTime:t}),this.delay(u,this.keepAliveListenKey,e)}}async keepAliveListenKey(e={}){let t=this.safeString2(this.options,"defaultType","authenticate","spot");t=this.safeString(e,"type",t);let s;[s,e]=this.handleSubTypeAndParams("keepAliveListenKey",void 0,e),this.isLinear(t,s)?t="future":this.isInverse(t,s)&&(t="delivery");const i=this.safeValue(this.options,t,{}),n=this.safeString(i,"listenKey");if(n===void 0)return;let r="publicPutUserDataStream";t==="future"?r="fapiPrivatePutListenKey":t==="delivery"?r="dapiPrivatePutListenKey":t==="margin"&&(r="sapiPutUserDataStream");const a={listenKey:n},o=this.milliseconds(),d=this.omit(e,"type");try{await this[r](this.extend(a,d))}catch(h){const f=this.urls.api.ws[t]+"/"+this.options[t].listenKey,l=this.client(f),m=Object.keys(l.futures);for(let g=0;g<m.length;g++){const y=m[g];l.reject(h,y)}this.options[t]=this.extend(i,{listenKey:void 0,lastAuthenticatedTime:0});return}this.options[t]=this.extend(i,{listenKey:n,lastAuthenticatedTime:o});const c=Object.values(this.clients),u=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);for(let h=0;h<c.length;h++){const f=c[h],l=Object.keys(f.subscriptions);for(let m=0;m<l.length;m++)if(l[m]===t)return this.delay(u,this.keepAliveListenKey,e)}}setBalanceCache(e,t){if(t in e.subscriptions)return;const s=this.safeValue(this.options,"watchBalance");if(this.safeValue(s,"fetchBalanceSnapshot",!1)){const n=t+":fetchBalanceSnapshot";n in e.futures||(e.future(n),this.spawn(this.loadBalanceSnapshot,e,n,t))}else this.balance[t]={}}async loadBalanceSnapshot(e,t,s){const i=await this.fetchBalance({type:s});this.balance[s]=this.extend(i,this.safeValue(this.balance,s,{})),e.futures[t].resolve(),e.resolve(this.balance[s],s+":balance")}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t=this.safeString(this.options,"defaultType","spot");let s=this.safeString(e,"type",t),i;[i,e]=this.handleSubTypeAndParams("watchBalance",void 0,e),this.isLinear(s,i)?s="future":this.isInverse(s,i)&&(s="delivery");const n=this.urls.api.ws[s]+"/"+this.options[s].listenKey,r=this.client(n);this.setBalanceCache(r,s);const a=this.safeValue(this.options,"watchBalance"),o=this.safeValue(a,"fetchBalanceSnapshot",!1),d=this.safeValue(a,"awaitBalanceSnapshot",!0);o&&d&&await r.future(s+":fetchBalanceSnapshot");const c=s+":balance",u=void 0;return await this.watch(n,c,u,s)}handleBalance(e,t){const s=this.safeValue(this.options,"wallet","wb"),n=Object.keys(e.subscriptions)[0],r=n+":balance";if(this.balance[n].info=t,this.safeString(t,"e")==="balanceUpdate"){const d=this.safeString(t,"a"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(t,"d");if(c in this.balance[n]){let f=this.balance[n][c].free;typeof f!="string"&&(f=this.numberToString(f)),u.free=uH.stringAdd(f,h)}else u.free=h;this.balance[n][c]=u}else{t=this.safeValue(t,"a",t);const d=this.safeValue(t,"B");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"a"),f=this.safeCurrencyCode(h),l=this.account();l.free=this.safeString(u,"f"),l.used=this.safeString(u,"l"),l.total=this.safeString(u,s),this.balance[n][f]=l}}const o=this.safeInteger(t,"E");this.balance[n].timestamp=o,this.balance[n].datetime=this.iso8601(o),this.balance[n]=this.safeBalance(this.balance[n]),e.resolve(this.balance[n],r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+e,i.symbol=e),await this.authenticate(i);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);let o;[o,i]=this.handleSubTypeAndParams("watchOrders",r,i),this.isLinear(a,o)?a="future":this.isInverse(a,o)&&(a="delivery");const d=this.urls.api.ws[a]+"/"+this.options[a].listenKey,c=this.client(d);this.setBalanceCache(c,a);const u=void 0,h=await this.watch(d,n,u,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"x"),i=this.safeString(e,"i"),n=this.safeString(e,"s"),r="ps"in e?"contract":"spot",a=this.safeSymbol(n,void 0,void 0,r);let o=this.safeInteger(e,"O");const d=this.safeInteger(e,"T");let c;s==="NEW"?o===void 0&&(o=d):s==="TRADE"&&(c=d);let u;const h=this.safeFloat(e,"n");if(h!==void 0&&h>0){const B=this.safeString(e,"N"),x=this.safeCurrencyCode(B);u={cost:h,currency:x}}const f=this.safeString(e,"p"),l=this.safeString(e,"q"),m=this.safeStringLower(e,"S"),g=this.safeStringLower(e,"o"),y=this.safeString(e,"z"),w=this.safeString(e,"Z"),b=this.safeString(e,"ap"),S=this.safeString(e,"X"),v=this.parseOrderStatus(S),T=void 0;let I=this.safeString(e,"C");(I===void 0||I.length===0)&&(I=this.safeString(e,"c"));const A=this.safeString2(e,"P","sp");let N=this.safeString(e,"f");return N==="GTX"&&(N="PO"),this.safeOrder({info:e,symbol:a,id:i,clientOrderId:I,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:c,type:g,timeInForce:N,postOnly:void 0,side:m,price:f,stopPrice:A,triggerPrice:A,amount:l,cost:w,average:b,filled:y,remaining:void 0,status:v,fee:u,trades:T})}handleOrderUpdate(e,t){this.safeString(t,"e")==="ORDER_TRADE_UPDATE"&&(t=this.safeValue(t,"o",t)),this.handleMyTrade(e,t),this.handleOrder(e,t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString2(this.options,"watchMyTrades","defaultType","spot");let r=this.safeString(i,"type",n),a;[a,i]=this.handleSubTypeAndParams("watchMyTrades",void 0,i),this.isLinear(r,a)?r="future":this.isInverse(r,a)&&(r="delivery");let o="myTrades";e!==void 0&&(e=this.symbol(e),o+=":"+e,i.symbol=e),await this.authenticate(i);const d=this.urls.api.ws[r]+"/"+this.options[r].listenKey,c=this.client(d);this.setBalanceCache(c,r);const u=void 0,h=await this.watch(d,o,u,r);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleMyTrade(e,t){const s="myTrades";if(this.safeString(t,"x")==="TRADE"){const n=this.parseTrade(t),r=this.safeString(n,"order"),a=this.safeValue(n,"fee"),o=this.safeString(n,"symbol");if(r!==void 0&&a!==void 0&&o!==void 0){const u=this.orders;if(u!==void 0){const h=this.safeValue(u.hashmap,o,{}),f=this.safeValue(h,r);if(f!==void 0){const l=this.safeValue(f,"fees"),m=this.safeValue(f,"fee");if(l!==void 0){let y=!0;for(let w=0;w<l.length;w++){const b=l[w];if(b.currency===a.currency){const S=this.sum(a.cost,b.cost);f.fees[w].cost=parseFloat(this.currencyToPrecision(a.currency,S)),y=!1;break}}y&&f.fees.push(a)}else if(m!==void 0)if(m.currency===a.currency){const y=this.sum(m.cost,a.cost);f.fee.cost=parseFloat(this.currencyToPrecision(a.currency,y))}else m.currency===void 0?f.fee=a:(f.fees=[m,a],f.fee=void 0);else f.fee=a;const g=this.safeValue(f,"trades",[]);g.push(n),f.trades=g}}}if(this.myTrades===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new t1(u)}this.myTrades.append(n),e.resolve(this.myTrades,s);const c=s+":"+o;e.resolve(this.myTrades,c)}}handleOrder(e,t){const s="orders",i=this.parseWsOrder(t),n=this.safeString(i,"symbol"),r=this.safeString(i,"id");if(n!==void 0){if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new t1(u)}const a=this.orders,o=this.safeValue(a.hashmap,n,{}),d=this.safeValue(o,r);if(d!==void 0){const u=this.safeValue(d,"fee");u!==void 0&&(i.fee=u);const h=this.safeValue(d,"fees");h!==void 0&&(i.fees=h),i.trades=this.safeValue(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}a.append(i),e.resolve(this.orders,s);const c=s+":"+n;e.resolve(this.orders,c)}}handleMessage(e,t){const s={depthUpdate:this.handleOrderBook,trade:this.handleTrade,aggTrade:this.handleTrade,kline:this.handleOHLCV,"24hrTicker@arr":this.handleTickers,"24hrMiniTicker@arr":this.handleTickers,"24hrTicker":this.handleTicker,"24hrMiniTicker":this.handleTicker,bookTicker:this.handleTicker,outboundAccountPosition:this.handleBalance,balanceUpdate:this.handleBalance,ACCOUNT_UPDATE:this.handleBalance,executionReport:this.handleOrderUpdate,ORDER_TRADE_UPDATE:this.handleOrderUpdate};let i=this.safeString(t,"e");if(Array.isArray(t)){const r=t[0];i=this.safeString(r,"e")+"@arr"}const n=this.safeValue(s,i);if(n===void 0){if(this.safeString(t,"id")!==void 0)return this.handleSubscriptionStatus(e,t);i===void 0&&this.handleTicker(e,t)}else return n.call(this,e,t)}};const lH=Bh;var pH=class extends lH{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{fetchMarkets:["inverse"],defaultSubType:"inverse"}})}};const mH=Bh;var gH=class extends mH{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{ws:{spot:"wss://stream.binance.us:9443/ws"},web:"https://www.binance.us",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v1",private:"https://api.binance.us/api/v3",v3:"https://api.binance.us/api/v3",v1:"https://api.binance.us/api/v1"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},options:{fetchCurrencies:!1,quoteOrderQty:!1,defaultType:"spot",fetchMarkets:["spot"]},fees:{trading:{tierBased:!1,percentage:!0,taker:0,maker:0}}})}};const yH=Bh;var wH=class extends yH{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{fetchMarkets:["linear"],defaultSubType:"linear"}})}};const bH=yg;var kH=class extends bH{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",name:"bitcoin.com",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/97296144-514fa300-1861-11eb-952b-3d55d492200b.jpg",api:{ws:"wss://api.fmfw.io/api/2/ws"}},fees:{trading:{maker:.15/100,taker:.2/100}}})}};const SH=cT,{ExchangeError:vH,AuthenticationError:TH}=Q,{ArrayCache:OH,ArrayCacheBySymbolById:IH}=Pe,qu=ae;var xH=class extends SH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!1},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/1",private:"wss://api.bitfinex.com/ws/1"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=e+":"+n,o={event:"subscribe",channel:e,symbol:n,messageHash:a};return await this.watch(r,a,this.deepExtend(o,s),a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"pair"),r=i+":"+n,a=this.safeInteger(this.options,"tradesLimit",1e3),o=this.safeMarket(n),d=o.symbol,c=this.safeValue(t,1);let u=this.safeValue(this.trades,d);if(u===void 0&&(u=new OH(a),this.trades[d]=u),Array.isArray(c)){const h=this.parseTrades(c,o);for(let f=0;f<h.length;f++)u.append(h[f])}else{if(this.safeString(t,1)!=="tu")return;const f=this.parseTrade(t,o);u.append(f)}return e.resolve(u,r),t}parseTrade(e,t=void 0){if(!Array.isArray(e))return super.parseTrade(e,t);const s=e.length,i=this.safeString(e,1);let n;i==="tu"&&(n=this.safeString(e,s-4));const r=this.safeTimestamp(e,s-3),a=this.safeFloat(e,s-2);let o=this.safeFloat(e,s-1),d;o!==void 0&&(d=o>0?"buy":"sell",o=Math.abs(o));let c;a!==void 0&&o!==void 0&&(c=a*o);const h=this.safeString(e,2).split("-");let f=this.safeString(h,1);f!==void 0&&(f=f.replace("t",""));const l=this.safeSymbol(f,t),m=void 0,g=void 0;return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:l,id:n,order:g,type:void 0,takerOrMaker:m,side:d,price:a,amount:o,cost:c,fee:void 0}}handleTicker(e,t,s){const i=this.milliseconds(),n=this.safeString(s,"pair"),r=this.safeSymbol(n),o="ticker"+":"+n,d=this.safeString(t,7),c=this.safeString(t,5);let u;d!==void 0&&c!==void 0&&(u=qu.stringSub(d,c));const h={symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(t,9),low:this.safeFloat(t,10),bid:this.safeFloat(t,1),bidVolume:void 0,ask:this.safeFloat(t,3),askVolume:void 0,vwap:void 0,open:this.parseNumber(u),close:this.parseNumber(d),last:this.parseNumber(d),previousClose:void 0,change:this.parseNumber(c),percentage:this.safeFloat(t,6),average:void 0,baseVolume:this.safeFloat(t,8),quoteVolume:void 0,info:t};this.tickers[r]=h,e.resolve(h,o)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new vH(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r,len:t};return(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"pair"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0";if(Array.isArray(t[1])){const c=this.safeInteger(s,"len");d?this.orderbooks[n]=this.indexedOrderBook({},c):this.orderbooks[n]=this.countedOrderBook({},c);const u=this.orderbooks[n];if(d){const h=t[1];for(let f=0;f<h.length;f++){const l=h[f],m=this.safeString(l,0),g=this.safeFloat(l,1),y=l[2]<0?-l[2]:l[2],w=l[2]<0?"asks":"bids";u[w].store(g,y,m)}}else{const h=t[1];for(let f=0;f<h.length;f++){const l=h[f],m=l[2]<0?-l[2]:l[2],g=l[2]<0?"asks":"bids";u[g].store(l[0],m,l[1])}}e.resolve(u,a)}else{const c=this.orderbooks[n];if(d){const u=this.safeString(t,1),h=this.safeFloat(t,2),f=t[3]<0?-t[3]:t[3],l=t[3]<0?"asks":"bids",m=c[l],g=h>0?f:0;m.store(h,g,u)}else{const u=t[3]<0?-t[3]:t[3],h=t[3]<0?"asks":"bids";c[h].store(t[1],u,t[2])}e.resolve(c,a)}}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),n="auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o="AUTH"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha384","hex"),c={apiKey:this.apiKey,authSig:d,authNonce:a,authPayload:o,event:n,filter:["trading","wallet"]};this.spawn(this.watch,t,n,c,1)}return await i}handleAuthenticationMessage(e,t){if(this.safeString(t,"status")==="OK")this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new TH(this.json(t));e.reject(i,"authenticated");const n=this.safeString(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.urls.api.ws.private;return await this.authenticate(),await this.watch(i,e,void 0,1)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws.private,r=await this.watch(n,"os",void 0,1);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]);if(this.safeString(t,1)==="os")for(let r=0;r<i.length;r++){const a=i[r];this.handleOrder(e,a)}else this.handleOrder(e,i);this.orders!==void 0&&e.resolve(this.orders,"os")}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled"};return this.safeString(t,e,e)}handleOrder(e,t){const s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeSymbol(i);let r=this.safeString(t,2),a=this.safeString(t,3),o="buy";qu.stringLt(r,"0")&&(r=qu.stringAbs(r),a=qu.stringAbs(a),o="sell");let d=this.safeString(t,4);d.indexOf("LIMIT")>-1?d="limit":d.indexOf("MARKET")>-1&&(d="market");const c=this.parseWsOrderStatus(this.safeString(t,5)),u=this.safeString(t,6),h=this.safeString(t,8),f=this.parse8601(h),l=this.safeOrder({info:t,id:s,clientOrderId:void 0,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,symbol:n,type:d,side:o,price:u,stopPrice:void 0,triggerPrice:void 0,average:void 0,amount:r,remaining:a,filled:void 0,status:c,fee:void 0,cost:void 0,trades:void 0});if(this.orders===void 0){const g=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new IH(g)}return this.orders.append(l),e.resolve(l,s),l}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0);if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,ticker:this.handleTicker,trades:this.handleTrades,os:this.handleOrders,on:this.handleOrders,oc:this.handleOrders},o=this.safeValue2(a,n,r);return o===void 0?t:o.call(this,e,t,i)}else{const s=this.safeString(t,"event");if(s!==void 0){const i={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}}};const _H=uT,Wp=ae,{ExchangeError:CH,AuthenticationError:MH,InvalidNonce:PH}=Q,{ArrayCache:AH,ArrayCacheBySymbolById:s1,ArrayCacheByTimestamp:BH}=Pe;var NH=class extends _H{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/2",private:"wss://api.bitfinex.com/ws/2"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3,checksum:!0}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=this.client(r),o=e+":"+n,d={event:"subscribe",channel:e,symbol:n},c=await this.watch(r,o,this.deepExtend(d,s),o,{checksum:!1});return this.safeValue(this.options,"checksum",!0)&&!a.subscriptions[o].checksum&&e==="book"&&(a.subscriptions[o].checksum=!0,a.send({event:"conf",flags:131072})),c}async subscribePrivate(e){await this.loadMarkets(),await this.authenticate();const t=this.urls.api.ws.private;return await this.watch(t,e,void 0,1)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="candles",d="trade:"+a+":"+r.id,c=o+":"+a+":"+r.id,u={event:"subscribe",channel:o,key:d},h=this.urls.api.ws.public,f=await this.watch(h,c,this.deepExtend(u,n),c);return this.newUpdates&&(i=f.getLimit(e,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t,s){const i=this.safeValue(t,1,[]);let n;const r=this.safeValue(i,0);Array.isArray(r)?n=i:n=[i];const a=this.safeValue(s,"channel"),o=this.safeString(s,"key"),d=o.split(":"),c=this.safeString(d,1);let u=o;u=u.replace("trade:",""),u=u.replace(c+":","");const h=this.safeMarket(u),f=this.findTimeframe(c),l=h.symbol,m=a+":"+c+":"+u;this.ohlcvs[l]=this.safeValue(this.ohlcvs,l,{});let g=this.safeValue(this.ohlcvs[l],f);if(g===void 0){const w=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new BH(w),this.ohlcvs[l][f]=g}const y=n.length;for(let w=0;w<y;w++){const b=n[y-w-1],S=this.parseOHLCV(b,h);g.append(S)}e.resolve(g,m)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="myTrade";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleMyTrade(e,t,s={}){const i="myTrade",n=this.safeValue(t,2),r=this.parseWsTrade(n,!1),a=r.symbol,o=this.market(a),d=i+":"+o.id;if(this.myTrades===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new s1(u)}const c=this.myTrades;c.append(r),this.myTrades=c,e.resolve(c,i),e.resolve(c,d)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=i+":"+n,o=this.safeInteger(this.options,"tradesLimit",1e3),d=r.symbol;let c=this.safeValue(this.trades,d);c===void 0&&(c=new AH(o),this.trades[d]=c);const u=!0;if(t.length===2){const f=this.safeValue(t,1,[]);for(let l=0;l<f.length;l++){const m=this.parseWsTrade(f[l],u,r);c.append(m)}}else{if(this.safeString(t,1)==="tu")return;const l=this.safeValue(t,2,[]),m=this.parseWsTrade(l,u,r);c.append(m)}return e.resolve(c,a),t}parseWsTrade(e,t=!1,s=void 0){let i=t?void 0:this.safeString(e,1);s=this.safeMarket(i,s);const n=t?1:2,r=t?3:5,a=t?2:4;i=s.id;let o=this.safeString(e,6);o!==void 0&&(o.indexOf("LIMIT")>-1?o="limit":o.indexOf("MARKET")>-1&&(o="market"));const d=t?void 0:this.safeString(e,3),c=this.safeString(e,0),u=this.safeInteger(e,n),h=this.safeString(e,r),f=this.safeString(e,a),l=this.parseNumber(Wp.stringAbs(f));let m;l!==void 0&&(m=Wp.stringGt(f,"0")?"buy":"sell");const g=this.safeSymbol(i,s),y=this.safeString(e,9);let w;if(y!==void 0){const v=this.safeString(e,10),T=this.safeCurrencyCode(v);w={cost:y,currency:T}}const b=this.safeInteger(e,8);let S;return b!==void 0&&(S=b===-1?"taker":"maker"),this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:g,id:c,order:d,type:o,takerOrMaker:S,side:m,price:h,amount:l,cost:void 0,fee:w},s)}handleTicker(e,t,s){const i=this.safeValue(t,1),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=this.safeSymbol(n),o=this.parseWsTicker(i,r),c="ticker"+":"+n;this.tickers[a]=o,e.resolve(o,c)}parseWsTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,6),n=this.safeString(e,4);return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,8),low:this.safeString(e,9),bid:this.safeString(e,0),bidVolume:this.safeString(e,1),ask:this.safeString(e,2),askVolume:this.safeString(e,3),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:n,percentage:this.safeString(e,5),average:void 0,baseVolume:this.safeString(e,7),quoteVolume:void 0,info:e},t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new CH(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r};return t!==void 0&&(a.len=t),(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0",c=this.safeString(t,0);let u=this.safeValue(this.orderbooks,n);if(u===void 0){const h=this.safeInteger(s,"len");if(d?this.orderbooks[n]=this.indexedOrderBook({},h):this.orderbooks[n]=this.countedOrderBook({},h),u=this.orderbooks[n],d){const f=t[1];for(let l=0;l<f.length;l++){const m=f[l],g=m[2]<0?-m[2]:m[2],y=m[2]<0?"asks":"bids",w=u[y],b=this.safeString(m,0),S=this.safeFloat(m,1);w.store(S,g,b)}}else{const f=t[1];for(let l=0;l<f.length;l++){const m=f[l],g=this.safeNumber(m,2),y=this.safeNumber(m,1),w=this.safeNumber(m,0),b=g<0?-g:g,S=g<0?"asks":"bids";u[S].store(w,b,y)}}e.resolve(u,a)}else{const h=t[1],f=this.orderbooks[n];if(d){const l=this.safeFloat(h,1),m=h[2]<0?-h[2]:h[2],g=h[2]<0?"asks":"bids",y=f[g],w=l>0?m:0;y.store(l,w,c)}else{const l=this.safeNumber(h,2),m=this.safeNumber(h,1),g=this.safeNumber(h,0),y=l<0?-l:l,w=l<0?"asks":"bids";f[w].store(g,y,m)}e.resolve(f,a)}}handleChecksum(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,o=this.safeValue(this.orderbooks,n);if(o===void 0)return;const d=this.safeInteger(s,"len"),c=[],u=o.bids,h=o.asks;for(let g=0;g<d;g++)c.push(u[g][0]),c.push(u[g][1]),c.push(h[g][0]),c.push(-h[g][1]);const f=c.join(":"),l=this.crc32(f,!0);if(this.safeInteger(t,2)!==l){const g=new PH(this.id+" invalid checksum");e.reject(g,a)}}async watchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"wallet","exchange");e=this.omit(e,"wallet");const s="balance:"+t;return await this.subscribePrivate(s)}handleBalance(e,t,s){const i=this.safeValue(t,1);let n;i==="ws"?n=this.safeValue(t,2):n=[this.safeValue(t,2)];const r={};for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,1),u=this.safeCurrencyCode(c),h=this.parseWsBalance(d),f=this.safeString(d,0),l=this.safeValue(this.balance,f,{});l[u]=h,l.info=t,this.balance[f]=this.safeBalance(l),r[f]=!0}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c="balance:"+d;e.resolve(this.balance[d],c)}}parseWsBalance(e){const t=this.safeString(e,2),s=this.safeString(e,4),i=this.account();return s!==void 0&&(i.free=s),i.total=t,i}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticate";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=this.milliseconds(),a="AUTH"+r.toString(),o=this.hmac(this.encode(a),this.encode(this.secret),"sha384","hex"),d="auth",c={apiKey:this.apiKey,authSig:o,authNonce:r,authPayload:a,event:d},u=this.extend(c,e);n=this.watch(t,i,u),s.subscriptions[i]=n}return n}handleAuthenticationMessage(e,t){const s="authenticated";if(this.safeString(t,"status")==="OK")e.resolve(t,s);else{const n=new MH(this.json(t));e.reject(n,s),s in e.subscriptions&&delete e.subscriptions[s]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]),n=this.safeString(t,1);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new s1(c)}const r=this.orders,a={};if(n==="os"){if(i.length===0)return;for(let u=0;u<i.length;u++){const h=i[u],f=this.parseWsOrder(h),l=f.symbol;a[l]=!0,r.append(f)}}else{const c=this.parseWsOrder(i);r.append(c)}const o="orders";e.resolve(this.orders,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeMarket(u),f=o+":"+h.id;e.resolve(this.orders,f)}}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",EXECUTED:"closed","PARTIALLY FILLED":"open"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,0),i=this.safeString(e,1),n=this.safeString(e,3),r=this.safeSymbol(n);t=this.safeMarket(r);let a=this.safeNumber(e,7),o="buy";a<0&&(a=Math.abs(a),o="sell");const d=Wp.stringAbs(this.safeString(e,6));let c=this.safeString(e,8);c.indexOf("LIMIT")>-1?c="limit":c.indexOf("MARKET")>-1&&(c="market");const h=this.safeString(e,13).split(" "),f=this.safeString(h,0),l=this.parseWsOrderStatus(f),m=this.safeString(e,16),g=this.safeInteger(e,4),y=this.safeString(e,17),w=this.omitZero(this.safeString(e,18));return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:c,side:o,price:m,stopPrice:w,triggerPrice:w,average:y,amount:a,remaining:d,filled:void 0,status:l,fee:void 0,cost:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeString(t,0);if(Array.isArray(t)){if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,cs:this.handleChecksum,candles:this.handleOHLCV,ticker:this.handleTicker,trades:this.handleTrades},o={os:this.handleOrders,ou:this.handleOrders,on:this.handleOrders,oc:this.handleOrders,wu:this.handleBalance,ws:this.handleBalance,tu:this.handleMyTrade};let d;return s==="0"?d=this.safeValue(o,r):d=this.safeValue2(a,r,n),d===void 0?t:d.call(this,e,t,i)}else{const i=this.safeString(t,"event");if(i!==void 0){const n={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}}};const VH=hT,{AuthenticationError:i1,BadRequest:EH,ArgumentsRequired:qH,NotSupported:LH,InvalidNonce:RH}=Q,n1=ae,{ArrayCache:r1,ArrayCacheBySymbolById:DH,ArrayCacheByTimestamp:FH}=Pe;var HH=class extends VH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://ws.bitget.com/spot/v1/stream"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","4h":"4H","12h":"12H","1d":"1D","1w":"1W"}},streaming:{ping:this.ping},exceptions:{ws:{exact:{30001:EH,30015:i1}}}})}getWsMarketId(e){return e.spot?e.info.symbolName:e.id.replace("_UMCBL","")}getMarketIdFromArg(e){const t=this.safeString(e,"instType");let s=this.safeString(e,"instId");return t==="sp"?s+="_SPBL":s+="_UMCBL",s}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="ticker:"+e,r={instType:s.spot?"sp":"mc",channel:"ticker",instId:this.getWsMarketId(s)};return await this.watchPublic(i,r,t)}handleTicker(e,t){const s=this.parseWsTicker(t),i=s.symbol;this.tickers[i]=s;const n="ticker:"+i;return e.resolve(s,n),t}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"arg",{}),i=this.safeValue(e,"data",[]),n=this.safeValue(i,0,{}),r=this.safeInteger2(n,"ts","systemTime"),a=this.getMarketIdFromArg(s);t=this.safeMarket(a,t);const o=this.safeString(n,"last"),d=this.safeString(n,"open24h"),c=this.safeString(n,"high24h"),u=this.safeString(n,"low24h"),h=this.safeString(n,"baseVolume"),f=this.safeString(n,"quoteVolume"),l=this.safeString(n,"bestBid"),m=this.safeString(n,"bestAsk");return this.safeTicker({symbol:t.symbol,timestamp:r,datetime:this.iso8601(r),high:c,low:u,bid:l,bidVolume:void 0,ask:m,askVolume:void 0,vwap:void 0,open:d,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:f,info:n},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.safeValue(this.options,"timeframes"),o=this.safeString(a,t),d="candles:"+t+":"+e,u={instType:r.spot?"sp":"mc",channel:"candle"+o,instId:this.getWsMarketId(r)},h=await this.watchPublic(d,u,n);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i=this.getMarketIdFromArg(s),r=this.safeString(s,"channel").replace("candle",""),a=this.safeValue(this.options,"timeframes"),o=this.findTimeframe(r,a),c=this.safeMarket(i).symbol;this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let u=this.safeValue(this.ohlcvs[c],o);if(u===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new FH(l),this.ohlcvs[c][o]=u}const h=this.safeValue(t,"data",[]);for(let l=0;l<h.length;l++){const m=this.parseWsOHLCV(h[l]);u.append(m)}const f="candles:"+o+":"+c;e.resolve(u,f)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r=i.spot?"sp":"mc";let a="books",o=!0;(t===5||t===15)&&(a+=t.toString(),o=!1);const d={instType:r,channel:a,instId:this.getWsMarketId(i)},c=await this.watchPublic(n,d,s);return o?c.limit():c}handleOrderBook(e,t){const s=this.safeValue(t,"arg"),i=this.safeString(s,"channel"),n=this.getMarketIdFromArg(s),a=this.safeMarket(n).symbol,o="orderbook:"+a,d=this.safeValue(t,"data"),c=this.safeValue(d,0),u=this.safeInteger(c,"ts"),h=i==="books";let f;if(h){f=this.safeValue(this.orderbooks,a),f===void 0&&(f=this.countedOrderBook({}));const l=this.safeValue(c,"asks",[]),m=this.safeValue(c,"bids",[]);if(this.handleDeltas(f.asks,l),this.handleDeltas(f.bids,m),f.timestamp=u,f.datetime=this.iso8601(u),this.safeValue(this.options,"checksum",!0)){const y=f.asks,w=f.bids,b=y.length,S=w.length,v=[];for(let N=0;N<25;N++)N<S&&(v.push(w[N][2][0]),v.push(w[N][2][1])),N<b&&(v.push(y[N][2][0]),v.push(y[N][2][1]));const T=v.join(":"),I=this.crc32(T,!0),A=this.safeInteger(c,"checksum");if(I!==A){const N=new RH(this.id+" invalid checksum");e.reject(N,o)}}}else f=this.parseOrderBook(c,a,u);this.orderbooks[a]=f,e.resolve(f,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);s.push(t),e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade:"+e,o={instType:n.spot?"sp":"mc",channel:"trade",instId:this.getWsMarketId(n)},d=await this.watchPublic(r,o,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.getMarketIdFromArg(s),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);a=new r1(c),this.trades[r]=a}const o=this.safeValue(t,"data",[]);for(let c=0;c<o.length;c++){const u=o[c],h=this.parseWsTrade(u,n);a.append(h)}const d="trade:"+r;e.resolve(a,d)}parseWsTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,0),i=this.safeString(e,3),n=this.safeString(e,1),r=this.safeString(e,2);return this.safeTrade({info:e,id:void 0,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:i,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:void 0},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="order";const o="order:trades";e!==void 0&&(n=this.market(e),e=n.symbol,r=n.id,a=a+":"+e);let d;if([d,i]=this.handleMarketTypeAndParams("watchOrders",n,i),d==="spot"&&e===void 0)throw new qH(this.id+" watchOrders requires a symbol argument for "+d+" markets.");const h={instType:d==="spot"?"spbl":"umcbl",channel:"orders",instId:d==="spot"?r:"default"},f=await this.watchPrivate(a,o,h,i);return this.newUpdates&&(s=f.getLimit(e,s)),this.filterBySymbolSinceLimit(f,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"arg",{}),r=this.safeString(i,"instType")==="umcbl",a=this.safeValue(t,"data",[]);if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new DH(u)}const o=this.orders,d={};for(let u=0;u<a.length;u++){const h=a[u];this.safeString(h,"execType")==="T"&&r&&this.handleMyTrades(e,h);const l=this.parseWsOrder(h);o.append(l);const m=l.symbol;d[m]=!0}const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],f="order:"+h;e.resolve(o,f)}e.resolve(o,"order")}parseWsOrder(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=this.safeString(e,"ordId"),n=this.safeString(e,"clOrdId"),r=this.safeString(e,"px"),a=this.safeString(e,"fillSz"),o=this.safeString(e,"sz"),d=this.safeString2(e,"notional","notionalUsd"),c=this.omitZero(this.safeString(e,"avgPx")),u=this.safeString(e,"ordType"),h=this.safeInteger(e,"cTime"),f=t.symbol;let l=this.safeString2(e,"side","posSide");l==="open_long"||l==="close_short"?l="buy":(l==="close_long"||l==="open_short")&&(l="sell");const m=this.safeString(e,"status","state"),g=this.safeString(e,"force"),y=this.parseWsOrderStatus(m),w=this.safeValue(e,"orderFee",[]),b=this.safeValue(w,0),S=this.safeString(b,"fee");let v;if(S!==void 0){const T=this.safeString(b,"feeCcy");v={cost:n1.stringAbs(S),currency:this.safeCurrencyCode(T)}}return this.safeOrder({info:e,symbol:f,id:i,clientOrderId:n,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,type:u,timeInForce:g,postOnly:void 0,side:l,price:r,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:d,average:c,filled:a,remaining:void 0,status:y,fee:v,trades:void 0},t)}parseWsOrderStatus(e){const t={new:"open","partial-fill":"open","full-fill":"closed",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r="myTrades";e!==void 0&&(n=this.market(e),e=n.symbol,r=r+":"+e);let a;if([a,i]=this.handleMarketTypeAndParams("watchMyTrades",n,i),a==="spot")throw new LH(this.id+" watchMyTrades is not supported for "+a+" markets.");const o="order:trades",d={instType:"umcbl",channel:"orders",instId:"default"},c=await this.watchPrivate(r,o,d,i);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){if(this.myTrades===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new r1(o)}const s=this.myTrades,i=this.parseWsMyTrade(t);s.append(i);const n=i.symbol,r="myTrades";e.resolve(s,r);const a="myTrades:"+n;e.resolve(s,a)}parseWsMyTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"ordId"),n=this.safeString(e,"instId");t=this.safeMarket(n,t);const r=this.safeInteger(e,"fillTime"),a=this.safeString(e,"side"),o=this.safeString(e,"fillPx"),d=this.safeString(e,"fillSz"),c=this.safeString(e,"ordType"),u=this.safeString(e,"notional"),h=this.safeString(e,"fillFeeCcy"),f=n1.stringAbs(this.safeString(e,"fillFee")),l={code:this.safeCurrencyCode(h),cost:f};return this.safeTrade({info:e,id:s,order:i,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:c,side:a,takerOrMaker:void 0,price:o,amount:d,cost:u,fee:l},t)}async watchBalance(e={}){let t;[t,e]=this.handleMarketTypeAndParams("watchOrders",void 0,e);const s=t==="spot"?"spbl":"umcbl",i={instType:s,channel:"account",instId:"default"},n="balance:"+s;return await this.watchPrivate(n,n,i,e)}handleBalance(e,t){const s=this.safeValue(t,"data",[]);for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"coinName"),c=this.safeCurrencyCode(d),u=c in this.balance?this.balance[c]:this.account();u.free=this.safeString(o,"available"),this.balance[c]=u}this.balance=this.safeBalance(this.balance);const i=this.safeValue(t,"arg"),n=this.safeStringLower(i,"instType"),r="balance:"+n;e.resolve(this.balance,r)}async watchPublic(e,t,s={}){const i=this.urls.api.ws,n={op:"subscribe",args:[t]},r=this.extend(n,s);return await this.watch(i,e,r,e)}authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=this.seconds().toString(),a=r+"GET/user/verify",o=this.hmac(this.encode(a),this.encode(this.secret),"sha256","base64"),c={op:"login",args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:r,sign:o}]},u=this.extend(c,e);n=this.watch(t,i,u),s.subscriptions[i]=n}return n}async watchPrivate(e,t,s,i={}){await this.authenticate();const n=this.urls.api.ws,r={op:"subscribe",args:[s]},a=this.extend(r,i);return await this.watch(n,e,a,t)}handleAuthenticate(e,t){const s="authenticated";e.resolve(t,s)}handleErrorMessage(e,t){const s=this.safeString(t,"event");try{if(s==="error"){const i=this.safeString(t,"code"),n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}return!1}catch(i){if(i instanceof i1){const n="authenticated";e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n]}return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if(this.safeString(t,"message")==="pong"){this.handlePong(e,t);return}if(t==="pong"){this.handlePong(e,t);return}const i=this.safeString(t,"event");if(i==="login"){this.handleAuthenticate(e,t);return}if(i==="subscribe"){this.handleSubscriptionStatus(e,t);return}const n={ticker:this.handleTicker,trade:this.handleTrades,orders:this.handleOrder,account:this.handleBalance},r=this.safeValue(t,"arg",{}),a=this.safeValue(r,"channel",""),o=this.safeValue(n,a);o!==void 0&&o.call(this,e,t),a.indexOf("candle")>=0&&this.handleOHLCV(e,t),a.indexOf("books")>=0&&this.handleOrderBook(e,t)}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscriptionStatus(e,t){return t}};const GH=fT,{ArgumentsRequired:a1,AuthenticationError:UH}=Q,{ArrayCache:$H,ArrayCacheByTimestamp:WH,ArrayCacheBySymbolById:zH}=Pe;var jH=class extends GH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://ws-manager-compress.{hostname}/api?protocol=1.1",private:"wss://ws-manager-compress.{hostname}/user?protocol=1.1"}}},options:{defaultType:"spot",watchOrderBook:{depth:"depth5"},ws:{inflate:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","45m":"45m","1h":"1H","2h":"2H","3h":"3H","4h":"4H","1d":"1D","1w":"1W","1M":"1M"}},streaming:{keepAlive:15e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.public),r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async subscribePrivate(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.private),r=e+":"+i.id;await this.authenticate();const a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new a1(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(e=n.symbol,n.type!=="spot")throw new a1(this.id+" watchOrders supports spot markets only");const r="spot/user/order",a=await this.subscribePrivate(r,e,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrders(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new zH(r));const a=this.orders,o=[];for(let d=0;d<i.length;d++){const c=this.parseWsOrder(i[d]);a.append(c);const u=c.symbol,h=this.market(u);o.push(h.id)}for(let d=0;d<o.length;d++){const c=s+":"+o[d];e.resolve(this.orders,c)}}}parseWsOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"order_id"),n=this.safeString(e,"clientOid"),r=this.safeString(e,"price"),a=this.safeString(e,"filled_size"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.safeString(e,"state"),u=this.parseOrderStatusByType(t.type,c),h=this.safeInteger(e,"ms_t"),f=t.symbol,l=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:f,id:i,clientOrderId:n,timestamp:void 0,datetime:void 0,lastTradeTimestamp:h,type:d,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"symbol"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new $H(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"symbol"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=this.safeValue(this.options,"timeframes",{}),a=this.safeString(r,t),o="kline"+a,d=await this.subscribe(o,e,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/"),a=this.safeString(n,1).replace("kline",""),o=this.safeValue(this.options,"timeframes",{}),d=this.findTimeframe(a,o),u=this.parseTimeframe(d)*1e3;for(let h=0;h<i.length;h++){const f=this.safeString(i[h],"symbol"),l=this.safeValue(i[h],"candle"),m=this.safeMarket(f),g=m.symbol,y=this.parseOHLCV(l,m);y[0]=parseInt(y[0]/u)*u,this.ohlcvs[g]=this.safeValue(this.ohlcvs,g,{});let w=this.safeValue(this.ohlcvs[g],d);if(w===void 0){const S=this.safeInteger(this.options,"OHLCVLimit",1e3);w=new WH(S),this.ohlcvs[g][d]=w}w.append(y);const b=s+":"+f;e.resolve(w,b)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth50");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.safeInteger(t,"ms_t"),a=this.safeString(t,"symbol"),o=this.safeSymbol(a);return s.symbol=o,s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"table"),n=i.split("/"),a=this.safeString(n,1).replace("depth",""),o=parseInt(a);for(let d=0;d<s.length;d++){const c=s[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u);let f=this.safeValue(this.orderbooks,h);f===void 0&&(f=this.orderBook({},o),this.orderbooks[h]=f),f.reset({}),this.handleOrderBookMessage(e,c,f);const l=i+":"+u;e.resolve(f,l)}return t}authenticate(e={}){this.checkRequiredCredentials();const t=this.implodeHostname(this.urls.api.ws.private),s="authenticated",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){const r=this.milliseconds().toString(),a=this.uid,o="bitmart.WebSocket",d=r+"#"+a+"#"+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256"),h={op:"login",args:[this.apiKey,r,c]},f=this.extend(h,e);n=this.watch(t,s,f),i.subscriptions[s]=n}return n}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){const s="authenticated";e.resolve(t,s)}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}return!1}catch(i){if(i instanceof UH){const n="authenticated";e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n]}return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth20:this.handleOrderBook,depth50:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade};let a=this.safeValue(r,n);return n.indexOf("kline")>=0&&(a=this.handleOHLCV),this.safeString(i,2)==="order"&&(a=this.handleOrders),a===void 0?t:a.call(this,e,t)}}};const KH=lT,{AuthenticationError:XH,ExchangeError:o1,RateLimitExceeded:YH}=Q,{ArrayCache:ZH,ArrayCacheByTimestamp:QH,ArrayCacheBySymbolById:d1}=Pe;var JH=class extends KH{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{test:{ws:"wss://ws.testnet.bitmex.com/realtime"},api:{ws:"wss://ws.bitmex.com/realtime"}},versions:{ws:"0.2.0"},options:{watchOrderBookLevel:"orderBookL2",tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{ws:{exact:{},broad:{"Rate limit exceeded":YH}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),n="instrument"+":"+s.id,r=this.urls.api.ws,a={op:"subscribe",args:[n]};return await this.watch(r,n,this.extend(a,t),n)}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(r,"symbol"),o=this.safeMarket(a),d=o.symbol,c=s+":"+a;let u=this.safeValue(this.tickers,d,{});const h=this.safeValue(u,"info",{});u=this.parseTicker(this.extend(h,r),o),this.tickers[d]=u,e.resolve(u,c)}return t}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate();const t="margin",s=this.urls.api.ws,i={op:"subscribe",args:[t]};return await this.watch(s,t,this.extend(i,e),t)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.parseBalance(s);this.balance=this.extend(this.balance,i);const n=this.safeString(t,"table");e.resolve(this.balance,n)}handleTrades(e,t){const s="trade",i=this.safeValue(t,"data",[]),n=this.groupBy(i,"symbol"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=s+":"+o,u=d.symbol,h=this.parseTrades(n[o],d);let f=this.safeValue(this.trades,u);if(f===void 0){const l=this.safeInteger(this.options,"tradesLimit",1e3);f=new ZH(l),this.trades[u]=f}for(let l=0;l<h.length;l++)f.append(h[l]);e.resolve(f,c)}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const a="trade"+":"+n.id,o=this.urls.api.ws,d={op:"subscribe",args:[a]},c=await this.watch(o,a,this.extend(d,i),a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="authKeyExpires";if(this.safeValue(s.subscriptions,n)===void 0)try{this.checkRequiredCredentials();const a=this.milliseconds(),o="GET/realtime"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret)),c={op:n,args:[this.apiKey,a,d]};this.spawn(this.watch,t,n,c,n)}catch(a){s.reject(a,"authenticated"),n in s.subscriptions&&delete s.subscriptions[n]}return await i}handleAuthenticationMessage(e,t){if(this.safeValue(t,"success",!1))this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new XH(this.json(t));e.reject(i,"authenticated");const n="authKeyExpires";n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="order",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data",[]),i="order",n=s.length;if(n>0){if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new d1(d)}const r=this.orders,a={};for(let d=0;d<n;d++){const c=s[d],u=this.safeString(c,"orderID"),h=this.safeValue(r.hashmap,u);let f=c;h!==void 0&&(f=this.extend(h.info,c));const l=this.parseOrder(f);r.append(l);const m=l.symbol;a[m]=!0}e.resolve(this.orders,i);const o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d];e.resolve(this.orders,i+":"+c)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="execution",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.groupBy(i,"execType"),r=this.safeValue(n,"Trade",[]),a=this.parseTrades(r);if(this.myTrades===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new d1(h)}const o=this.myTrades,d={};for(let h=0;h<a.length;h++){const f=a[h],l=f.symbol;o.append(f),d[l]=f}a.length>0&&e.resolve(o,s);const u=Object.keys(d);for(let h=0;h<u.length;h++)e.resolve(o,s+":"+u[h])}async watchOrderBook(e,t=void 0,s={}){let i;if(t===void 0)i=this.safeString(this.options,"watchOrderBookLevel","orderBookL2");else if(t===25)i="orderBookL2_25";else if(t===10)i="orderBookL10";else throw new o1(this.id+" watchOrderBook limit argument must be undefined (L2), 25 (L2) or 10 (L3)");await this.loadMarkets();const n=this.market(e),r=i+":"+n.id,a=this.urls.api.ws,o={op:"subscribe",args:[r]};return(await this.watch(a,r,this.deepExtend(o,s),r)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const o="tradeBin"+this.timeframes[t]+":"+r.id,d=this.urls.api.ws,c={op:"subscribe",args:[o]},u=await this.watch(d,o,this.extend(c,n),o);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=s.replace("tradeBin",""),n=this.findTimeframe(i),r=this.parseTimeframe(n),a=this.safeValue(t,"data",[]),o={};for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),f=this.safeMarket(h),l=f.symbol,m=s+":"+f.id,g=[this.parse8601(this.safeString(u,"timestamp"))-r*1e3,this.safeFloat(u,"open"),this.safeFloat(u,"high"),this.safeFloat(u,"low"),this.safeFloat(u,"close"),this.safeFloat(u,"volume")];this.ohlcvs[l]=this.safeValue(this.ohlcvs,l,{});let y=this.safeValue(this.ohlcvs[l],n);if(y===void 0){const w=this.safeInteger(this.options,"OHLCVLimit",1e3);y=new QH(w),this.ohlcvs[l][n]=y}y.append(g),o[m]=y}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c];e.resolve(o[u],u)}}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws;return await this.watch(s,t)}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(s==="partial"){const r=this.safeValue(t,"filter",{}),a=this.safeValue(r,"symbol"),d=this.safeMarket(a).symbol;i==="orderBookL2"?this.orderbooks[d]=this.indexedOrderBook():i==="orderBookL2_25"?this.orderbooks[d]=this.indexedOrderBook({},25):i==="orderBook10"&&(this.orderbooks[d]=this.indexedOrderBook({},10));const c=this.orderbooks[d];for(let h=0;h<n.length;h++){const f=this.safeFloat(n[h],"price"),l=this.safeFloat(n[h],"size"),m=this.safeString(n[h],"id");let g=this.safeString(n[h],"side");g=g==="Buy"?"bids":"asks",c[g].store(f,l,m)}const u=i+":"+a;e.resolve(c,u)}else{const r={};for(let o=0;o<n.length;o++){const d=this.safeValue(n[o],"symbol");d in r||(r[d]=0),r[d]=this.sum(r,1);const u=this.safeMarket(d).symbol,h=this.orderbooks[u],f=this.safeFloat(n[o],"price"),l=this.safeFloat(n[o],"size",0),m=this.safeString(n[o],"id");let g=this.safeString(n[o],"side");g=g==="Buy"?"bids":"asks",h[g].store(f,l,m)}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=i+":"+d,h=this.safeMarket(d).symbol,f=this.orderbooks[h];e.resolve(f,c)}}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){return t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0){const i=this.safeValue(t,"request",{}),n=this.safeString(i,"args",[]);if(n.length>0){const a=n[0],o=this.exceptions.ws.broad,d=this.findBroadlyMatchedKey(o,s);let c;return d===void 0?c=new o1(s):c=new o[d](s),e.reject(c,a),!1}}return!0}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"table"),i={orderBookL2:this.handleOrderBook,orderBookL2_25:this.handleOrderBook,orderBook10:this.handleOrderBook,instrument:this.handleTicker,trade:this.handleTrades,tradeBin1m:this.handleOHLCV,tradeBin5m:this.handleOHLCV,tradeBin1h:this.handleOHLCV,tradeBin1d:this.handleOHLCV,order:this.handleOrders,execution:this.handleMyTrades,margin:this.handleBalance},n=this.safeValue(i,s);if(n===void 0){const r=this.safeValue(t,"request",{});return this.safeValue(r,"op")==="authKeyExpires"?this.handleAuthenticationMessage.call(this,e,t):t}else return n.call(this,e,t)}}};const eG=pT,{ExchangeError:tG}=Q,{ArrayCache:sG}=Pe;var iG=class extends eG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{ws:{public:"wss://stream.bitopro.com:9443/ws/v1/pub",private:"wss://stream.bitopro.com:9443/ws/v1/pub/auth"}},requiredCredentials:{apiKey:!0,secret:!0,login:!0},options:{tradesLimit:1e3,ordersLimit:1e3,ws:{options:{headers:{}}}}})}async watchPublic(e,t,s){const i=this.urls.ws.public+"/"+e+"/"+s;return await this.watch(i,t,void 0,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new tG(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="ORDER_BOOK:"+e;let r;return t===void 0?r=i.id:r=i.id+":"+t,(await this.watchPublic("order-books",n,r)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n;let o=this.safeValue(this.orderbooks,n);o===void 0&&(o=this.orderBook({}));const d=this.safeInteger(t,"timestamp"),c=this.parseOrderBook(t,n,d,"bids","asks","price","amount");o.reset(c),e.resolve(o,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="TRADE:"+e,a=await this.watchPublic("trades",r,n.id,s);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_"),n=i.symbol,a=this.safeString(t,"event")+":"+n,o=this.safeValue(t,"data",[]),d=this.parseTrades(o,i);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new sG(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[n]=c,e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="TICKER:"+e;return await this.watchPublic("tickers",i,s.id)}handleTicker(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n,o=this.parseTicker(t),d=this.safeInteger(t,"timestamp"),c=this.safeString(t,"datetime");o.timestamp=d,o.datetime=c,this.tickers[n]=o,e.resolve(o,a)}authenticate(e){if(this.clients!==void 0&&e in this.clients)return;this.checkRequiredCredentials();const t=this.milliseconds(),s=this.json({nonce:t,identity:this.login}),i=this.stringToBase64(s),n=this.hmac(i,this.encode(this.secret),"sha384"),r={ws:{options:{headers:{}}}};this.options=this.extend(r,this.options);const a=this.options.ws.options.headers;this.options.ws.options.headers={"X-BITOPRO-API":"ccxt","X-BITOPRO-APIKEY":this.apiKey,"X-BITOPRO-PAYLOAD":i,"X-BITOPRO-SIGNATURE":n},this.client(e),this.options.ws.options.headers=a}async watchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t="ACCOUNT_BALANCE",s=this.urls.ws.private+"/account-balance";return this.authenticate(s),await this.watch(s,t,void 0,t)}handleBalance(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=this.safeString(n,a),d=this.safeValue(i,o),c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"available"),h.total=this.safeString(d,"amount"),r[u]=h}this.balance=this.safeBalance(r),e.resolve(this.balance,s)}handleMessage(e,t){const s={TRADE:this.handleTrade,TICKER:this.handleTicker,ORDER_BOOK:this.handleOrderBook,ACCOUNT_BALANCE:this.handleBalance},i=this.safeString(t,"event"),n=this.safeValue(s,i);return n===void 0?t:n.call(this,e,t)}};const nG=mT,{ArrayCacheBySymbolById:rG}=Pe,{ArgumentsRequired:aG}=Q;var oG=class extends nG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!1,watchTickers:!1,watchTrades:!1,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!1,watchOHLCV:!1},urls:{api:{open:"https://open.bitrue.com",ws:{public:"wss://ws.bitrue.com/market/ws",private:"wss://wsapi.bitrue.com"}}},api:{open:{private:{post:{"poseidon/api/v1/listenKey":1},put:{"poseidon/api/v1/listenKey/{listenKey}":1},delete:{"poseidon/api/v1/listenKey/{listenKey}":1}}}},options:{listenKeyRefreshRate:18e5,ws:{gunzip:!0}}})}async watchBalance(e={}){const t=await this.authenticate(),s="balance",i={event:"sub",params:{channel:"user_balance_update"}},n=this.deepExtend(i,e);return await this.watch(t,s,n,s)}handleBalance(e,t){const s=this.safeValue(t,"B",[]);this.parseWSBalances(s);const i="balance";e.resolve(this.balance,i)}parseWSBalances(e){for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"a"),n=this.safeCurrencyCode(i),r=this.account(),a=this.safeString(s,"F"),o=this.safeString(s,"L"),d=this.safeInteger(s,"T",0),c=this.safeInteger(s,"t",0),u=d!==0,h=c!==0;(u||h)&&(u&&(r.free=a),h&&(r.used=o),this.balance[n]=r)}this.balance=this.safeBalance(this.balance)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.authenticate(),r="orders",a={event:"sub",params:{channel:"user_order_update"}},o=this.deepExtend(a,i),d=await this.watch(n,r,o,r);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleOrder(e,t){const s=this.parseWSOrder(t);if(this.orders===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new rG(r)}this.orders.append(s);const n="orders";e.resolve(this.orders,n)}parseWSOrder(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeStringUpper(e,"s"),n=this.safeString(e,"o"),a=this.safeInteger(e,"S")===1?"buy":"sell",o=this.safeString(e,"X"),d=this.safeString(e,"N");return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"T"),symbol:this.safeSymbol(i,t),type:this.parseWSOrderType(n),timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"p"),triggerPrice:void 0,amount:this.safeString(e,"q"),cost:this.safeString(e,"Y"),average:void 0,filled:this.safeString(e,"z"),remaining:void 0,status:this.parseWSOrderStatus(o),fee:{currency:this.safeCurrencyCode(d),cost:this.safeNumber(e,"n")}},t)}async watchOrderBook(e,t=void 0,s={}){if(e===void 0)throw new aG(this.id+" watchOrderBook() requires a symbol argument");await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r=i.id.toLowerCase(),a="market_"+r+"_simple_depth_step0",o=this.urls.api.ws.public,d={event:"sub",params:{cb_id:r,channel:a}},c=this.deepExtend(d,s);return await this.watch(o,n,c,n)}handleOrderBook(e,t){const i=this.safeString(t,"channel").split("_"),n=this.safeStringUpper(i,1),a=this.safeMarket(n).symbol,o=this.safeInteger(t,"ts"),d=this.safeValue(t,"tick",{}),c=this.parseOrderBook(d,a,o,"buys","asks");this.orderbooks[a]=c;const u="orderbook:"+a;e.resolve(c,u)}parseWSOrderType(e){const t={1:"limit",2:"market",3:"limit"};return this.safeString(t,e,e)}parseWSOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"open",4:"canceled",7:"open"};return this.safeString(t,e,e)}handlePing(e,t){this.spawn(this.pong,e,t)}async pong(e,t){const i={pong:this.safeInteger(t,"ping")};await e.send(i)}handleMessage(e,t){if("channel"in t)this.handleOrderBook(e,t);else if("ping"in t)this.handlePing(e,t);else{const s=this.safeString(t,"e"),i={BALANCE:this.handleBalance,ORDER:this.handleOrder},n=this.safeValue(i,s);n!==void 0&&n.call(this,e,t)}}async authenticate(e={}){if(this.safeValue(this.options,"listenKey")===void 0){let s;try{s=await this.openPrivatePostPoseidonApiV1ListenKey(e)}catch{this.options.listenKey=void 0,this.options.listenKeyUrl=void 0;return}const i=this.safeValue(s,"data",{}),n=this.safeString(i,"listenKey");this.options.listenKey=n,this.options.listenKeyUrl=this.urls.api.ws.private+"/stream?listenKey="+n;const r=this.safeInteger(this.options,"listenKeyRefreshRate",18e5);this.delay(r,this.keepAliveListenKey)}return this.options.listenKeyUrl}async keepAliveListenKey(e={}){const s={listenKey:this.safeString(this.options,"listenKey")};try{await this.openPrivatePutPoseidonApiV1ListenKeyListenKey(this.extend(s,e))}catch{this.options.listenKey=void 0,this.options.listenKeyUrl=void 0;return}const i=this.safeInteger(this.options,"listenKeyRefreshRate",18e5);this.delay(i,this.keepAliveListenKey)}};const dG=gT,{ArgumentsRequired:cG,AuthenticationError:uG}=Q,{ArrayCache:hG,ArrayCacheBySymbolById:fG}=Pe;var lG=class extends dG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!1,watchTicker:!1,watchTickers:!1},urls:{api:{ws:"wss://ws.bitstamp.net"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{snapshotDelay:6},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:uG}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r="diff_order_book_"+i.id,a=this.urls.api.ws,o={event:"bts:subscribe",data:{channel:r}},d=this.extend(o,s);return(await this.watch(a,n,d,n)).limit()}handleOrderBook(e,t){const i=this.safeString(t,"channel").split("_"),n=this.safeString(i,3),r=this.safeSymbol(n),a=this.safeValue(this.orderbooks,r),o=this.safeValue(a,"nonce"),d=this.safeValue(t,"data"),c=this.safeInteger(d,"microtimestamp"),u="orderbook:"+r;if(o===void 0){const h=a.cache.length,f=this.handleOption("watchOrderBook","snapshotDelay",6);h===f&&this.spawn(this.loadOrderBook,e,u,r),a.cache.push(d);return}else if(o>=c)return;this.handleDelta(a,d),e.resolve(a,u)}handleDelta(e,t){const s=this.safeTimestamp(t,"timestamp");e.timestamp=s,e.datetime=this.iso8601(s),e.nonce=this.safeInteger(t,"microtimestamp");const i=this.safeValue(t,"bids",[]),n=this.safeValue(t,"asks",[]),r=e.bids,a=e.asks;this.handleBidAsks(r,i),this.handleBidAsks(a,n)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=this.parseBidAsk(t[s]);e.storeArray(i)}}getCacheIndex(e,t){const s=t[0],i=this.safeInteger(s,"microtimestamp"),n=this.safeInteger(e,"nonce");if(n<i)return-1;for(let r=0;r<t.length;r++){const a=t[r];if(this.safeInteger(a,"microtimestamp")===n)return r+1}return t.length}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades:"+e,a=this.urls.api.ws,o="live_trades_"+n.id,d={event:"bts:subscribe",data:{channel:o}},c=this.extend(d,i),u=await this.watch(a,r,c,r);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"microtimestamp"),i=this.safeString(e,"id"),n=parseInt(s/1e3),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=t.symbol;let d=this.safeInteger(e,"type");return d=d===0?"buy":"sell",this.safeTrade({info:e,timestamp:n,datetime:this.iso8601(n),symbol:o,id:i,order:void 0,type:void 0,takerOrMaker:void 0,side:d,price:r,amount:a,cost:void 0,fee:void 0},t)}handleTrade(e,t){const i=this.safeString(t,"channel").split("_"),n=this.safeString(i,2),r=this.safeMarket(n),a=r.symbol,o="trades:"+a,d=this.safeValue(t,"data"),c=this.parseWsTrade(d,r);let u=this.safeValue(this.trades,a);if(u===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);u=new hG(h),this.trades[a]=u}u.append(c),e.resolve(u,o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new cG(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="private-my_orders",a=r+"_"+n.id,o={symbol:e,limit:s,type:r,params:i},d=await this.subscribePrivate(o,a,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleOrders(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data",{}),n=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new fG(n));const r=this.orders,a=this.safeValue(e.subscriptions,s),o=this.safeString(a,"symbol"),d=this.market(o),c=this.parseWsOrder(i,d);r.append(c),e.resolve(this.orders,s)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"id_str"),i=this.safeStringLower(e,"order_type"),n=this.safeString(e,"price_str"),r=this.safeString(e,"amount_str"),a=i==="1"?"sell":"buy",o=this.safeTimestamp(e,"datetime");t=this.safeMarket(void 0,t);const d=t.symbol;return this.safeOrder({info:e,symbol:d,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,type:void 0,timeInForce:void 0,postOnly:void 0,side:a,price:n,stopPrice:void 0,triggerPrice:void 0,amount:r,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0},t)}handleOrderBookSubscription(e,t){const i=this.safeString(t,"channel").split("_"),n=this.safeString(i,3),r=this.safeSymbol(n);this.orderbooks[r]=this.orderBook()}handleSubscriptionStatus(e,t){this.safeString(t,"channel").indexOf("order_book")>-1&&this.handleOrderBookSubscription(e,t)}handleSubject(e,t){const s=this.safeString(t,"channel"),i={live_trades:this.handleTrade,diff_order_book:this.handleOrderBook,"private-my_orders":this.handleOrders},n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r];s.indexOf(a)>-1&&i[a].call(this,e,t)}}handleErrorMessage(e,t){if(this.safeString(t,"event")==="bts:error"){const i=this.id+" "+this.json(t),n=this.safeValue(t,"data",{}),r=this.safeNumber(n,"code");this.throwExactlyMatchedException(this.exceptions.exact,r,i)}return t}handleMessage(e,t){return this.handleErrorMessage(e,t)?this.safeString(t,"event")==="bts:subscription_succeeded"?this.handleSubscriptionStatus(e,t):this.handleSubject(e,t):void 0}async authenticate(e={}){this.checkRequiredCredentials();const t=this.milliseconds(),s=this.safeInteger(this.options,"expiresIn");if(s===void 0||t>s){const i=await this.privatePostWebsocketsToken(e),n=this.safeString(i,"token");if(n!==void 0){const r=this.safeNumber(i,"user_id"),a=this.safeIntegerProduct(i,"valid_sec",1e3);return this.options.expiresIn=this.sum(t,a),this.options.userId=r,this.options.wsSessionToken=n,i}}}async subscribePrivate(e,t,s={}){const i=this.urls.api.ws;await this.authenticate(),t+="-"+this.options.userId;const n={event:"bts:subscribe",data:{channel:t,auth:this.options.wsSessionToken}};return e.messageHash=t,await this.watch(i,t,this.extend(n,s),t,e)}};const pG=yT,{InvalidNonce:mG,BadRequest:gG}=Q,{ArrayCache:yG,ArrayCacheByTimestamp:wG,ArrayCacheBySymbolById:c1}=Pe;var bG=class extends pG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchHeartbeat:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://socket-v3.bittrex.com/signalr/connect",signalr:"https://socket-v3.bittrex.com/signalr"}},api:{signalr:{get:["negotiate","start"]}},options:{tradesLimit:1e3,hub:"c3",I:this.milliseconds()}})}getSignalRUrl(e){const t=this.safeString(e.response,"ConnectionToken"),s=this.extend(e.request,{connectionToken:t});return this.urls.api.ws+"?"+this.urlencode(s)}makeRequest(e,t,s){return{H:this.safeString(this.options,"hub","c3"),M:t,A:s,I:e}}makeRequestToSubscribe(e,t){const s="Subscribe";return this.makeRequest(e,s,t)}makeRequestToAuthenticate(e){const t=this.milliseconds(),s=this.uuid(),i=t.toString()+s,n=this.hmac(this.encode(i),this.encode(this.secret),"sha512"),r=[this.apiKey,t,s,n],a="Authenticate";return this.makeRequest(e,a,r)}requestId(){const e=this.sum(this.safeInteger(this.options,"I",0),1);return this.options.I=e,e}async sendRequestToSubscribe(e,t,s,i={}){const n=[t],r=this.requestId().toString(),a=this.makeRequestToSubscribe(r,[n]);s=this.extend({id:r,negotiation:e},s);const o=this.getSignalRUrl(e);return await this.watch(o,t,a,t,s)}async authenticate(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.sendRequestToAuthenticate(t,!1,e)}async sendRequestToAuthenticate(e,t=!1,s={}){const i=this.getSignalRUrl(e),n=this.client(i),r="authenticate";let a=this.safeValue(n.subscriptions,r);if(a===void 0||t){a=n.future(r),n.subscriptions[r]=a;const o=this.requestId().toString(),d=this.makeRequestToAuthenticate(o),c={id:o,params:s,negotiation:e,method:this.handleAuthenticate};this.spawn(this.watch,i,r,d,o,c)}return await a}async sendAuthenticatedRequestToSubscribe(e,t,s={}){const i=this.safeValue(e,"negotiation"),n={params:s};return await this.sendRequestToSubscribe(i,t,n,s)}handleAuthenticate(e,t,s){const i=this.safeString(s,"id");i in e.subscriptions&&delete e.subscriptions[i],e.resolve(s,"authenticate")}async handleAuthenticationExpiringHelper(){const e=await this.negotiate();return await this.sendRequestToAuthenticate(e,!0)}handleAuthenticationExpiring(e,t){this.spawn(this.handleAuthenticationExpiringHelper)}createSignalRQuery(e={}){const s=[{name:this.safeString(this.options,"hub","c3")}],i=this.milliseconds();return this.extend({transport:"webSockets",connectionData:this.json(s),clientProtocol:1.5,_:i,tid:this.sum(i%10,1)},e)}async negotiate(e={}){const t=this.client(this.urls.api.ws),s="negotiate";let i=this.safeValue(t.subscriptions,s);if(i===void 0){i=t.future(s),t.subscriptions[s]=i;const n=this.createSignalRQuery(e),r=await this.signalrGetNegotiate(this.extend(n,e)),a={request:n,response:r};t.resolve(a,s)}return await i}async start(e,t={}){const s=this.safeString(e.response,"ConnectionToken"),i=this.createSignalRQuery(this.extend(e.request,{connectionToken:s}));return await this.signalrGetStart(i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.symbol(e));const n=await this.authenticate(),r=await this.subscribeToOrders(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToOrders(e,t={}){const s="order";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleOrder(e,t){const s=this.safeValue(t,"delta",{}),i=this.parseOrder(s);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new c1(a)}this.orders.append(i);const r="order";e.resolve(this.orders,r)}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate();return await this.subscribeToBalance(t,e)}async subscribeToBalance(e,t={}){const s="balance";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleBalance(e,t){const s=this.safeValue(t,"delta",{}),i=this.safeString(s,"currencySymbol"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"available"),r.total=this.safeString(s,"total"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchHeartbeat(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.subscribeToHeartbeat(t,e)}async subscribeToHeartbeat(e,t={}){await this.loadMarkets();const s=this.getSignalRUrl(e),i=this.milliseconds().toString(),n="heartbeat",r=[n],a=this.makeRequestToSubscribe(i,[r]),o={id:i,params:t,negotiation:e};return await this.watch(s,n,a,n,o)}handleHeartbeat(e,t){e.resolve(t,"heartbeat")}async watchTicker(e,t={}){await this.loadMarkets();const s=await this.negotiate();return await this.subscribeToTicker(s,e,t)}async subscribeToTicker(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const r="ticker"+"_"+i.id,a={marketId:i.id,symbol:t,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTicker(e,t){const s=this.parseTicker(t),i=s.symbol,n=this.market(i);this.tickers[i]=s;const a="ticker"+"_"+n.id;e.resolve(s,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.negotiate(),a=await this.subscribeToOHLCV(r,e,t,n);return this.newUpdates&&(i=a.getLimit(e,i)),this.filterBySinceLimit(a,s,i,0,!0)}async subscribeToOHLCV(e,t,s="1m",i={}){await this.loadMarkets();const n=this.market(t),r=this.timeframes[s],o="candle"+"_"+n.id+"_"+r,d={symbol:t,timeframe:s,messageHash:o,params:i};return await this.sendRequestToSubscribe(e,o,d)}handleOHLCV(e,t){const s="candle",i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.safeString(t,"interval"),a=s+"_"+i+"_"+r,o=this.findTimeframe(r),d=this.safeValue(t,"delta",{}),c=this.parseOHLCV(d);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let u=this.safeValue(this.ohlcvs[n],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new wG(h),this.ohlcvs[n][o]=u}u.append(c),e.resolve(u,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.negotiate(),r=await this.subscribeToTrades(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async subscribeToTrades(e,t,s={}){await this.loadMarkets();const i=this.market(t),r="trade"+"_"+i.id,a={symbol:t,messageHash:r,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTrades(e,t){const s=this.safeValue(t,"deltas",[]),i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.market(n),o="trade"+"_"+i;let d=this.safeValue(this.trades,n);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new yG(u)}const c=this.parseTrades(s,r);for(let u=0;u<c.length;u++)d.append(c[u]);this.trades[n]=d,e.resolve(d,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.authenticate(),r=await this.subscribeToMyTrades(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToMyTrades(e,t={}){const s="execution";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleMyTrades(e,t){const s=this.safeValue(t,"deltas",{}),i=this.parseTrades(s);let n=this.myTrades;if(n===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new c1(a),this.myTrades=n}for(let a=0;a<i.length;a++)n.append(i[a]);const r="execution";e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){if(t=t===void 0?25:t,t!==1&&t!==25&&t!==500)throw new gG(this.id+" watchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");await this.loadMarkets(),e=this.symbol(e);const i=await this.negotiate();return(await this.subscribeToOrderBook(i,e,t,s)).limit()}async subscribeToOrderBook(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.market(t),a="orderbook"+"_"+n.id+"_"+s.toString(),o={symbol:t,messageHash:a,method:this.handleSubscribeToOrderBook,limit:s,params:i};return await this.sendRequestToSubscribe(e,a,o)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeInteger(c,"sequence"),h=this.safeInteger(a,"nonce");if(u!==void 0&&h<u){const f=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),l=this.safeInteger(f,"maxAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<l)r in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[r]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else throw new mG(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+l.toString()+" attempts")}else{o.reset(a);for(let f=0;f<d.length;f++){const l=d[f];this.handleOrderBookMessage(e,l,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){e.reject(a,r)}}handleSubscribeToOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleDelta(e,t){const s=this.safeFloat(t,"rate"),i=this.safeFloat(t,"quantity");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"marketSymbol"),i=this.safeSymbol(s,void 0,"-"),n=this.safeInteger(t,"depth");let r=this.safeValue(this.orderbooks,i);r===void 0&&(r=this.orderBook({},n)),r.nonce!==void 0?this.handleOrderBookMessage(e,t,r):r.cache.push(t)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"marketSymbol"),n=this.safeString(t,"depth"),a="orderbook"+"_"+i+"_"+n,o=this.safeInteger(t,"sequence");return o>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"askDeltas",[])),this.handleDeltas(s.bids,this.safeValue(t,"bidDeltas",[])),s.nonce=o,e.resolve(s,a)),s}async handleSystemStatusHelper(){const e=await this.negotiate();await this.start(e)}handleSystemStatus(e,t){return this.spawn(this.handleSystemStatusHelper),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"I");let i=this.safeValue(e.subscriptions,s);if(i===void 0){const r=this.indexBy(e.subscriptions,"id");i=this.safeValue(r,s,{})}else delete e.subscriptions[s];const n=this.safeValue(i,"method");return n===void 0?e.resolve(t,s):n.call(this,e,t,i),t}handleMessage(e,t){const s={authenticationExpiring:this.handleAuthenticationExpiring,order:this.handleOrder,balance:this.handleBalance,trade:this.handleTrades,candle:this.handleOHLCV,orderBook:this.handleOrderBook,heartbeat:this.handleHeartbeat,ticker:this.handleTicker,execution:this.handleMyTrades},i=this.safeValue(t,"M",[]);for(let a=0;a<i.length;a++){const o=this.safeValue(i[a],"M"),d=this.safeValue(s,o);if(d!==void 0)if(o==="heartbeat")d.call(this,e,t);else if(o==="authenticationExpiring")d.call(this,e,t);else{const c=this.safeValue(i[a],"A",[]);for(let u=0;u<c.length;u++){const h=this.inflate64(c[u]),f=JSON.parse(h);d.call(this,e,f)}}}"I"in t&&this.handleSubscriptionStatus(e,t),"S"in t&&this.handleSystemStatus(e,t),Object.keys(t).length<1&&this.handleHeartbeat(e,t)}};const kG=wT,{AuthenticationError:SG,ArgumentsRequired:u1}=Q,{ArrayCache:h1,ArrayCacheByTimestamp:vG,ArrayCacheBySymbolById:TG}=Pe;var OG=class extends kG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws.bitvavo.com/v2"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=e+"@"+i.id,r=this.urls.api.ws,a={action:"subscribe",channels:[{name:e,markets:[i.id]}]},o=this.extend(a,s);return await this.watch(r,n,o,n)}async watchTicker(e,t={}){return await this.watchPublic("ticker24h",e,t)}handleTicker(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market"),o=this.safeMarket(a,void 0,"-"),d=s+"@"+a,c=this.parseTicker(r,o),u=c.symbol;this.tickers[u]=c,e.resolve(c,d)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),n=i.symbol,a="trades"+"@"+s,o=this.parseTrade(t,i);let d=this.safeValue(this.trades,n);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new h1(c)}d.append(o),this.trades[n]=d,e.resolve(d,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=r.id,d=this.timeframes[t],c=a+"@"+o+"_"+d,u=this.urls.api.ws,h={action:"subscribe",channels:[{name:"candles",interval:[d],markets:[o]}]},f=this.extend(h,n),l=await this.watch(u,c,f,c);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s="candles",i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a),d=s+"@"+i+"_"+a,c=this.safeValue(t,"candle");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let u=this.safeValue(this.ohlcvs[r],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new vG(h),this.ohlcvs[r][o]=u}for(let h=0;h<c.length;h++){const f=c[h],l=this.parseOHLCV(f,n);u.append(l)}e.resolve(u,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="book",r=n+"@"+i.id,a=this.urls.api.ws,o={action:"subscribe",channels:[{name:n,markets:[i.id]}]},d={messageHash:r,name:n,symbol:e,marketId:i.id,method:this.handleOrderBookSubscription,limit:t,params:s},c=this.extend(o,s);return(await this.watch(a,r,c,r,d)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"nonce");return i>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"asks",[])),this.handleDeltas(s.bids,this.safeValue(t,"bids",[])),s.nonce=i),s}handleOrderBook(e,t){const s=this.safeString(t,"event"),i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=s+"@"+n.id,o=this.safeValue(this.orderbooks,r);if(o!==void 0)if(o.nonce===void 0){const d=this.safeValue(e.subscriptions,a,{});if(this.safeValue(d,"watchingOrderBookSnapshot")===void 0){d.watchingOrderBookSnapshot=!0,e.subscriptions[a]=d;const u=this.safeValue(this.options,"watchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.watchOrderBookSnapshot,e,t,d)}o.cache.push(t)}else this.handleOrderBookMessage(e,t,o),e.resolve(o,a)}async watchOrderBookSnapshot(e,t,s){const i=this.safeValue(s,"params"),n=this.safeString(s,"marketId"),r="getBook",a=r+"@"+n,o=this.urls.api.ws,d={action:r,market:n};return(await this.watch(o,a,this.extend(d,i),a,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"response");if(s===void 0)return t;const i=this.safeString(s,"market"),n=this.safeSymbol(i,void 0,"-"),a="book"+"@"+i,o=this.orderbooks[n],d=this.parseOrderBook(s,n);d.nonce=this.safeInteger(s,"nonce"),o.reset(d);const c=o.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,o)}this.orderbooks[n]=o,e.resolve(o,a)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n)}handleOrderBookSubscriptions(e,t,s){const i="book";for(let n=0;n<s.length;n++){const r=this.safeString(s,n),a=this.safeSymbol(r,void 0,"-"),o=i+"@"+r;if(!(a in this.orderbooks)){const d=this.safeValue(e.subscriptions,o),c=this.safeValue(d,"method");c!==void 0&&c.call(this,e,t,d)}}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new u1(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d="order:"+e,c={action:"subscribe",channels:[{name:o,markets:[r]}]},u=await this.watch(a,d,c,d);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new u1(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d="myTrades:"+e,c={action:"subscribe",channels:[{name:o,markets:[r]}]},u=await this.watch(a,d,c,d);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleOrder(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),n=i.symbol,r="order:"+n,a=this.parseOrder(t,i);if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new TG(d)}this.orders.append(a),e.resolve(this.orders,r)}handleMyTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),n=i.symbol,r="myTrades:"+n,a=this.parseTrade(t,i);if(this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new h1(d)}const o=this.myTrades;o.append(a),e.resolve(o,r)}handleSubscriptionStatus(e,t){const s=this.safeValue(t,"subscriptions",{}),i={book:this.handleOrderBookSubscriptions},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a);if(o!==void 0){const d=this.safeValue(s,a);o.call(this,e,t,d)}}return t}authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=this.milliseconds(),o=r.toString()+"GET/"+this.version+"/websocket",d=this.hmac(this.encode(o),this.encode(this.secret)),u={action:"authenticate",key:this.apiKey,signature:d,timestamp:r},h=this.extend(u,e);n=this.watch(t,i,h),s.subscriptions[i]=n}return n}handleAuthenticationMessage(e,t){const s="authenticated";if(this.safeValue(t,"authenticated",!1))e.resolve(t,s);else{const n=new SG(this.json(t));e.reject(n,s),s in e.subscriptions&&delete e.subscriptions[s]}}handleMessage(e,t){const s={subscribed:this.handleSubscriptionStatus,book:this.handleOrderBook,getBook:this.handleOrderBookSnapshot,trade:this.handleTrade,candle:this.handleOHLCV,ticker24h:this.handleTicker,authenticate:this.handleAuthenticationMessage,order:this.handleOrder,fill:this.handleMyTrade},i=this.safeString(t,"event");let n=this.safeValue(s,i);if(n===void 0){const r=this.safeString(t,"action");return n=this.safeValue(s,r),n===void 0?t:n.call(this,e,t)}else return n.call(this,e,t)}};const IG=bT,{NotSupported:xG,ExchangeError:_G,ArgumentsRequired:f1}=Q,{ArrayCache:CG,ArrayCacheBySymbolById:l1,ArrayCacheByTimestamp:MG}=Pe;var PG=class extends IG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://api.btcex.com/ws/api/v1"}},options:{watchOrderBook:{snapshotDelay:0}},streaming:{ping:this.ping,keepAlive:5e3},exceptions:{},timeframes:{"1m":"1","3m":"3","5m":"4","10m":"10","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","4h":"240","6h":"360","12h":"720","1d":"1D"}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchBalance(e={}){const t=await this.authenticate(e);let s;[s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const i=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(i,s,s);e=this.omit(e,"type");const r="balancess",a=this.urls.api.ws,o={jsonrpc:"2.0",id:this.requestId(),method:"/private/subscribe",params:{access_token:t,channels:["user.asset."+n]}},d=this.deepExtend(o,e);return await this.watch(a,r,d,r,d)}handleBalance(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n="balancess";this.balance=this.parseBalance(i),e.resolve(this.balance,n)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;let a=r.id;r.spot&&(a=r.baseId+"-"+r.quoteId);const o=this.safeString(this.timeframes,t,t),d="ohlcv:"+e+":"+o;let c={jsonrpc:"2.0",id:this.requestId(),method:"/public/subscribe",params:{channels:["chart.trades."+a+"."+o]}};c=this.deepExtend(c,n);const u=this.urls.api.ws,h=await this.watch(u,d,c,d,c);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params"),n=this.safeString(s,"channel").slice(13),r=n.indexOf("."),a=n.slice(0,r),o=n.slice(r+1),d=this.findTimeframe(o),c=this.safeSymbol(a,void 0,"-"),u="ohlcv:"+c+":"+o,h=this.safeValue(s,"data",{}),f=this.parseOHLCV(h);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let l=this.safeValue(this.ohlcvs[c],d);if(l===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new MG(m),this.ohlcvs[c][d]=l}l.append(f),e.resolve(l,u)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;let i=s.id;s.spot&&(i=s.baseId+"-"+s.quoteId);const n=this.urls.api.ws,r="ticker:"+e;let a={jsonrpc:"2.0",id:this.requestId(),method:"/public/subscribe",params:{channels:["ticker."+i+".raw"]}};return a=this.deepExtend(a,t),await this.watch(n,r,a,r)}handleTicker(e,t){const s=this.safeValue(t,"params"),i=this.safeValue(s,"data"),n=this.parseTicker(i),r=this.safeString(n,"symbol"),a="ticker:"+r;this.tickers[r]=n,e.resolve(n,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a="trades:"+e;let o={jsonrpc:"2.0",id:this.requestId(),method:"/public/subscribe",params:{channels:["trades."+n.id+".raw"]}};o=this.deepExtend(o,i);const d=await this.watch(r,a,o,a,o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),r=this.safeString(s,"channel").split(".")[1],a=this.safeSymbol(r),o="trades:"+a;let d=this.safeValue(this.trades,a);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new CG(u),this.trades[a]=d}const c=this.safeValue(s,"data",[]);for(let u=0;u<c.length;u++){const h=c[u],f=this.parseTrade(h,void 0);d.append(f)}this.trades[a]=d,e.resolve(d,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new f1(this.id+" watchMyTrades() requires a symbol argument");await this.loadMarkets();const n=await this.authenticate(),r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o="myTrades:"+e,d={jsonrpc:"2.0",id:this.requestId(),method:"/private/subscribe",params:{access_token:n,channels:["user.trades."+r.id+".raw"]}},c=await this.watch(a,o,d,o);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.indexOf(".raw"),r=i.slice(12,n),a=this.safeSymbol(r,void 0,"-"),o=this.safeValue(s,"data",[]);let d=this.myTrades;if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new l1(u)}for(let u=0;u<o.length;u++){const h=o[u],f=this.parseTrade(h);d.append(f)}this.myTrades=d;const c="myTrades:"+a;e.resolve(d,c)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new f1(this.id+"watchesOrders() requires a symbol");await this.loadMarkets();const n=await this.authenticate(),r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o={jsonrpc:"2.0",id:this.requestId(),method:"/private/subscribe",params:{access_token:n,channels:["user.orders."+r.id+".raw"]}},d="orders:"+e,c=this.deepExtend(o,i),u=await this.watch(a,d,c,d);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleOrder(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{});let n=this.orders;if(n===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);n=new l1(d)}const r=this.parseOrder(i),a=this.safeString(r,"symbol"),o="orders:"+a;n.append(r),this.orders=n,e.resolve(this.orders,o)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;let n=i.id;i.spot&&(n=i.baseId+"-"+i.quoteId);const r=this.urls.api.ws;s=this.omit(s,"type");const a="orderbook:"+e,o={jsonrpc:"2.0",id:this.requestId(),method:"/public/subscribe",params:{channels:["book."+n+".raw"]}},d=this.deepExtend(o,s);return(await this.watch(r,a,d,a)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params"),i=this.safeValue(s,"data"),n=this.safeString(i,"instrument_name"),r=this.safeSymbol(n,void 0,"-"),a=this.safeValue(this.orderbooks,r),o=this.safeInteger(a,"nonce"),d=this.safeInteger(i,"change_id"),c="orderbook:"+r;if(o===void 0){const u=a.cache.length,h=this.handleOption("watchOrderBook","snapshotDelay",0);u===h&&this.spawn(this.loadOrderBook,e,c,r,0),a.cache.push(i);return}else if(d<=o)return;this.handleDelta(a,i),e.resolve(a,c)}getCacheIndex(e,t){const s=t[0];let i=this.safeInteger(s,"change_id");const n=this.safeInteger(e,"nonce");if(n<i-1)return-1;for(let r=0;r<t.length;r++){const a=t[r];if(i=this.safeInteger(a,"change_id"),n===i-1)return r}return t.length}handleDelta(e,t){const s=this.safeInteger(t,"timestamp");e.timestamp=s,e.datetime=this.iso8601(s),e.nonce=this.safeInteger(t,"change_id");const i=this.safeValue(t,"bids",[]),n=this.safeValue(t,"asks",[]),r=e.bids,a=e.asks;this.handleBidAsks(r,i),this.handleBidAsks(a,n)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=this.parseBidAsk(t[s],1,2);e.storeArray(i)}}handleUser(e,t){const s=this.safeValue(t,"params"),n=this.safeString(s,"channel").slice(5),r=n.indexOf("."),a=n.slice(0,r),o={asset:this.handleBalance,orders:this.handleOrder,trades:this.handleMyTrades},d=this.safeValue(o,a);if(d!==void 0)return d.call(this,e,t);throw new xG(this.id+" received an unsupported message: "+this.json(t))}handleErrorMessage(e,t){const s=this.safeValue(t,"error",{});throw new _G(this.id+" error: "+this.json(s))}handleAuthenticate(e,t){const s=this.safeValue(t,"result",{}),i=this.safeInteger(s,"expires_in",0);this.options.expiresAt=this.sum(this.seconds(),i)*1e3;const n=this.safeString(s,"access_token");e.resolve(n,"authenticated")}handleSubscription(e,t){const s=this.safeValue(t,"result",[]);for(let i=0;i<s.length;i++){const r=s[i].split("."),a=this.safeString(r,0),o=this.safeString(r,1);if(a==="book"){const d=this.safeSymbol(o,void 0,"-");this.orderbooks[d]=this.orderBook({})}}}handlePong(e,t){e.lastPong=this.milliseconds()}handleMessage(e,t){if(t==="PONG"){this.handlePong(e,t);return}if(this.safeValue(t,"error")!==void 0)return this.handleErrorMessage(e,t);const i=this.safeValue(t,"result",{});if(this.safeString(i,"access_token")!==void 0)return this.handleAuthenticate(e,t);if(this.safeString(t,"method")==="subscription"){const a=this.safeValue(t,"params"),d=this.safeString(a,"channel").split("."),c=this.safeString(d,0),u={ticker:this.handleTicker,trades:this.handleTrades,chart:this.handleOHLCV,balances:this.handleBalance,trading:this.handleOrder,user:this.handleUser,book:this.handleOrderBook},h=this.safeValue(u,c);if(h!==void 0)return h.call(this,e,t)}else"result"in t&&this.handleSubscription(e,t);return t}authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=this.safeNumber(this.options,"expiresAt"),r=this.milliseconds();let a=this.safeValue(s.subscriptions,i);if(a===void 0||n<=r){const o={jsonrpc:"2.0",id:this.requestId(),method:"/public/auth",params:{grant_type:"client_credentials",client_id:this.apiKey,client_secret:this.secret}},d=this.extend(o,e);a=this.watch(t,i,d),s.subscriptions[i]=a}return a}ping(e){return"PING"}};const AG=kT,{AuthenticationError:zp,ExchangeError:BG,BadRequest:p1}=Q,{ArrayCache:NG,ArrayCacheBySymbolById:m1,ArrayCacheByTimestamp:VG}=Pe;var EG=class extends AG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchPosition:void 0},urls:{api:{ws:{public:{spot:"wss://stream.{hostname}/spot/public/v3",inverse:"wss://stream.{hostname}/contract/inverse/public/v3",usdt:"wss://stream.{hostname}/contract/usdt/public/v3",usdc:{option:"wss://stream.{hostname}/option/usdc/public/v3",swap:"wss://stream.{hostname}/contract/usdc/public/v3"}},private:{spot:"wss://stream.{hostname}/spot/private/v3",contract:{unified:"wss://stream.{hostname}/unified/private/v3",nonUnified:"wss://stream.{hostname}/contract/private/v3"}}}},test:{ws:{public:{spot:"wss://stream-testnet.{hostname}/spot/public/v3",inverse:"wss://stream-testnet.{hostname}/contract/inverse/public/v3",usdt:"wss://stream-testnet.{hostname}/contract/usdt/public/v3",usdc:{option:"wss://stream-testnet.{hostname}/option/usdc/public/v3",swap:"wss://stream-testnet.{hostname}/contract/usdc/public/v3"}},private:{spot:"wss://stream-testnet.{hostname}/spot/private/v3",contract:{unified:"wss://stream-testnet.{hostname}/unified/private/v3",nonUnified:"wss://stream-testnet.{hostname}/contract/private/v3"}}}}},options:{watchTicker:{name:"tickers"},spot:{timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"}},contract:{timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M"}}},streaming:{ping:this.ping,keepAlive:2e4},exceptions:{ws:{exact:{}}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}getUrlByMarketType(e=void 0,t=!1,s=!1,i=void 0,n={}){const r=t?"private":"public";let a,o,d,c,u,h=this.urls.api.ws;if(e!==void 0)u=this.market(e),a=u.settle==="USDC",c=u.settle==="USDT",o=u.spot,d=u.type;else{[d,n]=this.handleMarketTypeAndParams(i,void 0,n);let f=this.safeString(this.options,"defaultSettle");f=this.safeString2(n,"settle","defaultSettle",f),a=f==="USDC",c=f==="USDT",o=d==="spot"}if(t)if(o)h=h[r].spot;else{const f=s?"unified":"nonUnified";h=h[r].contract[f]}else o?h=h[r].spot:a?h=h[r].usdc[d]:c?h=h[r].usdt:h=h[r].inverse;return h=this.implodeHostname(h),h}cleanParams(e){return e=this.omit(e,["type","subType","settle","defaultSettle","unifiedMargin"]),e}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+s.symbol,n=this.getUrlByMarketType(e,!1,!1,t);t=this.cleanParams(t);const r=this.safeValue(this.options,"watchTicker",{});let a=this.safeString(r,"name","tickers");if(!s.spot&&a!=="tickers")throw new p1(this.id+" watchTicker() only supports name tickers for contract markets");a+="."+s.id;const o=[a];return await this.watchTopics(n,i,o,t)}handleTicker(e,t){const s=this.safeString(t,"topic",""),i=this.safeString(t,"type",""),n=this.safeValue(t,"data",{}),r=this.safeString(n,"s")!==void 0;let a,o;if(i==="snapshot"||r)o=this.parseTicker(n),a=o.symbol;else if(i==="delta"){const u=s.split("."),h=u.length,f=this.safeString(u,h-1);a=this.market(f).symbol;const m=this.safeValue(this.tickers,a,{}),g=this.safeValue(m,"info",{}),y=this.extend(g,n);o=this.parseTicker(y)}const d=this.safeInteger(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d),this.tickers[a]=o;const c="ticker:"+a;e.resolve(this.tickers[a],c)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.getUrlByMarketType(e,!1,!1,n);n=this.cleanParams(n);let o;const d=r.spot?"spot":"contract",c=this.safeValue(this.options,d,{}),u=this.safeValue(c,"timeframes",{}),h=this.safeString(u,t,t),f=["kline."+h+"."+r.id],l="kline:"+h+":"+e;return o=await this.watchTopics(a,l,f,n),this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),n=this.safeString(t,"topic").split("."),r=n.length,a=this.safeString(n,1),o=this.safeString(n,r-1),c=e.url.indexOf("spot")>-1?"spot":"contract",h=this.safeMarket(o,void 0,void 0,c).symbol,f=this.safeValue(this.ohlcvs,h);f===void 0&&(this.ohlcvs[h]={});let l=this.safeValue(f,a);if(l===void 0){const g=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new VG(g),this.ohlcvs[h][a]=l}if(Array.isArray(s))for(let g=0;g<s.length;g++){const y=this.parseWsContractOHLCV(s[g]);l.append(y)}else{const g=this.parseSpotOHLCV(s);l.append(g)}const m="kline:"+a+":"+h;e.resolve(l,m)}parseWsContractOHLCV(e){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber2(e,"volume","turnover")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.getUrlByMarketType(e,!1,!1,s);s=this.cleanParams(s);const r="orderbook:"+e;if(t===void 0)i.spot?t=40:t=200;else if(!i.spot&&t!==1&&t!==50&&t!==200)throw new p1(this.id+" watchOrderBook() can only use limit 1, 50 and 200.");const a=["orderbook."+t.toString()+"."+i.id];return(await this.watchTopics(n,r,a,s)).limit()}handleOrderBook(e,t){const s=e.url.indexOf("spot")>=0;let n=this.safeString(t,"type")==="snapshot";s&&(n=!0);const r=this.safeValue(t,"data",{}),a=this.safeString(r,"s"),o=s?"spot":"contract",c=this.safeMarket(a,void 0,void 0,o).symbol,u=this.safeInteger(t,"ts");let h=this.safeValue(this.orderbooks,c);if(h===void 0&&(h=this.orderBook()),n){const l=this.parseOrderBook(r,c,u,"b","a");h.reset(l)}else{const l=this.safeValue(r,"a",[]),m=this.safeValue(r,"b",[]);this.handleDeltas(h.asks,l),this.handleDeltas(h.bids,m),h.timestamp=u,h.datetime=this.iso8601(u)}const f="orderbook:"+c;this.orderbooks[c]=h,e.resolve(h,f)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.getUrlByMarketType(e,!1,!1,i);i=this.cleanParams(i);const a="trade:"+e;let o;n.spot?o="trade."+n.id:(o="publicTrade.",n.option?o+=n.baseId:o+=n.id);const d=await this.watchTopics(r,a,[o],i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic");let n;const r=i.split("."),o=this.safeString(r,0)==="trade"?"spot":"contract",d=this.safeString(r,1),c=this.safeMarket(d,void 0,void 0,o);Array.isArray(s)?n=s:n=[s];const u=c.symbol;let h=this.safeValue(this.trades,u);if(h===void 0){const l=this.safeInteger(this.options,"tradesLimit",1e3);h=new NG(l),this.trades[u]=h}for(let l=0;l<n.length;l++){const m=this.parseWsTrade(n[l],c);h.append(m)}const f="trade:"+u;e.resolve(h,f)}parseWsTrade(e,t=void 0){const s=this.safeStringN(e,["i","T","v"]),n="BT"in e?"contract":"spot",r=this.safeString(e,"s");t=this.safeMarket(r,t,void 0,n);const a=t.symbol,o=this.safeInteger2(e,"t","T");let d=this.safeStringLower(e,"S"),c;const u=this.safeValue(e,"m");d===void 0?d=u?"buy":"sell":c=u;const h=this.safeString(e,"p"),f=this.safeString2(e,"q","v"),l=this.safeString(e,"o");return this.safeTrade({id:s,info:e,timestamp:o,datetime:this.iso8601(o),symbol:a,order:l,type:void 0,side:d,takerOrMaker:c,price:h,amount:f,cost:void 0,fee:void 0},t)}getPrivateType(e){if(e.indexOf("spot")>=0)return"spot";if(e.indexOf("unified")>=0)return"unified";if(e.indexOf("contract")>=0)return"contract"}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n="watchMyTrades";let r="myTrades";await this.loadMarkets(),e!==void 0&&(e=this.symbol(e),r+=":"+e);const a=await this.isUnifiedMarginEnabled(),o=this.getUrlByMarketType(e,!0,a,n,i);await this.authenticate(o);const d={spot:"ticketInfo",contract:"user.execution.contractAccount",unified:"user.execution.unifiedAccount"},c=this.safeValue(d,this.getPrivateType(o)),u=await this.watchTopics(o,r,[c],i);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleMyTrades(e,t){const i=this.safeString(t,"topic")==="ticketInfo";let n=this.safeValue(t,"data",[]);if(n=this.safeValue(n,"result",n),this.myTrades===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new m1(u)}const r=this.myTrades,a={},o=i?"parseWsTrade":"parseTrade";for(let u=0;u<n.length;u++){const h=n[u],f=this[o](h),l=f.symbol;a[l]=!0,r.append(f)}const d=Object.keys(a);for(let u=0;u<d.length;u++){const h="myTrades:"+d[u];e.resolve(r,h)}const c="myTrades";e.resolve(r,c)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="watchOrders";let r="orders";e!==void 0&&(e=this.symbol(e),r+=":"+e);const a=await this.isUnifiedMarginEnabled(),o=this.getUrlByMarketType(void 0,!0,a,n,i);await this.authenticate(o);const d={spot:["order","stopOrder"],contract:["user.order.contractAccount"],unified:["user.order.unifiedAccount"]},c=this.safeValue(d,this.getPrivateType(o)),u=await this.watchTopics(o,r,c,i);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic","");if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new m1(u)}const n=this.orders;let r=[],a;i==="order"?(r=this.safeValue(t,"data",[]),a="parseWsSpotOrder"):(a="parseContractOrder",r=this.safeValue(t,"data",[]),r=this.safeValue(r,"result",r));const o={};for(let u=0;u<r.length;u++){const h=this[a](r[u]),f=h.symbol;o[f]=!0,n.append(h)}const d=Object.keys(o);for(let u=0;u<d.length;u++){const h="orders:"+d[u];e.resolve(n,h)}const c="orders";e.resolve(n,c)}parseWsSpotOrder(e,t=void 0){const s=this.safeString(e,"i"),i=this.safeString(e,"s"),n=this.safeSymbol(i,t,void 0,"spot"),r=this.safeInteger(e,"O");let a=this.safeString(e,"p");a==="0"&&(a=void 0);const o=this.safeString(e,"z"),d=this.parseOrderStatus(this.safeString(e,"X")),c=this.safeStringLower(e,"S"),u=this.safeString(e,"E"),h=this.safeString(e,"f");let f;const l=this.safeString(e,"Z"),m=this.safeString(e,"q");let g=this.safeStringLower(e,"o");g.indexOf("quote")>=0?f=o:f=m,g.indexOf("market")>=0&&(g="market");let y;const w=this.safeString(e,"n");if(w!==void 0&&w!=="0"){const b=this.safeString(e,"N"),S=this.safeCurrencyCode(b);y={cost:w,currency:S}}return this.safeOrder({info:e,id:s,clientOrderId:this.safeString(e,"c"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:u,symbol:n,type:g,timeInForce:h,postOnly:void 0,side:c,price:a,stopPrice:void 0,triggerPrice:void 0,amount:f,cost:l,average:void 0,filled:o,remaining:void 0,status:d,fee:y},t)}async watchBalance(e={}){const t="watchBalance",s="balances",i=await this.isUnifiedMarginEnabled(),n=this.getUrlByMarketType(void 0,!0,i,t,e);await this.authenticate(n);const r={spot:"outboundAccountInfo",contract:"user.wallet.contractAccount",unified:"user.wallet.unifiedAccount"},a=[this.safeValue(r,this.getPrivateType(n))];return await this.watchTopics(n,s,a,e)}handleBalance(e,t){this.balance===void 0&&(this.balance={});let s="balance";const i=this.safeValue(t,"topic");let n,r=[];if(i==="outboundAccountInfo"){const o=this.safeValue(t,"data",[]);for(let d=0;d<o.length;d++){const c=this.safeValue(o[d],"B",[]);r=this.arrayConcat(r,c)}n=r}if(i==="user.wallet.contractAccount"&&(r=this.safeValue(t,"data",[]),n=r),i==="user.wallet.unifiedAccount"){const o=this.safeValue(t,"data",{}),d=this.safeValue(o,"result",{});r=this.safeValue(d,"coin",[]),n=d}for(let o=0;o<r.length;o++)this.parseWsBalance(r[o]);this.balance.info=n;const a=this.safeInteger(t,"ts");this.balance.timestamp=a,this.balance.datetime=this.iso8601(a),this.balance=this.safeBalance(this.balance),s="balances",e.resolve(this.balance,s)}parseWsBalance(e){const t=this.account(),s=this.safeStringN(e,["a","currencyCoin","coin"]),i=this.safeCurrencyCode(s);t.free=this.safeStringN(e,["availableBalanceWithoutConvert","availableBalance","f"]),t.used=this.safeString(e,"l"),t.total=this.safeString(e,"walletBalance"),this.balance[i]=t}async watchTopics(e,t,s=[],i={}){const n={op:"subscribe",req_id:this.requestId(),args:s},r=this.extend(n,i);return await this.watch(e,t,r,t)}authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let n=this.safeValue(i.subscriptions,s);if(n===void 0){let r=this.milliseconds()+1e4;r=r.toString();const o="GET/realtime"+r,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256","hex"),c={op:"auth",args:[this.apiKey,r,d]},u=this.extend(c,t);n=this.watch(e,s,u),i.subscriptions[s]=n}return n}handleErrorMessage(e,t){const s=this.safeString2(t,"code","ret_code");try{if(s!==void 0){const n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,n)}const i=this.safeValue(t,"success");if(i!==void 0&&!i){const n=this.safeString(t,"ret_msg"),r=this.safeValue(t,"request",{});throw this.safeString(r,"op")==="auth"?new zp("Authentication failed: "+n):new BG(this.id+" "+n)}return!1}catch(i){if(i instanceof zp){const n="authenticated";e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n]}else e.reject(i);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if(this.safeString(t,"ret_msg")==="pong"){this.handlePong(e,t);return}if(this.safeInteger(t,"pong")!==void 0){this.handlePong(e,t);return}const n=this.safeString(t,"op");if(n==="pong"){this.handlePong(e,t);return}if(this.safeString(t,"event")==="sub"){this.handleSubscriptionStatus(e,t);return}const a=this.safeString(t,"topic",""),o={orderbook:this.handleOrderBook,kline:this.handleOHLCV,order:this.handleOrder,stopOrder:this.handleOrder,ticker:this.handleTicker,trade:this.handleTrades,publicTrade:this.handleTrades,depth:this.handleOrderBook,wallet:this.handleBalance,outboundAccountInfo:this.handleBalance,execution:this.handleMyTrades,ticketInfo:this.handleMyTrades},d=Object.keys(o);for(let u=0;u<d.length;u++){const h=d[u];if(a.indexOf(d[u])>=0){o[h].call(this,e,t);return}}const c=this.safeString(t,"type");(n==="auth"||c==="AUTH_RESP")&&this.handleAuthenticate(e,t)}ping(e){return{req_id:this.requestId(),op:"ping"}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"pong"),t}handleAuthenticate(e,t){const s=this.safeValue(t,"success"),i="authenticated";if(s)e.resolve(t,i);else{const n=new zp(this.id+" "+this.json(t));e.reject(n,i),i in e.subscriptions&&delete e.subscriptions[i]}return t}handleSubscriptionStatus(e,t){return t}};const{ExchangeError:jp,ArgumentsRequired:g1}=Q,y1=ae,qG=ST,{ArrayCacheBySymbolById:Kp,ArrayCacheByTimestamp:LG,ArrayCache:RG}=Pe;var DG=class extends qG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0,watchPosition:void 0},urls:{api:{ws:"wss://ws.cex.io/ws"}},options:{orderbook:{}},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i={e:"get-balance",data:{},oid:this.requestId()},n=this.deepExtend(i,e);return await this.watch(s,t,n,t,n)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"balance",{}),n=this.safeValue(s,"obalance",{}),r={},a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.account();c.free=this.safeString(i,d),c.used=this.safeString(n,d);const u=this.safeCurrencyCode(d);r[u]=c}this.balance=this.safeBalance(r),e.resolve(this.balance,"balance")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a="trades",o="old:"+e,d=this.safeValue(this.clients,r);if(d!==void 0){const f=Object.keys(d.subscriptions);for(let l=0;l<f.length;l++){let m=f[l];if(m!==o&&(m=m.slice(0,3),m==="old"))throw new jp(this.id+" watchTrades() only supports watching one symbol at a time.")}}const c={e:"subscribe",rooms:["pair-"+n.base+"-"+n.quote]},u=this.deepExtend(c,i),h=await this.watch(r,a,u,o);for(let f=0;f<h.length;f++)h[f].symbol=e;return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTradesSnapshot(e,t){const s=this.safeValue(t,"data",[]),i=this.safeInteger(this.options,"tradesLimit",1e3),n=new RG(i);for(let a=0;a<s.length;a++){const o=s[a],d=this.parseWsOldTrade(o);n.append(d)}const r="trades";this.trades=n,e.resolve(this.trades,r)}parseWsOldTrade(e,t=void 0){Array.isArray(e)||(e=e.split(":"));const s=this.safeString(e,0),i=this.safeNumber(e,1),n=this.safeString(e,2),r=this.safeString(e,3),a=this.safeString(e,4);return this.safeTrade({info:e,id:a,timestamp:i,datetime:this.iso8601(i),symbol:void 0,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:n,cost:void 0,fee:void 0},t)}handleTrade(e,t){const s=this.safeValue(t,"data",[]),i=this.trades;for(let r=0;r<s.length;r++){const a=s[r],o=this.parseWsOldTrade(a);i.append(o)}const n="trades";this.trades=i,e.resolve(this.trades,n)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws,n="ticker:"+e,r=this.safeString(t,"method","private");let a={e:"subscribe",rooms:["tickers"]},o="tickers";r==="private"&&(await this.authenticate(),a={e:"ticker",data:[s.baseId,s.quoteId],oid:this.requestId()},o="ticker:"+e);const d=this.deepExtend(a,t);return await this.watch(i,n,d,o)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",n={e:"subscribe",rooms:["tickers"]},r=this.deepExtend(n,t),a=await this.watch(s,i,r,i),o=a.symbol;if(e!==void 0&&!this.inArray(o,e))return await this.watchTickers(e,t);if(this.newUpdates){const d={};return d[o]=a,d}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTicker(s),n=i.symbol,r="ticker:"+n;this.tickers[n]=i,e.resolve(i,r),e.resolve(i,"tickers")}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"pair",[]);let i=this.safeString(e,"symbol1");i===void 0&&(i=this.safeString(s,0));let n=this.safeString(e,"symbol2");n===void 0&&(n=this.safeString(s,1));const r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=r+"/"+a;let d=this.safeInteger(e,"timestamp");return d!==void 0&&(d=d*1e3),this.safeTicker({symbol:o,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open24"),close:void 0,last:this.safeString2(e,"price","last"),previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercentage"),average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new g1(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e);e=r.symbol;const a="orders:"+e,o={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:e},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new g1(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e),a="myTrades:"+r.symbol,o="orders:"+r.symbol,d={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:r.symbol},c=this.deepExtend(d,i),u=await this.watch(n,a,c,o,c);return this.filterBySymbolSinceLimit(u,r.symbol,t,s,!0)}handleTransaction(e,t){const s=this.safeValue(t,"data");this.safeString(s,"symbol2")!==void 0&&(this.handleOrderUpdate(e,t),this.handleMyTrades(e,t))}handleMyTrades(e,t){const s=this.safeValue(t,"data",{});let i=this.myTrades;if(i===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);i=new Kp(a),this.myTrades=i}const n=this.parseWsTrade(s);i.append(n);const r="myTrades:"+n.symbol;e.resolve(i,r)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeString(e,"price"),n=this.safeString(e,"time"),r=this.safeString(e,"symbol"),a=this.safeString(e,"symbol2"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a);let c=o+"/"+d,u=this.safeString(e,"amount");s==="sell"&&(c=d+"/"+o,u=y1.stringDiv(u,i));const h={id:this.safeString(e,"id"),order:this.safeString(e,"order"),info:e,timestamp:this.parse8601(n),datetime:n,symbol:c,type:void 0,side:s,takerOrMaker:void 0,price:i,cost:void 0,amount:u,fee:void 0},f=this.safeString(e,"fee_amount");return f!==void 0&&(h.fee={cost:f,currency:d,rate:void 0}),this.safeTrade(h,t)}handleOrderUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"e")==="tx",n=this.safeString2(s,"id","order");let r=this.safeString(s,"remains"),a=this.safeString(s,"symbol"),o=this.safeString(s,"symbol2");const d=this.safeValue(s,"pair");d!==void 0&&(a=this.safeString(d,"symbol1"),o=this.safeString(d,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u,f=this.safeMarket(h);if(r=this.currencyFromPrecision(c,r),this.orders===void 0){const v=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new Kp(v)}const l=this.safeValue(this.orders.hashmap,h,{});let m=this.safeValue(l,n);m===void 0&&(m=this.parseWsOrderUpdate(s,f)),m.remaining=r,this.safeValue(s,"cancel",!1)&&(m.status="canceled"),i&&(m.status="closed");const y=this.safeNumber(s,"fee");y!==void 0&&(m.fee={cost:y,currency:u,rate:void 0});const w=this.safeInteger(s,"time",this.milliseconds());m.timestamp=w,m.datetime=this.iso8601(w),m=this.safeOrder(m);const b=this.orders;b.append(m);const S="orders:"+h;e.resolve(b,S)}parseWsOrderUpdate(e,t=void 0){const s=this.safeValue(e,"d")!==void 0,i=this.safeString(e,"remains");let n;i!==void 0&&(n=this.currencyFromPrecision(t.base,i));const r=this.safeString(e,"amount");s||this.currencyFromPrecision(t.base,r);let a=this.safeString(e,"symbol"),o=this.safeString(e,"symbol2");this.safeValue(e,"pair")!==void 0&&(a=this.safeString(e,"symbol1"),o=this.safeString(e,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u;t=this.safeMarket(h,t);const f=this.safeInteger(e,"time",this.milliseconds());let l=f;s&&(l=this.parse8601(f));const m=this.safeValue(e,"cancel",!1);let g="open";m?g="canceled":s&&(g="closed");const y={id:this.safeString2(e,"id","order"),clientOrderId:void 0,info:e,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:g,symbol:h,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:this.safeNumber(e,"price"),stopPrice:void 0,triggerPrice:void 0,average:void 0,cost:void 0,amount:r,filled:void 0,remaining:n,fee:{cost:this.safeNumber2(e,"fee","fee_amount"),currency:u,rate:void 0},trades:void 0};return s&&(y.trades=this.parseWsTrade(e,t)),this.safeOrder(y,t)}fromPrecision(e,t){if(e===void 0)return;const s=new y1(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}currencyFromPrecision(e,t){const s=this.safeInteger(this.currencies[e],"precision",0);return this.fromPrecision(t,s)}handleOrdersSnapshot(e,t){const s=this.safeString(t,"oid"),i=this.safeValue(t,"data",[]);let n=this.orders;if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);n=new Kp(a)}for(let a=0;a<i.length;a++){const o=i[a],d=this.safeMarket(s),c=this.parseOrder(o,d);c.status="open",n.append(c)}this.orders=n;const r="orders:"+s;n.length>0&&e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,a=t===void 0?0:t,o={e:"order-book-subscribe",data:{pair:[i.baseId,i.quoteId],subscribe:!0,depth:a},oid:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit(t)}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="orderbook:"+n,a=this.safeInteger2(s,"timestamp_ms","timestamp"),o=this.safeNumber(s,"id"),d=this.orderBook({}),c=this.parseOrderBook(s,n,a,"bids","asks");c.nonce=o,d.reset(c),this.options.orderbook[n]={incrementalId:o},this.orderbooks[n]=d,e.resolve(d,r)}pairToSymbol(e){const t=e.split(":"),s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i);return n+"/"+r}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeNumber(s,"id"),n=this.safeString(s,"pair",""),r=this.pairToSymbol(n),a=this.safeValue(this.orderbooks,r);if(i!==a.nonce+1)throw new jp(this.id+" watchOrderBook() skipped a message");const o="orderbook:"+r,d=this.safeInteger(s,"time"),c=this.safeValue(s,"asks",[]),u=this.safeValue(s,"bids",[]);this.handleDeltas(a.asks,c),this.handleDeltas(a.bids,u),a.timestamp=d,a.datetime=this.iso8601(d),a.nonce=i,e.resolve(a,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="ohlcv:"+e,o=this.urls.api.ws,d={e:"init-ohlcv",i:t,rooms:["pair-"+r.baseId+"-"+r.quoteId]},c=await this.watch(o,a,this.extend(d,n),a);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleInitOHLCV(e,t){const i=this.safeString(t,"pair").split(":"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r),d=a+"/"+o,c=this.safeMarket(d),u="ohlcv:"+d,h=this.safeValue(t,"data",[]),f=this.safeInteger(this.options,"OHLCVLimit",1e3),l=new LG(f),m=this.sortBy(h,0);for(let g=0;g<m.length;g++)l.append(this.parseOHLCV(m[g],c));this.ohlcvs[d]=l,e.resolve(l,u)}handleOHLCV24(e,t){return t}handleOHLCV1m(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=[this.safeTimestamp(s,"time"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")],o=this.safeValue(this.ohlcvs,n);o.append(a),e.resolve(o,r)}handleOHLCV(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=this.safeValue(this.ohlcvs,n);for(let o=0;o<s.length;o++){const d=[this.safeTimestamp(s[o],0),this.safeNumber(s[o],1),this.safeNumber(s[o],2),this.safeNumber(s[o],3),this.safeNumber(s[o],4),this.safeNumber(s[o],5)];a.append(d)}s.length>0&&e.resolve(a,r)}handleConnected(e,t){return t}handleErrorMessage(e,t){throw new jp(this.id+" "+this.json(t))}handleMessage(e,t){if(this.safeString(t,"ok")==="error")return this.handleErrorMessage(e,t);const i=this.safeString(t,"e"),n={auth:this.handleAuthenticationMessage,connected:this.handleConnected,tick:this.handleTicker,ticker:this.handleTicker,"init-ohlcv-data":this.handleInitOHLCV,ohlcv24:this.handleOHLCV24,ohlcv1m:this.handleOHLCV1m,ohlcv:this.handleOHLCV,"get-balance":this.handleBalance,"order-book-subscribe":this.handleOrderBookSnapshot,md_update:this.handleOrderBookUpdate,"open-orders":this.handleOrdersSnapshot,order:this.handleOrderUpdate,"history-update":this.handleTrade,history:this.handleTradesSnapshot,tx:this.handleTransaction},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");s!==void 0&&s.resolve(!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=s.future("authenticated");if(this.safeValue(s.subscriptions,i)===void 0){this.checkRequiredCredentials();const a=this.seconds().toString(),o=a+this.apiKey,d=this.hmac(this.encode(o),this.encode(this.secret)),c={e:"auth",auth:{key:this.apiKey,signature:d.toUpperCase(),timestamp:a}};this.spawn(this.watch,t,i,this.extend(c,e),i)}return await n}};const FG=fg,{BadSymbol:w1}=Q,{ArrayCache:HG,ArrayCacheBySymbolById:b1}=Pe;var zT=class extends FG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!1,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchBalance:!1,watchStatus:!1,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws-feed.pro.coinbase.com"}},options:{tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}authenticate(){this.checkRequiredCredentials();const e="/users/self/verify",t=this.nonce(),s=t.toString()+"GET"+e,i=this.hmac(this.encode(s),this.base64ToBinary(this.secret),"sha256","base64");return{timestamp:t,key:this.apiKey,signature:i,passphrase:this.password}}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.market(t),r=s+":"+n.id;let a=this.urls.api.ws;"signature"in i&&(a=a+"?");const o={type:"subscribe",product_ids:[n.id],channels:[e]},d=this.extend(o,i);return await this.watch(a,r,d,r)}async watchTicker(e,t={}){const s="ticker";return await this.subscribe(s,e,s,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="matches",r=await this.subscribe(n,e,n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new w1(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="myTrades",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new w1(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="orders",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="level2";await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=i+":"+n.id,a=this.urls.api.ws,o={type:"subscribe",product_ids:[n.id],channels:[i]},d=this.extend(o,s),c={messageHash:r,symbol:e,marketId:n.id,limit:t};return(await this.watch(a,r,d,r,c)).limit()}handleTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),n=i.symbol,a="matches"+":"+s;let o=this.safeValue(this.trades,n);if(o===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);o=new HG(d),this.trades[n]=o}o.append(i),e.resolve(o,a)}return t}handleMyTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),r="myTrades"+":"+s;let a=this.myTrades;if(a===void 0){const o=this.safeInteger(this.options,"myTradesLimit",1e3);a=new b1(o),this.myTrades=a}a.append(i),e.resolve(a,r)}return t}parseWsTrade(e){const t=super.parseTrade(e);let s;"maker_fee_rate"in e?(t.takerOrMaker="maker",s=this.safeNumber(e,"maker_fee_rate")):(t.takerOrMaker="taker",s=this.safeNumber(e,"taker_fee_rate"));const n=this.market(t.symbol).quote;let r;return t.cost!==void 0&&s!==void 0&&(r=t.cost*s),t.fee={rate:s,cost:r,currency:n},t}parseWsOrderStatus(e){const t={filled:"closed",canceled:"canceled"};return this.safeString(t,e,"open")}handleOrder(e,t){let s=this.orders;if(s===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);s=new b1(r),this.orders=s}const i=this.safeString(t,"type"),n=this.safeString(t,"product_id");if(n!==void 0){const r="orders:"+n,a=this.safeSymbol(n),o=this.safeString(t,"order_id"),d=this.safeString(t,"maker_order_id"),c=this.safeString(t,"taker_order_id"),u=this.orders,h=this.safeValue(u.hashmap,a,{});let f=this.safeValue(h,o);if(f===void 0&&(f=this.safeValue2(h,d,c)),f===void 0){const l=this.parseWsOrder(t);u.append(l),e.resolve(u,r)}else{const l=this.safeInteger(t,"sequence"),m=this.safeValue(f,"info",{}),g=this.safeInteger(m,"sequence");if(g===void 0||l>g){if(i==="match"){const y=this.parseWsTrade(t);f.trades===void 0&&(f.trades=[]),f.trades.push(y),f.lastTradeTimestamp=y.timestamp;let w=0,b=0;const S=f.trades;for(let v=0;v<S.length;v++){const T=S[v];w=this.sum(w,T.cost),b=this.sum(b,T.amount)}b>0&&(f.average=w/b),f.cost=w,f.filled!==void 0&&(f.filled+=y.amount,f.amount!==void 0&&(f.remaining=f.amount-f.filled)),f.fee===void 0&&(f.fee={cost:0,currency:y.fee.currency}),f.fee.cost!==void 0&&y.fee.cost!==void 0&&(f.fee.cost=this.sum(f.fee.cost,y.fee.cost)),u.append(f),e.resolve(u,r)}else if(i==="received"||i==="done"){const y=this.extend(f.info,t),w=this.parseWsOrder(y),b=Object.keys(w);for(let S=0;S<b.length;S++){const v=b[S];w[v]!==void 0&&(f[v]=w[v])}u.append(f),e.resolve(u,r)}}}}}parseWsOrder(e){const t=this.safeString(e,"order_id"),s=this.safeString(e,"client_oid"),i=this.safeString(e,"product_id"),n=this.safeSymbol(i),r=this.safeString(e,"side"),a=this.safeNumber(e,"price"),o=this.safeNumber2(e,"size","funds"),d=this.safeString(e,"time"),c=this.parse8601(d),u=this.safeString(e,"reason"),h=this.parseWsOrderStatus(u),f=this.safeString(e,"order_type");let l=this.safeNumber(e,"remaining_size");const m=this.safeString(e,"type");let g;o!==void 0&&l!==void 0?g=o-l:m==="received"&&(g=0,o!==void 0&&(l=o-g));let y;return a!==void 0&&o!==void 0&&(y=a*o),{info:e,symbol:n,id:t,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,type:f,timeInForce:void 0,postOnly:void 0,side:r,price:a,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:y,average:void 0,filled:g,remaining:l,status:h,fee:void 0,trades:void 0}}handleTicker(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseTicker(t),n=i.symbol;this.tickers[n]=i;const a=this.safeString(t,"type")+":"+s;e.resolve(i,a)}return t}parseTicker(e,t=void 0){if(this.safeString(e,"type")===void 0)return super.parseTicker(e,t);const i=this.safeString(e,"product_id"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"time")),a=this.safeNumber(e,"price");return{symbol:n,timestamp:r,datetime:this.iso8601(r),high:this.safeNumber(e,"high_24h"),low:this.safeNumber(e,"low_24h"),bid:this.safeNumber(e,"best_bid"),bidVolume:void 0,ask:this.safeNumber(e,"best_ask"),askVolume:void 0,vwap:void 0,open:this.safeNumber(e,"open_24h"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"volume_24h"),quoteVolume:void 0,info:e}}handleDelta(e,t){const s=this.safeNumber(t,0),i=this.safeNumber(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.safeMarket(i,void 0,"-").symbol,o="level2"+":"+i,d=this.safeValue(e.subscriptions,o,{}),c=this.safeInteger(d,"limit");if(s==="snapshot"){this.orderbooks[r]=this.orderBook({},c);const u=this.orderbooks[r];this.handleDeltas(u.asks,this.safeValue(t,"asks",[])),this.handleDeltas(u.bids,this.safeValue(t,"bids",[])),u.timestamp=void 0,u.datetime=void 0,e.resolve(u,o)}else if(s==="l2update"){const u=this.orderbooks[r],h=this.parse8601(this.safeString(t,"time")),f=this.safeValue(t,"changes",[]),l={sell:"asks",buy:"bids"};for(let m=0;m<f.length;m++){const g=f[m],y=this.safeString(g,0),w=this.safeString(l,y),b=this.safeNumber(g,1),S=this.safeNumber(g,2);u[w].store(b,S)}u.timestamp=h,u.datetime=this.iso8601(h),e.resolve(u,o)}}handleSubscriptionStatus(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"type"),i={snapshot:this.handleOrderBook,l2update:this.handleOrderBook,subscribe:this.handleSubscriptionStatus,ticker:this.handleTicker,received:this.handleOrder,open:this.handleOrder,change:this.handleOrder,done:this.handleOrder},n=e.url.length-0,r=e.url[n-1]==="?",a=this.safeValue(i,s);if(a===void 0)s==="match"&&(r?(this.handleMyTrade(e,t),this.handleOrder(e,t)):this.handleTrade(e,t));else return a.call(this,e,t)}};const GG=zT;var UG=class extends GG{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",has:{ws:!0,watchOrderBook:!0},urls:{test:{ws:"wss://ws-feed-public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{ws:"wss://ws-feed.exchange.coinbase.com"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com/",fees:"https://pro.coinbase.com/fees"}})}};const Xp=ae,$G=vT,{AuthenticationError:WG,BadRequest:zG,ExchangeNotAvailable:jG,NotSupported:Lu,RequestTimeout:KG,ExchangeError:Ru}=Q,{ArrayCache:XG,ArrayCacheByTimestamp:YG,ArrayCacheBySymbolById:ZG}=Pe;var QG=class extends $G{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{spot:"wss://socket.coinex.com/",swap:"wss://perpetual.coinex.com/"}}},options:{watchOHLCVWarning:!0,timeframes:{"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"12h":43200,"1d":86400,"3d":259200,"1w":604800},account:"spot",watchOrderBook:{limits:[5,10,20,50],defaultLimit:50,aggregations:["10","1","0","0.1","0.01"],defaultAggregation:"0"}},streaming:{},exceptions:{codes:{1:zG,2:Ru,3:jG,4:Lu,5:KG,6:WG}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}handleTicker(e,t){const s=this.safeString(this.options,"defaultType"),i=this.safeValue(t,"params",[]),n=this.safeValue(i,0,{}),r=Object.keys(n),a=this.safeString(r,0),o=this.safeSymbol(a,void 0,void 0,s),d=this.safeValue(n,a,{}),c=this.safeMarket(a,void 0,void 0,s),u=this.parseWSTicker(d,c),h="ticker:"+o;this.tickers[o]=u,e.resolve(u,h)}parseWSTicker(e,t=void 0){const s=this.safeString(this.options,"defaultType");return this.safeTicker({symbol:this.safeSymbol(void 0,t,void 0,s),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"buy_total"),ask:void 0,askVolume:this.safeString(e,"sell_total"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"deal"),info:e},t)}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t="balance";let s;[s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const i=this.urls.api.ws[s],n=Object.keys(this.currencies_by_id),r={method:"asset.subscribe",params:n,id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(i,t,a,t)}handleBalance(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0,{}),n=Object.keys(i);for(let a=0;a<n.length;a++){const o=n[a],d=this.safeCurrencyCode(o),c=this.safeString(i[o],"available"),u=this.safeString(i[o],"frozen"),h=Xp.stringAdd(c,u),f=this.account();f.free=this.parseNumber(c),f.used=this.parseNumber(u),f.total=this.parseNumber(h),this.balance[d]=f,this.balance=this.safeBalance(this.balance)}const r="balance";e.resolve(this.balance,r)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeValue(s,1,[]),r=this.safeString(this.options,"defaultType"),a=this.safeMarket(i,void 0,void 0,r),o=a.symbol,d="trades:"+o;let c=this.safeValue(this.trades,o);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new XG(u),this.trades[o]=c}for(let u=0;u<n.length;u++){const h=n[u],f=this.parseWSTrade(h,a);c.append(f)}this.trades[o]=c,e.resolve(this.trades[o],d)}parseWSTrade(e,t=void 0){const s=this.safeTimestamp(e,"time"),i=this.safeString(this.options,"defaultType");return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t,void 0,i),order:void 0,type:void 0,side:this.safeString(e,"type"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]),i="ohlcv",n=this.parseOHLCVs(s);if(Object.keys(this.ohlcvs).length===0){const r=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs=new YG(r)}for(let r=0;r<n.length;r++){const a=n[r];this.ohlcvs.append(a)}e.resolve(this.ohlcvs,i)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarketTypeAndParams("watchTicker",s,t);const n=this.urls.api.ws[i],r="ticker:"+e,a={method:"state.subscribe",id:this.requestId(),params:[s.id]},o=this.deepExtend(a,t);return await this.watch(n,r,o,r,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;let r;[r,i]=this.handleMarketTypeAndParams("watchTrades",n,i);const a=this.urls.api.ws[r],o="trades:"+e,d={method:"deals.subscribe",params:[n.id],id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(a,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;let n;[n,s]=this.handleMarketTypeAndParams("watchOrderBook",i,s);const r=this.urls.api.ws[n],o="orderbook"+":"+e,d=this.safeValue(this.options,"watchOrderBook",{}),c=this.safeValue(d,"limits",[]);if(t===void 0&&(t=this.safeValue(d,"defaultLimit",50)),!this.inArray(t,c))throw new Lu(this.id+" watchOrderBook() limit must be one of "+c.join(", "));const u=this.safeString(d,"defaultAggregation","0"),h=this.safeValue(d,"aggregations",[]),f=this.safeString(s,"aggregation",u);if(!this.inArray(f,h))throw new Lu(this.id+" watchOrderBook() aggregation must be one of "+h.join(", "));s=this.omit(s,"aggregation");const l={method:"depth.subscribe",id:this.requestId(),params:[i.id,t,f,!0]},m=this.deepExtend(l,s);return(await this.watch(r,o,m,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;let a;if([a,n]=this.handleMarketTypeAndParams("watchOHLCV",r,n),a!=="swap")throw new Lu(this.id+" watchOHLCV() is only supported for swap markets");const o=this.urls.api.ws[a],d="ohlcv",c=this.safeValue(this.options,"watchOHLCVWarning",!0),u=this.safeValue(this.clients,o,{}),h=this.safeValue(u.subscriptions,d);if(c&&h!==void 0&&(h.symbol!==e||h.timeframe!==t))throw new Ru(this.id+" watchOHLCV() can only watch one symbol and timeframe at a time. To supress this warning set watchOHLCVWarning to false in options");const f=this.safeValue(this.options,"timeframes",{}),l={method:"kline.subscribe",id:this.requestId(),params:[r.id,this.safeInteger(f,t,t)]},m={symbol:e,timeframe:t},g=this.deepExtend(l,n),y=await this.watch(o,d,g,d,m);return this.newUpdates&&(i=y.getLimit(e,i)),this.filterBySinceLimit(y,s,i,0,!0)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0);let n=this.safeValue(s,1);const r=this.safeString(s,2),a=this.safeString(this.options,"defaultType"),d=this.safeMarket(r,void 0,void 0,a).symbol,u="orderbook"+":"+d,h=this.safeNumber(n,"time"),f=this.safeValue(this.orderbooks,d);if(i){const l=this.parseOrderBook(n,d,h);f===void 0?(n=this.orderBook(l),this.orderbooks[d]=n):(n=this.orderbooks[d],n.reset(l))}else{const l=this.safeValue(n,"asks",[]),m=this.safeValue(n,"bids",[]);this.handleDeltas(f.asks,l),this.handleDeltas(f.bids,m),f.nonce=h,f.timestamp=h,f.datetime=this.iso8601(h),this.orderbooks[d]=f}e.resolve(this.orderbooks[d],u)}checkOrderBookChecksum(e){const t=this.safeValue(e,"asks",[]),s=this.safeValue(e,"bids",[]);let i="";const n=s.length;for(let d=0;d<n;d++){const c=s[d];d!==0&&(i+=":"),i+=c[0]+":"+c[1]}const r=t.length;for(let d=0;d<r;d++){const c=t[d];n!==0&&(i+=":"),i+=c[0]+":"+c[1]}const a=this.hash(i,"cr32","hex");if(this.safeString(e,"checksum")!==a)throw new Ru(this.id+" watchOrderBook () checksum failed")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let n="orders",r;const[a,o]=this.handleMarketTypeAndParams("watchOrders",r,i),d={method:"order.subscribe",id:this.requestId()};e!==void 0?(r=this.market(e),e=r.symbol,d.params=[r.id],n+=":"+e):d.params=this.ids;const c=this.urls.api.ws[a],u=this.deepExtend(d,o),h=await this.watch(c,n,u,n,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,1,{}),n=this.parseWSOrder(i);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new ZG(a)}this.orders.append(n);let r="orders";e.resolve(this.orders,r),r+=":"+n.symbol,e.resolve(this.orders,r)}parseWSOrder(e){const t=this.safeTimestamp2(e,"update_time","mtime"),s=this.safeString(e,"market"),i=this.safeString(e,"type"),n=this.safeString({1:"limit",2:"market"},i),r=this.safeString(e,"side"),a=this.safeString({1:"sell",2:"buy"},r),o=this.safeString(e,"left"),d=this.safeString(e,"amount"),c=this.safeString(e,"status"),u=this.safeString(this.options,"defaultType"),h=this.safeMarket(s,void 0,void 0,u);let f=this.safeString(e,"deal_money"),l=this.safeString(e,"deal_stock"),m;if(h.swap){const w=this.safeString(e,"leverage");f=Xp.stringDiv(l,w),m=Xp.stringDiv(l,d),l=void 0}let g;const y=this.omitZero(this.safeString(e,"money_fee"));if(y!==void 0){const w=this.safeString(e,"fee_asset",h.quote);g={currency:this.safeCurrencyCode(w),cost:y}}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","id"),clientOrderId:this.safeString(e,"client_id"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:this.safeTimestamp(e,"last_deal_time"),symbol:h.symbol,type:n===1?"limit":"market",timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stop_price"),triggerPrice:this.safeString(e,"stop_price"),amount:d,filled:l,remaining:o,cost:f,average:m,status:this.parseWSOrderStatus(c),fee:g,trades:void 0},h)}parseWSOrderStatus(e){const t={0:"pending",1:"ok"};return this.safeString(t,e,e)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new Ru(this.id+" "+this.json(s));const i=this.safeString(t,"method"),n={"state.update":this.handleTicker,"asset.update":this.handleBalance,"deals.update":this.handleTrades,"depth.update":this.handleOrderBook,"order.update":this.handleOrders,"kline.update":this.handleOHLCV,"order.update_stop":this.handleOrders},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):this.handleSubscriptionStatus(e,t)}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.safeValue(e.subscriptions,s);if(i!==void 0){const n=this.safeString(i,"future"),r=this.safeValue(e.futures,n);r!==void 0&&r.resolve(!0),delete e.subscriptions[s]}}authenticate(e={}){let t;[t,e]=this.handleMarketTypeAndParams("authenticate",void 0,e);const s=this.urls.api.ws[t],i=this.client(s),n=this.milliseconds();if(t==="spot"){const r="authenticated:spot";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future(r),d=this.requestId(),c={id:d,future:"authenticated:spot"},u="access_id="+this.apiKey+"&tonce="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"md5"),f={method:"server.sign",params:[this.apiKey,h.toUpperCase(),n],id:d};return this.spawn(this.watch,s,r,f,d,c),o}else{const r="authenticated:swap";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future("authenticated:swap"),d=this.requestId(),c={id:d,future:"authenticated:swap"},u="access_id="+this.apiKey+"&timestamp="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"sha256","hex"),f={method:"server.sign",params:[this.apiKey,h.toLowerCase(),n],id:d};return this.spawn(this.watch,s,r,f,d,c),o}}};const JG=TT,{AuthenticationError:eU,NotSupported:Du}=Q,{ArrayCache:tU,ArrayCacheByTimestamp:sU,ArrayCacheBySymbolById:iU}=Pe;var nU=class extends JG{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchMyTrades:!0,watchTrades:!0,watchOrderBook:!0,watchOrders:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://stream.crypto.com/v2/market",private:"wss://stream.crypto.com/v2/user"}},test:{public:"wss://uat-stream.3ona.co/v2/market",private:"wss://uat-stream.3ona.co/v2/user"}},options:{},streaming:{}})}async pong(e,t){await e.send({id:this.safeInteger(t,"id"),method:"public/respond-heartbeat"})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new Du(this.id+" watchOrderBook() supports spot markets only");const n="book."+i.id;return(await this.watchPublic(n,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),r=this.safeMarket(i).symbol;let a=this.safeValue(t,"data");a=this.safeValue(a,0);const o=this.safeInteger(a,"t"),d=this.parseOrderBook(a,r,o);d.nonce=this.safeInteger(a,"s");let c=this.safeValue(this.orderbooks,r);if(c===void 0){const u=this.safeInteger(t,"depth");c=this.orderBook({},u)}c.reset(d),this.orderbooks[r]=c,e.resolve(c,s)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(e=n.symbol,!n.spot)throw new Du(this.id+" watchTrades() supports spot markets only");const r="trade."+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel"),i=this.safeString(t,"instrument_name"),n=this.safeString(t,"subscription"),r=this.safeMarket(i),a=r.symbol;let o=this.safeValue(this.trades,a);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new tU(u),this.trades[a]=o}const d=this.safeValue(t,"data",[]),c=this.parseTrades(d,r);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,n),e.resolve(o,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.trade":"user.trade";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new Du(this.id+" watchTicker() supports spot markets only");const i="ticker."+s.id;return await this.watchPublic(i,t)}handleTicker(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.parseTicker(o,n),c=d.symbol;this.tickers[c]=d,e.resolve(d,s)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(e=r.symbol,!r.spot)throw new Du(this.id+" watchOHLCV() supports spot markets only");const a=this.timeframes[t],o="candlestick."+a+"."+r.id,d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let d=this.safeValue(this.ohlcvs[r],o);if(d===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);d=new sU(u),this.ohlcvs[r][o]=d}const c=this.safeValue(t,"data");for(let u=0;u<c.length;u++){const h=c[u],f=this.parseOHLCV(h,n);d.append(f)}e.resolve(d,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.order":"user.order";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"channel"),n=this.safeString(t,"subscription"),r=this.safeValue(t,"data",[]);if(r.length>0){if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new iU(c)}const o=this.orders,d=this.parseOrders(r);for(let c=0;c<d.length;c++)o.append(d[c]);e.resolve(o,n),e.resolve(o,i)}}async watchBalance(e={}){const s=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.balance":"user.balance";return await this.watchPrivate(s,e)}handleBalance(e,t){const s=this.safeString(t,"subscription"),i=this.safeValue(t,"data");for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.total=this.safeString(r,"balance"),this.balance[o]=d,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws.public,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t={}){await this.authenticate();const s=this.urls.api.ws.private,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}return!1}catch(i){if(i instanceof eU){const n="authenticated";e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n]}else e.reject(i);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"method");if(s==="public/heartbeat"){this.handlePing(e,t);return}if(s==="public/auth"){this.handleAuthenticate(e,t);return}const i={candlestick:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,book:this.handleOrderBookSnapshot,"user.order":this.handleOrders,"user.margin.order":this.handleOrders,"user.trade":this.handleTrades,"user.margin.trade":this.handleTrades,"user.balance":this.handleBalance,"user.margin.balance":this.handleBalance},n=this.safeValue2(t,"result","info"),r=this.safeString(n,"channel"),a=this.safeValue(i,r);a!==void 0&&a.call(this,e,n)}authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r="public/auth",a=this.nonce().toString(),o=r+a+this.apiKey+a,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256"),c={id:a,nonce:a,method:r,api_key:this.apiKey,sig:d},u=this.extend(c,e);n=this.watch(t,i,u),s.subscriptions[i]=n}return n}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){e.resolve(t,"authenticated")}};const rU=OT,aU=ae,{ArrayCache:oU,ArrayCacheByTimestamp:dU}=Pe;var cU=class extends rU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://api-adapter.backend.currency.com/connect"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"W1"}},streaming:{ping:this.ping,keepAlive:2e4}})}ping(e){const t=this.requestId().toString();return{destination:"ping",correlationId:t,payload:{}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleBalance(e,t,s){const i=this.safeValue(t,"payload"),n=this.parseBalance(i);this.balance=this.extend(this.balance,n);const r=this.safeString(s,"messageHash");e.resolve(this.balance,r),r in e.subscriptions&&delete e.subscriptions[r]}handleTicker(e,t,s){const i="/api/v1/ticker/24hr",n=this.safeValue(t,"payload"),r=this.safeValue(n,"tickers",[]);for(let a=0;a<r.length;a++){const o=this.parseTicker(r[a]),d=o.symbol;this.tickers[d]=o;const c=i+":"+d;e.resolve(o,c),c in e.subscriptions&&delete e.subscriptions[c]}}handleTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,void 0,"/"),n=this.safeInteger(e,"ts"),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.parseNumber(aU.stringMul(r,a)),d=this.parseNumber(r),c=this.parseNumber(a),u=this.safeString2(e,"id"),h=this.safeString(e,"orderId"),l=this.safeValue(e,"buyer")?"buy":"sell";return{info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:u,order:h,type:void 0,takerOrMaker:void 0,side:l,price:d,amount:c,cost:o,fee:void 0}}handleTrades(e,t,s){const i=this.safeValue(t,"payload"),n=this.handleTrade(i),r=n.symbol,o="trades.subscribe"+":"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new oU(c),this.trades[r]=d}d.append(n),e.resolve(d,o)}findTimeframe(e){const t=this.safeValue(this.options,"timeframes"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}handleOHLCV(e,t){const s="OHLCMarketData.subscribe",i=this.safeValue(t,"payload",{}),n=this.safeString(i,"interval"),r=this.findTimeframe(n),a=this.safeString(i,"symbol"),d=this.safeMarket(a).symbol,c=s+":"+r+":"+d,u=[this.safeInteger(i,"t"),this.safeNumber(i,"o"),this.safeNumber(i,"h"),this.safeNumber(i,"l"),this.safeNumber(i,"c"),void 0];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let h=this.safeValue(this.ohlcvs[d],r);if(h===void 0){const f=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new dU(f),this.ohlcvs[d][r]=h}h.append(u),e.resolve(h,c)}requestId(){const e=this.sum(this.safeInteger(this.options,"correlationId",0),1);return this.options.correlationId=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const n=e+":"+t,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:e,correlationId:a,payload:{symbols:[i.id]}},s),d=this.extend(o,{messageHash:n,symbol:t});return await this.watch(r,n,o,n,d)}async watchPrivate(e,t={}){await this.loadMarkets();const s="/api/v1/account",i=this.urls.api.ws,n=this.requestId().toString(),r={timestamp:this.milliseconds(),apiKey:this.apiKey},a=this.urlencode(this.keysort(r)),o=this.deepExtend({destination:e,correlationId:n,payload:r},t);o.payload.signature=this.hmac(this.encode(a),this.encode(this.secret));const d=this.extend(o,{messageHash:s});return await this.watch(i,s,o,s,d)}async watchBalance(e={}){return await this.loadMarkets(),await this.watchPrivate("/api/v1/account",e)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="/api/v1/ticker/24hr",n=i+":"+e,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:i,correlationId:a,payload:{symbol:s.id}},t),d=this.extend(o,{messageHash:n,symbol:e});return await this.watch(r,n,o,n,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades.subscribe",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return await this.loadMarkets(),e=this.symbol(e),(await this.watchPublic("depthMarketData.subscribe",e,s)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r="OHLCMarketData.subscribe",a=r+":"+t,o=this.safeValue(this.options,"timeframes"),d={destination:r,payload:{intervals:[o[t]]}},c=await this.watchPublic(a,e,this.extend(d,n));return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleDeltas(e,t){const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=t[n];e.store(parseFloat(n),parseFloat(r))}}handleOrderBook(e,t){const s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"symbol"),r=this.safeSymbol(n,void 0,"/"),o="depthMarketData.subscribe"+":"+r,d=this.safeInteger(i,"ts");let c=this.safeValue(this.orderbooks,r);c===void 0&&(c=this.orderBook()),c.reset({timestamp:d,datetime:this.iso8601(d)});const u=this.safeValue(i,"bid",{}),h=this.safeValue(i,"ofr",{});this.handleDeltas(c.bids,u),this.handleDeltas(c.asks,h),this.orderbooks[r]=c,e.resolve(c,o)}handleMessage(e,t){const s=this.safeString(t,"correlationId");if(s!==void 0){const n=this.indexBy(e.subscriptions,"correlationId"),r=this.safeString(t,"status"),a=this.safeValue(n,s);if(a!==void 0&&r==="OK"){const o=this.safeString(a,"destination");if(o!==void 0){const d={"/api/v1/ticker/24hr":this.handleTicker,"/api/v1/account":this.handleBalance},c=this.safeValue(d,o);return c===void 0?t:c.call(this,e,t,a)}}}const i=this.safeString(t,"destination");if(i!==void 0){const n={"marketdepth.event":this.handleOrderBook,"internal.trade":this.handleTrades,"ohlc.event":this.handleOHLCV,ping:this.handlePong},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}};const uU=IT,{NotSupported:k1,ExchangeError:hU}=Q,{ArrayCache:fU,ArrayCacheBySymbolById:S1,ArrayCacheByTimestamp:lU}=Pe;var pU=class extends uU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://test.deribit.com/ws/api/v2"},api:{ws:"wss://www.deribit.com/ws/api/v2"}},options:{timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":180,"6h":360,"12h":720,"1d":"1D"},currencies:["BTC","ETH","SOL","USDC"]},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.safeValue(this.options,"currencies",[]),n=[];for(let o=0;o<i.length;o++){const d=i[o];n.push("user.portfolio."+d)}const r={jsonrpc:"2.0",method:"private/subscribe",params:{channels:n},id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(s,t,a,t,a)}handleBalance(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.parseBalance(i);this.balance[r]=a;const o="balance";e.resolve(this.balance,o)}async watchTicker(e,t={}){const s=this.market(e),i=this.urls.api.ws,n=this.safeString(t,"interval","100ms");t=this.omit(t,"interval"),await this.loadMarkets(),n==="raw"&&await this.authenticate();const r="ticker."+s.id+"."+n,a={jsonrpc:"2.0",method:"public/subscribe",params:{channels:["ticker."+s.id+"."+n]},id:this.requestId()},o=this.deepExtend(a,t);return await this.watch(i,r,o,r,o)}handleTicker(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"instrument_name"),r=this.safeSymbol(n),a=this.parseTicker(i),o=this.safeString(s,"channel");this.tickers[r]=a,e.resolve(a,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.urls.api.ws,a=this.safeString(i,"interval","100ms");i=this.omit(i,"interval");const o="trades."+n.id+"."+a;a==="raw"&&await this.authenticate();const d={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[o]},id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(r,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeMarket(r),d=this.safeValue(s,"data",[]);let c=this.safeValue(this.trades,a);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new fU(u),this.trades[a]=c}for(let u=0;u<d.length;u++){const h=d[u],f=this.parseTrade(h,o);c.append(f)}this.trades[a]=c,e.resolve(this.trades[a],i)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(i),e!==void 0&&(await this.loadMarkets(),e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"interval","raw");i=this.omit(i,"interval");const a="user.trades.any.any."+r,o={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",[]);let r=this.myTrades;if(r===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);r=new S1(o)}const a=this.parseTrades(n);for(let o=0;o<a.length;o++){const d=a[o];r.append(d),d.symbol}e.resolve(r,i)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.urls.api.ws,r=this.safeString(s,"interval","100ms");s=this.omit(s,"interval"),r==="raw"&&await this.authenticate();const a="book."+i.id+"."+r,o={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,a,d,a)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"channel"),r=this.safeString(i,"instrument_name"),a=this.safeSymbol(r),o=this.safeNumber(i,"timestamp");let d=this.safeValue(this.orderbooks,a);d===void 0&&(d=this.countedOrderBook());const c=this.safeValue(i,"asks",[]),u=this.safeValue(i,"bids",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=o,d.timestamp=o,d.datetime=this.iso8601(o),d.symbol=a,this.orderbooks[a]=d,e.resolve(d,n)}cleanOrderBook(e){const t=this.safeValue(e,"bids",[]),s=this.safeValue(e,"asks",[]),i=[];for(let r=0;r<t.length;r++)i.push([t[r][1],t[r][2]]);const n=[];for(let r=0;r<s.length;r++)n.push([s[r][1],s[r][2]]);return e.bids=i,e.asks=n,e}handleDelta(e,t){const s=t[1],i=t[2];t[0]==="new"||t[0]==="change"?e.store(s,i,1):t[0]==="delete"&&e.store(s,i,0)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"currency","any"),a=this.safeString(i,"interval","raw"),o=this.safeString(i,"kind","any");i=this.omit(i,"interval","currency","kind");const d="user.orders."+o+"."+r+"."+a,c={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[d]},id:this.requestId()},u=this.deepExtend(c,i),h=await this.watch(n,d,u,d,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new S1(a)}const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",{});let r=[];Array.isArray(n)?r=this.parseOrders(n):r=[this.parseOrder(n)];for(let a=0;a<r.length;a++)this.orders.append(r[a]);e.resolve(this.orders,i)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.urls.api.ws,o=this.safeValue(this.options,"timeframes",{}),d=this.safeString(o,t);if(d===void 0)throw new k1(this.id+" this interval is not supported, please provide one of the supported timeframes");const c="chart.trades."+r.id+"."+d,u={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[c]},id:this.requestId()},h=this.deepExtend(u,n),f=await this.watch(a,c,h,c,h);return this.newUpdates&&(i=f.getLimit(r.symbol,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,2),a=this.safeSymbol(r),o=this.safeValue(s,"data",{}),d=[this.safeNumber(o,"tick"),this.safeNumber(o,"open"),this.safeNumber(o,"high"),this.safeNumber(o,"low"),this.safeNumber(o,"close"),this.safeNumber(o,"volume")];let c=this.safeValue(this.ohlcvs,a);if(c===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new lU(u)}c.append(d),this.ohlcvs[a]=c,e.resolve(c,i)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new hU(this.id+" "+this.json(s));const i=this.safeValue(t,"params"),n=this.safeString(i,"channel");if(n!==void 0){const o=n.split("."),d=this.safeString(o,0),c={trades:this.handleMyTrades,portfolio:this.handleBalance,orders:this.handleOrders},u={ticker:this.handleTicker,book:this.handleOrderBook,trades:this.handleTrades,chart:this.handleOHLCV,user:this.safeValue(c,this.safeString(o,1))},h=this.safeValue(u,d);if(h!==void 0)return h.call(this,e,t);throw new k1(this.id+" no handler found for this message "+this.json(t))}const r=this.safeValue(t,"result",{});return this.safeString(r,"access_token")!==void 0?this.handleAuthenticationMessage(e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=this.milliseconds(),n=this.numberToString(i),r=n,a="authenticated",o=s.future("authenticated");if(this.safeValue(s.subscriptions,a)===void 0){this.checkRequiredCredentials();const c=this.requestId(),u=this.hmac(this.encode(n+`
`+r+`
`),this.encode(this.secret),"sha256"),h={jsonrpc:"2.0",id:c,method:"public/auth",params:{grant_type:"client_signature",client_id:this.apiKey,timestamp:i,signature:u,nonce:r,data:""}};this.spawn(this.watch,t,a,this.extend(h,e),a)}return await o}};const mU=xT,{NotSupported:gU}=Q,{ArrayCache:yU,ArrayCacheBySymbolById:wU}=Pe;var bU=class extends mU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!1,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{public:"wss://ws-api.exmo.com:443/v1/public",spot:"wss://ws-api.exmo.com:443/v1/private",margin:"wss://ws-api.exmo.com:443/v1/margin/private"}}},options:{},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i="balance:"+t,n=this.urls.api.ws[t],r={method:"subscribe",topics:[t+"/wallet"],id:this.requestId()},a=this.deepExtend(r,s);return await this.watch(n,i,a,i,a)}handleBalance(e,t){const i=this.safeString(t,"topic").split("/"),n=this.safeString(i,0);n==="spot"?this.parseSpotBalance(t):n==="margin"&&this.parseMarginBalance(t);const r="balance:"+n;e.resolve(this.balance,r)}parseSpotBalance(e){const t=this.safeString(e,"event"),s=this.safeValue(e,"data");if(t==="snapshot"){const i=this.safeValue(s,"balances",{}),n=this.safeValue(s,"reserved",{}),r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=i[o],u=n[o],h=this.account();h.free=this.parseNumber(c),h.used=this.parseNumber(u),this.balance[d]=h}}else if(t==="update"){const i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeNumber(s,"balance"),r.used=this.safeNumber(s,"reserved"),this.balance[n]=r}this.balance=this.safeBalance(this.balance)}parseMarginBalance(e){const t=this.safeValue(e,"data"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(n),a=this.safeValue(t,n),o=this.account();o.free=this.safeNumber(a,"free"),o.used=this.safeNumber(a,"used"),o.total=this.safeNumber(a,"balance"),this.balance[r]=o,this.balance=this.safeBalance(this.balance)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws.public,n="ticker:"+e,r={method:"subscribe",topics:["spot/ticker:"+s.id],id:this.requestId()},a=this.deepExtend(r,t);return await this.watch(i,n,a,n,a)}handleTicker(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o=this.safeMarket(n),d=this.parseTicker(a,o),c="ticker:"+r;this.tickers[r]=d,e.resolve(d,c)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws.public,a="trades:"+e,o={method:"subscribe",topics:["spot/trades:"+n.id],id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a,d);return this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrades(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeMarket(n),o=this.safeValue(t,"data",[]),d="trades:"+r;let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new yU(u),this.trades[r]=c}for(let u=0;u<o.length;u++){const h=o[u],f=this.parseTrade(h,a);c.append(f)}this.trades[r]=c,e.resolve(this.trades[r],d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const[n,r]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),a=this.urls.api.ws[n];let o;if(e===void 0)o="myTrades:"+n;else{const h=this.market(e);e=h.symbol,o="myTrades:"+h.symbol}const d={method:"subscribe",topics:[n+"/user_trades"],id:this.requestId()},c=this.deepExtend(d,r),u=await this.watch(a,o,c,o,c);return this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrades(e,t){const i=this.safeString(t,"topic").split("/"),n=this.safeString(i,0),r="myTrades:"+n,a=this.safeString(t,"event");let o=[],d;if(this.myTrades===void 0){const f=this.safeInteger(this.options,"tradesLimit",1e3);d=new wU(f),this.myTrades=d}else d=this.myTrades;a==="snapshot"?o=this.safeValue(t,"data",[]):a==="update"&&(o=[this.safeValue(t,"data",{})]);const c=this.parseTrades(o),u={};for(let f=0;f<c.length;f++){const l=c[f];d.append(l),u[l.symbol]=!0}const h=Object.keys(u);for(let f=0;f<h.length;f++){const l=h[f],m="myTrades:"+l;e.resolve(d,m)}e.resolve(d,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws.public,r="orderbook:"+e;s=this.omit(s,"aggregation");const a={method:"subscribe",id:this.requestId(),topics:["spot/order_book_updates:"+i.id]},o=this.deepExtend(a,s);return(await this.watch(n,r,o,r)).limit()}handleOrderBook(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o="orderbook:"+r,d=this.safeNumber(t,"ts");let c=this.safeValue(this.orderbooks,r);if(c===void 0&&(c=this.orderBook({}),this.orderbooks[r]=c),this.safeString(t,"event")==="snapshot"){const h=this.parseOrderBook(a,r,d,"bid","ask");c.reset(h)}else{const h=this.safeValue(a,"ask",[]),f=this.safeValue(a,"bid",[]);this.handleDeltas(c.asks,h),this.handleDeltas(c.bids,f),c.timestamp=d,c.datetime=this.iso8601(d)}e.resolve(c,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"event"),i={logged_in:this.handleAuthenticationMessage,info:this.handleInfo,subscribed:this.handleSubscribed},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t);if(s==="update"||s==="snapshot"){const r=this.safeString(t,"topic");if(r!==void 0){const a=r.split(":"),o=this.safeString(a,0),d={"spot/ticker":this.handleTicker,"spot/wallet":this.handleBalance,"margin/wallet":this.handleBalance,"margin/wallets":this.handleBalance,"spot/trades":this.handleTrades,"margin/trades":this.handleTrades,"spot/order_book_updates":this.handleOrderBook,"spot/user_trades":this.handleMyTrades,"margin/user_trades":this.handleMyTrades},c=this.safeValue(d,o);if(c!==void 0)return c.call(this,e,t)}}throw new gU(this.id+" received an unsupported message: "+this.json(t))}handleSubscribed(e,t){return t}handleInfo(e,t){return t}handleAuthenticationMessage(e,t){const s="authenticated";e.resolve(t,s)}authenticate(e={}){const t="authenticated",[s,i]=this.handleMarketTypeAndParams("authenticate",void 0,e),n=this.urls.api.ws[s],r=this.client(n);let a=this.safeValue(r.subscriptions,t);if(a===void 0){const o=this.milliseconds();this.checkRequiredCredentials();const d=this.requestId(),c=this.apiKey+o.toString(),u=this.hmac(this.encode(c),this.encode(this.secret),"sha512","base64"),h={method:"login",id:d,api_key:this.apiKey,sign:u,nonce:o},f=this.extend(h,i);a=this.watch(n,t,f),r.subscriptions[t]=a}return a}};const kU=lg,{AuthenticationError:Yp,BadRequest:SU,ArgumentsRequired:v1,NotSupported:vU,InvalidNonce:TU}=Q,{ArrayCache:OU,ArrayCacheByTimestamp:IU,ArrayCacheBySymbolById:T1}=Pe;var jT=class extends kU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchMyTrades:!0,watchOHLCV:!0,watchBalance:!0,watchOrders:!0},urls:{api:{ws:"wss://ws.gate.io/v4",spot:"wss://api.gateio.ws/ws/v4/",swap:{usdt:"wss://fx-ws.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws.gateio.ws/v4/ws/delivery/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/delivery/btc"},option:"wss://op-ws.gateio.live/v4/ws"},test:{swap:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},option:"wss://op-ws-testnet.gateio.live/v4/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,watchTradesSubscriptions:{},watchTickerSubscriptions:{},watchOrderBookSubscriptions:{},watchTicker:{name:"tickers"},watchOrderBook:{interval:"100ms",snapshotDelay:10},watchBalance:{settle:"usdt",spot:"spot.balances"}},exceptions:{ws:{exact:{2:SU,4:Yp,6:Yp,11:Yp}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,[r,a]=this.handleOptionAndParams(s,"watchOrderBook","interval","100ms"),d=this.getTypeByMarket(i)+".order_book_update",c="orderbook:"+e,u=this.getUrlByMarket(i),h=[n,r];if(t===void 0&&(t=100),i.contract){const m=t.toString();h.push(m)}const f={symbol:e,limit:t};return(await this.subscribePublic(u,c,h,d,f,a)).limit()}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},n)}handleOrderBook(e,t){const s=this.safeString(t,"channel"),i=s.split("."),r=this.safeString(i,0)==="spot",a=r?"spot":"contract",o=this.safeValue(t,"result"),d=this.safeInteger(o,"U"),c=this.safeInteger(o,"u"),u=this.safeString(o,"s"),h=this.safeSymbol(u,void 0,"_",a),f="orderbook:"+h,l=this.safeValue(this.orderbooks,h),m=this.safeInteger(l,"nonce");if(m===void 0){const g=l.cache.length,y=this.handleOption("watchOrderBook","snapshotDelay",10);if(g===(r?y:0)){const b=e.subscriptions[s],S=this.safeInteger(b,"limit");this.spawn(this.loadOrderBook,e,f,h,S)}l.cache.push(o);return}else{if(m>=c)return;if(m>=d-1)this.handleDelta(l,o);else{const g=new TU(this.id+" orderbook update has a nonce bigger than u");e.reject(g,f)}}e.resolve(l,f)}getCacheIndex(e,t){const s=this.safeInteger(e,"nonce"),i=t[0],n=this.safeInteger(i,"U");if(s<n)return-1;for(let r=0;r<t.length;r++){const a=t[r],o=this.safeInteger(a,"U"),d=this.safeInteger(a,"u");if(s>=o-1&&s<d)return r}return t.length}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=t[s];if(Array.isArray(i))e.storeArray(this.parseBidAsk(i));else{const n=this.safeFloat(i,"p"),r=this.safeFloat(i,"s");e.store(n,r)}}}handleDelta(e,t){const s=this.safeInteger(t,"t");e.timestamp=s,e.datetime=this.iso8601(s),e.nonce=this.safeInteger(t,"u");const i=this.safeValue(t,"b",[]),n=this.safeValue(t,"a",[]),r=e.bids,a=e.asks;this.handleBidAsks(r,i),this.handleBidAsks(a,n)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.id,n=this.getUrlByMarket(s),r=this.getTypeByMarket(s),[a,o]=this.handleOptionAndParams(t,"watchTicker","method","tickers"),d=r+"."+a,c="ticker:"+e,u=[i];return await this.subscribePublic(n,c,u,d,void 0,o)}async watchTickers(e=void 0,t={}){if(await this.loadMarkets(),e=this.marketSymbols(e),e===void 0)throw new v1(this.id+" watchTickers requires symbols");const s=this.market(e[0]),i=this.getTypeByMarket(s),n=this.marketIds(e),[r,a]=this.handleOptionAndParams(t,"watchTicker","method","tickers"),o=i+"."+r,d="tickers",c=this.getUrlByMarket(s),u=await this.subscribePublic(c,d,n,o,void 0,a);let h={};return this.newUpdates?h[u.symbol]=u:h=this.tickers,this.filterByArray(h,"symbol",e,!0)}handleTicker(e,t){const i=this.safeString(t,"channel").split("."),r=this.safeString(i,0)==="futures"?"contract":"spot";let a=this.safeValue(t,"result");Array.isArray(a)||(a=[a]);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"s"),u=this.safeMarket(c,void 0,"_",r),h=this.parseTicker(d,u),f=h.symbol;this.tickers[f]=h;const l="ticker:"+f;e.resolve(h,l),e.resolve(h,"tickers")}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=n.id,o=this.getTypeByMarket(n)+".trades",d="trades:"+e,c=this.getUrlByMarket(n),u=[r],h=await this.subscribePublic(c,d,u,o,void 0,i);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){let s=this.safeValue(t,"result");Array.isArray(s)||(s=[s]);const i=this.parseTrades(s);for(let n=0;n<i.length;n++){const r=i[n],a=r.symbol;let o=this.safeValue(this.trades,a);if(o===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);o=new OU(c),this.trades[a]=o}o.append(r);const d="trades:"+a;e.resolve(o,d)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id,o=this.timeframes[t],c=this.getTypeByMarket(r)+".candlesticks",u="candles:"+o+":"+r.symbol,h=this.getUrlByMarket(r),f=[o,a],l=await this.subscribePublic(h,u,f,c,void 0,n);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const i=this.safeString(t,"channel").split("."),r=this.safeString(i,0)==="spot"?"spot":"contract";let a=this.safeValue(t,"result");Array.isArray(a)||(a=[a]);const o={};for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"n",""),f=h.split("_"),l=this.safeString(f,0),m=l+"_",g=h.replace(m,""),y=this.safeSymbol(g,void 0,"_",r),w=this.parseOHLCV(u);let b=this.safeValue(this.ohlcvs,y);if(b===void 0){const S=this.safeInteger(this.options,"OHLCVLimit",1e3);b=new IU(S),this.ohlcvs[y]=b}b.append(w),o[y]=l}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=o[u],f=this.findTimeframe(h),l="candles:"+f+":"+u,m=this.safeValue(this.ohlcvs,u);e.resolve(m,l)}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="!all",o;e!==void 0&&(o=this.market(e),a=o.id),[r,i]=this.handleMarketTypeAndParams("watchMyTrades",o,i),[n,i]=this.handleSubTypeAndParams("watchMyTrades",o,i);const c=this.getSupportedMapping(r,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".usertrades";let u="myTrades";e!==void 0&&(u+=":"+e);const h=n==="inverse",f=this.getUrlByMarketType(r,h),l=[a],m=r!=="spot",g=await this.subscribePrivate(f,u,l,c,i,m);return this.newUpdates&&(s=g.getLimit(e,s)),this.filterBySymbolSinceLimit(g,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"result",[]);if(s.length===0)return;let n=this.myTrades;if(n===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);n=new T1(d),this.myTrades=n}const r=this.parseTrades(s),a={};for(let d=0;d<r.length;d++){const c=r[d];n.append(c);const u=c.symbol;a[u]=!0}const o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u="myTrades:"+c;e.resolve(n,u)}e.resolve(n,"myTrades")}async watchBalance(e={}){await this.loadMarkets();let t,s;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e);const i=s==="inverse",n=this.getUrlByMarketType(t,i),r=t!=="spot",o=this.getSupportedMapping(t,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".balances",d="balance";return await this.subscribePrivate(n,d,void 0,o,e,r)}handleBalance(e,t){const s=this.safeValue(t,"result",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.account(),a=this.safeString(n,"currency","USDT"),o=this.safeCurrencyCode(a);r.free=this.safeString(n,"available"),r.total=this.safeString2(n,"total","balance"),this.balance[o]=r}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let r,a;[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);const d=this.getSupportedMapping(r,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".orders";let c="orders",u=["!all"];e!==void 0&&(c+=":"+n.id,u=[n.id]);let h;[h,a]=this.handleSubTypeAndParams("watchOrders",n,a);const f=h==="inverse",l=this.getUrlByMarketType(r,f),m=r!=="spot",g=await this.subscribePrivate(l,c,u,d,a,m);return this.newUpdates&&(s=g.getLimit(e,s)),this.filterBySinceLimit(g,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeValue(t,"result",[]),i=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new T1(i));const n=this.orders,r={},a=this.parseOrders(s);for(let d=0;d<a.length;d++){const c=a[d],u=this.safeValue(c,"info"),h=this.safeString(u,"event");h==="put"?c.status="open":h==="finish"&&(c.status="closed"),n.append(c);const f=c.symbol,l=this.market(f);r[l.id]=!0}const o=Object.keys(r);for(let d=0;d<o.length;d++){const c="orders:"+o[d];e.resolve(this.orders,c)}e.resolve(this.orders,"orders")}handleErrorMessage(e,t){const s=this.safeValue(t,"error",{}),i=this.safeInteger(s,"code");if(i!==void 0){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0)try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,this.json(t))}catch(o){const d=this.safeString(a,"messageHash");e.reject(o,d),n in e.subscriptions&&delete e.subscriptions[n]}}}handleBalanceSubscription(e,t){this.balance={}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channel",""),i={balance:this.handleBalanceSubscription,order_book:this.handleOrderBookSubscription},n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r];if(s.indexOf(a)>=0){const o=i[a],d=e.subscriptions[s];o.call(this,e,t,d)}}}handleMessage(e,t){if(this.handleErrorMessage(e,t),this.safeString(t,"event")==="subscribe"){this.handleSubscriptionStatus(e,t);return}const n=this.safeString(t,"channel","").split("."),r=this.safeValue(n,1),a={usertrades:this.handleMyTrades,candlesticks:this.handleOHLCV,orders:this.handleOrder,tickers:this.handleTicker,book_ticker:this.handleTicker,trades:this.handleTrades,order_book_update:this.handleOrderBook,balances:this.handleBalance},o=this.safeValue(a,r);o!==void 0&&o.call(this,e,t)}getUrlByMarket(e){const t=this.urls.api[e.type];return e.contract?e.linear?t.usdt:t.btc:t}getTypeByMarket(e){return e.spot?"spot":e.option?"options":"futures"}getUrlByMarketType(e,t=!1){if(e==="spot"){const s=this.urls.api.spot;if(s===void 0)throw new vU(this.id+" does not have a testnet for the "+e+" market type.");return s}else if(e==="swap"){const s=this.urls.api.swap;return t?s.btc:s.usdt}else if(e==="future"){const s=this.urls.api.future;return t?s.btc:s.usdt}else if(e==="option")return this.urls.api.option}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async subscribePublic(e,t,s,i,n,r={}){const a=this.requestId(),o=this.seconds(),d={id:a,time:o,channel:i,event:"subscribe",payload:s};n===void 0&&(n={}),n=this.extend(n,{id:a,messageHash:t});const c=this.extend(d,r);return await this.watch(e,t,c,i,n)}async subscribePrivate(e,t,s,i,n,r=!1){if(this.checkRequiredCredentials(),r){if(this.uid===void 0||this.uid.length===0)throw new v1(this.id+" requires uid to subscribe");const g=[this.uid];s===void 0?s=g:s=this.arrayConcat(g,s)}const a=this.seconds(),o="subscribe",d="channel="+i+"&event="+o+"&time="+a.toString(),c=this.hmac(this.encode(d),this.encode(this.secret),"sha512","hex"),u={method:"api_key",KEY:this.apiKey,SIGN:c},h=this.requestId(),f={id:h,time:a,channel:i,event:"subscribe",auth:u};s!==void 0&&(f.payload=s);const l=this.extend(f,n),m={id:h,messageHash:t};return await this.watch(e,t,l,i,m)}};const xU=jT;var _U=class extends xU{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"gateio"})}};const CU=_T,{ArrayCache:O1,ArrayCacheBySymbolById:MU,ArrayCacheByTimestamp:PU}=Pe,{ExchangeError:AU}=Q;var BU=class extends CU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},"hostname:":"api.gemini.com",urls:{api:{ws:"wss://api.gemini.com"},test:{ws:"wss://api.sandbox.gemini.com"}}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r="trades:"+n.symbol,a=n.id,o={type:"subscribe",subscriptions:[{name:"l2",symbols:[a.toUpperCase()]}]},d="l2:"+n.symbol,c=this.urls.api.ws+"/v2/marketdata",u=await this.watch(c,r,o,d);return this.newUpdates&&(s=u.getLimit(n.symbol,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"event_id"),n=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeStringLower(e,"side"),o=this.safeStringLower(e,"symbol"),d=this.safeSymbol(o,t);return this.safeTrade({id:i,order:void 0,info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:a,takerOrMaker:void 0,price:n,cost:void 0,amount:r,fee:void 0},t)}handleTrade(e,t){const s=this.parseWsTrade(t),i=s.symbol,n=this.safeInteger(this.options,"tradesLimit",1e3);let r=this.safeValue(this.trades,i);r===void 0&&(r=new O1(n),this.trades[i]=r),r.append(s);const a="trades:"+i;e.resolve(r,a)}handleTrades(e,t){const s=this.safeStringLower(t,"symbol"),i=this.safeMarket(s),n=this.safeValue(t,"trades");if(n!==void 0){const r=i.symbol,a=this.safeInteger(this.options,"tradesLimit",1e3);let o=this.safeValue(this.trades,r);o===void 0&&(o=new O1(a),this.trades[r]=o);for(let c=0;c<n.length;c++){const u=this.parseWsTrade(n[c],i);o.append(u)}const d="trades:"+r;e.resolve(o,d)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(this.timeframes,t,t),o={type:"subscribe",subscriptions:[{name:"candles_"+a,symbols:[r.id.toUpperCase()]}]},d="ohlcv:"+r.symbol+":"+a,c=this.urls.api.ws+"/v2/marketdata",u=await this.watch(c,d,o,d);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){let i=this.safeString(t,"type","").slice(8);const n=i.indexOf("_");i=i.slice(0,n);const r=this.safeString(t,"symbol","").toLowerCase(),a=this.safeMarket(r),o=this.safeSymbol(r,a),d=this.safeValue(t,"changes",[]),c=this.findTimeframe(i);this.safeValue(this.ohlcvs,o)===void 0&&(this.ohlcvs[o]={});let h=this.safeValue(this.ohlcvs[o],c);if(h===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new PU(m),this.ohlcvs[o][c]=h}const f=d.length;for(let m=0;m<f;m++){const g=f-m-1,y=this.parseOHLCV(d[g],a);h.append(y)}const l="ohlcv:"+o+":"+i;return e.resolve(h,l),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="orderbook:"+i.symbol,r=i.id,a={type:"subscribe",subscriptions:[{name:"l2",symbols:[r.toUpperCase()]}]},o="l2:"+i.symbol,d=this.urls.api.ws+"/v2/marketdata";return(await this.watch(d,n,a,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"changes",[]),i=this.safeStringLower(t,"symbol"),r=this.safeMarket(i).symbol,a="orderbook:"+r;let o=this.safeValue(this.orderbooks,r);o===void 0&&(o=this.orderBook());for(let d=0;d<s.length;d++){const c=s[d],u=this.safeNumber(c,1),h=this.safeNumber(c,2),f=c[0]==="buy"?"bids":"asks",l=o[f];l.store(u,h),o[f]=l}o.symbol=r,this.orderbooks[r]=o,e.resolve(o,a)}handleL2Updates(e,t){this.handleOrderBook(e,t),this.handleTrades(e,t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.urls.api.ws+"/v1/order/events?eventTypeFilter=initial&eventTypeFilter=accepted&eventTypeFilter=rejected&eventTypeFilter=fill&eventTypeFilter=cancelled&eventTypeFilter=booked";await this.loadMarkets();const r={url:n};await this.authenticate(r),e!==void 0&&(e=this.market(e).symbol);const a="orders",o=await this.watch(n,a,void 0,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleHeartbeat(e,t){return t}handleSubscription(e,t){return t}handleOrder(e,t){const s="orders";if(this.orders===void 0){const n=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new MU(n)}const i=this.orders;for(let n=0;n<t.length;n++){const r=this.parseWsOrder(t[n]);i.append(r)}e.resolve(this.orders,s)}parseWsOrder(e,t=void 0){const s=this.safeNumber(e,"timestampms"),i=this.safeString(e,"type"),n=this.safeString(e,"symbol"),r=this.safeString(e,"order_type"),a=this.safeString(e,"behavior");let o="GTC",d=!1;return a==="immediate-or-cancel"?o="IOC":a==="fill-or-kill"?o="FOK":a==="maker-or-cancel"&&(o="PO",d=!0),this.safeOrder({id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_order_id"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseWsOrderStatus(i),symbol:this.safeSymbol(n,t),type:this.parseWsOrderType(r),timeInForce:o,postOnly:d,side:this.safeString(e,"side"),price:this.safeNumber(e,"price"),stopPrice:void 0,average:this.safeNumber(e,"avg_execution_price"),cost:void 0,amount:this.safeNumber(e,"original_amount"),filled:this.safeNumber(e,"executed_amount"),remaining:this.safeNumber(e,"remaining_amount"),fee:void 0,trades:void 0},t)}parseWsOrderStatus(e){const t={accepted:"open",booked:"open",fill:"closed",cancelled:"canceled",cancel_rejected:"rejected",rejected:"rejected"};return this.safeString(t,e,e)}parseWsOrderType(e){const t={"exchange limit":"limit","market buy":"market","market sell":"market"};return this.safeString(t,e,e)}handleError(e,t){throw new AU(this.json(t))}handleMessage(e,t){if(Array.isArray(t))return this.handleOrder(e,t);this.safeString(t,"reason")==="error"&&this.handleError(e,t);const n={l2_updates:this.handleL2Updates,trade:this.handleTrade,subscription_ack:this.handleSubscription,heartbeat:this.handleHeartbeat},r=this.safeString(t,"type","");if(r.indexOf("candles")>=0)return this.handleOHLCV(e,t);const a=this.safeValue(n,r);a!==void 0&&a.call(this,e,t)}async authenticate(e={}){const t=this.safeString(e,"url");if(this.clients!==void 0&&t in this.clients)return;this.checkRequiredCredentials();const s=this.urls.api.ws.length,i=t.indexOf("?"),n=t.length,r=i>=0?i:n,o={request:t.slice(s,r),nonce:this.nonce()},d=this.stringToBase64(this.encode(this.json(o))),c=this.hmac(d,this.encode(this.secret),"sha384","hex"),u={ws:{options:{headers:{}}}};this.options=this.extend(u,this.options);const h=this.options.ws.options.headers;this.options.ws.options.headers={"X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":this.decode(d),"X-GEMINI-SIGNATURE":c},this.client(t),this.options.ws.options.headers=h}};const NU=CT,{AuthenticationError:VU,BadSymbol:EU,BadRequest:qU}=Q,{ArrayCache:I1,ArrayCacheBySymbolById:LU}=Pe;var RU=class extends NU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://api.hollaex.com/stream"},test:{ws:"wss://api.sandbox.hollaex.com/stream"}},options:{watchBalance:{},watchOrders:{}},streaming:{ping:this.ping},exceptions:{ws:{exact:{"Bearer or HMAC authentication required":EU,"Error: wrong input":qU}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="orderbook:"+i.id;return(await this.watchPublic(n,s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"topic"),r=this.safeMarket(s).symbol,a=this.safeValue(t,"data");let o=this.safeString(a,"timestamp");o=this.parse8601(o);const d=this.parseOrderBook(a,r,o);let c;r in this.orderbooks?(c=this.orderbooks[r],c.reset(d)):(c=this.orderBook(d),this.orderbooks[r]=c);const u=i+":"+s;e.resolve(c,u)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade:"+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"topic"),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new I1(u),this.trades[r]=a}const o=this.safeValue(t,"data",[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c=s+":"+i;e.resolve(a,c),e.resolve(a,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="usertrade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data");if(n.length===0)return 0;if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new I1(c)}const a=this.myTrades,o={};for(let c=0;c<n.length;c++){const u=n[c],h=this.parseTrade(u);a.append(h);const f=u.symbol,m=this.market(f).id;o[m]=!0}e.resolve(this.myTrades,i);const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=i+":"+u;e.resolve(this.myTrades,h)}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data",{});if(n.length===0)return 0;if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new LU(u)}const a=this.orders;let o;Array.isArray(n)?o=n:o=[n];const d={};for(let u=0;u<o.length;u++){const h=o[u],f=this.parseOrder(h);a.append(f);const l=h.symbol,g=this.market(l).id;d[g]=!0}e.resolve(this.orders,i);const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],f=i+":"+h;e.resolve(this.orders,f)}}async watchBalance(e={}){const t="wallet";return await this.watchPrivate(t,e)}handleBalance(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_"),d=this.safeString(o,0),c=this.safeCurrencyCode(d),u=c in this.balance?this.balance[c]:this.account(),f=this.safeString(o,1)==="available"?"free":"total";u[f]=this.safeString(i,a),this.balance[c]=u}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws,i={op:"subscribe",args:[e]},n=this.extend(i,t);return await this.watch(s,e,n,e)}async watchPrivate(e,t={}){this.checkRequiredCredentials();let s=this.safeString(this.options,"ws-expires");if(s===void 0){const u=parseInt(this.timeout/1e3);s=this.sum(this.seconds(),u),s=s.toString(),this.options["ws-expires"]=s}const i=this.urls.api.ws,n="CONNECT/stream"+s,r=this.hmac(this.encode(n),this.encode(this.secret)),a={"api-key":this.apiKey,"api-signature":r,"api-expires":s},o=i+"?"+this.urlencode(a),d={op:"subscribe",args:[e]},c=this.extend(d,t);return await this.watch(o,e,c,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"error");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,s,i)}}catch(i){if(i instanceof VU)return!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(this.safeString(t,"message")==="pong"){this.handlePong(e,t);return}const i={trade:this.handleTrades,orderbook:this.handleOrderBook,order:this.handleOrder,wallet:this.handleBalance,usertrade:this.handleMyTrades},n=this.safeValue(t,"topic"),r=this.safeValue(i,n);r!==void 0&&r.call(this,e,t)}ping(e){return{op:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}onError(e,t){this.options["ws-expires"]=void 0,super.onError(e,t)}onClose(e,t){this.options["ws-expires"]=void 0,super.onClose(e,t)}};const DU=pg,{ExchangeError:x1,InvalidNonce:FU,ArgumentsRequired:HU,BadRequest:Fu,BadSymbol:_1,AuthenticationError:C1}=Q,{ArrayCache:GU,ArrayCacheByTimestamp:UU,ArrayCacheBySymbolById:M1}=Pe;var KT=class extends DU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:{api:{spot:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"},future:{linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"},inverse:{public:"wss://api.hbdm.com/ws",private:"wss://api.hbdm.com/notification"}},swap:{inverse:{public:"wss://api.hbdm.com/swap-ws",private:"wss://api.hbdm.com/swap-notification"},linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"}}},"api-aws":{spot:{public:"wss://api-aws.huobi.pro/ws",private:"wss://api-aws.huobi.pro/ws/v2"},future:{linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"},inverse:{public:"wss://api.hbdm.vn/ws",private:"wss://api.hbdm.vn/notification"}},swap:{inverse:{public:"wss://api.hbdm.vn/swap-ws",private:"wss://api.hbdm.vn/swap-notification"},linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"}}}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",maxOrderBookSyncAttempts:3,ws:{gunzip:!0},watchTicker:{name:"market.{marketId}.detail"}},exceptions:{ws:{exact:{"bad-request":Fu,2002:C1,2021:Fu,2001:_1,2011:_1,2040:Fu}}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.safeValue(this.options,"watchTicker",{}),n=this.safeString(i,"name","market.{marketId}.detail");if(n==="market.{marketId}.ticker"&&s.type!=="spot")throw new Fu(this.id+" watchTicker() with name market.{marketId}.ticker is only allowed for spot markets, use market.{marketId}.detail instead");const r=this.implodeParams(n,{marketId:s.id}),a=this.getUrlByMarketType(s.type,s.linear);return await this.subscribePublic(a,e,r,void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.getUrlByMarketType(n.type,n.linear),o=await this.subscribePublic(a,e,r,void 0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new GU(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.getUrlByMarketType(r.type,r.linear),c=await this.subscribePublic(d,e,o,void 0,n);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const f=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new UU(f),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=[150],r=[20,150];if(t=t===void 0?150:t,i.spot&&!this.inArray(t,n))throw new x1(this.id+" watchOrderBook spot market accepts limits of 150 only");if(!i.spot&&!this.inArray(t,r))throw new x1(this.id+" watchOrderBook swap market accepts limits of 20 and 150 only");let a;i.spot?a="market."+i.id+".mbp."+t.toString():a="market."+i.id+".depth.size_"+t.toString()+".high_freq";const o=this.getUrlByMarketType(i.type,i.linear);let d=this.handleOrderBookSubscription;return i.spot||(s.data_type="incremental",d=void 0),(await this.subscribePublic(o,e,a,d,s)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash");try{const r=this.orderbooks[i],a=this.safeValue(t,"data"),o=r.cache,d=this.safeValue(o,0,{}),c=this.parseOrderBook(a,i),u=this.safeValue(d,"tick"),h=this.safeInteger(u,"seqNum"),f=this.safeInteger(a,"seqNum");if(c.nonce=f,h!==void 0&&f<h){const l=this.safeInteger(this.options,"maxOrderBookSyncAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<l)n in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[n]=s,this.spawn(this.watchOrderBookSnapshot,e,t,s));else throw new FU(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+l.toString()+" attempts")}else{r.reset(c);for(let l=0;l<o.length;l++){const m=o[l];this.handleOrderBookMessage(e,m,r)}this.orderbooks[i]=r,e.resolve(r,n)}}catch(r){e.reject(r,n)}}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeInteger(s,"numAttempts",0),o=this.safeString(s,"messageHash"),d=this.market(i),c=this.getUrlByMarketType(d.type,d.linear),u=this.requestId(),h={req:o,id:u},f={id:u,messageHash:o,symbol:i,limit:n,params:r,numAttempts:a,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,f)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeValue(t,"tick",{}),d=this.safeInteger2(o,"seqNum","version"),c=this.safeInteger(o,"prevSeqNum"),u=this.safeString(o,"event"),h=this.safeInteger(t,"ts");if(u==="snapshot"){const f=this.parseOrderBook(o,a,h);s.reset(f),s.nonce=d}if((c===void 0||c<=s.nonce)&&d>s.nonce){const f=this.safeValue(o,"asks",[]),l=this.safeValue(o,"bids",[]);this.handleDeltas(s.asks,f),this.handleDeltas(s.bids,l),s.nonce=d,s.timestamp=h,s.datetime=this.iso8601(h)}return s}handleOrderBook(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(s,"event"),n=this.safeString(t,"ch"),a=this.safeValue(t,"ch").split("."),o=this.safeString(a,1),d=this.safeSymbol(o);let c=this.safeValue(this.orderbooks,d);if(c===void 0){const h=this.safeString(a,3).split("_"),f=this.safeInteger(h,1);c=this.orderBook({},f)}c.nonce===void 0&&c.cache.push(t),(i!==void 0||c.nonce!==void 0)&&(this.orderbooks[d]=this.handleOrderBookMessage(e,t,c),e.resolve(c,n))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.markets[i].spot===!0&&this.spawn(this.watchOrderBookSnapshot,e,t,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials();let n,r="*",a,o,d,c,u;if(e!==void 0?(await this.loadMarkets(),a=this.market(e),e=a.symbol,n=a.type,u=a.linear?"linear":"inverse",r=a.lowercaseId):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),u=this.safeString2(this.options,"subType","defaultSubType","linear"),u=this.safeString(i,"subType",u),i=this.omit(i,["type","subType"])),n==="spot"){let h;h===void 0&&(h=this.safeString2(this.options,"watchMyTrades","mode","0"),h=this.safeString(i,"mode",h),i=this.omit(i,"mode")),o="trade.clearing#"+r+"#"+h,d=o}else{const h=this.getOrderChannelAndMessageHash(n,u,a,i);d=this.safeString(h,0),o=this.safeString(h,1)+":trade"}return c=await this.subscribePrivate(d,o,n,u,i),this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}getOrderChannelAndMessageHash(e,t,s=void 0,i={}){let n,r,a=this.safeString(this.options,"orderType","orders");a=this.safeString(i,"orderType",a),i=this.omit(i,"orderType");const o=s!==void 0?s.lowercaseId:void 0,d=s!==void 0?s.lowercaseBaseId:void 0,c=a;if(n=c,t==="linear"){const h=this.safeString(i,"margin","cross")==="cross"?c+"_cross":c;n=h,o!==void 0?(n+="."+o,r=n):r=h+".*"}else e==="future"?d!==void 0?(r=c+"."+d,n=r):r=c+".*":o!==void 0?(r=c+"."+o,n=r):r=c+".*";return[r,n]}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a,o="*";e!==void 0?(a=this.market(e),e=a.symbol,n=a.type,o=a.lowercaseId,r=a.linear?"linear":"inverse"):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),r=this.safeString2(this.options,"subType","defaultSubType","linear"),r=this.safeString(i,"subType",r),i=this.omit(i,["type","subType"]));let d,c;if(n==="spot")d="orders#"+o,c=d;else{const h=this.getOrderChannelAndMessageHash(n,r,a,i);c=this.safeString(h,0),d=this.safeString(h,1)}const u=await this.subscribePrivate(c,d,n,r,i);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString2(t,"ch","topic"),i=this.safeValue(t,"data");let n=this.safeString(t,"contract_code");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n);let a;if(i!==void 0)if(this.safeString(i,"eventType")==="trade"){const u=this.parseOrderTrade(i,r);a={id:this.safeString(u,"order"),trades:[u],status:"closed",symbol:r.symbol}}else a=this.parseWsOrder(i,r);else{a=this.parseWsOrder(t,r);const c=this.safeValue(t,"trade",[]);if(c.length>0){const h={trades:c,ch:s,symbol:n},f={order:this.safeString(a,"id"),type:this.safeString(a,"type"),side:this.safeString(a,"side")};this.handleMyTrade(e,h,f)}}if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new M1(c)}this.orders.append(a),e.resolve(this.orders,s);let d=s.replace("."+r.lowercaseId,"");d=d.replace("."+r.lowercaseBaseId,""),e.resolve(this.orders,d)}parseWsOrder(e,t=void 0){const s=this.safeInteger2(e,"lastActTime","ts"),i=this.safeInteger(e,"orderCreateTime"),n=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(n,t);const r=this.safeSymbol(n,t),a=this.safeString2(e,"orderSize","volume"),o=this.parseOrderStatus(this.safeString2(e,"orderStatus","status")),d=this.safeString2(e,"orderId","order_id"),c=this.safeString2(e,"clientOrderId","client_order_id"),u=this.safeString2(e,"orderPrice","price"),h=this.safeString(e,"execAmt");let f=this.safeString(e,"type");const l=this.safeString(e,"fee");let m;if(l!==void 0){const v=this.safeString(e,"fee_asset");m={cost:l,currency:this.safeCurrencyCode(v)}}const g=this.safeString(e,"trade_avg_price"),y=this.safeValue(e,"trade");f!==void 0&&(f=f.split("-"));let w=this.safeStringLower(f,1);w===void 0&&(w=this.safeString(e,"order_price_type"));let b=this.safeStringLower(f,0);b===void 0&&(b=this.safeString(e,"direction"));const S=this.safeString(e,"orderValue");return this.safeOrder({info:e,id:d,clientOrderId:c,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,status:o,symbol:r,type:w,timeInForce:void 0,postOnly:void 0,side:b,price:u,amount:a,filled:h,remaining:void 0,cost:S,fee:m,average:g,trades:y},t)}parseOrderTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime");let d=this.safeString(e,"type"),c;if(d!==void 0){const f=d.split("-");c=f[0],d=f[1]}const u=this.safeValue(e,"aggressor");let h;return u!==void 0&&(h=u?"taker":"maker"),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:a,type:d,takerOrMaker:h,side:c,price:n,amount:r,cost:void 0,fee:void 0},t)}async watchBalance(e={}){let t=this.safeString2(this.options,"watchBalance","defaultType","spot");t=this.safeString(e,"type",t);let s=this.safeString2(this.options,"watchBalance","subType","linear");s=this.safeString(e,"subType",s),e=this.omit(e,["type","subType"]),e=this.omit(e,"type"),await this.loadMarkets();let i,n,r;if(t==="spot"){let o=this.safeString2(this.options,"watchBalance","mode","2");o=this.safeString(e,"mode",o),i="accounts.update#"+o,n=i}else{const o=this.safeString(e,"symbol"),d=this.safeString(e,"currency"),c=o!==void 0?this.market(o):void 0,u=d!==void 0?this.currency(d):void 0;r=this.safeString(e,"margin","cross"),e=this.omit(e,["currency","symbol","margin"]);let h="accounts";i=h,s==="linear"?(h=r==="cross"?h+"_cross":h,i=h,r==="isolated"?o!==void 0?(i+="."+c.id,n=i):n=h+".*":u!==void 0?(n=h+"."+u.id,i=n):n=h+".*"):t==="future"?u!==void 0?(i+="."+u.id,n=i):n=h+".*":c!==void 0?(i+="."+c.id,n=i):n=h+".*"}const a={type:t,subType:s,margin:r};return await this.subscribePrivate(n,i,t,s,e,a)}handleBalance(e,t){const s=this.safeString(t,"ch");if(s!==void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"balance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}else{const i=this.safeValue(t,"data",[]);if(i.length===0)return;const r=this.safeValue(i,0,{});let a=this.safeString(t,"topic"),o=this.safeValue2(e.subscriptions,a,a+".*");if(o===void 0){const u=this.safeString(r,"margin_asset");a+="."+u.toLowerCase(),o=this.safeValue(e.subscriptions,a)}const d=this.safeString(o,"type");if(this.safeString(o,"subType")==="linear")if(this.safeString(o,"margin")==="cross"){const h=d==="future"?"futures_contract_detail":"contract_detail",f=this.safeValue(r,h,[]);if(f.length>0)for(let m=0;m<f.length;m++){const g=f[m],y=this.safeString2(g,"contract_code","margin_account"),w=this.safeMarket(y),b=this.safeString(g,"margin_asset"),S=this.safeCurrency(b),v=this.safeString(w,"settle",S.code);if(v!==void 0){const T=this.account();T.free=this.safeString2(g,"margin_balance","margin_available"),T.used=this.safeString(g,"margin_frozen");const I={};I[v]=T;const A=w.symbol;this.balance[A]=this.safeBalance(I)}}}else for(let h=0;h<i.length;h++){const f=i[h],l=this.account();l.free=this.safeString(f,"margin_balance","margin_available"),l.used=this.safeString(f,"margin_frozen");const m=this.safeString2(f,"margin_asset","symbol"),g=this.safeCurrencyCode(m);this.balance[g]=l,this.balance=this.safeBalance(this.balance)}else for(let u=0;u<i.length;u++){const h=i[u],f=this.safeString(h,"symbol"),l=this.safeCurrencyCode(f),m=this.account();m.free=this.safeString(h,"margin_available"),m.used=this.safeString(h,"margin_frozen"),this.balance[l]=m,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,a)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeValue(t,"ch",""),i=s.split(".");if(this.safeString(i,0)==="market"){const d=this.safeString(i,2),c={depth:this.handleOrderBook,mbp:this.handleOrderBook,detail:this.handleTicker,bbo:this.handleTicker,ticker:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},u=this.safeValue(c,d);return u===void 0?t:u.call(this,e,t)}const r=s.split("#"),a=this.safeString(r,0,"");if(a==="trade.clearing"){this.handleMyTrade(e,t);return}if(a.indexOf("accounts.update")!==-1){this.handleBalance(e,t);return}if(a==="orders"){this.handleOrder(e,t);return}if(this.safeString(t,"op")==="notify"){const d=this.safeString(t,"topic","");d.indexOf("orders")!==-1&&this.handleOrder(e,t),d.indexOf("account")!==-1&&this.handleBalance(e,t)}}async pong(e,t){const s=this.safeInteger(t,"ping");if(s!==void 0){await e.send({pong:s});return}if(this.safeString(t,"action")==="ping"){const r=this.safeValue(t,"data"),a=this.safeInteger(r,"ts");await e.send({action:"pong",data:{ts:a}});return}if(this.safeString(t,"op")==="ping"){const r=this.safeInteger(t,"ts");await e.send({op:"pong",ts:r})}}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){return e.resolve(t,"auth"),t}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0){const o=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.ws.exact,o,this.json(t))}catch(d){const c=this.safeString(a,"messageHash");e.reject(d,c),e.reject(d,n),n in e.subscriptions&&delete e.subscriptions[n]}}return!1}const i=this.safeInteger(t,"code");if(i!==void 0&&i!==200){const n=this.id+" "+this.json(t);try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}catch(r){if(r instanceof C1){e.reject(r,"auth");const a="auth";return a in e.subscriptions&&delete e.subscriptions[a],!1}else e.reject(r)}}return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){if("id"in t){this.handleSubscriptionStatus(e,t);return}if("action"in t){const s=this.safeString(t,"action");if(s==="ping"){this.handlePing(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}}if("ch"in t)if(t.ch==="auth"){this.handleAuthenticate(e,t);return}else{this.handleSubject(e,t);return}if("op"in t){const s=this.safeString(t,"op");if(s==="ping"){this.handlePing(e,t);return}if(s==="auth"){this.handleAuthenticate(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}if(s==="notify"){this.handleSubject(e,t);return}}"ping"in t&&this.handlePing(e,t)}}handleMyTrade(e,t,s={}){if(this.myTrades===void 0){const r=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new M1(r)}const i=this.myTrades,n=this.safeString(t,"ch");if(n!==void 0){const r=this.safeValue(t,"data");if(r!==void 0){const a=this.parseWsTrade(r);this.safeString(a,"symbol")!==void 0&&(i.append(a),e.resolve(this.myTrades,n))}else{const a=this.safeValue(t,"trades",[]),o=this.safeValue(t,"symbol"),d=this.market(o);for(let f=0;f<a.length;f++){const l=a[f];let m=this.parseTrade(l,d);m=this.extend(m,s),i.append(m)}const c=n+":trade";e.resolve(this.myTrades,c);let u=n.replace("."+d.lowercaseId,"");u=u.replace("."+d.lowercaseBaseId,"");const h=u+":trade";e.resolve(this.myTrades,h)}}}parseWsTrade(e){const t=this.safeSymbol(this.safeString(e,"symbol")),s=this.safeString2(e,"side","orderSide"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime"),d=this.market(t);let c=this.safeString(e,"orderType");const u=this.safeValue(e,"aggressor");let h;u!==void 0&&(h=u?"taker":"maker");let f;c!==void 0&&(c=c.split("-"),f=this.safeString(c,1));let l;const m=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));return m!==void 0&&(l={cost:this.safeString(e,"transactFee"),currency:m}),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:t,id:i,order:a,type:f,takerOrMaker:h,side:s,price:n,amount:r,cost:void 0,fee:l},d)}getUrlByMarketType(e,t=!0,s=!1){const i=this.safeString(this.options,"api","api"),n={hostname:this.hostname};let r,a;if(e==="spot")s?r=this.urls.api.ws[i].spot.private:r=this.urls.api.ws[i].spot.public,a=this.implodeParams(r,n);else{const o=this.urls.api.ws[i][e],d=t?o.linear:o.inverse;a=s?d.private:d.public}return a}async subscribePublic(e,t,s,i=void 0,n={}){const r=this.requestId(),a={sub:s,id:r},o={id:r,messageHash:s,symbol:t,params:n};return i!==void 0&&(o.method=i),await this.watch(e,s,this.extend(a,n),s,o)}async subscribePrivate(e,t,s,i,n={},r={}){const a=this.nonce(),o={id:a,messageHash:t,params:n},d=this.extend(o,r);let c;s==="spot"?c={action:"sub",ch:e}:c={op:"sub",topic:e,cid:a};const u=i==="linear",h=this.getUrlByMarketType(s,u,!0),f=s==="spot"?this.urls.hostnames.spot:this.urls.hostnames.contract,l={type:s,url:h,hostname:f};return s==="spot"&&(this.options.ws.gunzip=!1),await this.authenticate(l),await this.watch(h,t,this.extend(c,n),e,d)}async authenticate(e={}){const t=this.safeString(e,"url"),s=this.safeString(e,"hostname"),i=this.safeString(e,"type");if(t===void 0||s===void 0||i===void 0)throw new HU(this.id+" authenticate requires a url, hostname and type argument");this.checkRequiredCredentials();const n="auth",r=t.replace("wss://"+s,""),a=this.client(t);let o=this.safeValue(a.subscriptions,n);if(o===void 0){o=a.future(n);const d=this.ymdhms(this.milliseconds(),"T");let c;i==="spot"?c={accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d}:c={AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d},c=this.keysort(c);const u=this.urlencode(c),h=["GET",s,r,u].join(`
`),f=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");let l;i==="spot"?l={params:{authType:"api",accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d,signature:f},action:"req",ch:n}:l={op:n,type:"api",AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d,Signature:f},await this.watch(t,n,l,n,o)}return await o}};const $U=MT,{ExchangeError:WU}=Q,{ArrayCache:zU,ArrayCacheByTimestamp:jU}=Pe;var KU=class extends $U{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:{api:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",ws:{gunzip:!0}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",n=this.safeString(this.options,"api","api"),r={hostname:this.hostname},a=this.implodeParams(this.urls.api.ws[n].public,r),o=this.requestId(),d={sub:i,id:o},c={id:o,messageHash:i,symbol:e,params:t};return await this.watch(a,i,this.extend(d,t),i,c)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.safeString(this.options,"api","api"),o={hostname:this.hostname},d=this.implodeParams(this.urls.api.ws[a].public,o),c=this.requestId(),u={sub:r,id:c},h={id:c,messageHash:r,symbol:e,params:i},f=await this.watch(d,r,this.extend(u,i),r,h);return this.newUpdates&&(s=f.getLimit(e,s)),this.filterBySinceLimit(f,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new zU(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.safeString(this.options,"api","api"),c={hostname:this.hostname},u=this.implodeParams(this.urls.api.ws[d].public,c),h=this.requestId(),f={sub:o,id:h},l={id:h,messageHash:o,symbol:e,timeframe:t,params:n},m=await this.watch(u,o,this.extend(f,n),o,l);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const f=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new jU(f),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==150)throw new WU(this.id+" watchOrderBook accepts limit = 150 only");await this.loadMarkets();const i=this.market(e);e=i.symbol,t=t===void 0?150:t;const n="market."+i.id+".mbp."+t.toString(),r=this.safeString(this.options,"api","api"),a={hostname:this.hostname},o=this.implodeParams(this.urls.api.ws[r].public,a),d=this.requestId(),c={sub:n,id:d},u={id:d,messageHash:n,symbol:e,limit:t,params:s,method:this.handleOrderBookSubscription};return(await this.watch(o,n,this.extend(c,s),n,u)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash"),r=this.orderbooks[i],a=this.safeValue(t,"data"),o=this.parseOrderBook(a,i);o.nonce=this.safeInteger(a,"seqNum"),r.reset(o);const d=r.cache;for(let c=0;c<d.length;c++){const u=d[c];this.handleOrderBookMessage(e,u,r)}this.orderbooks[i]=r,e.resolve(r,n)}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(s,"messageHash"),o=this.safeString(this.options,"api","api"),d={hostname:this.hostname},c=this.implodeParams(this.urls.api.ws[o].public,d),u=this.requestId(),h={req:a,id:u},f={id:u,messageHash:a,symbol:i,limit:n,params:r,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,f)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"tick",{}),n=this.safeInteger(i,"seqNum");if(this.safeInteger(i,"prevSeqNum")<=s.nonce&&n>s.nonce){const a=this.safeValue(i,"asks",[]),o=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,a),this.handleDeltas(s.bids,o),s.nonce=n;const d=this.safeInteger(t,"ts");s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleOrderBook(e,t){const s=this.safeString(t,"ch"),n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.orderbooks[a];o.nonce===void 0?o.cache.push(t):(this.handleOrderBookMessage(e,t,o),e.resolve(o,s))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.watchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const i=this.safeValue(t,"ch").split(".");if(this.safeString(i,0)==="market"){const r=this.safeString(i,2),a={mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},o=this.safeValue(a,r);return o===void 0?t:o.call(this,e,t)}}async pong(e,t){await e.send({pong:this.safeInteger(t,"ping")})}handlePing(e,t){this.spawn(this.pong,e,t)}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const i=this.safeString(t,"id"),n=this.indexBy(e.subscriptions,"id"),r=this.safeValue(n,i);if(r!==void 0){const a=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.exact,a,this.json(t))}catch(o){const d=this.safeString(r,"messageHash");e.reject(o,d),e.reject(o,i),i in e.subscriptions&&delete e.subscriptions[i]}}return!1}return t}handleMessage(e,t){this.handleErrorMessage(e,t)&&("id"in t?this.handleSubscriptionStatus(e,t):"ch"in t?this.handleSubject(e,t):"ping"in t&&this.handlePing(e,t))}};const XU=KT;var YU=class extends XU{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"huobipro"})}};const ZU=PT,{InvalidNonce:QU}=Q,{ArrayCache:JU,ArrayCacheByTimestamp:e$,ArrayCacheBySymbolById:P1}=Pe;var t$=class extends ZU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchOHLCV:!0,watchTicker:!0,watchTickers:!1,watchOrders:!0,watchTransactions:!0},urls:{test:{ws:"wss://websocket-matic.idex.io/v1"},api:{}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchOrderBookLimit:1e3,orderBookSubscriptions:{},token:void 0,fetchOrderBookSnapshotMaxAttempts:10,fetchOrderBookSnapshotMaxDelay:1e4}})}async subscribe(e,t,s=!0){const i=this.urls.test.ws,n={method:"subscribe",subscriptions:[e]};return await this.watch(i,t,n,t,s)}async subscribePrivate(e,t){const s=await this.authenticate(),i=this.urls.test.ws,n={method:"subscribe",token:s,subscriptions:[e]};return await this.watch(i,t,n,t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="tickers",n={name:i,markets:[s.id]},r=i+":"+s.id;return await this.subscribe(this.extend(n,t),r)}handleTicker(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=s+":"+n,o=this.safeInteger(i,"t"),d=this.safeFloat(i,"c"),c=this.safeFloat(i,"P");let u;c!==void 0&&d!==void 0&&(u=d*c);const h={symbol:r,timestamp:o,datetime:this.iso8601(o),high:this.safeFloat(i,"h"),low:this.safeFloat(i,"l"),bid:this.safeFloat(i,"b"),bidVolume:void 0,ask:this.safeFloat(i,"a"),askVolume:void 0,vwap:void 0,open:this.safeFloat(i,"o"),close:d,last:d,previousClose:void 0,change:u,percentage:c,average:void 0,baseVolume:this.safeFloat(i,"v"),quoteVolume:this.safeFloat(i,"q"),info:t};e.resolve(h,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a={name:r,markets:[n.id]},o=r+":"+n.id,d=await this.subscribe(a,o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=this.parseWsTrade(i);if(Object.keys(this.trades).length===0){const u=this.safeInteger(this.options,"tradesLimit");this.trades=new P1(u)}const c=this.trades;c.append(a),e.resolve(c,r)}parseWsTrade(e){const t=this.safeString(e,"m"),s=this.safeSymbol(t),i=this.safeString(e,"i"),n=this.safeFloat(e,"p"),r=this.safeFloat(e,"q"),a=this.safeFloat(e,"Q"),o=this.safeInteger(e,"t"),d=this.safeString(e,"s"),c={currency:this.safeString(e,"a"),cost:this.safeFloat(e,"f")},u=this.safeString(e,"l");return{info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:void 0,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:c}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=this.timeframes[t],d={name:a,markets:[r.id],interval:o},c=a+":"+r.id,u=await this.subscribe(d,c);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=[this.safeInteger(i,"s"),this.safeFloat(i,"o"),this.safeFloat(i,"h"),this.safeFloat(i,"l"),this.safeFloat(i,"c"),this.safeFloat(i,"v")],o=this.safeSymbol(n),d=this.safeString(i,"i"),c=this.findTimeframe(d);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let u=this.safeValue(this.ohlcvs[o],c);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new e$(h),this.ohlcvs[o][c]=u}u.append(a),e.resolve(u,r)}handleSubscribeMessage(e,t){const s=this.safeValue(t,"subscriptions");for(let i=0;i<s.length;i++){const n=s[i];if(this.safeString(n,"name")==="l2orderbook"){const a=this.safeValue(n,"markets");for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(this.options,"orderBookSubscriptions",{});if(!(d in c)){const u=this.safeSymbol(d);if(!(u in this.orderbooks)){const h=this.countedOrderBook({});h.cache=[],this.orderbooks[u]=h}this.spawn(this.fetchOrderBookSnapshot,e,u)}}break}}}async fetchOrderBookSnapshot(e,t,s={}){const i=this.orderbooks[t],n=this.market(t),r="l2orderbook:"+n.id,a=e.subscriptions[r];a.fetchingOrderBookSnapshot||(a.startTime=this.milliseconds()),a.fetchingOrderBookSnapshot=!0;const o=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxAttempts",10),d=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxDelay",1e4);try{const c=this.safeInteger(a,"limit",0),u=await this.fetchOrderBook(t,c),h=this.safeValue(i.cache,0),f=this.safeValue(h,"data"),l=this.safeInteger(f,"u"),m=i.cache.length,g=this.safeValue(i.cache,m-1),y=this.safeValue(g,"data"),w=this.safeInteger(y,"u");if(l!==void 0&&w!==void 0&&l<=u.nonce+1&&w>u.nonce){i.reset(u);for(let S=0;S<i.cache.length;S++){const v=i.cache[S],T=this.safeValue(v,"data");this.safeInteger(T,"u")>i.nonce&&this.handleOrderBookMessage(e,v,i)}a.fetchingOrderBookSnapshot=!1,e.resolve(i,r)}else{a.numAttempts=a.numAttempts+1;const S=this.milliseconds()-a.startTime,v=a.numAttempts<o,T=S<d;if(v&&T)this.delay(this.rateLimit,this.fetchOrderBookSnapshot,e,t);else{const I=v?" after "+d.toString()+" milliseconds":" in "+o.toString()+" attempts";throw new QU(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+t+I)}}}catch(c){a.fetchingOrderBookSnapshot=!1,e.reject(c,r)}}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="l2orderbook",r={name:n,markets:[i.id]},a=n+":"+i.id,o={fetchingOrderBookSnapshot:!1,numAttempts:0,startTime:void 0};return t===void 0?o.limit=1e3:o.limit=t,(await this.subscribe(r,a,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"m"),n=this.safeSymbol(i),r=this.orderbooks[n];r.nonce===void 0?r.cache.push(t):this.handleOrderBookMessage(e,t,r)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"type"),n=this.safeValue(t,"data"),r=this.safeString(n,"m"),a=i+":"+r,o=this.safeInteger(n,"u"),d=this.safeInteger(n,"t"),c=this.safeValue(n,"b"),u=this.safeValue(n,"a");this.handleDeltas(s.bids,c),this.handleDeltas(s.asks,u),s.nonce=o,s.timestamp=d,s.datetime=this.iso8601(d),e.resolve(s,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),n=this.safeInteger(t,2);e.store(s,i,n)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async authenticate(e={}){const t=this.seconds(),s=this.safeInteger(this.options,"lastAuthenticatedTime",0);if(t-s>900){const i={wallet:this.walletAddress,nonce:this.uuidv1()},n=await this.privateGetWsToken(this.extend(i,e));this.options.lastAuthenticatedTime=t,this.options.token=this.safeString(n,"token")}return this.options.token}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="orders",r={name:n};let a=n;if(e!==void 0){e=this.symbol(e);const d=this.marketId(e);r.markets=[d],a=n+":"+d}const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=this.safeInteger(i,"t"),o=this.safeValue(i,"F"),d=[];for(let x=0;x<o.length;x++)d.push(this.parseWsTrade(o[x]));const c=this.safeString(i,"i"),u=this.safeString(i,"s"),h=this.safeString(i,"o"),f=this.safeFloat(i,"q"),l=this.safeFloat(i,"z");let m;f!==void 0&&l!==void 0&&(m=f-l);const g=this.safeFloat(i,"v"),y=this.safeFloat(i,"price",g);let w;f!==void 0&&y!==void 0&&(w=f*y);const b=this.safeString(i,"X"),S=this.parseOrderStatus(b),v={currency:void 0,cost:void 0};let T;for(let x=0;x<d.length;x++)T=d[x],v.currency=T.fee.currency,v.cost=this.sum(v.cost,T.fee.cost);const I=this.safeInteger(T,"timestamp"),A={info:t,id:c,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:I,symbol:r,type:h,side:u,price:y,stopPrice:void 0,triggerPrice:void 0,amount:f,cost:w,average:g,filled:l,remaining:m,status:S,fee:v,trades:d};if(this.orders===void 0){const x=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new P1(x)}const N=this.orders;N.append(A);const B=s+":"+n;e.resolve(N,B),e.resolve(N,s)}async watchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="balances",r={name:n};let a=n;e!==void 0&&(a=n+":"+e);const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTransaction(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"a"),r=s+":"+n,a=this.safeCurrencyCode(n),o=this.safeString(i,"w"),d={info:t,id:void 0,currency:a,amount:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:"ok",type:void 0,updated:void 0,txid:void 0,timestamp:void 0,datetime:void 0,fee:void 0};if(!(a in this.transactions)){const u=this.safeInteger(this.options,"transactionsLimit",1e3);this.transactions[a]=new JU(u)}const c=this.transactions[a];c.append(d),e.resolve(c,r),e.resolve(c,s)}handleMessage(e,t){const s=this.safeString(t,"type"),i={tickers:this.handleTicker,trades:this.handleTrade,subscriptions:this.handleSubscribeMessage,candles:this.handleOHLCV,l2orderbook:this.handleOrderBook,balances:this.handleTransaction,orders:this.handleOrder};s in i&&i[s].call(this,e,t)}};const s$=AT,{BadSymbol:i$,BadRequest:n$,ExchangeError:r$,NotSupported:a$,InvalidNonce:o$}=Q,{ArrayCache:A1,ArrayCacheByTimestamp:d$,ArrayCacheBySymbolById:c$}=Pe,B1=ae;var u$=class extends s${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ws.kraken.com",private:"wss://ws-auth.kraken.com",beta:"wss://beta-ws.kraken.com"}}},versions:{ws:"0.2.0"},options:{tradesLimit:1e3,OHLCVLimit:1e3,ordersLimit:1e3,symbolsByOrderId:{},checksum:!0},exceptions:{ws:{exact:{"Event(s) not found":n$},broad:{"Currency pair not in ISO 4217-A3 format":i$}}}})}handleTicker(e,t,s){const i=t[3],r="ticker"+":"+i,o=this.safeValue(this.options.marketsByWsName,i).symbol,d=t[1],c=this.safeFloat(d.p,0);let u;const h=this.safeFloat(d.v,0);h!==void 0&&c!==void 0&&(u=h*c);const f=this.safeFloat(d.c,0),l=this.milliseconds(),m={symbol:o,timestamp:l,datetime:this.iso8601(l),high:this.safeFloat(d.h,0),low:this.safeFloat(d.l,0),bid:this.safeFloat(d.b,0),bidVolume:this.safeFloat(d.b,2),ask:this.safeFloat(d.a,0),askVolume:this.safeFloat(d.a,2),vwap:c,open:this.safeFloat(d.o,0),close:f,last:f,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:u,info:d};this.tickers[o]=m,e.resolve(m,r)}handleTrades(e,t,s){const i=this.safeString(t,3),r=this.safeString(t,2)+":"+i,a=this.safeValue(this.options.marketsByWsName,i),o=a.symbol;let d=this.safeValue(this.trades,o);if(d===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);d=new A1(h),this.trades[o]=d}const c=this.safeValue(t,1,[]),u=this.parseTrades(c,a);for(let h=0;h<u.length;h++)d.append(u[h]);e.resolve(d,r)}handleOHLCV(e,t,s){const i=this.safeValue(s,"subscription",{}),n=this.safeInteger(i,"interval"),r=this.safeString(i,"name"),a=this.safeString(t,3),d=this.safeValue(this.options.marketsByWsName,a).symbol,c=this.findTimeframe(n),u=this.parseTimeframe(c);if(c!==void 0){const h=this.safeValue(t,1),f=r+":"+c+":"+a;let l=this.safeFloat(h,1);l-=u;const m=[parseInt(l*1e3),this.safeFloat(h,2),this.safeFloat(h,3),this.safeFloat(h,4),this.safeFloat(h,5),this.safeFloat(h,7)];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let g=this.safeValue(this.ohlcvs[d],c);if(g===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new d$(y),this.ohlcvs[d][c]=g}g.append(m),e.resolve(g,f)}}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(i.info,"wsname"),r=e+":"+n,a=this.urls.api.ws.public,o=this.requestId(),d={event:"subscribe",reqid:o,pair:[n],subscription:{name:e}},c=this.deepExtend(d,s);return await this.watch(a,r,c,r)}async watchTicker(e,t={}){return await this.watchPublic("ticker",e,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="trade",r=await this.watchPublic(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="book",n={};if(t!==void 0)if(t===10||t===25||t===100||t===500||t===1e3)n.subscription={depth:t};else throw new a$(this.id+" watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only");return(await this.watchPublic(i,e,this.extend(n,s))).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r="ohlc",a=this.market(e);e=a.symbol;const o=this.safeValue(a.info,"wsname"),d=r+":"+t+":"+o,c=this.urls.api.ws.public,u=this.requestId(),h={event:"subscribe",reqid:u,pair:[o],subscription:{name:r,interval:this.timeframes[t]}},f=this.deepExtend(h,n),l=await this.watch(c,d,f,d);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByWsName");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r];if(a.darkpool){const o=this.safeValue(a,"info",{}),d=this.safeString(o,"altname"),c=d.slice(0,3)+"/"+d.slice(3);i[c]=a}else{const o=this.safeValue(a,"info",{}),d=this.safeString(o,"wsname");i[d]=a}}this.options.marketsByWsName=i}return s}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws.public;return await this.watch(s,t)}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleOrderBook(e,t,s){const i=t.length,n=t[i-1],a=t[i-2].split("-"),o=this.safeInteger(a,1,10),c=this.safeValue(this.options.marketsByWsName,n).symbol;let u;const h="book:"+n;if("as"in t[1]){this.orderbooks[c]=this.orderBook({},o);const f=this.orderbooks[c],l={as:"asks",bs:"bids"},m=Object.keys(l);for(let g=0;g<m.length;g++){const y=m[g],w=l[y],b=f[w],S=this.safeValue(t[1],y,[]);u=this.handleDeltas(b,S,u)}f.symbol=c,f.timestamp=u,f.datetime=this.iso8601(u),e.resolve(f,h)}else{const f=this.orderbooks[c];let l,m,g;i===5?(l=this.safeValue(t[1],"a",[]),m=this.safeValue(t[2],"b",[]),g=this.safeInteger(t[1],"c"),g=this.safeInteger(t[2],"c",g)):(g=this.safeInteger(t[1],"c"),"a"in t[1]?l=this.safeValue(t[1],"a",[]):m=this.safeValue(t[1],"b",[]));const y=f.asks,w=f.bids;let b;if(l!==void 0&&(u=this.handleDeltas(y,l,u),b=this.safeValue(l,0)),m!==void 0&&(u=this.handleDeltas(w,m,u),b=this.safeValue(m,0)),f.limit(),this.safeValue(this.options,"checksum",!0)){const v=this.safeString(b,0),T=this.safeString(b,1),I=v.split("."),A=T.split("."),N=I[1].length-0,B=A[1].length-0,x=[];if(g!==void 0){for(let P=0;P<10;P++){const q=this.formatNumber(y[P][0],N)+this.formatNumber(y[P][1],B);x.push(q)}for(let P=0;P<10;P++){const q=this.formatNumber(w[P][0],N)+this.formatNumber(w[P][1],B);x.push(q)}}const k=x.join("");if(this.crc32(k,!1)!==g){const P=new o$(this.id+" invalid checksum");e.reject(P,h)}}f.symbol=c,f.timestamp=u,f.datetime=this.iso8601(u),e.resolve(f,h)}}formatNumber(e,t){const i=this.numberToString(e).split("."),n=this.safeString(i,0),a=this.safeString(i,1,"").padEnd(t,"0"),o=n+a;let d=0;for(;o[d]==="0";)d+=1;return d>0?o.slice(d):o}handleDeltas(e,t,s){for(let i=0;i<t.length;i++){const n=t[i],r=parseFloat(n[0]),a=parseFloat(n[1]);s=Math.max(s||0,parseInt(parseFloat(n[2])*1e3)),e.store(r,a)}return s}handleSystemStatus(e,t){return t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=await this.privatePostGetWebSocketsToken(e);n=this.safeValue(r,"result"),s.subscriptions[i]=n}return this.safeString(n,"token")}async watchPrivate(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.authenticate(),a=e;let o=e;t!==void 0&&(t=this.symbol(t),o+=":"+t);const d=this.urls.api.ws.private,c=this.requestId(),u={event:"subscribe",reqid:c,subscription:{name:e,token:r}},h=this.deepExtend(u,n),f=await this.watch(d,o,h,a);return this.newUpdates&&(i=f.getLimit(t,i)),this.filterBySymbolSinceLimit(f,t,s,i,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("ownTrades",e,t,s,i)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new A1(c)}const r=this.myTrades,a={};for(let c=0;c<i.length;c++){const u=this.safeValue(i,c,{}),h=Object.keys(u);for(let f=0;f<h.length;f++){const l=h[f],m=u[l],g=this.parseWsTrade(this.extend({id:l},m));r.append(g);const y=g.symbol;a[y]=!0}}const o="ownTrades";e.resolve(this.myTrades,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=o+":"+d[c];e.resolve(this.myTrades,u)}}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeValue(this.options.marketsByWsName,s,t);let i;const n=this.safeString(e,"ordertxid"),r=this.safeString2(e,"id","postxid"),a=this.safeTimestamp(e,"time"),o=this.safeString(e,"type"),d=this.safeString(e,"ordertype"),c=this.safeFloat(e,"price"),u=this.safeFloat(e,"vol");let h,f;if("fee"in e){let l;t!==void 0&&(l=t.quote),f={cost:this.safeFloat(e,"fee"),currency:l}}return t!==void 0&&(i=t.symbol),c!==void 0&&u!==void 0&&(h=c*u),{id:r,order:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:d,side:o,takerOrMaker:void 0,price:c,amount:u,cost:h,fee:f}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("openOrders",e,t,s,i)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new c$(r));const a=this.orders,o={};for(let u=0;u<i.length;u++){const h=this.safeValue(i,u,{}),f=Object.keys(h);for(let l=0;l<f.length;l++){const m=f[l],g=h[m],y=this.parseWsOrder(g);y.id=m;let w;const b=this.safeValue(this.options,"symbolsByOrderId",{});y.symbol!==void 0?(w=y.symbol,b[m]=w,this.options.symbolsByOrderId=b):w=this.safeString(b,m);const S=this.safeValue(a.hashmap,w),v=this.safeValue(S,m);let T=y;if(v!==void 0){const A=this.extend(v.info,T.info);T=this.parseWsOrder(A),T.id=m}if(a.length===r&&v===void 0){const A=a[0];A.id in b&&delete b[A.id]}a.append(T),o[w]=!0}}const d="openOrders";e.resolve(this.orders,d);const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=d+":"+c[u];e.resolve(this.orders,h)}}}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d;if(i!==void 0){const T=i.split(" ");n=this.safeString(T,0),d=this.safeString(T,1),a=this.safeString(T,2),r=this.safeString(T,4),o=this.safeString(T,5)}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a),t=this.safeValue(this.options.marketsByWsName,a,t);let c;const u=this.safeTimestamp(e,"opentm");d=this.safeString(e,"vol",d);const h=this.safeString(e,"vol_exec");let f;const l=this.safeString(e,"cost");o=this.safeString(s,"price",o),(o===void 0||B1.stringEq(o,"0.0"))&&(o=this.safeString(s,"price2")),(o===void 0||B1.stringEq(o,"0.0"))&&(o=this.safeString(e,"price",o));const m=this.safeString2(e,"avg_price","price");if(t!==void 0&&(c=t.symbol,"fee"in e)){const T=e.oflags;f={cost:this.safeString(e,"fee"),rate:void 0},T.indexOf("fciq")>=0?f.currency=t.quote:T.indexOf("fcib")>=0&&(f.currency=t.base)}const g=this.parseOrderStatus(this.safeString(e,"status"));let y=this.safeString(e,"id");if(y===void 0){const T=this.safeValue(e,"txid");y=this.safeString(T,0)}const w=this.safeString(e,"userref"),b=this.safeValue(e,"trades");let S;b!==void 0&&(S=this.parseTrades(b,t,void 0,void 0,{order:y}));const v=this.safeNumber(e,"stopprice");return this.safeOrder({id:y,clientOrderId:w,info:e,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,status:g,symbol:c,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:v,triggerPrice:v,cost:l,amount:d,filled:h,average:m,remaining:void 0,fee:f,trades:S})}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channelID");s!==void 0&&(e.subscriptions[s]=t)}handleErrorMessage(e,t){const s=this.safeValue(t,"errorMessage");if(s!==void 0){const i=this.safeValue(t,"reqid");if(i!==void 0){const n=this.exceptions.ws.broad,r=this.findBroadlyMatchedKey(n,s);let a;return r===void 0?a=new r$(s):a=new n[r](s),e.reject(a,i),!1}}return!0}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0),i=this.safeValue(e.subscriptions,s,{}),n=this.safeValue(i,"subscription",{}),r=t.length,a=this.safeString(t,r-2),o=this.safeString(n,"name"),d={book:this.handleOrderBook,ohlc:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,openOrders:this.handleOrders,ownTrades:this.handleMyTrades},c=this.safeValue2(d,o,a);return c===void 0?t:c.call(this,e,t,i)}else if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"event"),i={heartbeat:this.handleHeartbeat,systemStatus:this.handleSystemStatus,subscriptionStatus:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const h$=mg,{ExchangeError:f$}=Q,{ArrayCache:l$,ArrayCacheByTimestamp:p$,ArrayCacheBySymbolById:N1}=Pe;var m$=class extends h${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchMyTrades:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},options:{tradesLimit:1e3,watchTicker:{name:"market/snapshot"},watchOrderBook:{snapshotDelay:5}},streaming:{ping:this.ping}})}negotiate(e,t={}){const s=e?"private":"public",i=this.safeValue(this.options,"urls",{});return s in i||(i[s]=this.spawn(this.negotiateHelper,e,t),this.options.urls=i),i[s]}async negotiateHelper(e,t={}){let s;const i=e?"private":"public";e?s=await this.privatePostBulletPrivate(t):s=await this.publicPostBulletPublic(t);const n=this.safeValue(s,"data",{}),r=this.safeValue(n,"instanceServers",[]),a=this.safeValue(r,0),o=this.safeInteger(a,"pingInterval"),d=this.safeString(a,"endpoint"),c=this.safeString(n,"token"),u=d+"?"+this.urlencode({token:c,privateChannel:e,connectId:i}),h=this.client(u);return h.keepAlive=o,u}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i,n={}){const r=this.requestId().toString(),a={id:r,type:"subscribe",topic:s,response:!0},o=this.extend(a,n),d={id:r};return i===void 0?i=d:i=this.extend(d,i),await this.watch(e,t,o,s,i)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=await this.negotiate(!1),[n,r]=this.handleOptionAndParams(t,"watchTicker","method","/market/snapshot"),a=n+":"+s.id,o="ticker:"+e;return await this.subscribe(i,o,a,void 0,r)}handleTicker(e,t){const s=this.safeString(t,"topic");let i;if(s!==void 0){const c=s.split(":"),u=this.safeString(c,1);i=this.safeMarket(u,i,"-")}const n=this.safeValue(t,"data",{}),r=this.safeValue(n,"data",n),a=this.parseTicker(r,i),o=a.symbol;this.tickers[o]=a;const d="ticker:"+o;e.resolve(a,d)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.negotiate(!1),a=this.market(e);e=a.symbol;const o=this.timeframes[t],d="/market/candles:"+a.id+"_"+o,c="candles:"+e+":"+t,u=await this.subscribe(r,c,d,void 0,n);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"symbol"),n=this.safeValue(s,"candles",[]),a=this.safeString(t,"topic").split("_"),o=this.safeString(a,1),d=this.findTimeframe(o),c=this.safeMarket(i),u=c.symbol,h="candles:"+u+":"+d;this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});let f=this.safeValue(this.ohlcvs[u],d);if(f===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);f=new p$(m),this.ohlcvs[u][d]=f}const l=this.parseOHLCV(n,c);f.append(l),e.resolve(f,h)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(!1),r=this.market(e);e=r.symbol;const a="/market/match:"+r.id,o="trades:"+e,d=await this.subscribe(n,o,a,void 0,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),n=i.symbol,r="trades:"+n;let a=this.safeValue(this.trades,n);if(a===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);a=new l$(o),this.trades[n]=a}a.append(i),e.resolve(a,r)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==20&&t!==100)throw new f$(this.id+" watchOrderBook 'limit' argument must be undefined, 20 or 100");await this.loadMarkets();const i=await this.negotiate(!1),n=this.market(e);e=n.symbol;const r="/market/level2:"+n.id,a="orderbook:"+e,o={method:this.handleOrderBookSubscription,symbol:e,limit:t};return(await this.subscribe(i,a,r,o,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"symbol"),n=this.safeSymbol(i,void 0,"-"),r="orderbook:"+n,a=this.orderbooks[n],o=this.safeInteger(a,"nonce"),d=this.safeInteger(s,"sequenceEnd");if(o===void 0){const c=a.cache.length,u=this.safeString(t,"topic"),h=e.subscriptions[u],f=this.safeInteger(h,"limit"),l=this.handleOption("watchOrderBook","snapshotDelay",5);c===l&&this.spawn(this.loadOrderBook,e,r,n,f),a.cache.push(s);return}else if(o>=d)return;this.handleDelta(a,s),e.resolve(a,r)}getCacheIndex(e,t){const s=this.safeValue(t,0),i=this.safeInteger(e,"nonce"),n=this.safeInteger(s,"sequenceStart");if(i<n-1)return-1;for(let r=0;r<t.length;r++){const a=t[r],o=this.safeInteger(a,"sequenceStart"),d=this.safeInteger(a,"sequenceEnd");if(i>=o-1&&i<d)return r}return t.length}handleDelta(e,t){e.nonce=this.safeInteger(t,"sequenceEnd");const s=this.safeInteger(t,"time");e.timestamp=s,e.datetime=this.iso8601(s);const i=this.safeValue(t,"changes"),n=this.safeValue(i,"bids",[]),r=this.safeValue(i,"asks",[]),a=e.bids,o=e.asks;this.handleBidAsks(a,n),this.handleBidAsks(o,r)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=this.parseBidAsk(t[s]);e.storeArray(i)}}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},n)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(!0),r="/spotMarket/tradeOrders",a={privateChannel:!0};let o="orders";e!==void 0&&(e=this.market(e).symbol,o=o+":"+e);const d=await this.subscribe(n,o,r,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrderStatus(e){const t={open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),n=this.safeStringLower(e,"orderType"),r=this.safeString(e,"price"),a=this.safeString(e,"filledSize"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.parseWsOrderStatus(d),u=this.safeIntegerProduct(e,"orderTime",1e-6),h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const f=t.symbol,l=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:f,id:s,clientOrderId:i,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,type:n,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:c,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data"),n=this.parseWsOrder(i),r=this.safeString(n,"symbol"),a=this.safeString(n,"id");if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new N1(h)}const o=this.orders,d=this.safeValue(o.hashmap,r,{}),c=this.safeValue(d,a);if(c!==void 0){const h=this.safeValue(c,"stopPrice");h!==void 0&&(n.stopPrice=h),c.status==="closed"&&(n.status="closed")}o.append(n),e.resolve(this.orders,s);const u=s+":"+r;e.resolve(this.orders,u)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(!0),r="/spot/tradeFills",a={privateChannel:!0};let o="myTrades";if(e!==void 0){const c=this.market(e);e=c.symbol,o=o+":"+c.symbol}const d=await this.subscribe(n,o,r,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s)}handleMyTrade(e,t){let s=this.myTrades;if(s===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);s=new N1(o)}const i=this.safeValue(t,"data"),n=this.parseWsTrade(i);s.append(n);const r="myTrades";e.resolve(s,r);const a=r+":"+n.symbol;e.resolve(s,a)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"orderType"),r=this.safeString(e,"side"),a=this.safeString(e,"tradeId"),o=this.safeString(e,"price"),d=this.safeString(e,"size"),c=this.safeString(e,"orderId"),u=this.safeIntegerProduct(e,"time",1e-6),h=t.quote,f=this.safeString(e,"feeRate"),m={cost:this.safeString(e,"fee"),rate:f,currency:h};return this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:i,id:a,order:c,type:n,takerOrMaker:void 0,side:r,price:o,amount:d,cost:void 0,fee:m},t)}async watchBalance(e={}){await this.loadMarkets();const t=await this.negotiate(!0),s="/account/balance",i={privateChannel:!0},n="balance";return await this.subscribe(t,n,s,void 0,this.extend(i,e))}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i="balance",n=this.safeString(s,"currency"),r=this.safeString(s,"relationEvent");let a;if(r!==void 0){const f=r.split(".");a=this.safeString(f,0)}const o=this.safeString2(this.options,"watchBalance","defaultType","trade"),d=this.safeValue(this.options,"accountsByType"),c=this.safeString(d,a,"trade");c in this.balance||(this.balance[c]={});const u=this.safeCurrencyCode(n),h=this.account();h.free=this.safeString(s,"available"),h.used=this.safeString(s,"hold"),h.total=this.safeString(s,"total"),this.balance[c][u]=h,this.balance[c]=this.safeBalance(this.balance[c]),c===o&&e.resolve(this.balance[c],i)}handleSubject(e,t){const s=this.safeString(t,"subject"),i={"trade.l2update":this.handleOrderBook,"trade.ticker":this.handleTicker,"trade.snapshot":this.handleTicker,"trade.l3match":this.handleTrade,"trade.candles.update":this.handleOHLCV,"account.balance":this.handleBalance,"/spot/tradeFills":this.handleMyTrade,orderChange:this.handleOrder},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){e.lastPong=this.milliseconds()}handleErrorMessage(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t)}};const g$=BT,{ExchangeError:y$}=Q,{ArrayCache:w$,ArrayCacheBySymbolById:b$}=Pe;var k$=class extends g${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTrades:!0,watchOrderBook:!0,watchOrders:!0,watchBalance:!0},options:{accountsByType:{swap:"future",cross:"margin"},tradesLimit:1e3,watchOrderBook:{snapshotDelay:20},watchTicker:{name:"contractMarket/tickerV2"}},streaming:{ping:this.ping}})}negotiate(e,t={}){const s=e?"private":"public",i=this.safeValue(this.options,"urls",{});return s in i||(i[s]=this.spawn(this.negotiateHelper,e,t),this.options.urls=i),i[s]}async negotiateHelper(e,t={}){let s;const i=e?"private":"public";e?s=await this.futuresPrivatePostBulletPrivate(t):s=await this.futuresPublicPostBulletPublic(t);const n=this.safeValue(s,"data",{}),r=this.safeValue(n,"instanceServers",[]),a=this.safeValue(r,0),o=this.safeInteger(a,"pingInterval"),d=this.safeString(a,"endpoint"),c=this.safeString(n,"token"),u=d+"?"+this.urlencode({token:c,privateChannel:e,connectId:i}),h=this.client(u);return h.keepAlive=o,u}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i,n={}){const r=this.requestId().toString(),a={id:r,type:"subscribe",topic:s,response:!0},o=this.extend(a,n),d={id:r};return i===void 0?i=d:i=this.extend(d,i),await this.watch(e,t,o,s,i)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=await this.negotiate(!1),n=this.safeValue(this.options,"watchTicker",{}),r=this.safeString(n,"name","contractMarket/tickerV2"),a="/"+r+":"+s.id,o="ticker:"+e;return await this.subscribe(i,o,a,void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbol"),n=this.safeMarket(i,void 0,"-"),r=this.parseTicker(s,n);this.tickers[n.symbol]=r;const a="ticker:"+n.symbol;return e.resolve(r,a),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(!1),r=this.market(e);e=r.symbol;const a="/contractMarket/execution:"+r.id,o="trades:"+e,d=await this.subscribe(n,o,a,void 0,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),n=i.symbol;let r=this.safeValue(this.trades,n);if(r===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);r=new w$(o),this.trades[n]=r}r.append(i);const a="trades:"+n;return e.resolve(r,a),t}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==20&&t!==100)throw new y$(this.id+" watchOrderBook 'limit' argument must be undefined, 20 or 100");await this.loadMarkets();const i=await this.negotiate(!1),n=this.market(e);e=n.symbol;const r="/contractMarket/level2:"+n.id,a="orderbook:"+e,o={method:this.handleOrderBookSubscription,symbol:e,limit:t};return(await this.subscribe(i,a,r,o,s)).limit()}handleDelta(e,t){e.nonce=this.safeInteger(t,"sequence");const s=this.safeInteger(t,"timestamp");e.timestamp=s,e.datetime=this.iso8601(s);const n=this.safeValue(t,"change",{}).split(","),r=this.safeNumber(n,0),a=this.safeString(n,1),o=this.safeNumber(n,2),d=a==="buy"?"bids":"asks",c=[r,o];d==="bids"?e.bids.storeArray(c):e.asks.storeArray(c)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data"),n=this.safeString(t,"topic").split(":"),r=this.safeString(n,1),a=this.safeSymbol(r,void 0,"-"),o="orderbook:"+a,d=this.orderbooks[a],c=this.safeInteger(d,"nonce"),u=this.safeInteger(s,"sequence");if(c===void 0){const h=d.cache.length,f=this.safeString(t,"topic"),l=e.subscriptions[f],m=this.safeInteger(l,"limit"),g=this.handleOption("watchOrderBook","snapshotDelay",5);h===g&&this.spawn(this.loadOrderBook,e,o,a,m),d.cache.push(s);return}else if(c>=u)return;this.handleDelta(d,s),e.resolve(d,o)}getCacheIndex(e,t){const s=this.safeValue(t,0),i=this.safeInteger(e,"nonce"),n=this.safeInteger(s,"sequence");if(i<n-1)return-1;for(let r=0;r<t.length;r++){const a=t[r],o=this.safeInteger(a,"sequence");if(i<o-1)return r}return t.length}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},n)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(!0),r="/contractMarket/tradeOrders",a={privateChannel:!0};let o="orders";e!==void 0&&(e=this.market(e).symbol,o=o+":"+e);const d=await this.subscribe(n,o,r,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrderStatus(e){const t={open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),n=this.safeStringLower(e,"orderType"),r=this.safeString(e,"price"),a=this.safeString(e,"filledSize"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.parseWsOrderStatus(d),u=this.safeIntegerProduct(e,"orderTime",1e-6),h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const f=t.symbol,l=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:f,id:s,clientOrderId:i,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,type:n,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:c,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data"),n=this.parseWsOrder(i),r=this.safeString(n,"symbol"),a=this.safeString(n,"id");if(r!==void 0){if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new b$(h)}const o=this.orders,d=this.safeValue(o.hashmap,r,{}),c=this.safeValue(d,a);if(c!==void 0){const h=this.safeValue(c,"stopPrice");h!==void 0&&(n.stopPrice=h),c.status==="closed"&&(n.status="closed")}o.append(n),e.resolve(this.orders,s);const u=s+":"+r;e.resolve(this.orders,u)}}async watchBalance(e={}){const t=await this.negotiate(!0),s="/contractAccount/wallet",i={privateChannel:!0},n={method:this.handleBalanceSubscription},r="balance";return await this.subscribe(t,r,s,n,this.extend(i,e))}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"availableBalance"),r.used=this.safeString(s,"holdBalance"),this.balance[n]=r,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}handleBalanceSubscription(e,t,s){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets(),this.checkRequiredCredentials();const s="balance",n={type:this.safeString2(this.options,"watchBalance","defaultType","swap")},r=await this.fetchBalance(n),a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o];d!=="free"&&d!=="used"&&d!=="total"&&d!=="timestamp"&&d!=="datetime"&&d!=="info"&&(this.balance[d]=r[d])}e.resolve(this.balance,s)}handleSubject(e,t){const s=this.safeString(t,"subject"),i={level2:this.handleOrderBook,tickerV2:this.handleTicker,"availableBalance.change":this.handleBalance,match:this.handleTrade,orderChange:this.handleOrder,orderUpdated:this.handleOrder},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const S$=NT,{ArrayCache:v$}=Pe;var T$=class extends S${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:void 0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://ws.luno.com/api/1"}},options:{sequenceNumbers:{}},streaming:{},exceptions:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.checkRequiredCredentials(),await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="/stream/"+n.id,a={symbol:e},o=this.urls.api.ws+r,d="trades:"+e,c={api_key_id:this.apiKey,api_key_secret:this.secret},u=this.deepExtend(c,i),h=await this.watch(o,d,u,r,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"trade_updates",[]);if(i.length===0)return;const r=s.symbol,a=this.market(r),o="trades:"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new v$(c),this.trades[r]=d}for(let c=0;c<i.length;c++){const u=i[c],h=this.parseTrade(u,a);d.append(h)}this.trades[r]=d,e.resolve(this.trades[r],o)}parseTrade(e,t){return this.safeTrade({info:e,id:void 0,timestamp:void 0,datetime:void 0,symbol:t.symbol,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:void 0,amount:this.safeString(e,"base"),cost:this.safeString(e,"counter"),fee:void 0},t)}async watchOrderBook(e,t=void 0,s={}){await this.checkRequiredCredentials(),await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="/stream/"+i.id,r={symbol:e},a=this.urls.api.ws+n,o="orderbook:"+e,d={api_key_id:this.apiKey,api_key_secret:this.secret},c=this.deepExtend(d,s);return(await this.watch(a,o,c,n,r)).limit(t)}handleOrderBook(e,t,s){const i=s.symbol,n="orderbook:"+i,r=this.safeString(t,"timestamp");let a=this.safeValue(this.orderbooks,i);if(a===void 0&&(a=this.indexedOrderBook({}),this.orderbooks[i]=a),this.safeValue(t,"asks")!==void 0){const c=this.parseOrderBook(t,i,r,"bids","asks","price","volume","id");a.reset(c)}else this.handleDelta(a,t),a.timestamp=r,a.datetime=this.iso8601(r);const d=this.safeInteger(t,"sequence");a.nonce=d,e.resolve(a,n)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d=this.parseBidsAsks(this.safeValue(e,i,[]),r,a,o),c=this.parseBidsAsks(this.safeValue(e,n,[]),r,a,o);return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(c,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseBidsAsks(e,t=0,s=1,i=void 0){e=this.toArray(e);const n=[];for(let r=0;r<e.length;r++)n.push(this.parseBidAsk(e[r],t,s,i));return n}parseBidAsk(e,t=0,s=1,i=void 0){const n=this.safeNumber(e,t),r=this.safeNumber(e,s),a=[n,r];if(i!==void 0){const o=this.safeString(e,i);a.push(o)}return a}handleDelta(e,t){const s=this.safeValue(t,"create_update"),i=e.asks,n=e.bids;if(s!==void 0){const a=this.parseBidAsk(s,"price","volume","order_id"),o=this.safeString(s,"type");o==="ASK"?i.storeArray(a):o==="BID"&&n.storeArray(a)}const r=this.safeValue(t,"delete_update");if(r!==void 0){const a=this.safeString(r,"order_id");i.storeArray(0,0,a),n.storeArray(0,0,a)}return t}handleMessage(e,t){if(t==="")return;const s=Object.values(e.subscriptions),i=[this.handleOrderBook,this.handleTrades];for(let n=0;n<i.length;n++)i[n].call(this,e,t,s[0]);return t}};const O$=VT,{AuthenticationError:V1,BadSymbol:I$,BadRequest:x$,NotSupported:Zp}=Q,{ArrayCache:_$,ArrayCacheBySymbolById:E1,ArrayCacheByTimestamp:C$}=Pe;var M$=class extends O${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{spot:"wss://wbs.mexc.com/raw/ws",swap:"wss://contract.mexc.com/ws"}}},options:{timeframes:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},streaming:{ping:this.ping,keepAlive:1e4},exceptions:{ws:{exact:{"signature validation failed":V1},broad:{"Contract not exists":I$}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="sub.ticker",n="ticker:"+e,r={symbol:s.id};if(s.type==="spot")throw new Zp(this.id+" watchTicker does not support spot markets");return await this.watchSwapPublic(n,i,r,t)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const o="ticker:"+r;return e.resolve(a,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={};e=r.symbol;const o=r.type,d=this.safeValue(this.options,"timeframes",{}),c=this.safeString(d,t),u="sub.kline",h="kline:"+c+":"+e;a.symbol=r.id,a.interval=c,s!==void 0&&(a.start=s);let f;return o==="spot"?f=await this.watchSpotPublic(h,u,a,n):f=await this.watchSwapPublic(h,u,a,n),this.newUpdates&&(i=f.getLimit(e,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data",{}),a=this.safeString(r,"interval"),o="kline:"+a+":"+n,d=this.safeValue(this.options,"timeframes",{}),c=this.findTimeframe(a,d),u=this.parseWsOHLCV(r,i);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let h=this.safeValue(this.ohlcvs[n],c);if(h===void 0){const f=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new C$(f),this.ohlcvs[n][c]=h}return h.append(u),e.resolve(h,o),t}parseWsOHLCV(e,t=void 0){return[this.safeIntegerProduct(e,"t",1e3),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber2(e,"v","q")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r={symbol:i.id};if(t!==void 0){if(t!==5&&t!==10&&t!==20)throw new x$(this.id+" watchOrderBook limit parameter cannot be different from 5, 10 or 20")}else t=20;let a;if(i.type==="swap"){const o="sub.depth";r.compress=!0,r.limit=t,a=await this.watchSwapPublic(n,o,r,s)}else{const o="sub.limit.depth";r.depth=t,a=await this.watchSpotPublic(n,o,r,s)}return a.limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data"),a=this.safeInteger(t,"ts"),o=this.parseOrderBook(r,n,a);let d=this.safeNumber(r,"end");d===void 0&&(d=this.safeNumber(t,"version")),o.nonce=d;let c=this.safeValue(this.orderbooks,n);c===void 0?(c=this.orderBook(o),this.orderbooks[n]=c):i.type==="spot"?c.reset(o):this.handleOrderBookMessage(e,t,c);const u="orderbook:"+n;e.resolve(c,u)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeNumber(i,"end"),r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a);const o=this.safeInteger(t,"ts"),d=this.safeString(t,"symbol"),c=this.safeSymbol(d);return s.nonce=n,s.symbol=c,s.timestamp=o,s.datetime=this.iso8601(o),s}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="sub.deal",a="trades:"+e,o={symbol:n.id};let d;return n.type==="spot"?d=await this.watchSpotPublic(a,r,o,i):d=await this.watchSwapPublic(a,r,o,i),this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol;let r=this.safeValue(this.trades,n);if(r===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);r=new _$(c),this.trades[n]=r}const a=this.safeValue(t,"data",{});let o;"deals"in a?o=this.safeValue(a,"deals",[]):o=[a];for(let c=0;c<o.length;c++){const u=this.parseWsTrade(o[c],i);r.append(u)}const d="trades:"+n;e.resolve(r,d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i);let o;if(a==="spot")throw new Zp(this.id+" watchMyTrades does not support spot markets");return o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrade(e,t,s=void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"symbol"),r=this.safeMarket(n),a=this.parseWsTrade(i,r);if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new E1(c)}const o=this.myTrades;o.append(a);let d="trade";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWsTrade(e,t=void 0){const s=this.safeInteger2(e,"timestamp","t"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"price","p");let a=this.safeString2(e,"vol","q");a===void 0&&(a=this.safeString(e,"v"));let o=this.safeString(e,"T"),d;o===void 0?(o=this.safeString(e,"side"),d=this.parseSwapSide(o)):d=o==="1"?"buy":"sell";let c=this.safeString(e,"id");c===void 0&&(c=s.toString()+"-"+t.id+"-"+a);const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"feeCurrency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const f=this.safeString(e,"orderId"),m=this.safeValue(e,"taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:f,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:void 0,fee:h},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);let o;return a==="spot"?o=await this.watchSpotPrivate(n,i):o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"data",{});let n=this.safeString(t,"symbol");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n),a=this.parseWSOrder(i,r);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new E1(c)}const o=this.orders;o.append(a);let d="order";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWSOrder(e,t=void 0){const s=this.safeString2(e,"orderId","id"),i=this.safeString2(e,"state","status"),n=this.safeInteger(e,"createTime"),r=this.safeString(e,"price"),a=this.safeString2(e,"quantity","vol"),o=this.safeString(e,"remainQuantity"),d=this.safeString(e,"dealVol"),c=this.safeString(e,"amount"),u=this.safeString(e,"dealAvgPrice"),h=this.safeString2(e,"symbol","symbolDisplay"),f=this.safeSymbol(h,t,"_"),l=this.safeString(e,"side");let m=this.parseSwapSide(l);if(m===void 0){const v=this.safeStringLower(e,"tradeType");v==="ask"||v==="2"?m="sell":v==="bid"||v==="1"?m="buy":m=v}const g=this.parseWsOrderStatus(i,t);let y=this.safeString2(e,"client_order_id","orderId");y===""&&(y=void 0);const w=this.safeString(e,"orderType"),S=w==="3"||w==="5"?"market":"limit";return this.safeOrder({id:s,clientOrderId:y,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:g,symbol:f,type:S,timeInForce:void 0,side:m,price:r,stopPrice:void 0,triggerPrice:void 0,average:u,amount:a,cost:c,filled:d,remaining:o,fee:void 0,trades:void 0,info:e},t)}parseSwapSide(e){const t={1:"open long",2:"close short",3:"open short",4:"close long"};return this.safeString(t,e)}parseWsOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={1:"open",2:"closed",3:"open",4:"canceled",5:"open",NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:s={2:"open",3:"closed",4:"canceled"},this.safeString(s,e,e)}async watchBalance(e={}){await this.loadMarkets();const t="balance";let s;if([s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),s==="spot")throw new Zp(this.id+" watchBalance does not support spot markets");return this.watchSwapPrivate(t,e)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"availableBalance"),r.used=this.safeString(s,"frozenBalance"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchSwapPublic(e,t,s,i={}){const n=this.urls.api.ws.swap,r={method:t,param:s},a=this.extend(r,i);return await this.watch(n,e,a,e)}async watchSpotPublic(e,t,s,i={}){const n=this.urls.api.ws.spot,r={op:t},a=this.extend(r,s),o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchSpotPrivate(e,t={}){this.checkRequiredCredentials();const s="sub.personal",i=this.urls.api.ws.spot,n=this.milliseconds().toString(),r={op:s,api_key:this.apiKey,req_time:n},a=this.keysort(r);a.api_secret=this.secret;const o=this.urlencode(a),d=this.hash(this.encode(o),"md5");r.sign=d;const c=this.extend(r,t);return await this.watch(i,e,c,s)}async watchSwapPrivate(e,t={}){this.checkRequiredCredentials();const s="login",i=this.urls.api.ws.swap,n=this.milliseconds().toString(),r=this.apiKey+n,a=this.hmac(this.encode(r),this.encode(this.secret),"sha256"),o={method:s,param:{apiKey:this.apiKey,signature:a,reqTime:n}},d=this.extend(o,t),c=this.extend(d,t);return await this.watch(i,e,c,s)}handleErrorMessage(e,t){const s=this.safeString(t,"channel");try{const i=this.id+" "+this.json(t);if(s.indexOf("error")>=0){const n=this.safeValue(t,"data");typeof n=="string"&&(this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i),this.throwBroadlyMatchedException(this.exceptions.ws.broad,n,i))}if(s==="sub.personal"){const n=this.safeString(t,"msg");this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i)}}catch(i){if(i instanceof V1)return!1}return t}handleAuthenticate(e,t){return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong"){this.handlePong(e,t);return}const s=this.safeString(t,"channel"),i={pong:this.handlePong,"rs.login":this.handleAuthenticate,"push.deal":this.handleTrades,orderbook:this.handleOrderBook,"push.kline":this.handleOHLCV,"push.ticker":this.handleTicker,"push.depth":this.handleOrderBook,"push.limit.depth":this.handleOrderBook,"push.personal.order":this.handleOrder,"push.personal.trigger.order":this.handleOrder,"push.personal.plan.order":this.handleOrder,"push.personal.order.deal":this.handleMyTrade,"push.personal.asset":this.handleBalance},n=this.safeValue(i,s);n!==void 0&&n.call(this,e,t)}ping(e){return this.safeString(this.options,"defaultType","spot")==="spot"?"ping":{method:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}};const P$=Ah,{ArrayCache:A$}=Pe;var XT=class extends P${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0},urls:{test:{ws:"wss://ndaxmarginstaging.cdnhop.net:10456/WSAdminGatewa/"},api:{ws:"wss://api.ndax.io/WSGateway"}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n="SubscribeLevel1",r=n+":"+i.id,a=this.urls.api.ws,o=this.requestId(),d={OMSId:s,InstrumentId:parseInt(i.id)},c={m:0,i:o,n,o:this.json(d)},u=this.extend(c,t);return await this.watch(a,r,u,r)}handleTicker(e,t){const s=this.safeValue(t,"o",{}),i=this.parseTicker(s),n=i.symbol,r=this.market(n);this.tickers[n]=i;const o="SubscribeLevel1"+":"+r.id;e.resolve(i,o)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="SubscribeTrades",o=a+":"+r.id,d=this.urls.api.ws,c=this.requestId(),u={OMSId:n,InstrumentId:parseInt(r.id),IncludeLastCount:100},h={m:0,i:c,n:a,o:this.json(u)},f=this.extend(h,i),l=await this.watch(d,o,f,o);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"o",[]),i="SubscribeTrades",n={};for(let a=0;a<s.length;a++){const o=this.parseTrade(s[a]),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new A$(u)}c.append(o),this.trades[d]=c,n[d]=!0}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.market(o),c=i+":"+d.id,u=this.safeValue(this.trades,o);e.resolve(u,c)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="SubscribeTicker",d=o+":"+t+":"+a.id,c=this.urls.api.ws,u=this.requestId(),h={OMSId:r,InstrumentId:parseInt(a.id),Interval:parseInt(this.timeframes[t]),IncludeLastCount:100},f={m:0,i:u,n:o,o:this.json(h)},l=this.extend(f,n),m=await this.watch(c,d,l,d);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"o",[]),i={};for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,8),u=this.safeMarket(d).symbol;i[d]={},this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});const h=Object.keys(this.timeframes);for(let f=0;f<h.length;f++){const l=h[f],m=this.timeframes[l],g=parseInt(m)*1e3,y=this.safeInteger(o,0),w=[parseInt(y/g)*g,this.safeFloat(o,3),this.safeFloat(o,1),this.safeFloat(o,2),this.safeFloat(o,4),this.safeFloat(o,5)],b=this.safeValue(this.ohlcvs[u],l,[]),S=b.length;if(S&&w[0]===b[S-1][0]){const v=b[S-1];b[S-1]=[w[0],v[1],Math.max(w[1],v[1]),Math.min(w[2],v[2]),w[4],this.sum(w[5],v[5])],i[d][l]=!0}else{if(S&&w[0]<b[S-1][0])continue;{b.push(w);const v=this.safeInteger(this.options,"OHLCVLimit",1e3);S>=v&&b.shift(),i[d][l]=!0}}this.ohlcvs[u][l]=b}}const n="SubscribeTicker",r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=Object.keys(i[o]);for(let c=0;c<d.length;c++){const u=d[c],h=n+":"+u+":"+o,l=this.safeMarket(o).symbol,m=this.safeValue(this.ohlcvs[l],u,[]);e.resolve(m,h)}}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="SubscribeLevel2",a=r+":"+n.id,o=this.urls.api.ws,d=this.requestId();t=t===void 0?100:t;const c={OMSId:i,InstrumentId:parseInt(n.id),Depth:t},u={m:0,i:d,n:r,o:this.json(c)},h={id:d,messageHash:a,name:r,symbol:e,marketId:n.id,method:this.handleOrderBookSubscription,limit:t,params:s},f=this.extend(u,s);return(await this.watch(o,a,f,a,h)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"o",[]),i=this.safeValue(s,0,[]),n=this.safeString(i,7);if(n===void 0)return t;const a=this.safeMarket(n).symbol,o=this.safeValue(this.orderbooks,a);if(o===void 0)return t;let d,c;for(let f=0;f<s.length;f++){const l=s[f];if(d===void 0)d=this.safeInteger(l,2);else{const S=this.safeInteger(l,2);d=Math.max(d,S)}if(c===void 0)c=this.safeInteger(l,0);else{const S=this.safeInteger(l,0);c=Math.max(c,S)}const m=this.safeInteger(l,3),g=this.safeFloat(l,6),y=this.safeFloat(l,8),b=this.safeInteger(l,9)===0?o.bids:o.asks;m===0||m===1?b.store(g,y):m===2&&b.store(g,0)}o.nonce=c,o.timestamp=d,o.datetime=this.iso8601(d);const h="SubscribeLevel2"+":"+n;this.orderbooks[a]=o,e.resolve(o,h)}handleOrderBookSubscription(e,t,s){const i=this.safeValue(t,"o",[]),n=this.safeString(s,"symbol"),r=this.parseOrderBook(i,n),a=this.safeInteger(s,"limit"),o=this.orderBook(r,a);this.orderbooks[n]=o;const d=this.safeString(s,"messageHash");e.resolve(o,d)}handleSubscriptionStatus(e,t){const s=this.indexBy(e.subscriptions,"id"),i=this.safeInteger(t,"i"),n=this.safeValue(s,i);if(n!==void 0){const r=this.safeValue(n,"method");return r===void 0?t:r.call(this,e,t,n)}}handleMessage(e,t){const s=this.safeString(t,"o");if(s===void 0)return t;t.o=JSON.parse(s);const i={SubscribeLevel2:this.handleSubscriptionStatus,SubscribeLevel1:this.handleTicker,Level2UpdateEvent:this.handleOrderBook,Level1UpdateEvent:this.handleTicker,SubscribeTrades:this.handleTrades,TradeDataUpdateEvent:this.handleTrades,SubscribeTicker:this.handleOHLCV,TickerDataUpdateEvent:this.handleOHLCV},n=this.safeString(t,"n"),r=this.safeValue(i,n);return r===void 0?t:r.call(this,e,t)}};const B$=ET,{ArgumentsRequired:Nd,AuthenticationError:N$}=Q,{ArrayCache:V$,ArrayCacheByTimestamp:E$,ArrayCacheBySymbolById:q$}=Pe;var L$=class extends B${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:"wss://real.okcoin.com:8443/ws/v3"},logo:"https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513"},options:{fetchMarkets:["spot"],watchOrders:"order",watchOrderBook:{limit:400,type:"spot",depth:"depth_l2_tbt"},watchBalance:"spot",ws:{inflate:!0}},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.urls.api.ws,r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.safeString(this.options,"watchOrders","order"),r=await this.subscribe(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(n.length>0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new q$(a));const o=this.orders,d={},c=this.parseOrders(n);for(let h=0;h<c.length;h++){const f=c[h];o.append(f);const l=f.symbol,m=this.market(l);d[m.id]=!0}const u=Object.keys(d);for(let h=0;h<u.length;h++){const f=i+":"+u[h];e.resolve(this.orders,f)}}}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"instrument_id"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new V$(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"instrument_id"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=this.timeframes[t],a="candle"+r+"s",o=await this.subscribe(a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/");let a=this.safeString(n,1).replace("candle","");a=a.replace("s","");const o=this.findTimeframe(a);for(let d=0;d<i.length;d++){const c=this.safeString(i[d],"instrument_id"),u=this.safeValue(i[d],"candle"),h=this.safeMarket(c),f=h.symbol,l=this.parseOHLCV(u,h);this.ohlcvs[f]=this.safeValue(this.ohlcvs,f,{});let m=this.safeValue(this.ohlcvs[f],o);if(m===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);m=new E$(y),this.ohlcvs[f][o]=m}m.append(l);const g=s+":"+c;e.resolve(m,g)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth_l2_tbt");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.parse8601(this.safeString(t,"timestamp"));return s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"data",[]),n=this.safeString(t,"table");if(s==="partial")for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol,u=this.safeValue(this.options,"watchOrderBook",{}),h=this.safeInteger(u,"limit",400),f=this.orderBook({},h);this.orderbooks[c]=f,this.handleOrderBookMessage(e,a,f);const l=n+":"+o;e.resolve(f,l)}else for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol;if(c in this.orderbooks){const u=this.orderbooks[c];this.handleOrderBookMessage(e,a,u);const h=n+":"+o;e.resolve(u,h)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),u={op:s,args:[this.apiKey,this.password,r,c]};this.spawn(this.watch,t,s,u,s,n)}return await n}async watchBalance(e={}){const t=this.safeString2(this.options,"watchBalance","defaultType");if(this.safeString(e,"type",t)===void 0)throw new Nd(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");const i=await this.authenticate();return await this.subscribeToUserAccount(i,e)}async subscribeToUserAccount(e,t={}){const s=this.safeString2(this.options,"watchBalance","defaultType"),i=this.safeString(t,"type",s);if(i===void 0)throw new Nd(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");await this.loadMarkets();const n=this.safeString(t,"currency"),r=this.safeString(t,"code",this.safeCurrencyCode(n));let a;r!==void 0&&(a=this.currency(r));const o=this.safeString(t,"symbol"),d=this.market(o),c=d===void 0,u=a===void 0;if(i==="spot"){if(u)throw new Nd(this.id+" watchBalance requires a 'currency' (id) or a unified 'code' parameter for "+i+" accounts")}else if(i==="margin"||i==="swap"||i==="option"){if(c)throw new Nd(this.id+" watchBalance requires a 'instrument_id' (id) or a unified 'symbol' parameter for "+i+" accounts")}else if(i==="futures"&&u&&c)throw new Nd(this.id+" watchBalance requires a 'currency' (id), or unified 'code', or 'instrument_id' (id), or unified 'symbol' parameter for "+i+" accounts");let h;u?c||(h=d.id):h=a.id;const f=i==="margin"?"spot":i,l=i==="margin"?"margin_account":"account",m=f+"/"+l,g=m+":"+h,y=this.urls.api.ws,w={op:"subscribe",args:[g]},b=this.omit(t,["currency","code","instrument_id","symbol","type"]);return await this.watch(y,m,this.deepExtend(w,b),g)}handleBalance(e,t){const s=this.safeString(t,"table"),i=s.split("/");let n=this.safeString(i,0);n==="spot"&&this.safeString(i,1)==="margin_account"&&(n="margin");const r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=this.parseBalanceByType(n,r),d=this.safeValue(this.balance,n,{}),c=this.deepExtend(d,o);this.balance[n]=this.safeBalance(c),e.resolve(this.balance[n],s)}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof N$){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth_l2_tbt:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade,account:this.handleBalance,margin_account:this.handleBalance,order:this.handleOrders};let a=this.safeValue(r,n);return n.indexOf("candle")>=0&&(a=this.handleOHLCV),a===void 0?t:a.call(this,e,t)}}};const R$=gg,{AuthenticationError:D$,InvalidNonce:F$}=Q,{ArrayCache:H$,ArrayCacheByTimestamp:G$,ArrayCacheBySymbolById:U$}=Pe;var YT=class extends R${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://ws.okx.com:8443/ws/v5/public",private:"wss://ws.okx.com:8443/ws/v5/private"}},test:{ws:{public:"wss://wspap.okx.com:8443/ws/v5/public?brokerId=9999",private:"wss://wspap.okx.com:8443/ws/v5/private?brokerId=9999"}}},options:{watchOrderBook:{depth:"books"},watchBalance:"spot",ws:{},checksum:!0},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.urls.api.ws[e];let r=t;const a={channel:t};if(s!==void 0){const d=this.market(s);r+=":"+d.id,a.instId=d.id}const o={op:"subscribe",args:[this.deepExtend(a,i)]};return await this.watch(n,r,o,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("public","trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeInteger(this.options,"tradesLimit",1e3);for(let a=0;a<n.length;a++){const o=this.parseTrade(n[a]),d=o.symbol,c=this.safeString(o.info,"instId"),u=i+":"+c;let h=this.safeValue(this.trades,d);h===void 0&&(h=new H$(r),this.trades[d]=h),h.append(o),e.resolve(h,u)}return t}async watchTicker(e,t={}){return await this.subscribe("public","tickers",e,t)}handleTicker(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]);for(let r=0;r<n.length;r++){const a=this.parseTicker(n[r]),o=a.symbol,d=this.safeString(a.info,"instId"),c=i+":"+d;this.tickers[o]=a,e.resolve(a,c)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=this.timeframes[t],a="candle"+r,o=await this.subscribe("public",a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeString(s,"instId"),a=this.safeMarket(r),o=a.id,d=i.replace("candle",""),c=this.findTimeframe(d);for(let u=0;u<n.length;u++){const h=this.parseOHLCV(n[u],a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let f=this.safeValue(this.ohlcvs[o],c);if(f===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);f=new G$(m),this.ohlcvs[o][c]=f}f.append(h);const l=i+":"+r;e.resolve(f,l)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","books");return(await this.subscribe("public",n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i){const n=this.safeValue(t,"asks",[]),r=this.safeValue(t,"bids",[]),a=s.asks,o=s.bids;if(this.handleDeltas(a,n),this.handleDeltas(o,r),this.safeValue(this.options,"checksum",!0)){const u=a.length,h=o.length,f=[];for(let y=0;y<25;y++)y<h&&(f.push(this.numberToString(o[y][0])),f.push(this.numberToString(o[y][1]))),y<u&&(f.push(this.numberToString(a[y][0])),f.push(this.numberToString(a[y][1])));const l=f.join(":"),m=this.safeInteger(t,"checksum"),g=this.crc32(l,!0);if(m!==g){const y=new F$(this.id+" invalid checksum");e.reject(y,i)}}const c=this.safeInteger(t,"ts");return s.timestamp=c,s.datetime=this.iso8601(c),s}handleOrderBook(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeString(t,"action"),r=this.safeValue(t,"data",[]),a=this.safeString(s,"instId"),d=this.safeMarket(a).symbol,c={"bbo-tbt":1,books:400,books5:5,"books-l2-tbt":400,"books50-l2-tbt":50},u=this.safeInteger(c,i),h=i+":"+a;if(n==="snapshot")for(let f=0;f<r.length;f++){const l=r[f],m=this.orderBook({},u);this.orderbooks[d]=m,m.symbol=d,this.handleOrderBookMessage(e,l,m,h),e.resolve(m,h)}else if(n==="update"){if(d in this.orderbooks){const f=this.orderbooks[d];for(let l=0;l<r.length;l++){const m=r[l];this.handleOrderBookMessage(e,m,f,h),e.resolve(f,h)}}}else if(i==="books5"||i==="bbo-tbt"){let f=this.safeValue(this.orderbooks,d);f===void 0&&(f=this.orderBook({},u)),this.orderbooks[d]=f;for(let l=0;l<r.length;l++){const m=r[l],g=this.safeInteger(m,"ts"),y=this.parseOrderBook(m,d,g,"bids","asks",0,1);f.reset(y),e.resolve(f,h)}}return t}authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s="authenticated",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),h={op:"login",args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:r,sign:c}]},f=this.extend(h,e);n=this.watch(t,s,f),i.subscriptions[s]=n}return n}async watchBalance(e={}){return await this.loadMarkets(),await this.authenticate(),await this.subscribe("private","account",void 0,e)}handleBalance(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n="spot",r=this.parseTradingBalance(t),a=this.safeValue(this.balance,n,{}),o=this.deepExtend(a,r);this.balance[n]=this.safeBalance(o),e.resolve(this.balance[n],i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n=this.safeValue(this.options,"watchOrders",{});let r=this.safeString(n,"type","ANY");r=this.safeString(i,"type",r);const a=this.safeValue(i,"stop",!1);i=this.omit(i,["type","stop"]);let o;e!==void 0&&(o=this.market(e),e=o.symbol,r=o.type),r==="future"&&(r="futures");const c={instType:r.toUpperCase()},u=a?"orders-algo":"orders",h=await this.subscribe("private",u,e,this.extend(c,i));return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r=this.safeValue(t,"data",[]);if(r.length>0){const o=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new U$(o));const d=this.orders,c=[],u=this.parseOrders(r);for(let h=0;h<u.length;h++){const f=u[h];d.append(f);const l=f.symbol,m=this.market(l);c.push(m.id)}e.resolve(this.orders,n);for(let h=0;h<c.length;h++){const f=n+":"+c[h];e.resolve(this.orders,f)}}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){e.resolve(t,"authenticated")}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof D$){const n="authenticated";return e.reject(i,n),n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"event");if(s!==void 0){const i={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}else{const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r={"bbo-tbt":this.handleOrderBook,books:this.handleOrderBook,books5:this.handleOrderBook,"books50-l2-tbt":this.handleOrderBook,"books-l2-tbt":this.handleOrderBook,tickers:this.handleTicker,trades:this.handleTrades,account:this.handleBalance,orders:this.handleOrders,"orders-algo":this.handleOrders},a=this.safeValue(r,n);if(a===void 0)if(n.indexOf("candle")===0)this.handleOHLCV(e,t);else return t;else return a.call(this,e,t)}}};const $$=YT;var W$=class extends $${describe(){return this.deepExtend(super.describe(),{alias:!0,id:"okex"})}};const z$=LT,ar=ae,{ArrayCache:j$,ArrayCacheByTimestamp:K$,ArrayCacheBySymbolById:q1}=Pe;var X$=class extends z${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://testnet.phemex.com/ws"},api:{ws:"wss://phemex.com/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3},streaming:{keepAlive:2e4}})}fromEn(e,t){if(e===void 0)return;const s=new ar(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}parseSwapTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString(e,"close"),t),a=this.parseNumber(r),o=this.parseNumber(this.fromEv(this.safeString(e,"turnover"),t)),d=this.parseNumber(this.fromEv(this.safeString(e,"volume"),t));let c,u,h;const f=this.omitZero(this.fromEp(this.safeString(e,"open"),t)),l=this.parseNumber(f);return f!==void 0&&r!==void 0&&(c=this.parseNumber(ar.stringSub(r,f)),h=this.parseNumber(ar.stringDiv(ar.stringAdd(r,f),"2")),u=this.parseNumber(ar.stringMul(ar.stringSub(ar.stringDiv(r,f),"1"),"100"))),{symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.parseNumber(this.fromEp(this.safeString(e,"high"),t)),low:this.parseNumber(this.fromEp(this.safeString(e,"low"),t)),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:l,close:a,last:a,previousClose:void 0,change:c,percentage:u,average:h,baseVolume:d,quoteVolume:o,info:e}}handleTicker(e,t){let s="market24h",i=this.safeValue(t,s),n;i===void 0?(s="spot_market24h",i=this.safeValue(t,s),n=this.parseTicker(i)):n=this.parseSwapTicker(i);const r=n.symbol,a=s+":"+r,o=this.safeIntegerProduct(t,"timestamp",1e-6);n.timestamp=o,n.datetime=this.iso8601(o),this.tickers[r]=n,e.resolve(n,a)}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i=t+":balance";return await this.subscribePrivate(t,i,s)}handleBalance(e,t,s){for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account();let h=this.safeString(r,"totalUsedBalanceEv");if(h===void 0){const l=this.safeString(r,"lockedTradingBalanceEv"),m=this.safeString(r,"lockedWithdrawEv");h=ar.stringAdd(l,m)}const f=this.safeString2(r,"accountBalanceEv","balanceEv");u.used=this.fromEn(h,c),u.total=this.fromEn(f,c),this.balance[o]=u,this.balance=this.safeBalance(this.balance)}const i=e+":balance";t.resolve(this.balance,i)}handleTrades(e,t){const s="trade",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=s+":"+r;let o=this.safeValue(this.trades,r);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new j$(u),this.trades[r]=o}const d=this.safeValue(t,"trades",[]),c=this.parseTrades(d,n);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,a)}handleOHLCV(e,t){const s="kline",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.safeValue(t,s,[]),o=this.safeValue(a,0,[]),d=this.safeString(o,1),c=this.findTimeframe(d);if(c!==void 0){const u=s+":"+c+":"+r,h=this.parseOHLCVs(a,n);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let f=this.safeValue(this.ohlcvs[r],c);if(f===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);f=new K$(l),this.ohlcvs[r][c]=f}for(let l=0;l<h.length;l++){const m=h[l];f.append(m)}e.resolve(f,u)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.spot?"spot_market24h":"market24h",n=this.urls.api.ws,r=this.requestId(),a=i+".subscribe",o=i+":"+e,d={method:a,id:r,params:[]},c=this.deepExtend(d,t);return await this.watch(n,o,c,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a=this.requestId(),o="trade",d=o+":"+e,u={method:o+".subscribe",id:a,params:[n.id]},h=this.deepExtend(u,i),f=await this.watch(r,d,h,d);return this.newUpdates&&(s=f.getLimit(e,s)),this.filterBySinceLimit(f,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r=this.requestId(),a="orderbook",o=a+":"+e,c={method:a+".subscribe",id:r,params:[i.id]},u=this.deepExtend(c,s);return(await this.watch(n,o,u,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o=this.requestId(),d="kline",c=d+":"+t+":"+e,h={method:d+".subscribe",id:o,params:[r.id,this.safeInteger(this.timeframes,t)]},f=this.deepExtend(h,n),l=await this.watch(a,c,f,c);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleDelta(e,t,s=void 0){const i=this.parseBidAsk(t,0,1,s);e.storeArray(i)}handleDeltas(e,t,s=void 0){for(let i=0;i<t.length;i++)this.handleDelta(e,t[i],s)}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeString(t,"type"),a=this.safeInteger(t,"depth"),d="orderbook"+":"+n,c=this.safeInteger(t,"sequence"),u=this.safeIntegerProduct(t,"timestamp",1e-6);if(r==="snapshot"){const h=this.safeValue(t,"book",{}),f=this.parseOrderBook(h,n,u,"bids","asks",0,1,i);f.nonce=c;const l=this.orderBook(f,a);this.orderbooks[n]=l,e.resolve(l,d)}else{const h=this.safeValue(this.orderbooks,n);if(h!==void 0){const f=this.safeValue(t,"book",{}),l=this.safeValue(f,"asks",[]),m=this.safeValue(f,"bids",[]);this.handleDeltas(h.asks,l,i),this.handleDeltas(h.bids,m,i),h.nonce=c,h.timestamp=u,h.datetime=this.iso8601(u),this.orderbooks[n]=h,e.resolve(h,d)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trades",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t){const s="trades";if(t.length===0)return;let n=this.myTrades;if(n===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);n=new q1(c)}const r={};let a;for(let c=0;c<t.length;c++){const u=t[c],h=this.safeString(u,"symbol"),f=this.safeMarket(h),l=this.parseTrade(u);n.append(l);const m=l.symbol;a===void 0&&(a=f.type),r[m]=!0}const o=Object.keys(r);for(let c=0;c<o.length;c++){const u=o[c],h=s+":"+u;e.resolve(n,h)}const d=s+":"+a;e.resolve(n,d)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t){let s=[];const i=[];if("closed"in t||"fills"in t||"open"in t){const u=this.safeValue(t,"closed",[]),h=this.safeValue(t,"open",[]),f=this.arrayConcat(h,u);if(f.length===0)return;s=this.safeValue(t,"fills",[]);for(let m=0;m<f.length;m++){const g=f[m],y=this.parseOrder(g);i.push(y)}}else for(let u=0;u<t.length;u++){const h=t[u],f=this.safeString(h,"action");f!==void 0&&f!=="Cancel"&&s.push(h);const l=this.parseWSSwapOrder(h);i.push(l)}this.handleMyTrades(e,s);const n=this.safeInteger(this.options,"ordersLimit",1e3),r={};this.orders===void 0&&(this.orders=new q1(n));let a;const o=this.orders;for(let u=0;u<i.length;u++){const h=i[u];o.append(h);const f=h.symbol,l=this.market(f);a===void 0&&(a=l.type),r[f]=!0}const d=Object.keys(r);for(let u=0;u<d.length;u++){const h="orders:"+d[u];e.resolve(this.orders,h)}const c="orders:"+a;e.resolve(this.orders,c)}parseWSSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeString(e,"orderQty"),h=this.safeString(e,"cumQty"),f=this.safeString(e,"leavesQty"),l=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeString(e,"cumValueEv"),g=this.fromEv(m,t);let y=this.safeIntegerProduct(e,"transactTimeNs",1e-6);y===0&&(y=void 0);const w=this.parseTimeInForce(this.safeString(e,"timeInForce")),b=this.safeString(e,"stopPx"),S=w==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,datetime:this.iso8601(l),timestamp:l,lastTradeTimestamp:y,symbol:r,type:d,timeInForce:w,postOnly:S,side:o,price:c,stopPrice:b,triggerPrice:b,amount:u,filled:h,remaining:f,cost:g,average:void 0,status:a,fee:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeInteger(t,"id");if(s!==void 0){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}if("market24h"in t||"spot_market24h"in t)return this.handleTicker(e,t);if("trades"in t)return this.handleTrades(e,t);if("kline"in t)return this.handleOHLCV(e,t);if("book"in t)return this.handleOrderBook(e,t);if("orders"in t){const i=this.safeValue(t,"orders",{});this.handleOrders(e,i)}if("accounts"in t||"wallets"in t){const i="accounts"in t?"swap":"spot",n=this.safeValue2(t,"accounts","wallets",[]);this.handleBalance(i,e,n)}}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}async subscribePrivate(e,t,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws,n=this.seconds(),r=e==="spot"?"wo.subscribe":"aop.subscribe";let a={id:n,method:r,params:[]};a=this.extend(a,s);const o={id:n,messageHash:t};return await this.watch(i,t,a,r,o)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i=this.seconds(),n="authenticated",r=s.future(n);if(this.safeValue(s.subscriptions,n)===void 0){const o=this.safeInteger(this.options,"expires",120),d=this.seconds()+o,c=this.apiKey+d.toString(),u=this.hmac(this.encode(c),this.encode(this.secret),"sha256"),h={method:"user.auth",params:["API",this.apiKey,u,d],id:i},f={id:i,method:this.handleAuthenticate};this.spawn(this.watch,t,n,h,n,f)}return await r}};const Y$=RT,{ArrayCache:Z$}=Pe;var Q$=class extends Y${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0},urls:{api:{ws:"wss://api.exchange.ripio.com/ws/v2/consumer/non-persistent/public/default/"}},options:{tradesLimit:1e3,uuid:this.uuid()}})}async watchTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a=r+"_"+n.id.toLowerCase(),o=this.urls.api.ws+a+"/"+this.options.uuid,d={name:r,symbol:e,messageHash:a,method:this.handleTrade},c=await this.watch(o,a,void 0,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrade(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.market(r),d=this.parseTrade(n,o);let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new Z$(u),this.trades[r]=c}c.append(d),e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="rate",n=i+"_"+s.id.toLowerCase(),r=this.urls.api.ws+n+"/"+this.options.uuid,a={name:i,symbol:e,messageHash:n,method:this.handleTicker};return await this.watch(r,n,void 0,n,a)}handleTicker(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.parseTicker(n),a=this.parse8601(this.safeString(t,"publishTime"));r.timestamp=a,r.datetime=this.iso8601(a);const o=r.symbol;this.tickers[o]=r;const d=this.safeString(s,"messageHash");return d!==void 0&&e.resolve(r,d),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook",r=n+"_"+i.id.toLowerCase(),a=this.urls.api.ws+r+"/"+this.options.uuid,o=this.client(a),d={name:n,symbol:e,messageHash:r,method:this.handleOrderBook};if(!(r in o.subscriptions)){this.orderbooks[e]=this.orderBook({}),o.subscriptions[r]=d;const u=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.fetchOrderBookSnapshot,o,d)}return(await this.watch(a,r,void 0,r,d)).limit()}async fetchOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"messageHash");try{const n=await this.fetchOrderBook(s),r=this.orderbooks[s],a=r.cache;r.reset(n);for(let o=0;o<a.length;o++){const d=a[o];this.handleOrderBookMessage(e,d,r)}this.orderbooks[s]=r,e.resolve(r,i)}catch(n){e.reject(n,i)}}handleOrderBook(e,t,s){const i=this.safeString(s,"messageHash"),n=this.safeString(s,"symbol"),r=this.safeValue(this.orderbooks,n);return r===void 0||(r.nonce===void 0?r.cache.push(t):(this.handleOrderBookMessage(e,t,r),e.resolve(r,i))),t}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeInteger(n,"updated_id");if(r>s.nonce){const a=this.safeValue(n,"sell",[]),o=this.safeValue(n,"buy",[]);this.handleDeltas(s.asks,a,s.nonce),this.handleDeltas(s.bids,o,s.nonce),s.nonce=r;const d=this.parse8601(this.safeString(t,"publishTime"));s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"amount");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async ack(e,t){await e.send({messageId:t})}handleMessage(e,t){const s=this.safeString(t,"messageId");s!==void 0&&this.spawn(this.ack,e,s);const i=Object.keys(e.subscriptions),n=this.safeString(i,0),r=this.safeValue(e.subscriptions,n,{}),a=this.safeValue(r,"method");return a!==void 0?a.call(this,e,t,r):t}};const J$=DT,{ArrayCache:e9}=Pe;var t9=class extends J${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.upbit.com/websocket/v1"}},options:{tradesLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,r=this.urls.api.ws;this.options[t]=this.safeValue(this.options,t,{}),this.options[t][e]=!0;const a=Object.keys(this.options[t]),o=this.marketIds(a),d=[{ticket:this.uuid()},{type:t,codes:o}],c=t+":"+n;return await this.watch(r,c,d,c)}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic(e,"trade");return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook")).limit()}handleTicker(e,t){const s=this.safeString(t,"code"),i="ticker:"+s,n=this.parseTicker(t),r=n.symbol;this.tickers[r]=n,e.resolve(n,i)}handleOrderBook(e,t){const s=this.safeString(t,"code"),i=this.safeSymbol(s,void 0,"-"),n=this.safeString(t,"stream_type"),r=this.safeValue(this.options,"watchOrderBook",{}),a=this.safeInteger(r,"limit",15);n==="SNAPSHOT"&&(this.orderbooks[i]=this.orderBook({},a));const o=this.orderbooks[i];o.reset({}),o.symbol=i;const d=o.bids,c=o.asks,u=this.safeValue(t,"orderbook_units",[]);for(let m=0;m<u.length;m++){const g=u[m],y=this.safeFloat(g,"ask_price"),w=this.safeFloat(g,"ask_size"),b=this.safeFloat(g,"bid_price"),S=this.safeFloat(g,"bid_size");c.store(y,w),d.store(b,S)}const h=this.safeInteger(t,"timestamp"),f=this.iso8601(h);o.timestamp=h,o.datetime=f;const l="orderbook:"+s;e.resolve(o,l)}handleTrades(e,t){const s=this.parseTrade(t),i=s.symbol;let n=this.safeValue(this.trades,i);if(n===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);n=new e9(o),this.trades[i]=n}n.append(s);const r=this.safeString(t,"code"),a="trade:"+r;e.resolve(n,a)}handleMessage(e,t){const s={ticker:this.handleTicker,orderbook:this.handleOrderBook,trade:this.handleTrades},i=this.safeString(t,"type"),n=this.safeValue(s,i);n&&n.call(this,e,t)}};const s9=FT,{NotSupported:i9,ExchangeError:n9}=Q,{ArrayCacheBySymbolById:L1,ArrayCacheByTimestamp:r9,ArrayCache:a9}=Pe;var o9=class extends s9{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://stream.wazirx.com/stream"}},options:{},streaming:{},exceptions:{},api:{private:{post:{create_auth_token:1}}}})}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate(e),s="balance",i=this.urls.api.ws,n={event:"subscribe",streams:["outboundAccountPosition"],auth_key:t},r=this.deepExtend(n,e);return await this.watch(i,s,r,s)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"B",[]);for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"a"),d=this.safeCurrencyCode(o),c=this.safeNumber(a,"b"),u=this.safeNumber(a,"l"),h=this.account();h.free=c,h.used=u,this.balance[d]=h}this.balance=this.safeBalance(this.balance);const n="balance";e.resolve(this.balance,n)}parseWSTrade(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeString(e,"s");t=this.safeMarket(i,t);const n=this.safeString(e,"f"),r=this.safeString(e,"U"),a=this.safeValue(e,"m")===!0;let o;return n!==void 0&&(o={cost:n,currency:this.safeCurrencyCode(r),rate:void 0}),this.safeTrade({id:this.safeString(e,"t"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeStringN(e,["o"]),type:void 0,side:this.safeString(e,"S"),takerOrMaker:a?"maker":"taker",price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,fee:o},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,n="ticker:"+s.symbol,r="tickers",o={event:"subscribe",streams:["!ticker@arr"]},d=this.deepExtend(o,t);return await this.watch(i,n,d,r)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",r={event:"subscribe",streams:["!ticker@arr"]},a=this.deepExtend(r,t),o=await this.watch(s,i,a,i);return this.filterByArray(o,"symbol",e,!1)}handleTicker(e,t){const s=this.safeValue(t,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.parseWSTicker(n),a=r.symbol;this.tickers[a]=r;const o="ticker:"+a;e.resolve(r,o)}e.resolve(this.tickers,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeInteger(e,"E");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeNumber(e,"b"),bidVolume:void 0,ask:this.safeNumber(e,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:void 0,last:this.safeString(e,"l"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"q"),info:e},t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=n.id+"@trades",a=this.urls.api.ws,o={event:"subscribe",streams:[r]},d=this.extend(o,i),c=await this.watch(a,r,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"trades",[]),n=this.safeString(t,"stream"),r=n.split("@"),a=this.safeString(r,0),o=this.safeMarket(a),d=this.safeSymbol(a,o);let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new a9(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseWSTrade(i[u],o);c.append(h)}e.resolve(c,n)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.authenticate(i);e!==void 0&&(e=this.market(e).symbol);const r=this.urls.api.ws,a="myTrades",o={event:"subscribe",streams:["ownTrade"],auth_key:n},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o="ohlcv:"+e+":"+t,d=r.id+"@kline_"+t,c={event:"subscribe",streams:[d]},u=this.deepExtend(c,n),h=await this.watch(a,o,u,o);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"s"),n=this.safeMarket(i),r=this.safeSymbol(i,n),a=this.safeString(s,"i");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let o=this.safeValue(this.ohlcvs[r],a);if(o===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);o=new r9(u),this.ohlcvs[r][a]=o}const d=this.parseWsOHLCV(s,n);o.append(d);const c="ohlcv:"+r+":"+a;e.resolve(o,c)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"c"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,a=i.id+"@depth",o={event:"subscribe",streams:[a]},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit()}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"E"),n=this.safeString(s,"s"),a=this.safeMarket(n).symbol,o="orderbook:"+a,d=this.safeValue(this.orderbooks,a);if(d===void 0){const c=this.parseOrderBook(s,a,i,"b","a"),u=this.orderBook(c);this.orderbooks[a]=u}else{const c=this.safeValue(s,"a",[]),u=this.safeValue(s,"b",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=i,d.timestamp=i,d.datetime=this.iso8601(i),this.orderbooks[a]=d}e.resolve(this.orderbooks[a],o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.authenticate(i),r="orders",a={event:"subscribe",streams:["orderUpdate"],auth_key:n},o=this.urls.api.ws,d=this.deepExtend(a,i),c=await this.watch(o,r,d,r,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWSOrder(s);if(this.orders===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new L1(r)}this.orders.append(i);let n="orders";e.resolve(this.orders,n),n+=":"+i.symbol,e.resolve(this.orders,n)}parseWSOrder(e){const t=this.safeInteger(e,"O"),s=this.safeString(e,"s"),i=this.safeString(e,"X"),n=this.safeMarket(s);return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:void 0,symbol:n.symbol,type:this.safeValue(e,"m")?"limit":"market",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"o"),price:this.safeString(e,"p"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeString(e,"V"),filled:void 0,remaining:this.safeString(e,"q"),cost:void 0,average:this.safeString(e,"v"),status:this.parseOrderStatus(i),fee:void 0,trades:void 0},n)}handleMyTrades(e,t){const s=this.safeValue(t,"data",{}),i="myTrades";let n;if(this.myTrades===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new L1(a),this.myTrades=n}else n=this.myTrades;const r=this.parseWSTrade(s);n.append(r),e.resolve(n,i)}handleConnected(e,t){return t}handleSubscribed(e,t){return t}handleError(e,t){throw new n9(this.id+" "+this.json(t))}handleMessage(e,t){if(this.safeString(t,"status")==="error")return this.handleError(e,t);const i=this.safeString(t,"event"),n={error:this.handleError,connected:this.handleConnected,subscribed:this.handleSubscribed},r=this.safeValue(n,i);if(r!==void 0)return r.call(this,e,t);const a=this.safeString(t,"stream",""),o={"ticker@arr":this.handleTicker,"@depth":this.handleOrderBook,"@kline":this.handleOHLCV,"@trades":this.handleTrades,outboundAccountPosition:this.handleBalance,orderUpdate:this.handleOrder,ownTrade:this.handleMyTrades},d=Object.keys(o);for(let c=0;c<d.length;c++)if(this.inArray(d[c],a))return o[d[c]].call(this,e,t);throw new i9(this.id+" this message type is not supported yet. Message: "+this.json(t))}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=this.milliseconds();let r=this.safeValue(s.subscriptions,i);const a=this.safeInteger(r,"expires");return(r===void 0||n>a)&&(r=await this.privatePostCreateAuthToken(),r.expires=n+this.safeInteger(r,"timeout_duration")*1e3,s.subscriptions[i]=r),this.safeString(r,"auth_key")}};const d9=HT,c9=ae,{AuthenticationError:R1,BadRequest:Qp,ArgumentsRequired:D1}=Q,{ArrayCache:F1,ArrayCacheBySymbolById:u9,ArrayCacheByTimestamp:h9}=Pe;var f9=class extends d9{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.whitebit.com/ws"}},options:{timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","8h":"28800","1d":"86400","1w":"604800"},watchOrderBook:{priceInterval:0}},streaming:{ping:this.ping},exceptions:{ws:{exact:{1:Qp,2:Qp,4:Qp,6:R1}}}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.safeValue(this.options,"timeframes",{}),o=this.safeInteger(a,t),d=r.id,c="candles:"+e,u=[d,o],h="candles_subscribe",f=await this.watchPublic(c,h,u,n);return this.newUpdates&&(i=f.getLimit(e,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,7),a=this.safeMarket(r),o=a.symbol,d="candles:"+o,c=this.parseOHLCV(n,a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o);let u=this.ohlcvs[o];if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new h9(h),this.ohlcvs[o]=u}u.append(c),e.resolve(u,d)}return t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=10);const n="orderbook:"+i.symbol,r="depth_subscribe",a=this.safeValue(this.options,"watchOrderBook",{}),o=this.safeString(a,"priceInterval","0"),d=this.safeString(s,"priceInterval",o);s=this.omit(s,"priceInterval");const c=[i.id,t,d,!0];return(await this.watchPublic(n,r,c,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0),n=this.safeString(s,2),a=this.safeMarket(n).symbol,o=this.safeValue(s,1);let d;if(a in this.orderbooks?d=this.orderbooks[a]:(d=this.orderBook(),this.orderbooks[a]=d),i){const u=this.parseOrderBook(o,a);d.reset(u)}else{const u=this.safeValue(o,"asks",[]),h=this.safeValue(o,"bids",[]);this.handleDeltas(d.asks,u),this.handleDeltas(d.bids,h)}const c="orderbook:"+a;e.resolve(d,c)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets(),e=this.market(e).symbol;const i="market_subscribe",n="ticker:"+e;return await this.watchMultipleSubscription(n,i,e,!1,t)}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i,void 0),r=n.symbol,a=this.safeValue(s,1,{}),o="ticker:"+r,d=this.parseTicker(a,n);this.tickers[r]=d,e.resolve(d,o);const c=Object.keys(e.futures);for(let u=0;u<c.length;u++){const h=c[u];h.indexOf("tickers")>=0&&h.indexOf(r)>=0&&e.resolve(d,h)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.market(e).symbol;const r="trades:"+e,a="trades_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new F1(u),this.trades[r]=a}const o=this.safeValue(s,1,[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c="trades:"+n.symbol;e.resolve(a,c)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new D1(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="myTrades:"+e,a="deals_subscribe",o=await this.watchMultipleSubscription(r,a,e,!0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,"params");if(this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new F1(d)}const n=this.myTrades,r=this.parseWsTrade(i);n.append(r);const a=r.symbol,o="myTrades:"+a;e.resolve(n,o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,3),i=this.safeTimestamp(e,1),n=this.safeString(e,0),r=this.safeString(e,4),a=this.safeString(e,5),o=this.safeString(e,2);t=this.safeMarket(o,t);let d;const c=this.safeString(e,6);return c!==void 0&&(d={cost:c,currency:t.quote}),this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:s,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:d},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new D1(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="orders:"+e,a="ordersPending_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"params",[]),n=this.safeValue(i,1);if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new u9(u)}const r=this.orders,a=this.safeInteger(i,0),o=this.parseWsOrder(n,a);r.append(o);const d=o.symbol,c="orders:"+d;e.resolve(this.orders,c)}parseWsOrder(e,t,s=void 0){const i=this.safeString(e,"market");s=this.safeMarket(i,s);const n=this.safeString(e,"id"),r=this.omitZero(this.safeString(e,"client_order_id")),a=this.safeString(e,"price"),o=this.safeString(e,"deal_stock"),d=this.safeString(e,"deal_money"),c=this.safeString(e,"activation_price"),u=this.safeString(e,"type"),h=this.parseWsOrderType(u);let f,l;h==="market"?(f=this.safeString(e,"deal_stock"),l="0"):(l=this.safeString(e,"left"),f=this.safeString(e,"amount"));const m=this.safeTimestamp(e,"ctime"),g=this.safeTimestamp(e,"mtime"),y=s.symbol,b=this.safeInteger(e,"side")===1?"sell":"buy",S=this.safeString(e,"deal_fee");let v;return S!==void 0&&(v={cost:this.parseNumber(S),currency:s.quote}),t===1||t===2?t="open":c9.stringEquals(l,"0")?t="closed":t="canceled",this.safeOrder({info:e,symbol:y,id:n,clientOrderId:r,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:g,type:h,timeInForce:void 0,postOnly:void 0,side:b,price:a,stopPrice:c,triggerPrice:c,amount:f,cost:d,average:void 0,filled:o,remaining:l,status:t,fee:v,trades:void 0},s)}parseWsOrderType(e){const t={1:"limit",2:"market",202:"market",3:"limit",4:"market",5:"limit",6:"market",8:"limit",10:"market"};return this.safeString(t,e,e)}async watchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let s="wallet:",i;t==="spot"?(i="balanceSpot_subscribe",s+="spot"):(i="balanceMargin_subscribe",s+="margin");const n=Object.keys(this.currencies);return await this.watchPrivate(s,i,n,e)}handleBalance(e,t){const s=this.safeString(t,"method"),i=this.safeValue(t,"params"),n=this.safeValue(i,0),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.account();c.free=this.safeString(o,"available"),c.used=this.safeString(o,"freeze"),this.balance[d]=c,this.balance=this.safeBalance(this.balance);let u="wallet:";s.indexOf("Spot")>=0?u+="spot":u+="margin",e.resolve(this.balance,u)}async watchPublic(e,t,s=[],i={}){const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchMultipleSubscription(e,t,s,i=!1,n={}){await this.loadMarkets();const r=this.urls.api.ws,a=this.nonce(),o=this.safeValue(this.clients,r);let d;if(o===void 0){const c={},h=this.market(s).id;c[h]=!0;let f=[h];i&&(f=[f]),d={id:a,method:t,params:f};const l=this.extend(d,n);return await this.watch(r,e,l,t,c)}else{const c=this.safeValue(o.subscriptions,t,{});let u=!0;const f=this.market(s).id;if(this.safeValue(c,f,!1)||(c[f]=!0,u=!1),u)return await this.watch(r,e,d,t,c);{let m=Object.keys(c);i&&(m=[m]);const g={id:a,method:t,params:m};return t in o.subscriptions&&delete o.subscriptions[t],await this.watch(r,e,g,t,c)}}}async watchPrivate(e,t,s=[],i={}){this.checkRequiredCredentials(),await this.authenticate();const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t),n=i.future("authenticated");if(this.safeValue(i.subscriptions,s)===void 0){const a=await this.v4PrivatePostProfileWebsocketToken(),o=this.safeString(a,"websocket_token"),d=this.nonce(),c={id:d,method:"authorize",params:[o,"public"]},u={id:d,method:this.handleAuthenticate};this.spawn(this.watch,t,s,c,s,u)}return await n}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");try{if(s!==void 0){const i=this.safeString(t,"code"),n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}}catch(i){if(i instanceof R1)return e.reject(i,"authenticated"),"login"in e.subscriptions&&delete e.subscriptions.login,!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeValue(t,"result",{});if(s!==void 0&&s==="pong"){this.handlePong(e,t);return}const i=this.safeInteger(t,"id");if(i!==void 0){this.handleSubscriptionStatus(e,t,i);return}const n={market_update:this.handleTicker,trades_update:this.handleTrades,depth_update:this.handleOrderBook,candles_update:this.handleOHLCV,ordersPending_update:this.handleOrder,ordersExecuted_update:this.handleOrder,balanceSpot_update:this.handleBalance,balanceMargin_update:this.handleBalance,deals_update:this.handleMyTrades},r=this.safeValue(t,"method"),a=this.safeValue(n,r);a!==void 0&&a.call(this,e,t)}handleSubscriptionStatus(e,t,s){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}ping(e){return{id:0,method:"ping",params:[]}}};const l9=GT,{ExchangeError:p9,AuthenticationError:H1}=Q,{ArrayCacheByTimestamp:m9,ArrayCacheBySymbolById:g9,ArrayCache:y9}=Pe,w9=ae;var b9=class extends l9{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!1,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0},urls:{api:{ws:{public:"wss://wss.woo.org/ws/stream",private:"wss://wss.woo.network/v2/ws/private/stream"}},test:{ws:{public:"wss://wss.staging.woo.org/ws/stream",private:"wss://wss.staging.woo.org/v2/ws/private/stream"}}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},options:{tradesLimit:1e3,ordersLimit:1e3,requestId:{}},streaming:{ping:this.ping,keepAlive:1e4}})}requestId(e){const t=this.safeValue(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}async watchPublic(e,t){this.checkRequiredUid();const s=this.urls.api.ws.public+"/"+this.uid,n={id:this.requestId(s)},r=this.extend(n,t);return await this.watch(s,e,r,e,n)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="orderbook",r=this.market(e).id+"@"+i,a={event:"subscribe",topic:r},o=this.extend(a,s);return(await this.watchPublic(r,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.safeString(t,"topic");let o=this.safeValue(this.orderbooks,r);o===void 0&&(o=this.orderBook({}));const d=this.safeInteger(t,"ts"),c=this.parseOrderBook(s,r,d,"bids","asks");o.reset(c),e.resolve(o,a)}async watchTicker(e,t={}){await this.loadMarkets();const s="ticker",n=this.market(e).id+"@"+s,r={event:"subscribe",topic:n},a=this.extend(r,t);return await this.watchPublic(n,a)}parseWsTicker(e,t=void 0){const s=this.safeInteger(e,"date",this.milliseconds());return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"amount"),info:e},t)}handleTicker(e,t){const s=this.safeValue(t,"data"),i=this.safeValue(t,"topic"),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=this.safeInteger(t,"ts");s.date=a;const o=this.parseWsTicker(s,r);return o.symbol=r.symbol,this.tickers[r.symbol]=o,e.resolve(o,i),t}async watchTickers(e=void 0,t={}){await this.loadMarkets();const i="tickers",n={event:"subscribe",topic:i},r=this.extend(n,t),a=await this.watchPublic(i,r);return this.filterByArray(a,"symbol",e)}handleTickers(e,t){const s=this.safeValue(t,"topic"),i=this.safeValue(t,"data"),n=this.safeInteger(t,"ts"),r=[];for(let a=0;a<i.length;a++){const o=this.safeString(i[a],"symbol"),d=this.safeMarket(o),c=this.parseWsTicker(this.extend(i[a],{date:n}),d);this.tickers[d.symbol]=c,r.push(c)}e.resolve(r,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(await this.loadMarkets(),t!=="1m"&&t!=="5m"&&t!=="15m"&&t!=="30m"&&t!=="1h"&&t!=="1d"&&t!=="1w"&&t!=="1M")throw new p9(this.id+" watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M");const r=this.market(e),a=this.timeframes[t],o="kline",d=r.id+"@"+o+"_"+a,c={event:"subscribe",topic:d},u=this.extend(c,n),h=await this.watchPublic(d,u);return this.newUpdates&&(i=h.getLimit(r.symbol,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data"),i=this.safeValue(t,"topic"),n=this.safeString(s,"symbol"),a=this.safeMarket(n).symbol,o=this.safeString(s,"type"),d=this.findTimeframe(o),c=[this.safeInteger(s,"startTime"),this.safeFloat(s,"open"),this.safeFloat(s,"high"),this.safeFloat(s,"low"),this.safeFloat(s,"close"),this.safeFloat(s,"volume")];this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let u=this.safeValue(this.ohlcvs[a],d);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new m9(h),this.ohlcvs[a][d]=u}u.append(c),e.resolve(u,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.id+"@trade",a={event:"subscribe",topic:r},o=this.extend(a,i),d=await this.watchPublic(r,o);return this.newUpdates&&(s=d.getLimit(n.symbol,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleTrade(e,t){const s=this.safeString(t,"topic"),i=this.safeInteger(t,"ts"),n=this.safeValue(t,"data"),r=this.safeString(n,"symbol"),a=this.safeMarket(r),o=a.symbol,d=this.parseWsTrade(this.extend(n,{timestamp:i}),a);let c=this.safeValue(this.trades,o);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new y9(u)}c.append(d),this.trades[o]=c,e.resolve(c,s)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"price"),r=this.safeString(e,"size"),a=w9.stringMul(n,r),o=this.safeStringLower(e,"side"),d=this.safeInteger(e,"timestamp");return this.safeTrade({id:void 0,timestamp:d,datetime:this.iso8601(d),symbol:i,side:o,price:n,amount:r,cost:a,order:void 0,takerOrMaker:void 0,type:void 0,fee:void 0,info:e},t)}checkRequiredUid(e=!0){if(!this.uid){if(e)throw new H1(this.id+" requires `uid` credential");return!1}return!0}authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private+"/"+this.uid,s=this.client(t),i="authenticated",n="auth";let r=this.safeValue(s.subscriptions,i);if(r===void 0){const a=this.nonce().toString(),o="|"+a,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256"),c={event:n,params:{apikey:this.apiKey,sign:d,timestamp:a}},u=this.extend(c,e);r=this.watch(t,i,u),s.subscriptions[i]=r}return r}async watchPrivate(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws.private+"/"+this.uid,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="executionreport";let r=n;e!==void 0&&(e=this.market(e).symbol,r+=":"+e);const a={event:"subscribe",topic:n},o=this.extend(a,i),d=await this.watchPrivate(r,o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"symbol");t=this.market(i);const n=t.symbol,r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"totalFee"),o={cost:a,currency:this.safeString(e,"feeAsset")},d=this.safeFloat(e,"price"),c=this.safeFloat(e,"quantity"),u=this.safeStringLower(e,"side"),h=this.safeStringLower(e,"type"),f=this.safeFloat(e,"executedQuantity"),l=this.safeFloat(e,"totalExecutedQuantity");let m=c;c>=l&&(m-=l);const g=this.safeString(e,"status"),y=this.parseOrderStatus(g),w=void 0,b=this.safeString(e,"clientOrderId");return{info:e,symbol:n,id:s,clientOrderId:b,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:r,type:h,timeInForce:void 0,postOnly:void 0,side:u,price:d,stopPrice:void 0,triggerPrice:void 0,amount:c,cost:a,average:void 0,filled:f,remaining:m,status:y,fee:o,trades:w}}handleOrderUpdate(e,t){const s=this.safeValue(t,"data");this.handleOrder(e,s)}handleOrder(e,t){const s="executionreport",i=this.parseWsOrder(t),n=this.safeString(i,"symbol"),r=this.safeString(i,"id");if(n!==void 0){if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new g9(u)}const a=this.orders,o=this.safeValue(a.hashmap,n,{}),d=this.safeValue(o,r);if(d!==void 0){const u=this.safeValue(d,"fee");u!==void 0&&(i.fee=u);const h=this.safeValue(d,"fees");h!==void 0&&(i.fees=h),i.trades=this.safeValue(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}a.append(i),e.resolve(this.orders,s);const c=s+":"+n;e.resolve(this.orders,c)}}handleMessage(e,t){const s={ping:this.handlePing,pong:this.handlePong,subscribe:this.handleSubscribe,orderbook:this.handleOrderBook,ticker:this.handleTicker,tickers:this.handleTickers,kline:this.handleOHLCV,auth:this.handleAuth,executionreport:this.handleOrderUpdate,trade:this.handleTrade},i=this.safeString(t,"event");let n=this.safeValue(s,i);if(n!==void 0)return n.call(this,e,t);const r=this.safeString(t,"topic");if(r!==void 0){if(n=this.safeValue(s,r),n!==void 0)return n.call(this,e,t);const a=r.split("@");if(a.length===2){const o=this.safeString(a,1);if(n=this.safeValue(s,o),n!==void 0)return n.call(this,e,t);const d=o.split("_");if(d.length===2&&(n=this.safeValue(s,this.safeString(d,0)),n!==void 0))return n.call(this,e,t)}}return t}ping(e){return{event:"ping"}}handlePing(e,t){return{event:"pong"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscribe(e,t){return t}handleAuth(e,t){const s="authenticated";if(this.safeValue(t,"success"))e.resolve(t,s);else{const n=new H1(this.json(t));e.reject(n,s),s in e.subscriptions&&delete e.subscriptions.authenticated}}};const k9=UT,{ExchangeError:S9,AuthenticationError:v9,NotSupported:T9}=Q,{ArrayCache:O9,ArrayCacheByTimestamp:I9}=Pe;var x9=class extends k9{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0,watchOHLCV:!0},urls:{api:{ws:{spot:"wss://api.{hostname}/websocket",contract:"wss://fapi.{hostname}/ws/public/v1"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o=this.market(s).spot?"spot":"contract";let d;const c=n!==void 0;o==="spot"?(d={event:"addChannel",channel:t},c&&(d.length=n)):(d={action:"subscribe",channel:t},c&&(d.size=n));const u=this.extend(d,r),h={symbol:s,messageHash:t,method:i};return c&&(h.limit=n),await this.watch(e,t,u,t,h)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n=s.spot?"spot":"contract";n==="spot"?i=s.baseId+s.quoteId+"_ticker":i=s.id+".Ticker";const r=this.implodeHostname(this.urls.api.ws[n]);return await this.watchPublic(r,i,e,this.handleTicker,void 0,t)}parseWsTicker(e,t=void 0){const s=this.safeInteger(e,6),i=this.safeString(e,3);return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:void 0,high:this.safeString(e,1),low:this.safeString(e,2),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,0),close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,5),average:void 0,baseVolume:this.safeString(e,4),quoteVolume:void 0,info:e},t,!1)}handleTicker(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(t,"channel"),r=this.market(i);let a=this.safeValue(t,"ticker"),o;return a===void 0?(a=this.safeValue(t,"data",[]),o=this.parseWsTicker(a,r)):(a.date=this.safeValue(t,"date"),o=this.parseTicker(a,r)),o.symbol=i,this.tickers[i]=o,e.resolve(o,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(r.spot)throw new T9(this.id+" watchOHLCV() supports contract markets only");(i===void 0||i>1440)&&(i=100);const a=this.timeframes[t],o=r.id+".KLine_"+a,d=this.implodeHostname(this.urls.api.ws.contract),c=await this.watchPublic(d,o,e,this.handleOHLCV,i,n);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t,s){const i=this.safeValue(t,"data",[]),n=this.safeString(t,"channel",""),r=n.split("_"),a=r.length,o=this.safeString(r,a-1),d=this.findTimeframe(o),c=this.safeString(s,"symbol"),u=this.market(c);for(let h=0;h<i.length;h++){const f=i[h],l=this.parseOHLCV(f,u);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let m=this.safeValue(this.ohlcvs[c],d);if(m===void 0){const g=this.safeInteger(this.options,"OHLCVLimit",1e3);m=new I9(g),this.ohlcvs[c][d]=m}m.append(l),e.resolve(m,n)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r;const a=n.spot?"spot":"contract";a==="spot"?r=n.baseId+n.quoteId+"_trades":r=n.id+".Trade";const o=this.implodeHostname(this.urls.api.ws[a]),d=await this.watchPublic(o,r,e,this.handleTrades,s,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"channel"),n=this.safeString(s,"symbol"),r=this.market(n),a=this.safeValue(t,"data"),o=this.safeString(t,"type");let d=[];if(o==="Whole")for(let u=0;u<a.length;u++){const h=a[u],f=this.parseWsTrade(h,r);d.push(f)}else d=this.parseTrades(a,r);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new O9(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[n]=c,e.resolve(c,i)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0){if(t!==5&&t!==10)throw new S9(this.id+" watchOrderBook limit argument must be undefined, 5, or 10")}else t=5;await this.loadMarkets();const i=this.market(e),n=i.spot?"spot":"contract";let r,a=this.implodeHostname(this.urls.api.ws[n]);return n==="spot"?(a+="/"+i.baseId,r=i.baseId+i.quoteId+"_quick_depth"):r=i.id+".Depth",(await this.watchPublic(a,r,e,this.handleOrderBook,t,s)).limit()}parseWsTrade(e,t=void 0){const s=this.safeTimestamp(e,3),i=this.safeString(e,0),n=this.safeString(e,1);t=this.safeMarket(void 0,t);const a=this.safeInteger(e,2)===1?"buy":"sell";return this.safeTrade({id:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:void 0,side:a,takerOrMaker:void 0,price:i,amount:n,cost:void 0,fee:void 0,info:e},t)}handleOrderBook(e,t,s){const i=this.safeString2(t,"type","dataType"),n=this.safeString(t,"channel"),r=this.safeString(s,"symbol");let a=this.safeValue(this.orderbooks,r);if(i!==void 0){const o=i==="Whole",d=o?this.safeValue(t,"data"):t,c=this.safeInteger2(d,"lastTime","time"),u=o?"asks":"listUp",h=o?"bids":"listDown",f=this.parseOrderBook(d,r,c,h,u);if(r in this.orderbooks)a=this.orderbooks[r],a.reset(f);else{const l=this.safeInteger(this.options,"watchOrderBookLimit",1e3),m=this.safeInteger(s,"limit",l);a=this.orderBook(f,m),this.orderbooks[r]=a}a.symbol=r,e.resolve(a,n)}else this.handleOrderBookMessage(e,t,a),e.resolve(a,n)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"time"),r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);return this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a),s.timestamp=n,s.datetime=this.iso8601(n),s}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s);if(i!==void 0){const n=this.safeValue(i,"method");if(n!==void 0)return n.call(this,e,t,i)}return t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof v9){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}};const _9=XT;var C9=class extends _9{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP",ws:"wss://apws.zipmex.com/WSGateway"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};const ZT=re,Cm=GN,M9=ae,P9=Zd,A9=Q,wg="2.6.36";ZT.ccxtVersion=wg;const Mm={alpaca:rT,ascendex:aT,bequant:oV,bigone:hV,binance:tc,binancecoinm:bV,binanceus:SV,binanceusdm:TV,bit2c:AV,bitbank:LV,bitbay:XV,bitbns:iE,bitcoincom:aE,bitfinex:cT,bitfinex2:uT,bitflyer:ME,bitforex:qE,bitget:hT,bithumb:XE,bitmart:fT,bitmex:lT,bitopro:pT,bitpanda:fq,bitrue:mT,bitso:_q,bitstamp:gT,bitstamp1:Gq,bittrex:yT,bitvavo:wT,bkex:dL,bl3p:hL,blockchaincom:bL,btcalpha:_L,btcbox:qL,btcex:bT,btcmarkets:zL,btctradeua:YL,btcturk:t3,buda:o3,bybit:kT,cex:ST,coinbase:O3,coinbaseprime:N3,coinbasepro:fg,coincheck:R3,coinex:vT,coinfalcon:J3,coinmate:oR,coinone:pR,coinspot:bR,cryptocom:TT,currencycom:OT,delta:GR,deribit:IT,digifinex:s4,exmo:xT,flowbtc:l4,fmfwio:dT,gate:lg,gateio:S4,gemini:_T,hitbtc:Ph,hitbtc3:V4,hollaex:CT,huobi:pg,huobijp:MT,huobipro:e5,idex:PT,independentreserve:g5,indodax:v5,itbit:_5,kraken:AT,kucoin:mg,kucoinfutures:BT,kuna:Q5,latoken:aD,lbank:fD,lbank2:kD,luno:NT,lykke:MD,mercado:VD,mexc:VT,mexc3:jD,ndax:Ah,novadax:a6,oceanex:f6,okcoin:ET,okex:qT,okex5:_6,okx:gg,paymium:A6,phemex:LT,poloniex:W6,poloniexfutures:Q6,probit:oF,ripio:RT,stex:TF,therock:_F,tidex:VF,timex:FF,tokocrypto:YF,upbit:DT,wavesexchange:c8,wazirx:FT,whitebit:HT,woo:GT,yobit:P8,zaif:E8,zb:UT,zipmex:U8,zonda:oT},ro={alpaca:Z8,ascendex:iH,bequant:dH,binance:Bh,binancecoinm:pH,binanceus:gH,binanceusdm:wH,bitcoincom:kH,bitfinex:xH,bitfinex2:NH,bitget:HH,bitmart:jH,bitmex:JH,bitopro:iG,bitrue:oG,bitstamp:lG,bittrex:bG,bitvavo:OG,btcex:PG,bybit:EG,cex:DG,coinbaseprime:UG,coinbasepro:zT,coinex:QG,cryptocom:nU,currencycom:cU,deribit:pU,exmo:bU,gate:jT,gateio:_U,gemini:BU,hitbtc:yg,hollaex:RU,huobi:KT,huobijp:KU,huobipro:YU,idex:t$,kraken:u$,kucoin:m$,kucoinfutures:k$,luno:T$,mexc:M$,ndax:XT,okcoin:L$,okex:W$,okx:YT,phemex:X$,ripio:Q$,upbit:t9,wazirx:o9,whitebit:f9,woo:b9,zb:x9,zipmex:C9};for(const p in ro){const e=Mm[p];Object.getPrototypeOf(e).name==="Exchange"&&(Object.setPrototypeOf(e,Cm),Object.setPrototypeOf(e.prototype,Cm.prototype))}ro.version=wg;ro.exchanges=Object.keys(ro);ro.Exchange=Cm;var B9=Object.assign({version:wg,Exchange:ZT,Precise:M9,exchanges:Object.keys(Mm),pro:ro},Mm,P9,A9);function N9(){const p=ch(),e=new B9.pro.binance,t=_t({bid:"",ask:""});return(()=>{p.activeBot.isWebserverMode||(e.loadMarkets(),setInterval(async()=>{if(!p.activeBot.selectedPair)return;const i=await e.fetchOrderBook(p.activeBot.selectedPair,5);t.value.bid=i.bids.length?i.bids[0][0].toString():"",t.value.ask=i.asks.length?i.asks[0][0].toString():""},700))})(),{orderbook:t}}Nm([rI,Gx,aI,TI,OI,oI,z_,dI,A_,cI,II,xI,oC,Ex,_I,CI,RI,uI]);const Jp="5.5%",em="1%",G1=55,Vd=8,V9="#26A69A",E9="#26A69A",q9="#EF5350",L9="#EF5350",R9="#00ff26",D9="#00ff26",F9="#faba25",H9="#faba25",G9=uh({name:"CandleChart",components:{"v-chart":nI},props:{trades:{required:!1,default:()=>[],type:Array},dataset:{required:!0,type:Object},heikinAshi:{required:!1,default:!1,type:Boolean},useUTC:{required:!1,default:!0,type:Boolean},plotConfig:{required:!0,type:Object},theme:{default:"dark",type:String},sliderPosition:{required:!1,type:Object,default:()=>{}}},setup(p){const e=_t(),t=_t([]),s=_t([]),i=_t({}),n=ch(),r=N9(),a=Zt(()=>p.dataset?p.dataset.strategy:""),o=Zt(()=>p.dataset?p.dataset.pair:""),d=Zt(()=>p.dataset?p.dataset.timeframe:""),c=Zt(()=>p.dataset?p.dataset.columns:[]),u=Zt(()=>p.dataset!==null&&typeof p.dataset=="object"),h=Zt(()=>p.trades.filter(b=>b.pair===o.value)),f=Zt(()=>`${a.value} - ${o.value} - ${d.value}`),l=()=>{var I;const b="#AD00FF",S="#0066FF",v=[{lineStyle:{color:"green",width:1,type:"dotted"},name:"Bid",yAxis:r.orderbook.value.bid},{lineStyle:{color:"red",width:1,type:"dotted"},name:"Ask",yAxis:r.orderbook.value.ask}],T=h.value.find(A=>A.is_open);return T&&T.orders&&(v.push({lineStyle:{color:"red",width:2,type:"dashed"},name:"Stop",yAxis:T.stop_loss_abs.toString()}),v.push({lineStyle:{color:T.is_short?b:S,width:T.orders[0].is_open?1:2,type:"dashed"},name:"Average rate",yAxis:T.orders[0].is_open?T.orders[0].safe_price.toString():T.open_rate.toString()}),(I=T==null?void 0:T.orders)==null||I.forEach(A=>{A.is_open&&v.push({lineStyle:{color:T.is_short?b:S,width:1,type:"dashed"},name:"Open order",yAxis:A.safe_price.toString()})})),{silent:!0,label:{show:!1},symbol:["none","none"],data:v}},m=(b=!1)=>{var E,U,G,$;if(!u.value)return;(E=i.value)!=null&&E.title&&(i.value.title[0].text=f.value);const S=p.dataset.columns.findIndex(Z=>Z==="__date_ts"),v=p.dataset.columns.findIndex(Z=>Z==="open"),T=p.dataset.columns.findIndex(Z=>Z==="high"),I=p.dataset.columns.findIndex(Z=>Z==="low"),A=p.dataset.columns.findIndex(Z=>Z==="close"),N=p.dataset.columns.findIndex(Z=>Z==="volume"),B=p.dataset.columns.findIndex(Z=>Z==="_buy_signal_close"||Z==="_enter_long_signal_close"),x=p.dataset.columns.findIndex(Z=>Z==="_sell_signal_close"||Z==="_exit_long_signal_close"),k=p.dataset.columns.findIndex(Z=>Z==="_enter_short_signal_close"),O=p.dataset.columns.findIndex(Z=>Z==="_exit_short_signal_close"),P="subplots"in p.plotConfig?Object.keys(p.plotConfig.subplots).length+1:1;if(Array.isArray((U=i.value)==null?void 0:U.dataZoom))if(b){const Z=(1-250/p.dataset.length)*100;i.value.dataZoom.forEach((he,me)=>{i.value&&i.value.dataZoom&&(i.value.dataZoom[me].start=Z)})}else i.value.dataZoom.forEach((Z,he)=>{i.value&&i.value.dataZoom&&(delete i.value.dataZoom[he].start,delete i.value.dataZoom[he].end)});const q=p.heikinAshi?dC(c.value,p.dataset.data):p.dataset.data.slice(),L=Array(q[q.length-2].length);L[S]=q[q.length-1][S]+p.dataset.timeframe_ms*15,q.push(L);const D={dataset:{source:q},grid:[{left:Jp,right:em,bottom:`${P*Vd+2}%`},{left:Jp,right:em,bottom:`${P*Vd}%`,height:`${Vd}%`}],series:[{name:"Candles",type:"candlestick",barWidth:"80%",itemStyle:{color:V9,color0:q9,borderColor:E9,borderColor0:L9},encode:{x:S,y:[v,A,I,T]}},{name:"Volume",type:"bar",xAxisIndex:1,yAxisIndex:1,itemStyle:{color:"#777777"},large:!0,encode:{x:S,y:N}},{name:"Entry",type:"scatter",symbol:"triangle",symbolSize:10,xAxisIndex:0,yAxisIndex:0,itemStyle:{color:R9},encode:{x:S,y:B}}]};if(n.activeBot.isWebserverMode||D&&D.series&&(D.series[0].markLine=l()),x>=0&&Array.isArray(D.series)&&D.series.push({name:"Exit",type:"scatter",symbol:"diamond",symbolSize:8,xAxisIndex:0,yAxisIndex:0,itemStyle:{color:F9},encode:{x:S,y:x}}),Array.isArray(D.series)&&(k>=0&&D.series.push({name:"Entry",type:"scatter",symbol:"triangle",symbolRotate:180,symbolSize:10,xAxisIndex:0,yAxisIndex:0,itemStyle:{color:D9},tooltip:{},encode:{x:S,y:k}}),O>=0&&D.series.push({name:"Exit",type:"scatter",symbol:"pin",symbolSize:8,xAxisIndex:0,yAxisIndex:0,itemStyle:{color:H9},tooltip:{},encode:{x:S,y:O}})),Object.assign(i.value,D),"main_plot"in p.plotConfig&&Object.entries(p.plotConfig.main_plot).forEach(([Z,he])=>{var ye,xe,Ae,Mt,Me;const me=p.dataset.columns.findIndex(ge=>ge===Z);if(me>1){!Array.isArray((ye=i.value)==null?void 0:ye.legend)&&((Ae=(xe=i.value)==null?void 0:xe.legend)==null?void 0:Ae.data)&&i.value.legend.data.push(Z);const ge={name:Z,type:he.type||"line",xAxisIndex:0,yAxisIndex:0,itemStyle:{color:he.color},encode:{x:S,y:me},showSymbol:!1};Array.isArray((Mt=i.value)==null?void 0:Mt.series)&&((Me=i.value)==null||Me.series.push(ge))}else console.log(`element ${Z} for main plot not found in columns.`)}),"subplots"in p.plotConfig){let Z=2;Object.entries(p.plotConfig.subplots).forEach(([he,me])=>{const ye=Z;Array.isArray(i.value.yAxis)&&i.value.yAxis.length<=Z&&i.value.yAxis.push({scale:!0,gridIndex:ye,name:he,nameLocation:"middle",nameGap:G1,axisLabel:{show:!0},axisLine:{show:!1},axisTick:{show:!1},splitLine:{show:!1}}),Array.isArray(i.value.xAxis)&&i.value.xAxis.length<=Z&&i.value.xAxis.push({type:"time",scale:!0,gridIndex:ye,boundaryGap:!1,axisLine:{onZero:!1},axisTick:{show:!1},axisLabel:{show:!1},axisPointer:{label:{show:!1}},splitLine:{show:!1},splitNumber:20}),Array.isArray(i.value.dataZoom)&&i.value.dataZoom.forEach(xe=>xe.xAxisIndex&&Array.isArray(xe.xAxisIndex)?xe.xAxisIndex.push(Z):null),i.value.grid&&Array.isArray(i.value.grid)&&i.value.grid.push({left:Jp,right:em,bottom:`${(P-Z+1)*Vd}%`,height:`${Vd}%`}),Object.entries(me).forEach(([xe,Ae])=>{var Me;const Mt=p.dataset.columns.findIndex(ge=>ge===xe);if(Mt>0){!Array.isArray(i.value.legend)&&((Me=i.value.legend)==null?void 0:Me.data)&&i.value.legend.data.push(xe);const ge={name:xe,type:Ae.type||"line",xAxisIndex:Z,yAxisIndex:Z,itemStyle:{color:Ae.color||$u()},encode:{x:S,y:Mt},showSymbol:!1};i.value.series&&Array.isArray(i.value.series)&&i.value.series.push(ge)}else console.log(`element ${xe} was not found in the columns.`)}),Z+=1})}Array.isArray(i.value.grid)&&(i.value.grid[i.value.grid.length-1].bottom="50px",delete i.value.grid[i.value.grid.length-1].top);const{tradeData:H}=lC(p.dataset,h.value),R="Trades";!Array.isArray(i.value.legend)&&((G=i.value.legend)==null?void 0:G.data)&&i.value.legend.data.push(R);const _={name:R,type:"scatter",xAxisIndex:0,yAxisIndex:0,encode:{x:0,y:1,label:5,tooltip:6},label:{show:!0,fontSize:12,backgroundColor:p.theme!=="dark"?"#fff":"#000",padding:2,color:p.theme==="dark"?"#fff":"#000"},labelLayout:{rotate:75,align:"left",dx:10},itemStyle:{color:Z=>Z.data[4],opacity:.9},symbol:Z=>Z[2],symbolRotate:Z=>Z[3],symbolSize:13,data:H};Array.isArray(i.value.series)&&i.value.series.push(_),($=e.value)==null||$.setOption(i.value,{replaceMerge:["series","grid","yAxis","xAxis","legend"],noMerge:!b})},g=()=>{var b;(b=e.value)==null||b.setOption({},{noMerge:!0}),i.value={title:[{show:!1}],backgroundColor:"rgba(0, 0, 0, 0)",useUTC:p.useUTC,animation:!1,legend:{data:["Candles","Volume","Entry","Exit"],right:"1%"},tooltip:{show:!0,trigger:"axis",renderMode:"richText",backgroundColor:"rgba(80,80,80,0.7)",borderWidth:0,textStyle:{color:"#fff"},axisPointer:{type:"cross",lineStyle:{color:"#cccccc",width:1,opacity:1}},position(S,v,T,I,A){const N={top:60},B=S[0]<A.viewSize[0]/2;return N[["left","right"][+B]]=B?5:60,N}},axisPointer:{link:[{xAxisIndex:"all"}],label:{backgroundColor:"#777"}},xAxis:[{type:"time",scale:!0,boundaryGap:!1,axisLine:{onZero:!1},axisTick:{show:!0},axisLabel:{show:!0},axisPointer:{label:{show:!1}},position:"top",splitLine:{show:!1},splitNumber:20,min:"dataMin",max:"dataMax"},{type:"time",gridIndex:1,scale:!0,boundaryGap:!1,axisLine:{onZero:!1},axisTick:{show:!1},axisLabel:{show:!1},axisPointer:{label:{show:!1}},splitLine:{show:!1},splitNumber:20,min:"dataMin",max:"dataMax"}],yAxis:[{scale:!0},{scale:!0,gridIndex:1,splitNumber:2,name:"volume",nameLocation:"middle",nameGap:G1,axisLabel:{show:!1},axisLine:{show:!1},axisTick:{show:!1},splitLine:{show:!1}}],dataZoom:[{type:"inside",xAxisIndex:[0,1],start:80,end:100},{show:!0,xAxisIndex:[0,1],type:"slider",bottom:10,start:80,end:100}]},console.log("Initialized"),m(!0)},y=()=>{if(!p.sliderPosition)return;const b=Og(p.sliderPosition.startValue-p.dataset.timeframe_ms*40,"yyyy-MM-dd HH:mm:ss"),S=Og(p.sliderPosition.endValue?p.sliderPosition.endValue+p.dataset.timeframe_ms*40:p.sliderPosition.startValue+p.dataset.timeframe_ms*80,"yyyy-MM-dd HH:mm:ss");e.value&&e.value.dispatchAction({type:"dataZoom",dataZoomIndex:0,startValue:b,endValue:S})},w=()=>{var b;(b=e.value)==null||b.setOption({series:[{markLine:l()}]})};return Pm(()=>{g()}),Yi(()=>p.useUTC,()=>g()),Yi(()=>p.dataset,()=>m()),Yi(()=>p.plotConfig,()=>g()),Yi(()=>p.heikinAshi,()=>m()),Yi(()=>p.sliderPosition,()=>y()),Yi(()=>p.trades,()=>w()),Yi(()=>r.orderbook.value,()=>w(),{deep:!0}),{candleChart:e,buyData:t,sellData:s,strategy:a,pair:o,timeframe:d,datasetColumns:c,hasData:u,filteredTrades:h,chartTitle:f}}}),U9={class:"d-flex flex-grow-1 chart-wrapper"};function $9(p,e,t,s,i,n){const r=Ct("v-chart");return qe(),at("div",U9,[p.hasData?(qe(),pi(r,{key:0,ref:"candleChart",theme:p.theme,autoresize:"","manual-update":""},null,8,["theme"])):os("",!0)])}var W9=$d(G9,[["render",$9],["__scopeId","data-v-e89189be"]]);const QT="ft_custom_plot_config",JT="ft_selected_plot_config";function z9(){return localStorage.getItem(JT)||"default"}function eO(p){localStorage.setItem(JT,p)}function bg(){return JSON.parse(localStorage.getItem(QT)||"{}")}function U1(){return Object.keys(bg())}function tO(p){const e=bg();return p in e?e[p]:{...Qu}}function j9(p){const t={...bg(),...p};localStorage.setItem(QT,JSON.stringify(t)),eO(Object.keys(p)[0])}const K9={name:"CloseCircleOutlineIcon",emits:["click"],props:{title:{type:String},fillColor:{type:String,default:"currentColor"},size:{type:Number,default:24}}},X9=["aria-hidden","aria-label"],Y9=["fill","width","height"],Z9={d:"M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22C17.53,22 22,17.53 22,12C22,6.47 17.53,2 12,2M14.59,8L12,10.59L9.41,8L8,9.41L10.59,12L8,14.59L9.41,16L12,13.41L14.59,16L16,14.59L13.41,12L16,9.41L14.59,8Z"},Q9={key:0};function J9(p,e,t,s,i,n){return qe(),at("span",tm(p.$attrs,{"aria-hidden":!t.title,"aria-label":t.title,class:"material-design-icon close-circle-outline-icon",role:"img",onClick:e[0]||(e[0]=r=>p.$emit("click",r))}),[(qe(),at("svg",{fill:t.fillColor,class:"material-design-icon__svg",width:t.size,height:t.size,viewBox:"0 0 24 24"},[ot("path",Z9,[t.title?(qe(),at("title",Q9,mn(t.title),1)):os("",!0)])],8,Y9))],16,X9)}var e7=$d(K9,[["render",J9]]);const t7=p=>(X1("data-v-0ff81b08"),p=p(),Y1(),p),s7={key:0},i7=t7(()=>ot("hr",null,null,-1)),n7={class:"d-flex d-flex-columns"},r7=uh({__name:"PlotIndicator",props:{modelValue:{required:!0,type:Object},columns:{required:!0,type:Array},addNew:{required:!0,type:Boolean}},emits:["update:modelValue"],setup(p,{emit:e}){const t=p,s=_t($u()),i=_t(Uu.line),n=_t(Object.keys(Uu)),r=_t(""),a=_t(""),o=_t(!1),d=Zt(()=>t.columns.filter(l=>l.toLowerCase().includes(r.value.toLowerCase()))),c=()=>{s.value=$u()},u=Zt(()=>o.value||!a.value?{}:{[a.value]:{color:s.value,type:i.value}}),h=()=>{e("update:modelValue",u.value)},f=()=>{o.value=!0,h()};return Yi(()=>t.modelValue,()=>{[a.value]=Object.keys(t.modelValue),o.value=!1,a.value&&t.modelValue&&(s.value=t.modelValue[a.value].color||$u(),i.value=t.modelValue[a.value].type||Uu.line)}),Yi(s,()=>{t.addNew||h()}),(l,m)=>{const g=Ct("b-form-input"),y=Ct("b-input-group-append"),w=Ct("b-input-group"),b=Ct("b-form-select"),S=Ct("b-form-group"),v=Ct("b-input-group-prepend"),T=Ct("b-button");return qe(),at("div",null,[p.addNew?(qe(),at("div",s7,[Ne(S,{label:"Add indicator","label-for":"indicatorSelector"},{default:We(()=>[Ne(w,{size:"sm"},{default:We(()=>[Ne(g,{modelValue:r.value,"onUpdate:modelValue":m[0]||(m[0]=I=>r.value=I),placeholder:"Filter indicators"},null,8,["modelValue"]),Ne(y,null,{default:We(()=>[Ne(e7,{class:"pointer align-self-center ms-1",size:18,onClick:m[1]||(m[1]=I=>r.value="")})]),_:1})]),_:1}),Ne(b,{id:"indicatorSelector",modelValue:a.value,"onUpdate:modelValue":m[2]||(m[2]=I=>a.value=I),options:or(d),"select-size":4},null,8,["modelValue","options"])]),_:1})])):os("",!0),Ne(S,{label:"Type","label-for":"plotTypeSelector"},{default:We(()=>[Ne(b,{id:"plotTypeSelector",modelValue:i.value,"onUpdate:modelValue":m[3]||(m[3]=I=>i.value=I),size:"sm",options:n.value,onChange:m[4]||(m[4]=I=>h())},null,8,["modelValue","options"])]),_:1}),i7,Ne(S,{label:"Color","label-for":"colsel",size:"sm"},{default:We(()=>[Ne(w,null,{default:We(()=>[Ne(v,null,{default:We(()=>[ot("div",{style:rO({"background-color":s.value}),class:"colorbox me-2"},null,4)]),_:1}),Ne(g,{id:"colsel",modelValue:s.value,"onUpdate:modelValue":m[5]||(m[5]=I=>s.value=I),size:"sm"},null,8,["modelValue"]),Ne(y,null,{default:We(()=>[Ne(T,{variant:"primary",size:"sm",onClick:c},{default:We(()=>[ls("\u21BB")]),_:1})]),_:1})]),_:1})]),_:1}),ot("div",n7,[p.addNew?(qe(),pi(T,{key:0,class:"flex-grow-1",variant:"primary",title:"Add ",size:"sm",onClick:h},{default:We(()=>[ls(" Save indicator ")]),_:1})):os("",!0),p.addNew?(qe(),pi(T,{key:1,class:"ms-1 flex-grow-1",variant:"secondary",title:"Add ",size:"sm",onClick:f},{default:We(()=>[ls(" Cancel ")]),_:1})):os("",!0)])])}}});var a7=$d(r7,[["__scopeId","data-v-0ff81b08"]]);const sO=aO("plotConfig",{state:()=>({customPlotConfig:{},plotConfigName:z9(),availablePlotConfigNames:U1(),plotConfig:{...Qu}}),getters:{},actions:{saveCustomPlotConfig(p){this.customPlotConfig=p,j9(p),this.availablePlotConfigNames=U1()},setPlotConfigName(p){this.plotConfigName=p,eO(p)},plotConfigChanged(p=""){console.log("plotConfigChanged"),this.setPlotConfigName(p||this.plotConfigName),this.plotConfig=tO(this.plotConfigName)},setPlotConfig(p){console.log("emit..."),this.plotConfig={...p}}}});const kg=p=>(X1("data-v-042ee6f0"),p=p(),Y1(),p),o7={key:0},d7={class:"col-mb-3"},c7=kg(()=>ot("hr",null,null,-1)),u7=kg(()=>ot("hr",null,null,-1)),h7=kg(()=>ot("hr",null,null,-1)),f7={key:1,class:"col-mb-5 ms-1 mt-2"},l7=uh({__name:"PlotConfigurator",props:{columns:{required:!0,type:Array},asModal:{required:!1,default:!0,type:Boolean}},setup(p){const e=sO(),t=ch(),s=_t(Qu),i=_t("default"),n=_t(""),r=_t(""),a=_t(!1),o=_t(!1),d=_t("main_plot"),c=_t(),u=_t(!0),h=Zt(()=>d.value==="main_plot"),f=Zt(()=>h.value?s.value.main_plot:s.value.subplots[d.value]),l=Zt(()=>["main_plot",...Object.keys(s.value.subplots)]),m=Zt(()=>h.value?Object.keys(s.value.main_plot):d.value in s.value.subplots?Object.keys(s.value.subplots[d.value]):[]);function g(x){console.log(s.value);const k=Object.keys(x)[0],O=x[k];h.value?(console.log(`Adding ${k} to MainPlot`),s.value.main_plot[k]={...O}):(console.log(`Adding ${k} to ${d.value}`),s.value.subplots[d.value][k]={...O}),s.value={...s.value},a.value=!1,e.setPlotConfig(s.value)}const y=Zt({get(){return a.value?{}:r.value?{[r.value]:f.value[r.value]}:{}},set(x){Object.keys(x)[0]&&x?g(x):a.value=!1}}),w=Zt({get(){return JSON.stringify(s.value,null,2)},set(x){try{c.value=JSON.parse(x),u.value=!0}catch{u.value=!1}}});function b(){console.log(s.value),h.value?(console.log(`Removing ${r.value} from MainPlot`),delete s.value.main_plot[r.value]):(console.log(`Removing ${r.value} from ${d.value}`),delete s.value.subplots[d.value][r.value]),s.value={...s.value},console.log(s.value),r.value="",e.setPlotConfig(s.value)}function S(){s.value.subplots={...s.value.subplots,[n.value]:{}},d.value=n.value,n.value="",e.setPlotConfig(s.value)}function v(){delete s.value.subplots[d.value],s.value.subplots={...s.value.subplots},d.value="",e.setPlotConfig(s.value)}function T(){s.value=tO(i.value),console.log(s.value),console.log("loading config"),e.setPlotConfig(s.value)}function I(){c.value!==void 0&&u.value&&(s.value=c.value,e.setPlotConfig(s.value))}function A(){s.value={...Qu}}async function N(){if(t.activeBot.isWebserverMode&&!t.activeBot.strategy.strategy){xg("No strategy selected, can't load plot config.");return}try{await t.activeBot.getStrategyPlotConfig(),t.activeBot.strategyPlotConfig&&(s.value=t.activeBot.strategyPlotConfig,e.setPlotConfig(s.value))}catch{xg("Failed to load Plot configuration from Strategy.")}}function B(){e.saveCustomPlotConfig({[i.value]:s.value})}return Pm(()=>{s.value=e.plotConfig,i.value=e.plotConfigName}),(x,k)=>{const O=Ct("b-form-input"),P=Ct("b-form-group"),q=Ct("b-form-select"),L=Ct("b-button"),D=Ct("b-input-group-append"),H=Ct("b-input-group"),R=Ct("b-form-textarea");return p.columns?(qe(),at("div",o7,[Ne(P,{label:"Plot config name","label-for":"idPlotConfigName"},{default:We(()=>[Ne(O,{id:"idPlotConfigName",modelValue:i.value,"onUpdate:modelValue":k[0]||(k[0]=_=>i.value=_),size:"sm"},null,8,["modelValue"])]),_:1}),ot("div",d7,[c7,Ne(P,{label:"Target","label-for":"FieldSel"},{default:We(()=>[Ne(q,{id:"FieldSel",modelValue:d.value,"onUpdate:modelValue":k[1]||(k[1]=_=>d.value=_),options:or(l),"select-size":3},null,8,["modelValue","options"])]),_:1})]),Ne(P,{label:"Add new plot","label-for":"newSubPlot"},{default:We(()=>[Ne(H,{size:"sm"},{default:We(()=>[Ne(O,{id:"newSubPlot",modelValue:n.value,"onUpdate:modelValue":k[2]||(k[2]=_=>n.value=_),class:"addPlot"},null,8,["modelValue"]),Ne(D,null,{default:We(()=>[Ne(L,{disabled:!n.value,onClick:S},{default:We(()=>[ls("+")]),_:1},8,["disabled"]),d.value&&d.value!="main_plot"?(qe(),pi(L,{key:0,onClick:v},{default:We(()=>[ls("-")]),_:1})):os("",!0)]),_:1})]),_:1})]),_:1}),u7,ot("div",null,[Ne(P,{label:"Used indicators","label-for":"selectedIndicators"},{default:We(()=>[Ne(q,{id:"selectedIndicators",modelValue:r.value,"onUpdate:modelValue":k[3]||(k[3]=_=>r.value=_),options:or(m),"select-size":4},null,8,["modelValue","options"])]),_:1})]),ot("div",null,[Ne(L,{variant:"primary",title:"Add indicator to plot",size:"sm",disabled:a.value,onClick:k[4]||(k[4]=_=>a.value=!a.value)},{default:We(()=>[ls(" Add new indicator ")]),_:1},8,["disabled"]),Ne(L,{variant:"secondary",title:"Remove indicator to plot",size:"sm",disabled:!r.value,class:"ms-1",onClick:b},{default:We(()=>[ls(" Remove indicator ")]),_:1},8,["disabled"])]),r.value||a.value?(qe(),pi(a7,{key:0,modelValue:or(y),"onUpdate:modelValue":k[5]||(k[5]=_=>Ig(y)?y.value=_:null),class:"mt-1",columns:p.columns,"add-new":a.value},null,8,["modelValue","columns","add-new"])):os("",!0),h7,ot("div",null,[Ne(L,{class:"ms-1",variant:"secondary",size:"sm",onClick:T},{default:We(()=>[ls("Load")]),_:1}),Ne(L,{disabled:or(t).activeBot.isWebserverMode&&or(t).activeBot.botApiVersion<2.23||!or(t).activeBot.isBotOnline,class:"ms-1",variant:"secondary",size:"sm",onClick:N},{default:We(()=>[ls(" From strategy ")]),_:1},8,["disabled"]),Ne(L,{class:"ms-1",variant:"secondary",size:"sm",title:"Load configuration from text box below",onClick:A},{default:We(()=>[ls("Reset")]),_:1}),Ne(L,{id:"showButton",class:"ms-1",variant:"secondary",size:"sm",title:"Show configuration for easy transfer to a strategy",onClick:k[6]||(k[6]=_=>o.value=!o.value)},{default:We(()=>[ls("Show")]),_:1}),o.value?(qe(),pi(L,{key:0,class:"ms-1",variant:"secondary",size:"sm",title:"Load configuration from text box below",onClick:I},{default:We(()=>[ls("Load from String")]),_:1})):os("",!0),Ne(L,{class:"ms-1",variant:"primary",size:"sm","data-toggle":"tooltip",title:"Save configuration",onClick:B},{default:We(()=>[ls("Save")]),_:1})]),o.value?(qe(),at("div",f7,[Ne(R,{id:"TextArea",modelValue:or(w),"onUpdate:modelValue":k[7]||(k[7]=_=>Ig(w)?w.value=_:null),class:"textArea",size:"sm",state:u.value},null,8,["modelValue","state"])])):os("",!0)])):os("",!0)}}});var p7=$d(l7,[["__scopeId","data-v-042ee6f0"]]),m7=Object.defineProperty,g7=Object.defineProperties,y7=Object.getOwnPropertyDescriptors,$1=Object.getOwnPropertySymbols,w7=Object.prototype.hasOwnProperty,b7=Object.prototype.propertyIsEnumerable,W1=(p,e,t)=>e in p?m7(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t,Ga=(p,e)=>{for(var t in e||(e={}))w7.call(e,t)&&W1(p,t,e[t]);if($1)for(var t of $1(e))b7.call(e,t)&&W1(p,t,e[t]);return p},z1=(p,e)=>g7(p,y7(e));const k7={props:{autoscroll:{type:Boolean,default:!0}},watch:{typeAheadPointer(){this.autoscroll&&this.maybeAdjustScroll()},open(p){this.autoscroll&&p&&this.$nextTick(()=>this.maybeAdjustScroll())}},methods:{maybeAdjustScroll(){var p;const e=((p=this.$refs.dropdownMenu)==null?void 0:p.children[this.typeAheadPointer])||!1;if(e){const t=this.getDropdownViewport(),{top:s,bottom:i,height:n}=e.getBoundingClientRect();if(s<t.top)return this.$refs.dropdownMenu.scrollTop=e.offsetTop;if(i>t.bottom)return this.$refs.dropdownMenu.scrollTop=e.offsetTop-(t.height-n)}},getDropdownViewport(){return this.$refs.dropdownMenu?this.$refs.dropdownMenu.getBoundingClientRect():{height:0,top:0,bottom:0}}}},S7={data(){return{typeAheadPointer:-1}},watch:{filteredOptions(){for(let p=0;p<this.filteredOptions.length;p++)if(this.selectable(this.filteredOptions[p])){this.typeAheadPointer=p;break}},open(p){p&&this.typeAheadToLastSelected()},selectedValue(){this.open&&this.typeAheadToLastSelected()}},methods:{typeAheadUp(){for(let p=this.typeAheadPointer-1;p>=0;p--)if(this.selectable(this.filteredOptions[p])){this.typeAheadPointer=p;break}},typeAheadDown(){for(let p=this.typeAheadPointer+1;p<this.filteredOptions.length;p++)if(this.selectable(this.filteredOptions[p])){this.typeAheadPointer=p;break}},typeAheadSelect(){const p=this.filteredOptions[this.typeAheadPointer];p&&this.selectable(p)&&this.select(p)},typeAheadToLastSelected(){this.typeAheadPointer=this.selectedValue.length!==0?this.filteredOptions.indexOf(this.selectedValue[this.selectedValue.length-1]):-1}}},v7={props:{loading:{type:Boolean,default:!1}},data(){return{mutableLoading:!1}},watch:{search(){this.$emit("search",this.search,this.toggleLoading)},loading(p){this.mutableLoading=p}},methods:{toggleLoading(p=null){return p==null?this.mutableLoading=!this.mutableLoading:this.mutableLoading=p}}},Sg=(p,e)=>{const t=p.__vccOpts||p;for(const[s,i]of e)t[s]=i;return t},T7={},O7={xmlns:"http://www.w3.org/2000/svg",width:"10",height:"10"},I7=ot("path",{d:"M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z"},null,-1),x7=[I7];function _7(p,e){return qe(),at("svg",O7,x7)}const C7=Sg(T7,[["render",_7]]),M7={},P7={xmlns:"http://www.w3.org/2000/svg",width:"14",height:"10"},A7=ot("path",{d:"M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z"},null,-1),B7=[A7];function N7(p,e){return qe(),at("svg",P7,B7)}const V7=Sg(M7,[["render",N7]]),j1={Deselect:C7,OpenIndicator:V7},E7={mounted(p,{instance:e}){if(e.appendToBody){const{height:t,top:s,left:i,width:n}=e.$refs.toggle.getBoundingClientRect();let r=window.scrollX||window.pageXOffset,a=window.scrollY||window.pageYOffset;p.unbindPosition=e.calculatePosition(p,e,{width:n+"px",left:r+i+"px",top:a+s+t+"px"}),document.body.appendChild(p)}},unmounted(p,{instance:e}){e.appendToBody&&(p.unbindPosition&&typeof p.unbindPosition=="function"&&p.unbindPosition(),p.parentNode&&p.parentNode.removeChild(p))}};function q7(p){const e={};return Object.keys(p).sort().forEach(t=>{e[t]=p[t]}),JSON.stringify(e)}let L7=0;function R7(){return++L7}const D7={components:Ga({},j1),directives:{appendToBody:E7},mixins:[k7,S7,v7],compatConfig:{MODE:3},emits:["open","close","update:modelValue","search","search:compositionstart","search:compositionend","search:keydown","search:blur","search:focus","search:input","option:created","option:selecting","option:selected","option:deselecting","option:deselected"],props:{modelValue:{},components:{type:Object,default:()=>({})},options:{type:Array,default(){return[]}},disabled:{type:Boolean,default:!1},clearable:{type:Boolean,default:!0},deselectFromDropdown:{type:Boolean,default:!1},searchable:{type:Boolean,default:!0},multiple:{type:Boolean,default:!1},placeholder:{type:String,default:""},transition:{type:String,default:"vs__fade"},clearSearchOnSelect:{type:Boolean,default:!0},closeOnSelect:{type:Boolean,default:!0},label:{type:String,default:"label"},autocomplete:{type:String,default:"off"},reduce:{type:Function,default:p=>p},selectable:{type:Function,default:p=>!0},getOptionLabel:{type:Function,default(p){return typeof p=="object"?p.hasOwnProperty(this.label)?p[this.label]:console.warn(`[vue-select warn]: Label key "option.${this.label}" does not exist in options object ${JSON.stringify(p)}.
https://vue-select.org/api/props.html#getoptionlabel`):p}},getOptionKey:{type:Function,default(p){if(typeof p!="object")return p;try{return p.hasOwnProperty("id")?p.id:q7(p)}catch(e){return console.warn(`[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.
https://vue-select.org/api/props.html#getoptionkey`,p,e)}}},onTab:{type:Function,default:function(){this.selectOnTab&&!this.isComposing&&this.typeAheadSelect()}},taggable:{type:Boolean,default:!1},tabindex:{type:Number,default:null},pushTags:{type:Boolean,default:!1},filterable:{type:Boolean,default:!0},filterBy:{type:Function,default(p,e,t){return(e||"").toLocaleLowerCase().indexOf(t.toLocaleLowerCase())>-1}},filter:{type:Function,default(p,e){return p.filter(t=>{let s=this.getOptionLabel(t);return typeof s=="number"&&(s=s.toString()),this.filterBy(t,s,e)})}},createOption:{type:Function,default(p){return typeof this.optionList[0]=="object"?{[this.label]:p}:p}},resetOnOptionsChange:{default:!1,validator:p=>["function","boolean"].includes(typeof p)},clearSearchOnBlur:{type:Function,default:function({clearSearchOnSelect:p,multiple:e}){return p&&!e}},noDrop:{type:Boolean,default:!1},inputId:{type:String},dir:{type:String,default:"auto"},selectOnTab:{type:Boolean,default:!1},selectOnKeyCodes:{type:Array,default:()=>[13]},searchInputQuerySelector:{type:String,default:"[type=search]"},mapKeydown:{type:Function,default:(p,e)=>p},appendToBody:{type:Boolean,default:!1},calculatePosition:{type:Function,default(p,e,{width:t,top:s,left:i}){p.style.top=s,p.style.left=i,p.style.width=t}},dropdownShouldOpen:{type:Function,default({noDrop:p,open:e,mutableLoading:t}){return p?!1:e&&!t}},uid:{type:[String,Number],default:()=>R7()}},data(){return{search:"",open:!1,isComposing:!1,pushedTags:[],_value:[],deselectButtons:[]}},computed:{isReducingValues(){return this.$props.reduce!==this.$options.props.reduce.default},isTrackingValues(){return typeof this.modelValue=="undefined"||this.isReducingValues},selectedValue(){let p=this.modelValue;return this.isTrackingValues&&(p=this.$data._value),p!=null&&p!==""?[].concat(p):[]},optionList(){return this.options.concat(this.pushTags?this.pushedTags:[])},searchEl(){return this.$slots.search?this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector):this.$refs.search},scope(){const p={search:this.search,loading:this.loading,searching:this.searching,filteredOptions:this.filteredOptions};return{search:{attributes:Ga({disabled:this.disabled,placeholder:this.searchPlaceholder,tabindex:this.tabindex,readonly:!this.searchable,id:this.inputId,"aria-autocomplete":"list","aria-labelledby":`vs${this.uid}__combobox`,"aria-controls":`vs${this.uid}__listbox`,ref:"search",type:"search",autocomplete:this.autocomplete,value:this.search},this.dropdownOpen&&this.filteredOptions[this.typeAheadPointer]?{"aria-activedescendant":`vs${this.uid}__option-${this.typeAheadPointer}`}:{}),events:{compositionstart:()=>this.isComposing=!0,compositionend:()=>this.isComposing=!1,keydown:this.onSearchKeyDown,blur:this.onSearchBlur,focus:this.onSearchFocus,input:e=>this.search=e.target.value}},spinner:{loading:this.mutableLoading},noOptions:{search:this.search,loading:this.mutableLoading,searching:this.searching},openIndicator:{attributes:{ref:"openIndicator",role:"presentation",class:"vs__open-indicator"}},listHeader:p,listFooter:p,header:z1(Ga({},p),{deselect:this.deselect}),footer:z1(Ga({},p),{deselect:this.deselect})}},childComponents(){return Ga(Ga({},j1),this.components)},stateClasses(){return{"vs--open":this.dropdownOpen,"vs--single":!this.multiple,"vs--multiple":this.multiple,"vs--searching":this.searching&&!this.noDrop,"vs--searchable":this.searchable&&!this.noDrop,"vs--unsearchable":!this.searchable,"vs--loading":this.mutableLoading,"vs--disabled":this.disabled}},searching(){return!!this.search},dropdownOpen(){return this.dropdownShouldOpen(this)},searchPlaceholder(){return this.isValueEmpty&&this.placeholder?this.placeholder:void 0},filteredOptions(){const p=[].concat(this.optionList);if(!this.filterable&&!this.taggable)return p;const e=this.search.length?this.filter(p,this.search,this):p;if(this.taggable&&this.search.length){const t=this.createOption(this.search);this.optionExists(t)||e.unshift(t)}return e},isValueEmpty(){return this.selectedValue.length===0},showClearButton(){return!this.multiple&&this.clearable&&!this.open&&!this.isValueEmpty}},watch:{options(p,e){const t=()=>typeof this.resetOnOptionsChange=="function"?this.resetOnOptionsChange(p,e,this.selectedValue):this.resetOnOptionsChange;!this.taggable&&t()&&this.clearSelection(),this.modelValue&&this.isTrackingValues&&this.setInternalValueFromOptions(this.modelValue)},modelValue:{immediate:!0,handler(p){this.isTrackingValues&&this.setInternalValueFromOptions(p)}},multiple(){this.clearSelection()},open(p){this.$emit(p?"open":"close")}},created(){this.mutableLoading=this.loading},methods:{setInternalValueFromOptions(p){Array.isArray(p)?this.$data._value=p.map(e=>this.findOptionFromReducedValue(e)):this.$data._value=this.findOptionFromReducedValue(p)},select(p){this.$emit("option:selecting",p),this.isOptionSelected(p)?this.deselectFromDropdown&&(this.clearable||this.multiple&&this.selectedValue.length>1)&&this.deselect(p):(this.taggable&&!this.optionExists(p)&&(this.$emit("option:created",p),this.pushTag(p)),this.multiple&&(p=this.selectedValue.concat(p)),this.updateValue(p),this.$emit("option:selected",p)),this.onAfterSelect(p)},deselect(p){this.$emit("option:deselecting",p),this.updateValue(this.selectedValue.filter(e=>!this.optionComparator(e,p))),this.$emit("option:deselected",p)},clearSelection(){this.updateValue(this.multiple?[]:null)},onAfterSelect(p){this.closeOnSelect&&(this.open=!this.open,this.searchEl.blur()),this.clearSearchOnSelect&&(this.search="")},updateValue(p){typeof this.modelValue=="undefined"&&(this.$data._value=p),p!==null&&(Array.isArray(p)?p=p.map(e=>this.reduce(e)):p=this.reduce(p)),this.$emit("update:modelValue",p)},toggleDropdown(p){const e=p.target!==this.searchEl;e&&p.preventDefault();const t=[...this.deselectButtons||[],this.$refs.clearButton];if(this.searchEl===void 0||t.filter(Boolean).some(s=>s.contains(p.target)||s===p.target)){p.preventDefault();return}this.open&&e?this.searchEl.blur():this.disabled||(this.open=!0,this.searchEl.focus())},isOptionSelected(p){return this.selectedValue.some(e=>this.optionComparator(e,p))},isOptionDeselectable(p){return this.isOptionSelected(p)&&this.deselectFromDropdown},optionComparator(p,e){return this.getOptionKey(p)===this.getOptionKey(e)},findOptionFromReducedValue(p){const e=s=>JSON.stringify(this.reduce(s))===JSON.stringify(p),t=[...this.options,...this.pushedTags].filter(e);return t.length===1?t[0]:t.find(s=>this.optionComparator(s,this.$data._value))||p},closeSearchOptions(){this.open=!1,this.$emit("search:blur")},maybeDeleteValue(){if(!this.searchEl.value.length&&this.selectedValue&&this.selectedValue.length&&this.clearable){let p=null;this.multiple&&(p=[...this.selectedValue.slice(0,this.selectedValue.length-1)]),this.updateValue(p)}},optionExists(p){return this.optionList.some(e=>this.optionComparator(e,p))},normalizeOptionForSlot(p){return typeof p=="object"?p:{[this.label]:p}},pushTag(p){this.pushedTags.push(p)},onEscape(){this.search.length?this.search="":this.searchEl.blur()},onSearchBlur(){if(this.mousedown&&!this.searching)this.mousedown=!1;else{const{clearSearchOnSelect:p,multiple:e}=this;this.clearSearchOnBlur({clearSearchOnSelect:p,multiple:e})&&(this.search=""),this.closeSearchOptions();return}if(this.search.length===0&&this.options.length===0){this.closeSearchOptions();return}},onSearchFocus(){this.open=!0,this.$emit("search:focus")},onMousedown(){this.mousedown=!0},onMouseUp(){this.mousedown=!1},onSearchKeyDown(p){const e=i=>(i.preventDefault(),!this.isComposing&&this.typeAheadSelect()),t={8:i=>this.maybeDeleteValue(),9:i=>this.onTab(),27:i=>this.onEscape(),38:i=>(i.preventDefault(),this.typeAheadUp()),40:i=>(i.preventDefault(),this.typeAheadDown())};this.selectOnKeyCodes.forEach(i=>t[i]=e);const s=this.mapKeydown(t,this);if(typeof s[p.keyCode]=="function")return s[p.keyCode](p)}}},F7=["dir"],H7=["id","aria-expanded","aria-owns"],G7={ref:"selectedOptions",class:"vs__selected-options"},U7=["disabled","title","aria-label","onClick"],$7={ref:"actions",class:"vs__actions"},W7=["disabled"],z7={class:"vs__spinner"},j7=["id"],K7=["id","aria-selected","onMouseover","onClick"],X7={key:0,class:"vs__no-options"},Y7=ls(" Sorry, no matching options. "),Z7=["id"];function Q7(p,e,t,s,i,n){const r=oO("append-to-body");return qe(),at("div",{dir:t.dir,class:Pg(["v-select",n.stateClasses])},[qi(p.$slots,"header",Li(en(n.scope.header))),ot("div",{id:`vs${t.uid}__combobox`,ref:"toggle",class:"vs__dropdown-toggle",role:"combobox","aria-expanded":n.dropdownOpen.toString(),"aria-owns":`vs${t.uid}__listbox`,"aria-label":"Search for option",onMousedown:e[1]||(e[1]=a=>n.toggleDropdown(a))},[ot("div",G7,[(qe(!0),at(_g,null,Cg(n.selectedValue,(a,o)=>qi(p.$slots,"selected-option-container",{option:n.normalizeOptionForSlot(a),deselect:n.deselect,multiple:t.multiple,disabled:t.disabled},()=>[(qe(),at("span",{key:t.getOptionKey(a),class:"vs__selected"},[qi(p.$slots,"selected-option",Li(en(n.normalizeOptionForSlot(a))),()=>[ls(mn(t.getOptionLabel(a)),1)]),t.multiple?(qe(),at("button",{key:0,ref_for:!0,ref:d=>i.deselectButtons[o]=d,disabled:t.disabled,type:"button",class:"vs__deselect",title:`Deselect ${t.getOptionLabel(a)}`,"aria-label":`Deselect ${t.getOptionLabel(a)}`,onClick:d=>n.deselect(a)},[(qe(),pi(Qh(n.childComponents.Deselect)))],8,U7)):os("",!0)]))])),256)),qi(p.$slots,"search",Li(en(n.scope.search)),()=>[ot("input",tm({class:"vs__search"},n.scope.search.attributes,dO(n.scope.search.events)),null,16)])],512),ot("div",$7,[Hu(ot("button",{ref:"clearButton",disabled:t.disabled,type:"button",class:"vs__clear",title:"Clear Selected","aria-label":"Clear Selected",onClick:e[0]||(e[0]=(...a)=>n.clearSelection&&n.clearSelection(...a))},[(qe(),pi(Qh(n.childComponents.Deselect)))],8,W7),[[sm,n.showClearButton]]),qi(p.$slots,"open-indicator",Li(en(n.scope.openIndicator)),()=>[t.noDrop?os("",!0):(qe(),pi(Qh(n.childComponents.OpenIndicator),Li(tm({key:0},n.scope.openIndicator.attributes)),null,16))]),qi(p.$slots,"spinner",Li(en(n.scope.spinner)),()=>[Hu(ot("div",z7,"Loading...",512),[[sm,p.mutableLoading]])])],512)],40,H7),Ne(Z1,{name:t.transition},{default:We(()=>[n.dropdownOpen?Hu((qe(),at("ul",{id:`vs${t.uid}__listbox`,ref:"dropdownMenu",key:`vs${t.uid}__listbox`,class:"vs__dropdown-menu",role:"listbox",tabindex:"-1",onMousedown:e[2]||(e[2]=Mg((...a)=>n.onMousedown&&n.onMousedown(...a),["prevent"])),onMouseup:e[3]||(e[3]=(...a)=>n.onMouseUp&&n.onMouseUp(...a))},[qi(p.$slots,"list-header",Li(en(n.scope.listHeader))),(qe(!0),at(_g,null,Cg(n.filteredOptions,(a,o)=>(qe(),at("li",{id:`vs${t.uid}__option-${o}`,key:t.getOptionKey(a),role:"option",class:Pg(["vs__dropdown-option",{"vs__dropdown-option--deselect":n.isOptionDeselectable(a)&&o===p.typeAheadPointer,"vs__dropdown-option--selected":n.isOptionSelected(a),"vs__dropdown-option--highlight":o===p.typeAheadPointer,"vs__dropdown-option--disabled":!t.selectable(a)}]),"aria-selected":o===p.typeAheadPointer?!0:null,onMouseover:d=>t.selectable(a)?p.typeAheadPointer=o:null,onClick:Mg(d=>t.selectable(a)?n.select(a):null,["prevent","stop"])},[qi(p.$slots,"option",Li(en(n.normalizeOptionForSlot(a))),()=>[ls(mn(t.getOptionLabel(a)),1)])],42,K7))),128)),n.filteredOptions.length===0?(qe(),at("li",X7,[qi(p.$slots,"no-options",Li(en(n.scope.noOptions)),()=>[Y7])])):os("",!0),qi(p.$slots,"list-footer",Li(en(n.scope.listFooter)))],40,j7)),[[r]]):(qe(),at("ul",{key:1,id:`vs${t.uid}__listbox`,role:"listbox",style:{display:"none",visibility:"hidden"}},null,8,Z7))]),_:3},8,["name"]),qi(p.$slots,"footer",Li(en(n.scope.footer)))],10,F7)}const J7=Sg(D7,[["render",Q7]]);const eW=uh({name:"CandleChartContainer",components:{CandleChart:W9,PlotConfigurator:p7,vSelect:J7},props:{trades:{required:!1,default:()=>[],type:Array},availablePairs:{required:!0,type:Array},timeframe:{required:!0,type:String},historicView:{required:!1,default:!1,type:Boolean},plotConfigModal:{required:!1,default:!0,type:Boolean},timerange:{required:!1,default:"",type:String},strategy:{required:!1,default:"",type:String},sliderPosition:{required:!1,type:Object,default:()=>{}}},setup(p){const e=cO(),t=ch(),s=sO(),i=_t(""),n=_t(p.plotConfigModal),r=Zt(()=>{var m,g;return p.historicView?(m=t.activeBot.history[`${i.value}__${p.timeframe}`])==null?void 0:m.data:(g=t.activeBot.candleData[`${i.value}__${p.timeframe}`])==null?void 0:g.data}),a=Zt(()=>{var m;return p.strategy||((m=r.value)==null?void 0:m.strategy)||""}),o=Zt(()=>r.value?r.value.columns:[]),d=Zt(()=>!!r.value),c=Zt(()=>p.historicView?t.activeBot.historyStatus===ko.loading:t.activeBot.candleDataStatus===ko.loading),u=Zt(()=>{switch(p.historicView?t.activeBot.historyStatus:t.activeBot.candleDataStatus){case ko.loading:return"Loading...";case ko.success:return"No data available";case ko.error:return"Failed to load data";default:return"Unknown"}}),h=_t(!1),f=()=>{p.plotConfigModal?h.value=!h.value:n.value=!n.value},l=()=>{console.log("refresh",i.value,p.timeframe),i.value&&p.timeframe&&(p.historicView?t.activeBot.getPairHistory({pair:i.value,timeframe:p.timeframe,timerange:p.timerange,strategy:p.strategy}):t.activeBot.getPairCandles({pair:i.value,timeframe:p.timeframe,limit:500}))};return Yi(()=>p.availablePairs,()=>{p.availablePairs.find(m=>m===i.value)||([i.value]=p.availablePairs,l())}),Yi(()=>t.activeBot.selectedPair,()=>{i.value=t.activeBot.selectedPair,l()}),Pm(()=>{t.activeBot.selectedPair?i.value=t.activeBot.selectedPair:p.availablePairs.length>0&&([i.value]=p.availablePairs),s.plotConfigChanged(),d||l()}),{botStore:t,settingsStore:e,plotStore:s,history,dataset:r,strategyName:a,datasetColumns:o,isLoadingDataset:c,noDatasetText:u,hasDataset:d,showPlotConfig:n,showConfigurator:f,refresh:l,pair:i,showPlotConfigModal:h}}}),tW={class:"d-flex h-100"},sW={class:"flex-fill w-100 flex-column align-items-stretch d-flex h-100"},iW={class:"d-flex me-0"},nW={class:"ms-2 d-flex flex-wrap flex-md-nowrap align-items-center w-auto"},rW={class:"ms-2 text-nowrap"},aW={key:0,class:"ms-2 text-nowrap",title:"Long entry signals"},oW={key:1,class:"ms-2 text-nowrap",title:"Long exit signals"},dW={key:2,class:"ms-2 text-nowrap"},cW={key:3,class:"ms-2 text-nowrap"},uW={class:"ms-auto d-flex align-items-center w-auto"},hW={class:"ms-2"},fW={class:"ms-2 me-0 me-md-1"},lW={class:"me-1 ms-1 h-100"},pW={key:1,class:"m-auto"},mW={key:1,style:{"font-size":"1.5rem"}},gW={key:0,class:"w-25 config-sidebar"};function yW(p,e,t,s,i,n){const r=Ct("v-select"),a=Ct("b-button"),o=Ct("b-form-checkbox"),d=Ct("b-form-select"),c=Ct("CandleChart"),u=Ct("b-spinner"),h=Ct("PlotConfigurator"),f=Ct("b-modal");return qe(),at("div",tW,[ot("div",sW,[ot("div",iW,[ot("div",nW,[ot("span",rW,mn(p.strategyName)+" | "+mn(p.timeframe||""),1),Ne(r,{modelValue:p.pair,"onUpdate:modelValue":e[0]||(e[0]=l=>p.pair=l),class:"ms-2",options:p.availablePairs,style:{"min-width":"7em"},size:"sm",clearable:!1,onInput:p.refresh},null,8,["modelValue","options","onInput"]),Ne(a,{class:"ms-2",disabled:!p.pair,size:"sm",onClick:p.refresh},{default:We(()=>[ls("\u21BB")]),_:1},8,["disabled","onClick"]),p.dataset?(qe(),at("small",aW,"Long signals: "+mn(p.dataset.enter_long_signals||p.dataset.buy_signals),1)):os("",!0),p.dataset?(qe(),at("small",oW,"Long exit: "+mn(p.dataset.exit_long_signals||p.dataset.sell_signals),1)):os("",!0),p.dataset&&p.dataset.enter_short_signals?(qe(),at("small",dW,"Short entries: "+mn(p.dataset.enter_short_signals),1)):os("",!0),p.dataset&&p.dataset.exit_short_signals?(qe(),at("small",cW,"Short exits: "+mn(p.dataset.exit_short_signals),1)):os("",!0)]),ot("div",uW,[Ne(o,{modelValue:p.settingsStore.useHeikinAshiCandles,"onUpdate:modelValue":e[1]||(e[1]=l=>p.settingsStore.useHeikinAshiCandles=l)},{default:We(()=>[ls("Heikin Ashi")]),_:1},8,["modelValue"]),ot("div",hW,[Ne(d,{modelValue:p.plotStore.plotConfigName,"onUpdate:modelValue":e[2]||(e[2]=l=>p.plotStore.plotConfigName=l),options:p.plotStore.availablePlotConfigNames,size:"sm",onChange:p.plotStore.plotConfigChanged},null,8,["modelValue","options","onChange"])]),ot("div",fW,[Ne(a,{size:"sm",title:"Plot configurator",onClick:p.showConfigurator},{default:We(()=>[ls(" \u2699 ")]),_:1},8,["onClick"])])])]),ot("div",lW,[p.hasDataset?(qe(),pi(c,{key:0,dataset:p.dataset,trades:p.trades,"plot-config":p.plotStore.plotConfig,"heikin-ashi":p.settingsStore.useHeikinAshiCandles,"use-u-t-c":p.settingsStore.timezone==="UTC",theme:p.settingsStore.chartTheme,"slider-position":p.sliderPosition},null,8,["dataset","trades","plot-config","heikin-ashi","use-u-t-c","theme","slider-position"])):(qe(),at("div",pW,[p.isLoadingDataset?(qe(),pi(u,{key:0,label:"Spinning"})):(qe(),at("div",mW,mn(p.noDatasetText),1))]))])]),Ne(Z1,{name:"fade",mode:"in-out"},{default:We(()=>[p.plotConfigModal?os("",!0):Hu((qe(),at("div",gW,[Ne(h,{columns:p.datasetColumns,"as-modal":!1},null,8,["columns"])],512)),[[sm,p.showPlotConfig]])]),_:1}),p.plotConfigModal?(qe(),pi(f,{key:0,id:"plotConfiguratorModal",modelValue:p.showPlotConfigModal,"onUpdate:modelValue":e[3]||(e[3]=l=>p.showPlotConfigModal=l),title:"Plot Configurator","ok-only":"","hide-backdrop":""},{default:We(()=>[p.showPlotConfigModal?(qe(),pi(h,{key:0,columns:p.datasetColumns},null,8,["columns"])):os("",!0)]),_:1},8,["modelValue"])):os("",!0)])}var PK=$d(eW,[["render",yW],["__scopeId","data-v-3985287f"]]);export{PK as C};
//# sourceMappingURL=CandleChartContainer.117ee9ed.js.map
